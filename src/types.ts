/*
 * THIS FILE IS AUTOMATICALLY GENERATED.
 * Manually editing it will only lead to sorrow.
 */

/* eslint-disable */

import { Connection } from "./Connection";

const typeNames: {
  [key in "classes" | "enums" | "interfaces"]: Record<string, Record<string, string | typeof ManagedObject>>;
} = {
  classes: {},
  enums: {},
  interfaces: {}
};

const literalTypes = ["undefined", "string", "boolean", "number", "any", "unknown", "null"];

const constructHelperObjects = (connection: Connection, data: any, thisName: string, options?: { fromConstructor: boolean }): any => {
  const { fromConstructor = false } = options ?? {};
  if (!data) {
    return data;
  }
  if (thisName in typeNames.enums || literalTypes.includes(thisName) || thisName === undefined) {
    return (typeof data === "object" && !!data && "$value" in data) ? data.$value : data;
  }
  if (thisName === "Date") {
    return new Date(data);
  }
  if (thisName === "Buffer") {
    return Buffer.from(data, "base64");
  }
  if (data instanceof Array) {
    return data.map(item => constructHelperObjects(connection, item, thisName));
  }
  if (thisName.endsWith("[]")) {
    thisName = thisName.slice(0, -2);
  }
  const fieldMap = typeNames.classes[thisName] ?? typeNames.interfaces[thisName];
  if (connection.options.debug) {
    console.log("vsphere-soap.constructHelperObjects", { thisName, fieldMap, data, fromConstructor });
  }
  if (typeof data === "string") {
    data = { $value: data };
  }
  if (fieldMap !== undefined && "_this" in fieldMap && typeof fieldMap._this === "function" && !fromConstructor) {
    return new fieldMap._this(connection, data);
  }
  return Object.fromEntries(Object.entries(data).map(([key, value]) => {
    const itemConstructor = fieldMap[key];
    if (typeof itemConstructor !== "function") {
      return [key, constructHelperObjects(connection, value, itemConstructor)];
    }
    if (value instanceof Array) {
      return [key, value.map(v => new itemConstructor(connection, v))];
    }
    return [key, new itemConstructor(connection, value as Partial<ManagedObject>)];
  }));
}

export type ObjectReference = string | {
  attributes: {
    type: string;
  };
  $value?: string;
}

export interface DataObject {
  attributes?: {
    "xsi:type": string;
  }
}
typeNames.interfaces["DataObject"] = {};

export class ManagedObject {
  $value!: string;

  constructor(
    public connection: Connection,
    init?: Partial<ManagedObject>
  ) { Object.assign(this, init); }

  get id(): string {
    return this.$value;
  }
}
typeNames.classes["ManagedObject"] = {
  _this: ManagedObject,
  $value: "string"
};

export interface FaultCause {
  fault: MethodFault;
  localizedMessage?: string;
}
typeNames.interfaces["FaultCause"] = {
  fault: "MethodFault",
  localizedMessage: "string"
};

export interface FaultMessageArg {
  key: string;
  value: string;
}
typeNames.interfaces["FaultMessageArg"] = {
  key: "string",
  value: "string"
}

export interface FaultMessage {
  arg?: FaultMessageArg[];
  key: string;
  message: string;
}
typeNames.interfaces["FaultMessage"] = {
  arg: "FaultMessageArg",
  key: "string",
  message: "string"
};

export interface MethodFault {
  faultCause?: {
    fault: MethodFault;
    localizedMessage?: string;
  };
  faultMessage?: {
    arg?: {
      key: string;
      value: string;
    }[];
    key: string;
    message: string;
  }[];
}
typeNames.interfaces["MethodFault"] = {
  faultCause: "FaultCause",
  faultMessage: "FaultMessage"
};

export interface RuntimeFault extends MethodFault { }
typeNames.interfaces["RuntimeFault"] = typeNames.interfaces["MethodFault"];


export type DynamicArray = DataObject &  {
  dynamicType?: string;
  val: any[];
}
export type DynamicData = DataObject &  {
  dynamicType?: string;
  dynamicProperty?: DynamicProperty[];
}
export type DynamicProperty = DataObject &  {
  name: string;
  val: any;
}
export type KeyAnyValue = DynamicData &  {
  key: string;
  value: any;
}
export type LocalizableMessage = DynamicData &  {
  key: string;
  arg?: KeyAnyValue[];
  message?: string;
}
export type HostCommunication = RuntimeFault &  {
  
}
export type HostNotConnected = HostCommunication &  {
  
}
export type HostNotReachable = HostCommunication &  {
  
}
export type InvalidArgument = RuntimeFault &  {
  invalidProperty?: string;
}
export type InvalidRequest = RuntimeFault &  {
  
}
export type InvalidType = InvalidRequest &  {
  argument?: string;
}
export type ManagedObjectNotFound = RuntimeFault &  {
  obj: ManagedObject;
}
export type MethodNotFound = InvalidRequest &  {
  receiver: ManagedObject;
  method: string;
}
export type NotEnoughLicenses = RuntimeFault &  {
  
}
export type NotImplemented = RuntimeFault &  {
  
}
export type NotSupported = RuntimeFault &  {
  
}
export type RequestCanceled = RuntimeFault &  {
  
}
export type SecurityError = RuntimeFault &  {
  
}
export type SystemError = RuntimeFault &  {
  reason: string;
}
export type UnexpectedFault = RuntimeFault &  {
  faultName: string;
  fault?: MethodFault;
}
export type InvalidCollectorVersion = MethodFault &  {
  
}
export type InvalidProperty = MethodFault &  {
  name: string;
}
export type PropertyFilterSpec = DynamicData &  {
  propSet: PropertySpec[];
  objectSet: ObjectSpec[];
  reportMissingObjectsInResults?: boolean;
}
export type PropertySpec = DynamicData &  {
  type: string;
  all?: boolean;
  pathSet?: string[];
}
export type ObjectSpec = DynamicData &  {
  obj: ManagedObject;
  skip?: boolean;
  selectSet?: SelectionSpec[];
}
export type SelectionSpec = DynamicData &  {
  name?: string;
}
export type TraversalSpec = SelectionSpec &  {
  type: string;
  path: string;
  skip?: boolean;
  selectSet?: SelectionSpec[];
}
export type ObjectContent = DynamicData &  {
  obj: ManagedObject;
  propSet?: DynamicProperty[];
  missingSet?: MissingProperty[];
}
export type UpdateSet = DynamicData &  {
  version: string;
  filterSet?: PropertyFilterUpdate[];
  truncated?: boolean;
}
export type PropertyFilterUpdate = DynamicData &  {
  filter: PropertyFilter;
  objectSet?: ObjectUpdate[];
  missingSet?: MissingObject[];
}
export type ObjectUpdate = DynamicData &  {
  kind: ObjectUpdateKind;
  obj: ManagedObject;
  changeSet?: PropertyChange[];
  missingSet?: MissingProperty[];
}
export type PropertyChange = DynamicData &  {
  name: string;
  op: PropertyChangeOp;
  val?: any;
}
export type MissingProperty = DynamicData &  {
  path: string;
  fault: MethodFault;
}
export type MissingObject = DynamicData &  {
  obj: ManagedObject;
  fault: MethodFault;
}
export type WaitOptions = DynamicData &  {
  maxWaitSeconds?: number;
  maxObjectUpdates?: number;
}
export type RetrieveOptions = DynamicData &  {
  maxObjects?: number;
}
export type RetrieveResult = DynamicData &  {
  token?: string;
  objects: ObjectContent[];
}
export type AboutInfo = DynamicData &  {
  name: string;
  fullName: string;
  vendor: string;
  version: string;
  build: string;
  localeVersion?: string;
  localeBuild?: string;
  osType: string;
  productLineId: string;
  apiType: string;
  apiVersion: string;
  instanceUuid?: string;
  licenseProductName?: string;
  licenseProductVersion?: string;
}
export type AuthorizationDescription = DynamicData &  {
  privilege: ElementDescription[];
  privilegeGroup: ElementDescription[];
}
export type BatchResult = DynamicData &  {
  result: string;
  hostKey: string;
  ds?: Datastore;
  fault?: MethodFault;
}
export type Capability = DynamicData &  {
  provisioningSupported: boolean;
  multiHostSupported: boolean;
  userShellAccessSupported: boolean;
  supportedEVCMode?: EVCMode[];
  supportedEVCGraphicsMode?: FeatureEVCMode[];
  networkBackupAndRestoreSupported?: boolean;
  ftDrsWithoutEvcSupported?: boolean;
  hciWorkflowSupported?: boolean;
  computePolicyVersion?: number;
  clusterPlacementSupported?: boolean;
  lifecycleManagementSupported?: boolean;
  scalableSharesSupported?: boolean;
}
export type CustomFieldDef = DynamicData &  {
  key: number;
  name: string;
  type: string;
  managedObjectType?: string;
  fieldDefPrivileges?: PrivilegePolicyDef;
  fieldInstancePrivileges?: PrivilegePolicyDef;
}
export type CustomFieldStringValue = CustomFieldValue &  {
  value: string;
}
export type CustomFieldValue = DynamicData &  {
  key: number;
}
export type CustomizationSpecInfo = DynamicData &  {
  name: string;
  description: string;
  type: string;
  changeVersion?: string;
  lastUpdateTime?: Date;
}
export type CustomizationSpecItem = DynamicData &  {
  info: CustomizationSpecInfo;
  spec: CustomizationSpec;
}
export type Description = DynamicData &  {
  label: string;
  summary: string;
}
export type DesiredSoftwareSpec = DynamicData &  {
  baseImageSpec: DesiredSoftwareSpecBaseImageSpec;
  vendorAddOnSpec?: DesiredSoftwareSpecVendorAddOnSpec;
}
export type DesiredSoftwareSpecBaseImageSpec = DynamicData &  {
  version: string;
}
export type DesiredSoftwareSpecVendorAddOnSpec = DynamicData &  {
  name: string;
  version: string;
}
export type DiagnosticManagerBundleInfo = DynamicData &  {
  system?: HostSystem;
  url: string;
}
export type DiagnosticManagerLogDescriptor = DynamicData &  {
  key: string;
  fileName: string;
  creator: string;
  format: string;
  mimeType: string;
  info: Description;
}
export type DiagnosticManagerLogHeader = DynamicData &  {
  lineStart: number;
  lineEnd: number;
  lineText?: string[];
}
export type ElementDescription = Description &  {
  key: string;
}
export type EnumDescription = DynamicData &  {
  key: string;
  tags: ElementDescription[];
}
export type EnvironmentBrowserConfigOptionQuerySpec = DynamicData &  {
  key?: string;
  host?: HostSystem;
  guestId?: string[];
}
export type ExtendedDescription = Description &  {
  messageCatalogKeyPrefix: string;
  messageArg?: KeyAnyValue[];
}
export type ExtendedElementDescription = ElementDescription &  {
  messageCatalogKeyPrefix: string;
  messageArg?: KeyAnyValue[];
}
export type Extension = DynamicData &  {
  description: Description;
  key: string;
  company?: string;
  type?: string;
  version: string;
  subjectName?: string;
  server?: ExtensionServerInfo[];
  client?: ExtensionClientInfo[];
  taskList?: ExtensionTaskTypeInfo[];
  eventList?: ExtensionEventTypeInfo[];
  faultList?: ExtensionFaultTypeInfo[];
  privilegeList?: ExtensionPrivilegeInfo[];
  resourceList?: ExtensionResourceInfo[];
  lastHeartbeatTime: Date;
  healthInfo?: ExtensionHealthInfo;
  ovfConsumerInfo?: ExtensionOvfConsumerInfo;
  extendedProductInfo?: ExtExtendedProductInfo;
  managedEntityInfo?: ExtManagedEntityInfo[];
  shownInSolutionManager?: boolean;
  solutionManagerInfo?: ExtSolutionManagerInfo;
}
export type ExtensionClientInfo = DynamicData &  {
  version: string;
  description: Description;
  company: string;
  type: string;
  url: string;
}
export type ExtensionEventTypeInfo = DynamicData &  {
  eventID: string;
  eventTypeSchema?: string;
}
export type ExtensionFaultTypeInfo = DynamicData &  {
  faultID: string;
}
export type ExtensionHealthInfo = DynamicData &  {
  url: string;
}
export type ExtensionOvfConsumerInfo = DynamicData &  {
  callbackUrl: string;
  sectionType: string[];
}
export type ExtensionPrivilegeInfo = DynamicData &  {
  privID: string;
  privGroupName: string;
}
export type ExtensionResourceInfo = DynamicData &  {
  locale: string;
  module: string;
  data: KeyValue[];
}
export type ExtensionServerInfo = DynamicData &  {
  url: string;
  description: Description;
  company: string;
  type: string;
  adminEmail: string[];
  serverThumbprint?: string;
}
export type ExtensionTaskTypeInfo = DynamicData &  {
  taskID: string;
}
export type ExtensionManagerIpAllocationUsage = DynamicData &  {
  extensionKey: string;
  numAddresses: number;
}
export type FaultsByHost = DynamicData &  {
  host: HostSystem;
  faults?: MethodFault[];
}
export type FaultsByVM = DynamicData &  {
  vm: VirtualMachine;
  faults?: MethodFault[];
}
export type FeatureEVCMode = ElementDescription &  {
  mask?: HostFeatureMask[];
  capability?: HostFeatureCapability[];
  requirement?: VirtualMachineFeatureRequirement[];
}
export type HbrManagerReplicationVmInfo = DynamicData &  {
  state: string;
  progressInfo?: ReplicationVmProgressInfo;
  imageId?: string;
  lastError?: MethodFault;
}
export type ReplicationVmProgressInfo = DynamicData &  {
  progress: number;
  bytesTransferred: number;
  bytesToTransfer: number;
  checksumTotalBytes?: number;
  checksumComparedBytes?: number;
}
export type HbrManagerVmReplicationCapability = DynamicData &  {
  vm: VirtualMachine;
  supportedQuiesceMode: string;
  compressionSupported: boolean;
  maxSupportedSourceDiskCapacity: number;
  minRpo?: number;
  fault?: MethodFault;
}
export type HealthUpdateInfo = DynamicData &  {
  id: string;
  componentType: string;
  description: string;
}
export type PerfInterval = DynamicData &  {
  key: number;
  samplingPeriod: number;
  name: string;
  length: number;
  level?: number;
  enabled: boolean;
}
export type HostServiceTicket = DynamicData &  {
  host?: string;
  port?: number;
  sslThumbprint?: string;
  service: string;
  serviceVersion: string;
  sessionId: string;
}
export type HttpNfcLeaseCapabilities = DynamicData &  {
  pullModeSupported: boolean;
  corsSupported: boolean;
}
export type HttpNfcLeaseDatastoreLeaseInfo = DynamicData &  {
  datastoreKey: string;
  hosts: HttpNfcLeaseHostInfo[];
}
export type HttpNfcLeaseDeviceUrl = DynamicData &  {
  key: string;
  importKey: string;
  url: string;
  sslThumbprint: string;
  disk?: boolean;
  targetId?: string;
  datastoreKey?: string;
  fileSize?: number;
}
export type HttpNfcLeaseHostInfo = DynamicData &  {
  url: string;
  sslThumbprint: string;
}
export type HttpNfcLeaseInfo = DynamicData &  {
  lease: HttpNfcLease;
  entity: ManagedEntity;
  deviceUrl?: HttpNfcLeaseDeviceUrl[];
  totalDiskCapacityInKB: number;
  leaseTimeout: number;
  hostMap?: HttpNfcLeaseDatastoreLeaseInfo[];
}
export type HttpNfcLeaseManifestEntry = DynamicData &  {
  key: string;
  sha1: string;
  checksum?: string;
  checksumType?: string;
  size: number;
  disk: boolean;
  capacity?: number;
  populatedSize?: number;
}
export type HttpNfcLeaseSourceFile = DynamicData &  {
  targetDeviceId: string;
  url: string;
  memberName?: string;
  create: boolean;
  sslThumbprint?: string;
  httpHeaders?: KeyValue[];
  size?: number;
}
export type InheritablePolicy = DynamicData &  {
  inherited: boolean;
}
export type IntPolicy = InheritablePolicy &  {
  value?: number;
}
export type ClusterIoFilterInfo = IoFilterInfo &  {
  opType: string;
  vibUrl?: string;
}
export type HostIoFilterInfo = IoFilterInfo &  {
  available: boolean;
}
export type IoFilterInfo = DynamicData &  {
  id: string;
  name: string;
  vendor: string;
  version: string;
  type?: string;
  summary?: string;
  releaseDate?: string;
}
export type IoFilterQueryIssueResult = DynamicData &  {
  opType: string;
  hostIssue?: IoFilterHostIssue[];
}
export type IoFilterHostIssue = DynamicData &  {
  host: HostSystem;
  issue: MethodFault[];
}
export type IpPoolManagerIpAllocation = DynamicData &  {
  ipAddress: string;
  allocationId: string;
}
export type KeyValue = DynamicData &  {
  key: string;
  value: string;
}
export type LatencySensitivity = DynamicData &  {
  level: LatencySensitivitySensitivityLevel;
  sensitivity?: number;
}
export type LicenseAvailabilityInfo = DynamicData &  {
  feature: LicenseFeatureInfo;
  total: number;
  available: number;
}
export type LicenseDiagnostics = DynamicData &  {
  sourceLastChanged: Date;
  sourceLost: string;
  sourceLatency: number;
  licenseRequests: string;
  licenseRequestFailures: string;
  licenseFeatureUnknowns: string;
  opState: LicenseManagerState;
  lastStatusUpdate: Date;
  opFailureMessage: string;
}
export type LicenseManagerEvaluationInfo = DynamicData &  {
  properties: KeyAnyValue[];
}
export type EvaluationLicenseSource = LicenseSource &  {
  remainingHours?: number;
}
export type LicenseFeatureInfo = DynamicData &  {
  key: string;
  featureName: string;
  featureDescription?: string;
  state?: LicenseFeatureInfoState;
  costUnit: string;
  sourceRestriction?: string;
  dependentKey?: string[];
  edition?: boolean;
  expiresOn?: Date;
}
export type HostLicensableResourceInfo = DynamicData &  {
  resource: KeyAnyValue[];
}
export type LicenseManagerLicenseInfo = DynamicData &  {
  licenseKey: string;
  editionKey: string;
  name: string;
  total: number;
  used?: number;
  costUnit: string;
  properties?: KeyAnyValue[];
  labels?: KeyValue[];
}
export type LicenseServerSource = LicenseSource &  {
  licenseServer: string;
}
export type LicenseSource = DynamicData &  {
  
}
export type LicenseUsageInfo = DynamicData &  {
  source: LicenseSource;
  sourceAvailable: boolean;
  reservationInfo?: LicenseReservationInfo[];
  featureInfo?: LicenseFeatureInfo[];
}
export type LocalLicenseSource = LicenseSource &  {
  licenseKeys: string;
}
export type LicenseReservationInfo = DynamicData &  {
  key: string;
  state: LicenseReservationInfoState;
  required: number;
}
export type LocalizationManagerMessageCatalog = DynamicData &  {
  moduleName: string;
  catalogName: string;
  locale: string;
  catalogUri: string;
  lastModified?: Date;
  md5sum?: string;
  version?: string;
}
export type LongPolicy = InheritablePolicy &  {
  value?: number;
}
export type MethodDescription = Description &  {
  key: string;
}
export type NegatableExpression = DynamicData &  {
  negate?: boolean;
}
export type NumericRange = DynamicData &  {
  start: number;
  end: number;
}
export type OvfConsumerOstNode = DynamicData &  {
  id: string;
  type: string;
  section?: OvfConsumerOvfSection[];
  child?: OvfConsumerOstNode[];
  entity?: ManagedEntity;
}
export type OvfConsumerOvfSection = DynamicData &  {
  lineNumber: number;
  xml: string;
}
export type OvfManagerCommonParams = DynamicData &  {
  locale: string;
  deploymentOption: string;
  msgBundle?: KeyValue[];
  importOption?: string[];
}
export type OvfCreateDescriptorParams = DynamicData &  {
  ovfFiles?: OvfFile[];
  name?: string;
  description?: string;
  includeImageFiles?: boolean;
  exportOption?: string[];
  snapshot?: VirtualMachineSnapshot;
}
export type OvfCreateDescriptorResult = DynamicData &  {
  ovfDescriptor: string;
  error?: MethodFault[];
  warning?: MethodFault[];
  includeImageFiles?: boolean;
}
export type OvfCreateImportSpecParams = OvfManagerCommonParams &  {
  entityName: string;
  hostSystem?: HostSystem;
  networkMapping?: OvfNetworkMapping[];
  ipAllocationPolicy?: string;
  ipProtocol?: string;
  propertyMapping?: KeyValue[];
  resourceMapping?: OvfResourceMap[];
  diskProvisioning?: string;
  instantiationOst?: OvfConsumerOstNode;
}
export type OvfCreateImportSpecResult = DynamicData &  {
  importSpec?: ImportSpec;
  fileItem?: OvfFileItem[];
  warning?: MethodFault[];
  error?: MethodFault[];
}
export type OvfDeploymentOption = DynamicData &  {
  key: string;
  label: string;
  description: string;
}
export type OvfFileItem = DynamicData &  {
  deviceId: string;
  path: string;
  compressionMethod?: string;
  chunkSize?: number;
  size?: number;
  cimType: number;
  create: boolean;
}
export type OvfNetworkInfo = DynamicData &  {
  name: string;
  description: string;
}
export type OvfNetworkMapping = DynamicData &  {
  name: string;
  network: Network;
}
export type OvfFile = DynamicData &  {
  deviceId: string;
  path: string;
  compressionMethod?: string;
  chunkSize?: number;
  size: number;
  capacity?: number;
  populatedSize?: number;
}
export type OvfOptionInfo = DynamicData &  {
  option: string;
  description: LocalizableMessage;
}
export type OvfParseDescriptorParams = OvfManagerCommonParams &  {
  
}
export type OvfParseDescriptorResult = DynamicData &  {
  eula?: string[];
  network?: OvfNetworkInfo[];
  ipAllocationScheme?: string[];
  ipProtocols?: string[];
  property?: VAppPropertyInfo[];
  productInfo?: VAppProductInfo;
  annotation: string;
  approximateDownloadSize?: number;
  approximateFlatDeploymentSize?: number;
  approximateSparseDeploymentSize?: number;
  defaultEntityName: string;
  virtualApp: boolean;
  deploymentOption?: OvfDeploymentOption[];
  defaultDeploymentOption: string;
  entityName?: KeyValue[];
  annotatedOst?: OvfConsumerOstNode;
  error?: MethodFault[];
  warning?: MethodFault[];
}
export type OvfResourceMap = DynamicData &  {
  source: string;
  parent?: ResourcePool;
  resourceSpec?: ResourceConfigSpec;
  datastore?: Datastore;
}
export type OvfValidateHostParams = OvfManagerCommonParams &  {
  
}
export type OvfValidateHostResult = DynamicData &  {
  downloadSize?: number;
  flatDeploymentSize?: number;
  sparseDeploymentSize?: number;
  error?: MethodFault[];
  warning?: MethodFault[];
  supportedDiskProvisioning?: string[];
}
export type PasswordField = DynamicData &  {
  value: string;
}
export type PerformanceDescription = DynamicData &  {
  counterType: ElementDescription[];
  statsType: ElementDescription[];
}
export type PerfCompositeMetric = DynamicData &  {
  entity?: PerfEntityMetricBase;
  childEntity?: PerfEntityMetricBase[];
}
export type PerfCounterInfo = DynamicData &  {
  key: number;
  nameInfo: ElementDescription;
  groupInfo: ElementDescription;
  unitInfo: ElementDescription;
  rollupType: PerfSummaryType;
  statsType: PerfStatsType;
  level?: number;
  perDeviceLevel?: number;
  associatedCounterId?: number[];
}
export type PerformanceManagerCounterLevelMapping = DynamicData &  {
  counterId: number;
  aggregateLevel?: number;
  perDeviceLevel?: number;
}
export type PerfEntityMetric = PerfEntityMetricBase &  {
  sampleInfo?: PerfSampleInfo[];
  value?: PerfMetricSeries[];
}
export type PerfEntityMetricBase = DynamicData &  {
  entity: ManagedObject;
}
export type PerfEntityMetricCSV = PerfEntityMetricBase &  {
  sampleInfoCSV: string;
  value?: PerfMetricSeriesCSV[];
}
export type PerfMetricIntSeries = PerfMetricSeries &  {
  value?: number[];
}
export type PerfMetricId = DynamicData &  {
  counterId: number;
  instance: string;
}
export type PerfMetricSeries = DynamicData &  {
  id: PerfMetricId;
}
export type PerfMetricSeriesCSV = PerfMetricSeries &  {
  value?: string;
}
export type PerfProviderSummary = DynamicData &  {
  entity: ManagedObject;
  currentSupported: boolean;
  summarySupported: boolean;
  refreshRate?: number;
}
export type PerfQuerySpec = DynamicData &  {
  entity: ManagedObject;
  startTime?: Date;
  endTime?: Date;
  maxSample?: number;
  metricId?: PerfMetricId[];
  intervalId?: number;
  format?: string;
}
export type PerfSampleInfo = DynamicData &  {
  timestamp: Date;
  interval: number;
}
export type PrivilegePolicyDef = DynamicData &  {
  createPrivilege: string;
  readPrivilege: string;
  updatePrivilege: string;
  deletePrivilege: string;
}
export type ResourceAllocationInfo = DynamicData &  {
  reservation?: number;
  expandableReservation?: boolean;
  limit?: number;
  shares?: SharesInfo;
  overheadLimit?: number;
}
export type ResourceAllocationOption = DynamicData &  {
  sharesOption: SharesOption;
}
export type ResourceConfigOption = DynamicData &  {
  cpuAllocationOption: ResourceAllocationOption;
  memoryAllocationOption: ResourceAllocationOption;
}
export type ResourceConfigSpec = DynamicData &  {
  entity?: ManagedEntity;
  changeVersion?: string;
  lastModified?: Date;
  cpuAllocation: ResourceAllocationInfo;
  memoryAllocation: ResourceAllocationInfo;
  scaleDescendantsShares?: string;
}
export type DatabaseSizeEstimate = DynamicData &  {
  size: number;
}
export type DatabaseSizeParam = DynamicData &  {
  inventoryDesc: InventoryDescription;
  perfStatsDesc?: PerformanceStatisticsDescription;
}
export type InventoryDescription = DynamicData &  {
  numHosts: number;
  numVirtualMachines: number;
  numResourcePools?: number;
  numClusters?: number;
  numCpuDev?: number;
  numNetDev?: number;
  numDiskDev?: number;
  numvCpuDev?: number;
  numvNetDev?: number;
  numvDiskDev?: number;
}
export type PerformanceStatisticsDescription = DynamicData &  {
  intervals?: PerfInterval[];
}
export type SDDCBase = DynamicData &  {
  
}
export type SelectionSet = DynamicData &  {
  
}
export type ServiceContent = DynamicData &  {
  rootFolder: Folder;
  propertyCollector: PropertyCollector;
  viewManager?: ViewManager;
  about: AboutInfo;
  setting?: OptionManager;
  userDirectory?: UserDirectory;
  sessionManager?: SessionManager;
  authorizationManager?: AuthorizationManager;
  serviceManager?: ServiceManager;
  perfManager?: PerformanceManager;
  scheduledTaskManager?: ScheduledTaskManager;
  alarmManager?: AlarmManager;
  eventManager?: EventManager;
  taskManager?: TaskManager;
  extensionManager?: ExtensionManager;
  customizationSpecManager?: CustomizationSpecManager;
  guestCustomizationManager?: VirtualMachineGuestCustomizationManager;
  customFieldsManager?: CustomFieldsManager;
  accountManager?: HostLocalAccountManager;
  diagnosticManager?: DiagnosticManager;
  licenseManager?: LicenseManager;
  searchIndex?: SearchIndex;
  fileManager?: FileManager;
  datastoreNamespaceManager?: DatastoreNamespaceManager;
  virtualDiskManager?: VirtualDiskManager;
  virtualizationManager?: VirtualizationManager;
  snmpSystem?: HostSnmpSystem;
  vmProvisioningChecker?: VirtualMachineProvisioningChecker;
  vmCompatibilityChecker?: VirtualMachineCompatibilityChecker;
  ovfManager?: OvfManager;
  ipPoolManager?: IpPoolManager;
  dvSwitchManager?: DistributedVirtualSwitchManager;
  hostProfileManager?: HostProfileManager;
  clusterProfileManager?: ClusterProfileManager;
  complianceManager?: ProfileComplianceManager;
  localizationManager?: LocalizationManager;
  storageResourceManager?: StorageResourceManager;
  guestOperationsManager?: GuestOperationsManager;
  overheadMemoryManager?: OverheadMemoryManager;
  certificateManager?: CertificateManager;
  ioFilterManager?: IoFilterManager;
  vStorageObjectManager?: VStorageObjectManagerBase;
  hostSpecManager?: HostSpecificationManager;
  cryptoManager?: CryptoManager;
  healthUpdateManager?: HealthUpdateManager;
  failoverClusterConfigurator?: FailoverClusterConfigurator;
  failoverClusterManager?: FailoverClusterManager;
  tenantManager?: TenantTenantManager;
  siteInfoManager?: SiteInfoManager;
  storageQueryManager?: StorageQueryManager;
}
export type ServiceLocator = DynamicData &  {
  instanceUuid: string;
  url: string;
  credential: ServiceLocatorCredential;
  sslThumbprint?: string;
}
export type ServiceLocatorCredential = DynamicData &  {
  
}
export type ServiceLocatorNamePassword = ServiceLocatorCredential &  {
  username: string;
  password: string;
}
export type ServiceLocatorSAMLCredential = ServiceLocatorCredential &  {
  token?: string;
}
export type ServiceManagerServiceInfo = DynamicData &  {
  serviceName: string;
  location?: string[];
  service: ManagedObject;
  description: string;
}
export type SessionManagerGenericServiceTicket = DynamicData &  {
  id: string;
  hostName?: string;
  sslThumbprint?: string;
}
export type SessionManagerHttpServiceRequestSpec = SessionManagerServiceRequestSpec &  {
  method?: string;
  url: string;
}
export type SessionManagerLocalTicket = DynamicData &  {
  userName: string;
  passwordFilePath: string;
}
export type SessionManagerServiceRequestSpec = DynamicData &  {
  
}
export type SessionManagerVmomiServiceRequestSpec = SessionManagerServiceRequestSpec &  {
  method: string;
}
export type SharesInfo = DynamicData &  {
  shares: number;
  level: SharesLevel;
}
export type SharesOption = DynamicData &  {
  sharesOption: IntOption;
  defaultLevel: SharesLevel;
}
export type SiteInfo = DynamicData &  {
  
}
export type StorageIOAllocationInfo = DynamicData &  {
  limit?: number;
  shares?: SharesInfo;
  reservation?: number;
}
export type StorageIOAllocationOption = DynamicData &  {
  limitOption: LongOption;
  sharesOption: SharesOption;
}
export type StorageIORMInfo = DynamicData &  {
  enabled: boolean;
  congestionThresholdMode: string;
  congestionThreshold: number;
  percentOfPeakThroughput?: number;
  statsCollectionEnabled: boolean;
  reservationEnabled: boolean;
  statsAggregationDisabled?: boolean;
  reservableIopsThreshold?: number;
}
export type StorageIORMConfigOption = DynamicData &  {
  enabledOption: BoolOption;
  congestionThresholdOption: IntOption;
  statsCollectionEnabledOption: BoolOption;
  reservationEnabledOption: BoolOption;
}
export type StorageIORMConfigSpec = DynamicData &  {
  enabled?: boolean;
  congestionThresholdMode?: string;
  congestionThreshold?: number;
  percentOfPeakThroughput?: number;
  statsCollectionEnabled?: boolean;
  reservationEnabled?: boolean;
  statsAggregationDisabled?: boolean;
  reservableIopsThreshold?: number;
}
export type PodStorageDrsEntry = DynamicData &  {
  storageDrsConfig: StorageDrsConfigInfo;
  recommendation?: ClusterRecommendation[];
  drsFault?: ClusterDrsFaults[];
  actionHistory?: ClusterActionHistory[];
}
export type StoragePerformanceSummary = DynamicData &  {
  interval: number;
  percentile: number[];
  datastoreReadLatency: number[];
  datastoreWriteLatency: number[];
  datastoreVmLatency: number[];
  datastoreReadIops: number[];
  datastoreWriteIops: number[];
  siocActivityDuration: number;
}
export type StorageResourceManagerStorageProfileStatistics = DynamicData &  {
  profileId: string;
  totalSpaceMB: number;
  usedSpaceMB: number;
}
export type StringExpression = NegatableExpression &  {
  value?: string;
}
export type StringPolicy = InheritablePolicy &  {
  value?: string;
}
export type Tag = DynamicData &  {
  key: string;
}
export type TaskDescription = DynamicData &  {
  methodInfo: ElementDescription[];
  state: ElementDescription[];
  reason: TypeDescription[];
}
export type TaskInfo = DynamicData &  {
  key: string;
  task: Task;
  description?: LocalizableMessage;
  name?: string;
  descriptionId: string;
  entity?: ManagedEntity;
  entityName?: string;
  locked?: ManagedEntity[];
  state: TaskInfoState;
  cancelled: boolean;
  cancelable: boolean;
  error?: MethodFault;
  result?: any;
  progress?: number;
  reason: TaskReason;
  queueTime: Date;
  startTime?: Date;
  completeTime?: Date;
  eventChainId: number;
  changeTag?: string;
  parentTaskKey?: string;
  rootTaskKey?: string;
  activationId?: string;
}
export type TaskReason = DynamicData &  {
  
}
export type TaskReasonAlarm = TaskReason &  {
  alarmName: string;
  alarm: Alarm;
  entityName: string;
  entity: ManagedEntity;
}
export type TaskReasonSchedule = TaskReason &  {
  name: string;
  scheduledTask: ScheduledTask;
}
export type TaskReasonSystem = TaskReason &  {
  
}
export type TaskReasonUser = TaskReason &  {
  userName: string;
}
export type TypeDescription = Description &  {
  key: string;
}
export type UpdateVirtualMachineFilesResult = DynamicData &  {
  failedVmFile?: UpdateVirtualMachineFilesResultFailedVmFileInfo[];
}
export type UpdateVirtualMachineFilesResultFailedVmFileInfo = DynamicData &  {
  vmFile: string;
  fault: MethodFault;
}
export type UserSearchResult = DynamicData &  {
  principal: string;
  fullName?: string;
  group: boolean;
}
export type UserSession = DynamicData &  {
  key: string;
  userName: string;
  fullName: string;
  loginTime: Date;
  lastActiveTime: Date;
  locale: string;
  messageLocale: string;
  extensionSession: boolean;
  ipAddress: string;
  userAgent: string;
  callCount: number;
}
export type VVolVmConfigFileUpdateResult = DynamicData &  {
  succeededVmConfigFile?: KeyValue[];
  failedVmConfigFile?: VVolVmConfigFileUpdateResultFailedVmConfigFileInfo[];
}
export type VVolVmConfigFileUpdateResultFailedVmConfigFileInfo = DynamicData &  {
  targetConfigVVolId: string;
  dsPath?: string;
  fault: MethodFault;
}
export type VASAStorageArray = DynamicData &  {
  name: string;
  uuid: string;
  vendorId: string;
  modelId: string;
}
export type VimVasaProvider = DynamicData &  {
  uid?: string;
  url: string;
  name?: string;
  selfSignedCertificate?: string;
}
export type VimVasaProviderStatePerArray = DynamicData &  {
  priority: number;
  arrayId: string;
  active: boolean;
}
export type VimVasaProviderInfo = DynamicData &  {
  provider: VimVasaProvider;
  arrayState?: VimVasaProviderStatePerArray[];
}
export type VsanUpgradeSystemAPIBrokenIssue = VsanUpgradeSystemPreflightCheckIssue &  {
  hosts: HostSystem[];
}
export type VsanUpgradeSystemAutoClaimEnabledOnHostsIssue = VsanUpgradeSystemPreflightCheckIssue &  {
  hosts: HostSystem[];
}
export type VsanUpgradeSystemHostsDisconnectedIssue = VsanUpgradeSystemPreflightCheckIssue &  {
  hosts: HostSystem[];
}
export type VsanUpgradeSystemMissingHostsInClusterIssue = VsanUpgradeSystemPreflightCheckIssue &  {
  hosts: HostSystem[];
}
export type VsanUpgradeSystemNetworkPartitionInfo = DynamicData &  {
  hosts: HostSystem[];
}
export type VsanUpgradeSystemNetworkPartitionIssue = VsanUpgradeSystemPreflightCheckIssue &  {
  partitions: VsanUpgradeSystemNetworkPartitionInfo[];
}
export type VsanUpgradeSystemNotEnoughFreeCapacityIssue = VsanUpgradeSystemPreflightCheckIssue &  {
  reducedRedundancyUpgradePossible: boolean;
}
export type VsanUpgradeSystemPreflightCheckIssue = DynamicData &  {
  msg: string;
}
export type VsanUpgradeSystemPreflightCheckResult = DynamicData &  {
  issues?: VsanUpgradeSystemPreflightCheckIssue[];
  diskMappingToRestore?: VsanHostDiskMapping;
}
export type VsanUpgradeSystemRogueHostsInClusterIssue = VsanUpgradeSystemPreflightCheckIssue &  {
  uuids: string[];
}
export type VsanUpgradeSystemUpgradeHistoryDiskGroupOp = VsanUpgradeSystemUpgradeHistoryItem &  {
  operation: string;
  diskMapping: VsanHostDiskMapping;
}
export type VsanUpgradeSystemUpgradeHistoryItem = DynamicData &  {
  timestamp: Date;
  host?: HostSystem;
  message: string;
  task?: Task;
}
export type VsanUpgradeSystemUpgradeHistoryPreflightFail = VsanUpgradeSystemUpgradeHistoryItem &  {
  preflightResult: VsanUpgradeSystemPreflightCheckResult;
}
export type VsanUpgradeSystemUpgradeStatus = DynamicData &  {
  inProgress: boolean;
  history?: VsanUpgradeSystemUpgradeHistoryItem[];
  aborted?: boolean;
  completed?: boolean;
  progress?: number;
}
export type VsanUpgradeSystemV2ObjectsPresentDuringDowngradeIssue = VsanUpgradeSystemPreflightCheckIssue &  {
  uuids: string[];
}
export type VsanUpgradeSystemWrongEsxVersionIssue = VsanUpgradeSystemPreflightCheckIssue &  {
  hosts: HostSystem[];
}
export type Action = DynamicData &  {
  
}
export type CreateTaskAction = Action &  {
  taskTypeId: string;
  cancelable: boolean;
}
export type MethodAction = Action &  {
  name: string;
  argument?: MethodActionArgument[];
}
export type MethodActionArgument = DynamicData &  {
  value?: any;
}
export type RunScriptAction = Action &  {
  script: string;
}
export type SendEmailAction = Action &  {
  toList: string;
  ccList: string;
  subject: string;
  body: string;
}
export type SendSNMPAction = Action &  {
  
}
export type AlarmAction = DynamicData &  {
  
}
export type AlarmDescription = DynamicData &  {
  expr: TypeDescription[];
  stateOperator: ElementDescription[];
  metricOperator: ElementDescription[];
  hostSystemConnectionState: ElementDescription[];
  virtualMachinePowerState: ElementDescription[];
  datastoreConnectionState: ElementDescription[];
  hostSystemPowerState: ElementDescription[];
  virtualMachineGuestHeartbeatStatus: ElementDescription[];
  entityStatus: ElementDescription[];
  action: TypeDescription[];
}
export type AlarmExpression = DynamicData &  {
  
}
export type AlarmSetting = DynamicData &  {
  toleranceRange: number;
  reportingFrequency: number;
}
export type AlarmSpec = DynamicData &  {
  name: string;
  systemName?: string;
  description: string;
  enabled: boolean;
  expression: AlarmExpression;
  action?: AlarmAction;
  actionFrequency?: number;
  setting?: AlarmSetting;
}
export type AndAlarmExpression = AlarmExpression &  {
  expression: AlarmExpression[];
}
export type GroupAlarmAction = AlarmAction &  {
  action: AlarmAction[];
}
export type MetricAlarmExpression = AlarmExpression &  {
  operator: MetricAlarmOperator;
  type: string;
  metric: PerfMetricId;
  yellow?: number;
  yellowInterval?: number;
  red?: number;
  redInterval?: number;
}
export type OrAlarmExpression = AlarmExpression &  {
  expression: AlarmExpression[];
}
export type StateAlarmExpression = AlarmExpression &  {
  operator: StateAlarmOperator;
  type: string;
  statePath: string;
  yellow?: string;
  red?: string;
}
export type ClusterAction = DynamicData &  {
  type: string;
  target?: ManagedObject;
}
export type ClusterActionHistory = DynamicData &  {
  action: ClusterAction;
  time: Date;
}
export type ClusterAttemptedVmInfo = DynamicData &  {
  vm: VirtualMachine;
  task?: Task;
}
export type ClusterConfigInfo = DynamicData &  {
  dasConfig: ClusterDasConfigInfo;
  dasVmConfig?: ClusterDasVmConfigInfo[];
  drsConfig: ClusterDrsConfigInfo;
  drsVmConfig?: ClusterDrsVmConfigInfo[];
  rule?: ClusterRuleInfo[];
}
export type ClusterConfigSpec = DynamicData &  {
  dasConfig?: ClusterDasConfigInfo;
  dasVmConfigSpec?: ClusterDasVmConfigSpec[];
  drsConfig?: ClusterDrsConfigInfo;
  drsVmConfigSpec?: ClusterDrsVmConfigSpec[];
  rulesSpec?: ClusterRuleSpec[];
}
export type ClusterCryptoConfigInfo = DynamicData &  {
  cryptoMode?: string;
}
export type ClusterDasAamNodeState = DynamicData &  {
  host: HostSystem;
  name: string;
  configState: string;
  runtimeState: string;
}
export type ClusterDasAdmissionControlInfo = DynamicData &  {
  
}
export type ClusterDasAdmissionControlPolicy = DynamicData &  {
  resourceReductionToToleratePercent?: number;
}
export type ClusterDasAdvancedRuntimeInfo = DynamicData &  {
  dasHostInfo?: ClusterDasHostInfo;
  vmcpSupported?: ClusterDasAdvancedRuntimeInfoVmcpCapabilityInfo;
  heartbeatDatastoreInfo?: DasHeartbeatDatastoreInfo[];
}
export type DasHeartbeatDatastoreInfo = DynamicData &  {
  datastore: Datastore;
  hosts: HostSystem[];
}
export type ClusterDasAdvancedRuntimeInfoVmcpCapabilityInfo = DynamicData &  {
  storageAPDSupported: boolean;
  storagePDLSupported: boolean;
}
export type ClusterDasConfigInfo = DynamicData &  {
  enabled?: boolean;
  vmMonitoring?: string;
  hostMonitoring?: string;
  vmComponentProtecting?: string;
  failoverLevel?: number;
  admissionControlPolicy?: ClusterDasAdmissionControlPolicy;
  admissionControlEnabled?: boolean;
  defaultVmSettings?: ClusterDasVmSettings;
  option?: OptionValue[];
  heartbeatDatastore?: Datastore[];
  hBDatastoreCandidatePolicy?: string;
}
export type ClusterDasData = DynamicData &  {
  
}
export type ClusterDasDataSummary = ClusterDasData &  {
  hostListVersion: number;
  clusterConfigVersion: number;
  compatListVersion: number;
}
export type ClusterDasFailoverLevelAdvancedRuntimeInfo = ClusterDasAdvancedRuntimeInfo &  {
  slotInfo: ClusterDasFailoverLevelAdvancedRuntimeInfoSlotInfo;
  totalSlots: number;
  usedSlots: number;
  unreservedSlots: number;
  totalVms: number;
  totalHosts: number;
  totalGoodHosts: number;
  hostSlots?: ClusterDasFailoverLevelAdvancedRuntimeInfoHostSlots[];
  vmsRequiringMultipleSlots?: ClusterDasFailoverLevelAdvancedRuntimeInfoVmSlots[];
}
export type ClusterDasFailoverLevelAdvancedRuntimeInfoHostSlots = DynamicData &  {
  host: HostSystem;
  slots: number;
}
export type ClusterDasFailoverLevelAdvancedRuntimeInfoSlotInfo = DynamicData &  {
  numVcpus: number;
  cpuMHz: number;
  memoryMB: number;
}
export type ClusterDasFailoverLevelAdvancedRuntimeInfoVmSlots = DynamicData &  {
  vm: VirtualMachine;
  slots: number;
}
export type ClusterDasFdmHostState = DynamicData &  {
  state: string;
  stateReporter?: HostSystem;
}
export type ClusterDasHostInfo = DynamicData &  {
  
}
export type ClusterDasHostRecommendation = DynamicData &  {
  host: HostSystem;
  drsRating?: number;
}
export type ClusterDasVmConfigInfo = DynamicData &  {
  key: VirtualMachine;
  restartPriority?: DasVmPriority;
  powerOffOnIsolation?: boolean;
  dasSettings?: ClusterDasVmSettings;
}
export type ClusterDasVmSettings = DynamicData &  {
  restartPriority?: string;
  restartPriorityTimeout?: number;
  isolationResponse?: string;
  vmToolsMonitoringSettings?: ClusterVmToolsMonitoringSettings;
  vmComponentProtectionSettings?: ClusterVmComponentProtectionSettings;
}
export type ClusterDpmConfigInfo = DynamicData &  {
  enabled?: boolean;
  defaultDpmBehavior?: DpmBehavior;
  hostPowerActionRate?: number;
  option?: OptionValue[];
}
export type ClusterDpmHostConfigInfo = DynamicData &  {
  key: HostSystem;
  enabled?: boolean;
  behavior?: DpmBehavior;
}
export type ClusterDrsConfigInfo = DynamicData &  {
  enabled?: boolean;
  enableVmBehaviorOverrides?: boolean;
  defaultVmBehavior?: DrsBehavior;
  vmotionRate?: number;
  scaleDescendantsShares?: string;
  option?: OptionValue[];
}
export type ClusterDrsFaults = DynamicData &  {
  reason: string;
  faultsByVm: ClusterDrsFaultsFaultsByVm[];
}
export type ClusterDrsFaultsFaultsByVirtualDisk = ClusterDrsFaultsFaultsByVm &  {
  disk?: VirtualDiskId;
}
export type ClusterDrsFaultsFaultsByVm = DynamicData &  {
  vm?: VirtualMachine;
  fault: MethodFault[];
}
export type ClusterDrsMigration = DynamicData &  {
  key: string;
  time: Date;
  vm: VirtualMachine;
  cpuLoad?: number;
  memoryLoad?: number;
  source: HostSystem;
  sourceCpuLoad?: number;
  sourceMemoryLoad?: number;
  destination: HostSystem;
  destinationCpuLoad?: number;
  destinationMemoryLoad?: number;
}
export type ClusterDrsRecommendation = DynamicData &  {
  key: string;
  rating: number;
  reason: string;
  reasonText: string;
  migrationList: ClusterDrsMigration[];
}
export type ClusterDrsVmConfigInfo = DynamicData &  {
  key: VirtualMachine;
  enabled?: boolean;
  behavior?: DrsBehavior;
}
export type ClusterEVCManagerCheckResult = DynamicData &  {
  evcModeKey: string;
  error: MethodFault;
  host?: HostSystem[];
}
export type ClusterEVCManagerEVCState = DynamicData &  {
  supportedEVCMode: EVCMode[];
  currentEVCModeKey?: string;
  guaranteedCPUFeatures?: HostCpuIdInfo[];
  featureCapability?: HostFeatureCapability[];
  featureMask?: HostFeatureMask[];
  featureRequirement?: VirtualMachineFeatureRequirement[];
}
export type ClusterEnterMaintenanceResult = DynamicData &  {
  recommendations?: ClusterRecommendation[];
  fault?: ClusterDrsFaults;
}
export type ClusterFailoverHostAdmissionControlPolicy = ClusterDasAdmissionControlPolicy &  {
  failoverHosts?: HostSystem[];
  failoverLevel?: number;
}
export type ClusterFailoverLevelAdmissionControlInfo = ClusterDasAdmissionControlInfo &  {
  currentFailoverLevel: number;
}
export type ClusterFailoverLevelAdmissionControlPolicy = ClusterDasAdmissionControlPolicy &  {
  failoverLevel: number;
  slotPolicy?: ClusterSlotPolicy;
}
export type ClusterFailoverResourcesAdmissionControlInfo = ClusterDasAdmissionControlInfo &  {
  currentCpuFailoverResourcesPercent: number;
  currentMemoryFailoverResourcesPercent: number;
}
export type ClusterFailoverResourcesAdmissionControlPolicy = ClusterDasAdmissionControlPolicy &  {
  cpuFailoverResourcesPercent: number;
  memoryFailoverResourcesPercent: number;
  failoverLevel?: number;
  autoComputePercentages?: boolean;
}
export type ClusterGroupInfo = DynamicData &  {
  name: string;
  userCreated?: boolean;
  uniqueID?: string;
}
export type ClusterHostGroup = ClusterGroupInfo &  {
  host?: HostSystem[];
}
export type ClusterHostInfraUpdateHaModeAction = ClusterAction &  {
  operationType: string;
}
export type ClusterHostPowerAction = ClusterAction &  {
  operationType: HostPowerOperationType;
  powerConsumptionWatt?: number;
  cpuCapacityMHz?: number;
  memCapacityMB?: number;
}
export type ClusterHostRecommendation = DynamicData &  {
  host: HostSystem;
  rating: number;
}
export type ClusterInfraUpdateHaConfigInfo = DynamicData &  {
  enabled?: boolean;
  behavior?: string;
  moderateRemediation?: string;
  severeRemediation?: string;
  providers?: string[];
}
export type ClusterInitialPlacementAction = ClusterAction &  {
  targetHost: HostSystem;
  pool?: ResourcePool;
}
export type ClusterMigrationAction = ClusterAction &  {
  drsMigration?: ClusterDrsMigration;
}
export type ClusterNotAttemptedVmInfo = DynamicData &  {
  vm: VirtualMachine;
  fault: MethodFault;
}
export type ClusterOrchestrationInfo = DynamicData &  {
  defaultVmReadiness?: ClusterVmReadiness;
}
export type PlacementAction = ClusterAction &  {
  vm?: VirtualMachine;
  targetHost?: HostSystem;
  relocateSpec?: VirtualMachineRelocateSpec;
}
export type PlacementResult = DynamicData &  {
  recommendations?: ClusterRecommendation[];
  drsFault?: ClusterDrsFaults;
}
export type ClusterPowerOnVmResult = DynamicData &  {
  attempted?: ClusterAttemptedVmInfo[];
  notAttempted?: ClusterNotAttemptedVmInfo[];
  recommendations?: ClusterRecommendation[];
}
export type ClusterProactiveDrsConfigInfo = DynamicData &  {
  enabled?: boolean;
}
export type ClusterRecommendation = DynamicData &  {
  key: string;
  type: string;
  time: Date;
  rating: number;
  reason: string;
  reasonText: string;
  warningText?: string;
  warningDetails?: LocalizableMessage;
  prerequisite?: string[];
  action?: ClusterAction[];
  target?: ManagedObject;
}
export type ClusterResourceUsageSummary = DynamicData &  {
  cpuUsedMHz: number;
  cpuCapacityMHz: number;
  memUsedMB: number;
  memCapacityMB: number;
  pMemAvailableMB?: number;
  pMemCapacityMB?: number;
  storageUsedMB: number;
  storageCapacityMB: number;
}
export type ClusterSlotPolicy = DynamicData &  {
  
}
export type ClusterUsageSummary = DynamicData &  {
  totalCpuCapacityMhz: number;
  totalMemCapacityMB: number;
  cpuReservationMhz: number;
  memReservationMB: number;
  poweredOffCpuReservationMhz?: number;
  poweredOffMemReservationMB?: number;
  cpuDemandMhz: number;
  memDemandMB: number;
  statsGenNumber: number;
  cpuEntitledMhz: number;
  memEntitledMB: number;
  poweredOffVmCount: number;
  totalVmCount: number;
}
export type ClusterVmComponentProtectionSettings = DynamicData &  {
  vmStorageProtectionForAPD?: string;
  enableAPDTimeoutForHosts?: boolean;
  vmTerminateDelayForAPDSec?: number;
  vmReactionOnAPDCleared?: string;
  vmStorageProtectionForPDL?: string;
}
export type ClusterVmGroup = ClusterGroupInfo &  {
  vm?: VirtualMachine[];
}
export type ClusterVmOrchestrationInfo = DynamicData &  {
  vm: VirtualMachine;
  vmReadiness: ClusterVmReadiness;
}
export type ClusterVmReadiness = DynamicData &  {
  readyCondition?: string;
  postReadyDelay?: number;
}
export type ClusterVmToolsMonitoringSettings = DynamicData &  {
  enabled?: boolean;
  vmMonitoring?: string;
  clusterSettings?: boolean;
  failureInterval?: number;
  minUpTime?: number;
  maxFailures?: number;
  maxFailureWindow?: number;
}
export type DistributedVirtualPort = DynamicData &  {
  key: string;
  config: DVPortConfigInfo;
  dvsUuid: string;
  portgroupKey?: string;
  proxyHost?: HostSystem;
  connectee?: DistributedVirtualSwitchPortConnectee;
  conflict: boolean;
  conflictPortKey?: string;
  state?: DVPortState;
  connectionCookie?: number;
  lastStatusChange: Date;
  hostLocalPort?: boolean;
  externalId?: string;
  segmentPortId?: string;
}
export type DVPortConfigInfo = DynamicData &  {
  name?: string;
  scope?: ManagedEntity[];
  description?: string;
  setting?: DVPortSetting;
  configVersion: string;
}
export type DVPortConfigSpec = DynamicData &  {
  operation: string;
  key?: string;
  name?: string;
  scope?: ManagedEntity[];
  description?: string;
  setting?: DVPortSetting;
  configVersion?: string;
}
export type DvsFilterConfig = InheritablePolicy &  {
  key?: string;
  agentName?: string;
  slotNumber?: string;
  parameters?: DvsFilterParameter;
  onFailure?: string;
}
export type DvsFilterConfigSpec = DvsFilterConfig &  {
  operation: string;
}
export type DvsFilterParameter = DynamicData &  {
  parameters?: string[];
}
export type DvsFilterPolicy = InheritablePolicy &  {
  filterConfig?: DvsFilterConfig[];
}
export type DVSHostLocalPortInfo = DynamicData &  {
  switchUuid: string;
  portKey: string;
  setting: DVPortSetting;
  vnic: string;
}
export type DVPortStatus = DynamicData &  {
  linkUp: boolean;
  blocked: boolean;
  vlanIds?: NumericRange[];
  trunkingMode?: boolean;
  mtu?: number;
  linkPeer?: string;
  macAddress?: string;
  statusDetail?: string;
  vmDirectPathGen2Active?: boolean;
  vmDirectPathGen2InactiveReasonNetwork?: string[];
  vmDirectPathGen2InactiveReasonOther?: string[];
  vmDirectPathGen2InactiveReasonExtended?: string;
}
export type DVPortSetting = DynamicData &  {
  blocked?: BoolPolicy;
  vmDirectPathGen2Allowed?: BoolPolicy;
  inShapingPolicy?: DVSTrafficShapingPolicy;
  outShapingPolicy?: DVSTrafficShapingPolicy;
  vendorSpecificConfig?: DVSVendorSpecificConfig;
  networkResourcePoolKey?: StringPolicy;
  filterPolicy?: DvsFilterPolicy;
}
export type DVPortState = DynamicData &  {
  runtimeInfo?: DVPortStatus;
  stats: DistributedVirtualSwitchPortStatistics;
  vendorSpecificState?: DistributedVirtualSwitchKeyedOpaqueBlob[];
}
export type DvsTrafficFilterConfig = DvsFilterConfig &  {
  trafficRuleset?: DvsTrafficRuleset;
}
export type DvsTrafficFilterConfigSpec = DvsTrafficFilterConfig &  {
  operation: string;
}
export type DVSTrafficShapingPolicy = InheritablePolicy &  {
  enabled?: BoolPolicy;
  averageBandwidth?: LongPolicy;
  peakBandwidth?: LongPolicy;
  burstSize?: LongPolicy;
}
export type DVSVendorSpecificConfig = InheritablePolicy &  {
  keyValue?: DistributedVirtualSwitchKeyedOpaqueBlob[];
}
export type DistributedVirtualPortgroupInfo = DynamicData &  {
  switchName: string;
  switchUuid: string;
  portgroupName: string;
  portgroupKey: string;
  portgroupType: string;
  uplinkPortgroup: boolean;
  portgroup: DistributedVirtualPortgroup;
  networkReservationSupported?: boolean;
  backingType?: string;
  logicalSwitchUuid?: string;
  segmentId?: string;
}
export type DVPortgroupSelection = SelectionSet &  {
  dvsUuid: string;
  portgroupKey: string[];
}
export type DistributedVirtualSwitchInfo = DynamicData &  {
  switchName: string;
  switchUuid: string;
  distributedVirtualSwitch: DistributedVirtualSwitch;
  networkReservationSupported?: boolean;
}
export type DVSSelection = SelectionSet &  {
  dvsUuid: string;
}
export type EntityBackup = DynamicData &  {
  
}
export type EntityBackupConfig = DynamicData &  {
  entityType: string;
  configBlob: Buffer;
  key?: string;
  name?: string;
  container?: ManagedEntity;
  configVersion?: string;
}
export type DistributedVirtualSwitchHostMember = DynamicData &  {
  runtimeState?: DistributedVirtualSwitchHostMemberRuntimeState;
  config: DistributedVirtualSwitchHostMemberConfigInfo;
  productInfo?: DistributedVirtualSwitchProductSpec;
  uplinkPortKey?: string[];
  status: string;
  statusDetail?: string;
}
export type DistributedVirtualSwitchHostMemberBacking = DynamicData &  {
  
}
export type DistributedVirtualSwitchHostMemberConfigInfo = DynamicData &  {
  host?: HostSystem;
  maxProxySwitchPorts: number;
  vendorSpecificConfig?: DistributedVirtualSwitchKeyedOpaqueBlob[];
  backing: DistributedVirtualSwitchHostMemberBacking;
  nsxSwitch?: boolean;
  ensEnabled?: boolean;
  ensInterruptEnabled?: boolean;
  transportZones?: DistributedVirtualSwitchHostMemberTransportZoneInfo[];
  nsxtUsedUplinkNames?: string[];
}
export type DistributedVirtualSwitchHostMemberConfigSpec = DynamicData &  {
  operation: string;
  host: HostSystem;
  backing?: DistributedVirtualSwitchHostMemberBacking;
  maxProxySwitchPorts?: number;
  vendorSpecificConfig?: DistributedVirtualSwitchKeyedOpaqueBlob[];
}
export type HostMemberHealthCheckResult = DynamicData &  {
  summary?: string;
}
export type DistributedVirtualSwitchHostMemberPnicBacking = DistributedVirtualSwitchHostMemberBacking &  {
  pnicSpec?: DistributedVirtualSwitchHostMemberPnicSpec[];
}
export type DistributedVirtualSwitchHostMemberPnicSpec = DynamicData &  {
  pnicDevice: string;
  uplinkPortKey?: string;
  uplinkPortgroupKey?: string;
  connectionCookie?: number;
}
export type HostMemberRuntimeInfo = DynamicData &  {
  host: HostSystem;
  status?: string;
  statusDetail?: string;
  nsxtStatus?: string;
  nsxtStatusDetail?: string;
  healthCheckResult?: HostMemberHealthCheckResult[];
}
export type DistributedVirtualSwitchHostMemberRuntimeState = DynamicData &  {
  currentMaxProxySwitchPorts: number;
}
export type DistributedVirtualSwitchHostMemberTransportZoneInfo = DynamicData &  {
  uuid: string;
  type: string;
}
export type HostMemberUplinkHealthCheckResult = HostMemberHealthCheckResult &  {
  uplinkPortKey: string;
}
export type DistributedVirtualSwitchHostProductSpec = DynamicData &  {
  productLineId?: string;
  version?: string;
}
export type DistributedVirtualSwitchKeyedOpaqueBlob = DynamicData &  {
  key: string;
  opaqueData: string;
}
export type DVSNetworkResourcePool = DynamicData &  {
  key: string;
  name?: string;
  description?: string;
  configVersion: string;
  allocationInfo: DVSNetworkResourcePoolAllocationInfo;
}
export type DVSNetworkResourcePoolAllocationInfo = DynamicData &  {
  limit?: number;
  shares?: SharesInfo;
  priorityTag?: number;
}
export type DVSNetworkResourcePoolConfigSpec = DynamicData &  {
  key: string;
  configVersion?: string;
  allocationInfo?: DVSNetworkResourcePoolAllocationInfo;
  name?: string;
  description?: string;
}
export type DistributedVirtualSwitchPortConnectee = DynamicData &  {
  connectedEntity?: ManagedEntity;
  nicKey?: string;
  type?: string;
  addressHint?: string;
}
export type DistributedVirtualSwitchPortConnection = DynamicData &  {
  switchUuid: string;
  portgroupKey?: string;
  portKey?: string;
  connectionCookie?: number;
}
export type DistributedVirtualSwitchPortCriteria = DynamicData &  {
  connected?: boolean;
  active?: boolean;
  uplinkPort?: boolean;
  nsxPort?: boolean;
  scope?: ManagedEntity;
  portgroupKey?: string[];
  inside?: boolean;
  portKey?: string[];
  host?: HostSystem[];
}
export type DistributedVirtualSwitchPortStatistics = DynamicData &  {
  packetsInMulticast: number;
  packetsOutMulticast: number;
  bytesInMulticast: number;
  bytesOutMulticast: number;
  packetsInUnicast: number;
  packetsOutUnicast: number;
  bytesInUnicast: number;
  bytesOutUnicast: number;
  packetsInBroadcast: number;
  packetsOutBroadcast: number;
  bytesInBroadcast: number;
  bytesOutBroadcast: number;
  packetsInDropped: number;
  packetsOutDropped: number;
  packetsInException: number;
  packetsOutException: number;
  bytesInFromPnic?: number;
  bytesOutToPnic?: number;
}
export type DistributedVirtualSwitchProductSpec = DynamicData &  {
  name?: string;
  vendor?: string;
  version?: string;
  build?: string;
  forwardingClass?: string;
  bundleId?: string;
  bundleUrl?: string;
}
export type DvsTrafficRule = DynamicData &  {
  key?: string;
  description?: string;
  sequence?: number;
  qualifier?: DvsNetworkRuleQualifier[];
  action?: DvsNetworkRuleAction;
  direction?: string;
}
export type DvsAcceptNetworkRuleAction = DvsNetworkRuleAction &  {
  
}
export type DvsNetworkRuleAction = DynamicData &  {
  
}
export type DvsCopyNetworkRuleAction = DvsNetworkRuleAction &  {
  
}
export type DvsDropNetworkRuleAction = DvsNetworkRuleAction &  {
  
}
export type DvsGreEncapNetworkRuleAction = DvsNetworkRuleAction &  {
  encapsulationIp: SingleIp;
}
export type DvsIpPort = NegatableExpression &  {
  
}
export type DvsIpPortRange = DvsIpPort &  {
  startPortNumber: number;
  endPortNumber: number;
}
export type DvsIpNetworkRuleQualifier = DvsNetworkRuleQualifier &  {
  sourceAddress?: IpAddress;
  destinationAddress?: IpAddress;
  protocol?: IntExpression;
  sourceIpPort?: DvsIpPort;
  destinationIpPort?: DvsIpPort;
  tcpFlags?: IntExpression;
}
export type DvsLogNetworkRuleAction = DvsNetworkRuleAction &  {
  
}
export type DvsMacNetworkRuleQualifier = DvsNetworkRuleQualifier &  {
  sourceAddress?: MacAddress;
  destinationAddress?: MacAddress;
  protocol?: IntExpression;
  vlanId?: IntExpression;
}
export type DvsMacRewriteNetworkRuleAction = DvsNetworkRuleAction &  {
  rewriteMac: string;
}
export type DvsPuntNetworkRuleAction = DvsNetworkRuleAction &  {
  
}
export type DvsNetworkRuleQualifier = DynamicData &  {
  key?: string;
}
export type DvsRateLimitNetworkRuleAction = DvsNetworkRuleAction &  {
  packetsPerSecond: number;
}
export type DvsSingleIpPort = DvsIpPort &  {
  portNumber: number;
}
export type DvsSystemTrafficNetworkRuleQualifier = DvsNetworkRuleQualifier &  {
  typeOfSystemTraffic?: StringExpression;
}
export type DvsUpdateTagNetworkRuleAction = DvsNetworkRuleAction &  {
  qosTag?: number;
  dscpTag?: number;
}
export type DvsTrafficRuleset = DynamicData &  {
  key?: string;
  enabled?: boolean;
  precedence?: number;
  rules?: DvsTrafficRule[];
}
export type DVSVmVnicNetworkResourcePool = DynamicData &  {
  key: string;
  name?: string;
  description?: string;
  configVersion: string;
  allocationInfo?: DvsVmVnicResourceAllocation;
}
export type DvsVmVnicResourcePoolConfigSpec = DynamicData &  {
  operation: string;
  key?: string;
  configVersion?: string;
  allocationInfo?: DvsVmVnicResourceAllocation;
  name?: string;
  description?: string;
}
export type DvsVmVnicResourceAllocation = DynamicData &  {
  reservationQuota?: number;
}
export type DvsVmVnicNetworkResourcePoolRuntimeInfo = DynamicData &  {
  key: string;
  name?: string;
  capacity?: number;
  usage?: number;
  available?: number;
  status: string;
  allocatedResource?: DvsVnicAllocatedResource[];
}
export type DvsVnicAllocatedResource = DynamicData &  {
  vm: VirtualMachine;
  vnicKey: string;
  reservation?: number;
}
export type CryptoKeyId = DynamicData &  {
  keyId: string;
  providerId?: KeyProviderId;
}
export type CryptoKeyPlain = DynamicData &  {
  keyId: CryptoKeyId;
  algorithm: string;
  keyData: string;
}
export type CryptoKeyResult = DynamicData &  {
  keyId: CryptoKeyId;
  success: boolean;
  reason?: string;
  fault?: MethodFault;
}
export type CryptoSpec = DynamicData &  {
  
}
export type CryptoSpecDecrypt = CryptoSpec &  {
  
}
export type CryptoSpecDeepRecrypt = CryptoSpec &  {
  newKeyId: CryptoKeyId;
}
export type CryptoSpecEncrypt = CryptoSpec &  {
  cryptoKeyId: CryptoKeyId;
}
export type CryptoSpecNoOp = CryptoSpec &  {
  
}
export type CryptoSpecRegister = CryptoSpecNoOp &  {
  cryptoKeyId: CryptoKeyId;
}
export type CryptoSpecShallowRecrypt = CryptoSpec &  {
  newKeyId: CryptoKeyId;
}
export type KeyProviderId = DynamicData &  {
  id: string;
}
export type KmipClusterInfo = DynamicData &  {
  clusterId: KeyProviderId;
  servers?: KmipServerInfo[];
  useAsDefault: boolean;
  managementType?: string;
  useAsEntityDefault?: ManagedEntity[];
}
export type KmipServerInfo = DynamicData &  {
  name: string;
  address: string;
  port: number;
  proxyAddress?: string;
  proxyPort?: number;
  reconnect?: number;
  protocol?: string;
  nbio?: number;
  timeout?: number;
  userName?: string;
}
export type KmipServerSpec = DynamicData &  {
  clusterId: KeyProviderId;
  info: KmipServerInfo;
  password?: string;
}
export type ChangesInfoEventArgument = DynamicData &  {
  modified?: string;
  added?: string;
  deleted?: string;
}
export type DvsOutOfSyncHostArgument = DynamicData &  {
  outOfSyncHost: HostEventArgument;
  configParamters: string[];
}
export type Event = DynamicData &  {
  key: number;
  chainId: number;
  createdTime: Date;
  userName: string;
  datacenter?: DatacenterEventArgument;
  computeResource?: ComputeResourceEventArgument;
  host?: HostEventArgument;
  vm?: VmEventArgument;
  ds?: DatastoreEventArgument;
  net?: NetworkEventArgument;
  dvs?: DvsEventArgument;
  fullFormattedMessage?: string;
  changeTag?: string;
}
export type EventArgument = DynamicData &  {
  
}
export type EventDescription = DynamicData &  {
  category: ElementDescription[];
  eventInfo: EventDescriptionEventDetail[];
  enumeratedTypes?: EnumDescription[];
}
export type EventArgDesc = DynamicData &  {
  name: string;
  type: string;
  description?: ElementDescription;
}
export type EventDescriptionEventDetail = DynamicData &  {
  key: string;
  description?: string;
  category: string;
  formatOnDatacenter: string;
  formatOnComputeResource: string;
  formatOnHost: string;
  formatOnVm: string;
  fullFormat: string;
  longDescription?: string;
}
export type EventEx = Event &  {
  eventTypeId: string;
  severity?: string;
  message?: string;
  arguments?: KeyAnyValue[];
  objectId?: string;
  objectType?: string;
  objectName?: string;
  fault?: MethodFault;
}
export type EventFilterSpec = DynamicData &  {
  entity?: EventFilterSpecByEntity;
  time?: EventFilterSpecByTime;
  userName?: EventFilterSpecByUsername;
  eventChainId?: number;
  alarm?: Alarm;
  scheduledTask?: ScheduledTask;
  disableFullMessage?: boolean;
  category?: string[];
  type?: string[];
  tag?: string[];
  eventTypeId?: string[];
  maxCount?: number;
}
export type EventFilterSpecByEntity = DynamicData &  {
  entity: ManagedEntity;
  recursion: EventFilterSpecRecursionOption;
}
export type EventFilterSpecByTime = DynamicData &  {
  beginTime?: Date;
  endTime?: Date;
}
export type EventFilterSpecByUsername = DynamicData &  {
  systemUser: boolean;
  userList?: string[];
}
export type GeneralEvent = Event &  {
  message: string;
}
export type GeneralHostErrorEvent = GeneralEvent &  {
  
}
export type GeneralHostInfoEvent = GeneralEvent &  {
  
}
export type GeneralHostWarningEvent = GeneralEvent &  {
  
}
export type GeneralUserEvent = GeneralEvent &  {
  entity?: ManagedEntityEventArgument;
}
export type GeneralVmErrorEvent = GeneralEvent &  {
  
}
export type GeneralVmInfoEvent = GeneralEvent &  {
  
}
export type GeneralVmWarningEvent = GeneralEvent &  {
  
}
export type HealthStatusChangedEvent = Event &  {
  componentId: string;
  oldStatus: string;
  newStatus: string;
  componentName: string;
  serviceId?: string;
}
export type HostEvent = Event &  {
  
}
export type HostGetShortNameFailedEvent = HostEvent &  {
  
}
export type HostInAuditModeEvent = HostEvent &  {
  
}
export type HostInventoryUnreadableEvent = Event &  {
  
}
export type HostIpChangedEvent = HostEvent &  {
  oldIP: string;
  newIP: string;
}
export type HostIpInconsistentEvent = HostEvent &  {
  ipAddress: string;
  ipAddress2: string;
}
export type HostIpToShortNameFailedEvent = HostEvent &  {
  
}
export type HostNonCompliantEvent = HostEvent &  {
  
}
export type HostProfileAppliedEvent = HostEvent &  {
  profile: ProfileEventArgument;
}
export type HostReconnectionFailedEvent = HostEvent &  {
  
}
export type HostRemovedEvent = HostEvent &  {
  
}
export type HostShortNameToIpFailedEvent = HostEvent &  {
  shortName: string;
}
export type HostShutdownEvent = HostEvent &  {
  reason: string;
}
export type HostSpecificationChangedEvent = HostEvent &  {
  
}
export type HostSpecificationRequireEvent = HostEvent &  {
  
}
export type HostSpecificationUpdateEvent = HostEvent &  {
  hostSpec: HostSpecification;
}
export type HostSubSpecificationDeleteEvent = HostEvent &  {
  subSpecName: string;
}
export type HostSubSpecificationUpdateEvent = HostEvent &  {
  hostSubSpec: HostSubSpecification;
}
export type HostSyncFailedEvent = HostEvent &  {
  reason: MethodFault;
}
export type HostUpgradeFailedEvent = HostEvent &  {
  
}
export type HostUserWorldSwapNotEnabledEvent = HostEvent &  {
  
}
export type HostVnicConnectedToCustomizedDVPortEvent = HostEvent &  {
  vnic: VnicPortArgument;
  prevPortKey?: string;
}
export type HostWwnChangedEvent = HostEvent &  {
  oldNodeWwns?: number[];
  oldPortWwns?: number[];
  newNodeWwns?: number[];
  newPortWwns?: number[];
}
export type HostWwnConflictEvent = HostEvent &  {
  conflictedVms?: VmEventArgument[];
  conflictedHosts?: HostEventArgument[];
  wwn: number;
}
export type LicenseEvent = Event &  {
  
}
export type LicenseExpiredEvent = Event &  {
  feature: LicenseFeatureInfo;
}
export type LicenseNonComplianceEvent = LicenseEvent &  {
  url: string;
}
export type LicenseRestrictedEvent = LicenseEvent &  {
  
}
export type LicenseServerAvailableEvent = LicenseEvent &  {
  licenseServer: string;
}
export type LicenseServerUnavailableEvent = LicenseEvent &  {
  licenseServer: string;
}
export type LocalDatastoreCreatedEvent = HostEvent &  {
  datastore: DatastoreEventArgument;
  datastoreUrl?: string;
}
export type LocalTSMEnabledEvent = HostEvent &  {
  
}
export type LockerMisconfiguredEvent = Event &  {
  datastore: DatastoreEventArgument;
}
export type LockerReconfiguredEvent = Event &  {
  oldDatastore?: DatastoreEventArgument;
  newDatastore?: DatastoreEventArgument;
}
export type NASDatastoreCreatedEvent = HostEvent &  {
  datastore: DatastoreEventArgument;
  datastoreUrl?: string;
}
export type NetworkRollbackEvent = Event &  {
  methodName: string;
  transactionId: string;
}
export type NoDatastoresConfiguredEvent = HostEvent &  {
  
}
export type NoLicenseEvent = LicenseEvent &  {
  feature: LicenseFeatureInfo;
}
export type ProfileEvent = Event &  {
  profile: ProfileEventArgument;
}
export type ProfileEventArgument = EventArgument &  {
  profile: Profile;
  name: string;
}
export type ProfileReferenceHostChangedEvent = ProfileEvent &  {
  referenceHost?: HostSystem;
  referenceHostName?: string;
  prevReferenceHostName?: string;
}
export type ProfileRemovedEvent = ProfileEvent &  {
  
}
export type RemoteTSMEnabledEvent = HostEvent &  {
  
}
export type ResourcePoolEvent = Event &  {
  resourcePool: ResourcePoolEventArgument;
}
export type ResourcePoolMovedEvent = ResourcePoolEvent &  {
  oldParent: ResourcePoolEventArgument;
  newParent: ResourcePoolEventArgument;
}
export type ResourcePoolReconfiguredEvent = ResourcePoolEvent &  {
  configChanges?: ChangesInfoEventArgument;
}
export type ResourceViolatedEvent = ResourcePoolEvent &  {
  
}
export type RoleEventArgument = EventArgument &  {
  roleId: number;
  name: string;
}
export type ScheduledTaskEvent = Event &  {
  scheduledTask: ScheduledTaskEventArgument;
  entity: ManagedEntityEventArgument;
}
export type ScheduledTaskFailedEvent = ScheduledTaskEvent &  {
  reason: MethodFault;
}
export type ScheduledTaskReconfiguredEvent = ScheduledTaskEvent &  {
  configChanges?: ChangesInfoEventArgument;
}
export type ScheduledTaskRemovedEvent = ScheduledTaskEvent &  {
  
}
export type ScheduledTaskStartedEvent = ScheduledTaskEvent &  {
  
}
export type ServerLicenseExpiredEvent = LicenseEvent &  {
  product: string;
}
export type SessionEvent = Event &  {
  
}
export type SessionTerminatedEvent = SessionEvent &  {
  sessionId: string;
  terminatedUsername: string;
}
export type TaskEvent = Event &  {
  info: TaskInfo;
}
export type TaskTimeoutEvent = TaskEvent &  {
  
}
export type TemplateUpgradeEvent = Event &  {
  legacyTemplate: string;
}
export type TemplateUpgradeFailedEvent = TemplateUpgradeEvent &  {
  reason: MethodFault;
}
export type TemplateUpgradedEvent = TemplateUpgradeEvent &  {
  
}
export type TimedOutHostOperationEvent = HostEvent &  {
  
}
export type UnlicensedVirtualMachinesEvent = LicenseEvent &  {
  unlicensed: number;
  available: number;
}
export type UnlicensedVirtualMachinesFoundEvent = LicenseEvent &  {
  available: number;
}
export type UpdatedAgentBeingRestartedEvent = HostEvent &  {
  
}
export type UpgradeEvent = Event &  {
  message: string;
}
export type UserAssignedToGroup = HostEvent &  {
  userLogin: string;
  group: string;
}
export type UserLoginSessionEvent = SessionEvent &  {
  ipAddress: string;
  userAgent?: string;
  locale: string;
  sessionId: string;
}
export type UserLogoutSessionEvent = SessionEvent &  {
  ipAddress?: string;
  userAgent?: string;
  callCount?: number;
  sessionId?: string;
  loginTime?: Date;
}
export type UserPasswordChanged = HostEvent &  {
  userLogin: string;
}
export type UserUnassignedFromGroup = HostEvent &  {
  userLogin: string;
  group: string;
}
export type UserUpgradeEvent = UpgradeEvent &  {
  
}
export type VMFSDatastoreCreatedEvent = HostEvent &  {
  datastore: DatastoreEventArgument;
  datastoreUrl?: string;
}
export type VMFSDatastoreExpandedEvent = HostEvent &  {
  datastore: DatastoreEventArgument;
}
export type VMFSDatastoreExtendedEvent = HostEvent &  {
  datastore: DatastoreEventArgument;
}
export type VMotionLicenseExpiredEvent = LicenseEvent &  {
  
}
export type VcAgentUninstallFailedEvent = HostEvent &  {
  reason?: string;
}
export type VcAgentUninstalledEvent = HostEvent &  {
  
}
export type VcAgentUpgradeFailedEvent = HostEvent &  {
  reason?: string;
}
export type VcAgentUpgradedEvent = HostEvent &  {
  
}
export type VimAccountPasswordChangedEvent = HostEvent &  {
  
}
export type VmEvent = Event &  {
  template: boolean;
}
export type VmFailedMigrateEvent = VmEvent &  {
  destHost: HostEventArgument;
  reason: MethodFault;
  destDatacenter?: DatacenterEventArgument;
  destDatastore?: DatastoreEventArgument;
}
export type VmFailedRelayoutEvent = VmEvent &  {
  reason: MethodFault;
}
export type VmFailedRelayoutOnVmfs2DatastoreEvent = VmEvent &  {
  
}
export type VmFailedStartingSecondaryEvent = VmEvent &  {
  reason?: string;
}
export type VmFailedToPowerOffEvent = VmEvent &  {
  reason: MethodFault;
}
export type VmFailedToPowerOnEvent = VmEvent &  {
  reason: MethodFault;
}
export type VmFailedToRebootGuestEvent = VmEvent &  {
  reason: MethodFault;
}
export type VmFailedToResetEvent = VmEvent &  {
  reason: MethodFault;
}
export type VmFailedToShutdownGuestEvent = VmEvent &  {
  reason: MethodFault;
}
export type VmFailedToStandbyGuestEvent = VmEvent &  {
  reason: MethodFault;
}
export type VmFailedToSuspendEvent = VmEvent &  {
  reason: MethodFault;
}
export type VmFailedUpdatingSecondaryConfig = VmEvent &  {
  
}
export type VmFailoverFailed = VmEvent &  {
  reason?: MethodFault;
}
export type VmFaultToleranceTurnedOffEvent = VmEvent &  {
  
}
export type VmFaultToleranceVmTerminatedEvent = VmEvent &  {
  reason?: string;
}
export type VmGuestOSCrashedEvent = VmEvent &  {
  
}
export type VmGuestRebootEvent = VmEvent &  {
  
}
export type VmGuestShutdownEvent = VmEvent &  {
  
}
export type VmGuestStandbyEvent = VmEvent &  {
  
}
export type VmInstanceUuidAssignedEvent = VmEvent &  {
  instanceUuid: string;
}
export type VmInstanceUuidChangedEvent = VmEvent &  {
  oldInstanceUuid: string;
  newInstanceUuid: string;
}
export type VmInstanceUuidConflictEvent = VmEvent &  {
  conflictedVm: VmEventArgument;
  instanceUuid: string;
}
export type VmMacAssignedEvent = VmEvent &  {
  adapter: string;
  mac: string;
}
export type VmMacChangedEvent = VmEvent &  {
  adapter: string;
  oldMac: string;
  newMac: string;
}
export type VmMacConflictEvent = VmEvent &  {
  conflictedVm: VmEventArgument;
  mac: string;
}
export type VmMaxFTRestartCountReached = VmEvent &  {
  
}
export type VmMaxRestartCountReached = VmEvent &  {
  
}
export type VmMessageErrorEvent = VmEvent &  {
  message: string;
  messageInfo?: VirtualMachineMessage[];
}
export type VmMessageEvent = VmEvent &  {
  message: string;
  messageInfo?: VirtualMachineMessage[];
}
export type VmMessageWarningEvent = VmEvent &  {
  message: string;
  messageInfo?: VirtualMachineMessage[];
}
export type VmMigratedEvent = VmEvent &  {
  sourceHost: HostEventArgument;
  sourceDatacenter?: DatacenterEventArgument;
  sourceDatastore?: DatastoreEventArgument;
}
export type VmNoCompatibleHostForSecondaryEvent = VmEvent &  {
  
}
export type VmNoNetworkAccessEvent = VmEvent &  {
  destHost: HostEventArgument;
}
export type VmOrphanedEvent = VmEvent &  {
  
}
export type VmPoweredOffEvent = VmEvent &  {
  
}
export type VmPoweredOnEvent = VmEvent &  {
  
}
export type VmPoweringOnWithCustomizedDVPortEvent = VmEvent &  {
  vnic: VnicPortArgument[];
}
export type VmPrimaryFailoverEvent = VmEvent &  {
  reason?: string;
}
export type VmReconfiguredEvent = VmEvent &  {
  configSpec: VirtualMachineConfigSpec;
  configChanges?: ChangesInfoEventArgument;
}
export type VmRegisteredEvent = VmEvent &  {
  
}
export type VmRelayoutSuccessfulEvent = VmEvent &  {
  
}
export type VmRelayoutUpToDateEvent = VmEvent &  {
  
}
export type VmReloadFromPathEvent = VmEvent &  {
  configPath: string;
}
export type VmReloadFromPathFailedEvent = VmEvent &  {
  configPath: string;
}
export type VmRelocateSpecEvent = VmEvent &  {
  
}
export type VmRelocatedEvent = VmRelocateSpecEvent &  {
  sourceHost: HostEventArgument;
  sourceDatacenter?: DatacenterEventArgument;
  sourceDatastore?: DatastoreEventArgument;
}
export type VmRemoteConsoleConnectedEvent = VmEvent &  {
  
}
export type VmRemoteConsoleDisconnectedEvent = VmEvent &  {
  
}
export type VmRemovedEvent = VmEvent &  {
  
}
export type VmRenamedEvent = VmEvent &  {
  oldName: string;
  newName: string;
}
export type VmRequirementsExceedCurrentEVCModeEvent = VmEvent &  {
  
}
export type VmResettingEvent = VmEvent &  {
  
}
export type VmResourcePoolMovedEvent = VmEvent &  {
  oldParent: ResourcePoolEventArgument;
  newParent: ResourcePoolEventArgument;
}
export type VmResourceReallocatedEvent = VmEvent &  {
  configChanges?: ChangesInfoEventArgument;
}
export type VmRestartedOnAlternateHostEvent = VmPoweredOnEvent &  {
  sourceHost: HostEventArgument;
}
export type VmResumingEvent = VmEvent &  {
  
}
export type VmSecondaryAddedEvent = VmEvent &  {
  
}
export type VmSecondaryDisabledBySystemEvent = VmEvent &  {
  reason?: MethodFault;
}
export type VmSecondaryDisabledEvent = VmEvent &  {
  
}
export type VmSecondaryEnabledEvent = VmEvent &  {
  
}
export type VmSecondaryStartedEvent = VmEvent &  {
  
}
export type VmShutdownOnIsolationEvent = VmPoweredOffEvent &  {
  isolatedHost: HostEventArgument;
  shutdownResult?: string;
}
export type VmStartRecordingEvent = VmEvent &  {
  
}
export type VmStartReplayingEvent = VmEvent &  {
  
}
export type VmStartingEvent = VmEvent &  {
  
}
export type VmStartingSecondaryEvent = VmEvent &  {
  
}
export type VmStaticMacConflictEvent = VmEvent &  {
  conflictedVm: VmEventArgument;
  mac: string;
}
export type VmStoppingEvent = VmEvent &  {
  
}
export type VmSuspendedEvent = VmEvent &  {
  
}
export type VmSuspendingEvent = VmEvent &  {
  
}
export type VmTimedoutStartingSecondaryEvent = VmEvent &  {
  timeout?: number;
}
export type VmUnsupportedStartingEvent = VmStartingEvent &  {
  guestId: string;
}
export type VmUpgradeCompleteEvent = VmEvent &  {
  version: string;
}
export type VmUpgradeFailedEvent = VmEvent &  {
  
}
export type VmUpgradingEvent = VmEvent &  {
  version: string;
}
export type VmUuidAssignedEvent = VmEvent &  {
  uuid: string;
}
export type VmUuidChangedEvent = VmEvent &  {
  oldUuid: string;
  newUuid: string;
}
export type VmUuidConflictEvent = VmEvent &  {
  conflictedVm: VmEventArgument;
  uuid: string;
}
export type VmWwnAssignedEvent = VmEvent &  {
  nodeWwns: number[];
  portWwns: number[];
}
export type VmWwnChangedEvent = VmEvent &  {
  oldNodeWwns?: number[];
  oldPortWwns?: number[];
  newNodeWwns?: number[];
  newPortWwns?: number[];
}
export type VmWwnConflictEvent = VmEvent &  {
  conflictedVms?: VmEventArgument[];
  conflictedHosts?: HostEventArgument[];
  wwn: number;
}
export type VnicPortArgument = DynamicData &  {
  vnic: string;
  port: DistributedVirtualSwitchPortConnection;
}
export type WarningUpgradeEvent = UpgradeEvent &  {
  
}
export type IScsiBootFailureEvent = HostEvent &  {
  
}
export type ExtExtendedProductInfo = DynamicData &  {
  companyUrl?: string;
  productUrl?: string;
  managementUrl?: string;
  self?: ManagedEntity;
}
export type ManagedByInfo = DynamicData &  {
  extensionKey: string;
  type: string;
}
export type ExtManagedEntityInfo = DynamicData &  {
  type: string;
  smallIconUrl?: string;
  iconUrl?: string;
  description?: string;
}
export type ExtSolutionManagerInfo = DynamicData &  {
  tab?: ExtSolutionManagerInfoTabInfo[];
  smallIconUrl?: string;
}
export type ExtSolutionManagerInfoTabInfo = DynamicData &  {
  label: string;
  url: string;
}
export type CannotDisableDrsOnClustersWithVApps = RuntimeFault &  {
  
}
export type ConflictingDatastoreFound = RuntimeFault &  {
  name: string;
  url: string;
}
export type DatabaseError = RuntimeFault &  {
  
}
export type DisallowedChangeByService = RuntimeFault &  {
  serviceName: string;
  disallowedChange?: string;
}
export type DisallowedOperationOnFailoverHost = RuntimeFault &  {
  host: HostSystem;
  hostname: string;
}
export type ExpiredFeatureLicense = NotEnoughLicenses &  {
  feature: string;
  count: number;
  expirationDate: Date;
}
export type FailToLockFaultToleranceVMs = RuntimeFault &  {
  vmName: string;
  vm: VirtualMachine;
  alreadyLockedVm: VirtualMachine;
}
export type HostAccessRestrictedToManagementServer = NotSupported &  {
  managementServer: string;
}
export type HostInventoryFull = NotEnoughLicenses &  {
  capacity: number;
}
export type InUseFeatureManipulationDisallowed = NotEnoughLicenses &  {
  
}
export type IncompatibleSetting = InvalidArgument &  {
  conflictingProperty: string;
}
export type IncorrectHostInformation = NotEnoughLicenses &  {
  
}
export type InvalidDasConfigArgument = InvalidArgument &  {
  entry?: string;
  clusterName?: string;
}
export type InvalidDasRestartPriorityForFtVm = InvalidArgument &  {
  vm: VirtualMachine;
  vmName: string;
}
export type InvalidDrsBehaviorForFtVm = InvalidArgument &  {
  vm: VirtualMachine;
  vmName: string;
}
export type InvalidEditionLicense = NotEnoughLicenses &  {
  feature: string;
}
export type InvalidIndexArgument = InvalidArgument &  {
  key: string;
}
export type InvalidProfileReferenceHost = RuntimeFault &  {
  reason?: string;
  host?: HostSystem;
  profile?: Profile;
  profileName?: string;
}
export type InventoryHasStandardAloneHosts = NotEnoughLicenses &  {
  hosts: string[];
}
export type LicenseAssignmentFailed = RuntimeFault &  {
  reason?: string;
}
export type LicenseDowngradeDisallowed = NotEnoughLicenses &  {
  edition: string;
  entityId: string;
  features: KeyAnyValue[];
}
export type LicenseExpired = NotEnoughLicenses &  {
  licenseKey: string;
}
export type LicenseKeyEntityMismatch = NotEnoughLicenses &  {
  
}
export type LicenseRestricted = NotEnoughLicenses &  {
  
}
export type LicenseSourceUnavailable = NotEnoughLicenses &  {
  licenseSource: LicenseSource;
}
export type MethodAlreadyDisabledFault = RuntimeFault &  {
  sourceId: string;
}
export type MethodDisabled = RuntimeFault &  {
  source?: string;
}
export type NoLicenseServerConfigured = NotEnoughLicenses &  {
  
}
export type NoPermission = SecurityError &  {
  object: ManagedObject;
  privilegeId: string;
}
export type NotAuthenticated = NoPermission &  {
  
}
export type OperationDisallowedOnHost = RuntimeFault &  {
  
}
export type RestrictedByAdministrator = RuntimeFault &  {
  details: string;
}
export type RestrictedVersion = SecurityError &  {
  
}
export type SolutionUserRequired = SecurityError &  {
  
}
export type ThirdPartyLicenseAssignmentFailed = RuntimeFault &  {
  host: HostSystem;
  module: string;
  reason?: string;
}
export type VAppOperationInProgress = RuntimeFault &  {
  
}
export type VimFault = MethodFault &  {
  
}
export type VmConfigFault = VimFault &  {
  
}
export type VmConfigIncompatibleForFaultTolerance = VmConfigFault &  {
  fault?: MethodFault;
}
export type VmConfigIncompatibleForRecordReplay = VmConfigFault &  {
  fault?: MethodFault;
}
export type VmFaultToleranceIssue = VimFault &  {
  
}
export type VmFaultToleranceOpIssuesList = VmFaultToleranceIssue &  {
  errors?: MethodFault[];
  warnings?: MethodFault[];
}
export type VmHostAffinityRuleViolation = VmConfigFault &  {
  vmName: string;
  hostName: string;
}
export type VmLimitLicense = NotEnoughLicenses &  {
  limit: number;
}
export type VmMetadataManagerFault = VimFault &  {
  
}
export type VmMonitorIncompatibleForFaultTolerance = VimFault &  {
  
}
export type VmToolsUpgradeFault = VimFault &  {
  
}
export type VmValidateMaxDevice = VimFault &  {
  device: string;
  max: number;
  count: number;
}
export type VramLimitLicense = NotEnoughLicenses &  {
  limit: number;
}
export type VsanFault = VimFault &  {
  
}
export type WipeDiskFault = VimFault &  {
  
}
export type HostActiveDirectory = DynamicData &  {
  changeOperation: string;
  spec?: HostActiveDirectorySpec;
}
export type HostActiveDirectorySpec = DynamicData &  {
  domainName?: string;
  userName?: string;
  password?: string;
  camServer?: string;
  thumbprint?: string;
  smartCardAuthenticationEnabled?: boolean;
  smartCardTrustAnchors?: string[];
}
export type HostAssignableHardwareBinding = DynamicData &  {
  instanceId: string;
  vm: VirtualMachine;
}
export type HostAssignableHardwareConfig = DynamicData &  {
  attributeOverride?: HostAssignableHardwareConfigAttributeOverride[];
}
export type HostAssignableHardwareConfigAttributeOverride = DynamicData &  {
  instanceId: string;
  name: string;
  value?: any;
}
export type HostAuthenticationManagerInfo = DynamicData &  {
  authConfig: HostAuthenticationStoreInfo[];
}
export type HostAuthenticationStoreInfo = DynamicData &  {
  enabled: boolean;
}
export type AutoStartPowerInfo = DynamicData &  {
  key: VirtualMachine;
  startOrder: number;
  startDelay: number;
  waitForHeartbeat: AutoStartWaitHeartbeatSetting;
  startAction: string;
  stopDelay: number;
  stopAction: string;
}
export type HostAutoStartManagerConfig = DynamicData &  {
  defaults?: AutoStartDefaults;
  powerInfo?: AutoStartPowerInfo[];
}
export type AutoStartDefaults = DynamicData &  {
  enabled?: boolean;
  startDelay?: number;
  stopDelay?: number;
  waitForHeartbeat?: boolean;
  stopAction?: string;
}
export type HostBIOSInfo = DynamicData &  {
  biosVersion?: string;
  releaseDate?: Date;
  vendor?: string;
  majorRelease?: number;
  minorRelease?: number;
  firmwareMajorRelease?: number;
  firmwareMinorRelease?: number;
}
export type HostBootDevice = DynamicData &  {
  key: string;
  description: string;
}
export type HostCacheConfigurationInfo = DynamicData &  {
  key: Datastore;
  swapSize: number;
}
export type HostCacheConfigurationSpec = DynamicData &  {
  datastore: Datastore;
  swapSize: number;
}
export type HostCapability = DynamicData &  {
  recursiveResourcePoolsSupported: boolean;
  cpuMemoryResourceConfigurationSupported: boolean;
  rebootSupported: boolean;
  shutdownSupported: boolean;
  vmotionSupported: boolean;
  standbySupported: boolean;
  ipmiSupported?: boolean;
  maxSupportedVMs?: number;
  maxRunningVMs?: number;
  maxSupportedVcpus?: number;
  maxRegisteredVMs?: number;
  datastorePrincipalSupported: boolean;
  sanSupported: boolean;
  nfsSupported: boolean;
  iscsiSupported: boolean;
  vlanTaggingSupported: boolean;
  nicTeamingSupported: boolean;
  highGuestMemSupported: boolean;
  maintenanceModeSupported: boolean;
  suspendedRelocateSupported: boolean;
  restrictedSnapshotRelocateSupported: boolean;
  perVmSwapFiles: boolean;
  localSwapDatastoreSupported: boolean;
  unsharedSwapVMotionSupported: boolean;
  backgroundSnapshotsSupported: boolean;
  preAssignedPCIUnitNumbersSupported: boolean;
  screenshotSupported: boolean;
  scaledScreenshotSupported: boolean;
  storageVMotionSupported: boolean;
  vmotionWithStorageVMotionSupported: boolean;
  vmotionAcrossNetworkSupported?: boolean;
  maxNumDisksSVMotion?: number;
  hbrNicSelectionSupported: boolean;
  vrNfcNicSelectionSupported: boolean;
  recordReplaySupported: boolean;
  ftSupported: boolean;
  replayUnsupportedReason?: string;
  replayCompatibilityIssues?: string[];
  smpFtSupported: boolean;
  ftCompatibilityIssues?: string[];
  smpFtCompatibilityIssues?: string[];
  maxVcpusPerFtVm?: number;
  loginBySSLThumbprintSupported?: boolean;
  cloneFromSnapshotSupported: boolean;
  deltaDiskBackingsSupported: boolean;
  perVMNetworkTrafficShapingSupported: boolean;
  tpmSupported: boolean;
  tpmVersion?: string;
  txtEnabled?: boolean;
  supportedCpuFeature?: HostCpuIdInfo[];
  virtualExecUsageSupported: boolean;
  storageIORMSupported: boolean;
  vmDirectPathGen2Supported: boolean;
  vmDirectPathGen2UnsupportedReason?: string[];
  vmDirectPathGen2UnsupportedReasonExtended?: string;
  supportedVmfsMajorVersion?: number[];
  vStorageCapable: boolean;
  snapshotRelayoutSupported: boolean;
  firewallIpRulesSupported?: boolean;
  servicePackageInfoSupported?: boolean;
  maxHostRunningVms?: number;
  maxHostSupportedVcpus?: number;
  vmfsDatastoreMountCapable: boolean;
  eightPlusHostVmfsSharedAccessSupported: boolean;
  nestedHVSupported: boolean;
  vPMCSupported: boolean;
  interVMCommunicationThroughVMCISupported: boolean;
  scheduledHardwareUpgradeSupported?: boolean;
  featureCapabilitiesSupported: boolean;
  latencySensitivitySupported: boolean;
  storagePolicySupported?: boolean;
  accel3dSupported: boolean;
  reliableMemoryAware?: boolean;
  multipleNetworkStackInstanceSupported?: boolean;
  messageBusProxySupported?: boolean;
  vsanSupported?: boolean;
  vFlashSupported?: boolean;
  hostAccessManagerSupported?: boolean;
  provisioningNicSelectionSupported: boolean;
  nfs41Supported?: boolean;
  nfs41Krb5iSupported?: boolean;
  turnDiskLocatorLedSupported?: boolean;
  virtualVolumeDatastoreSupported?: boolean;
  markAsSsdSupported?: boolean;
  markAsLocalSupported?: boolean;
  smartCardAuthenticationSupported?: boolean;
  pMemSupported?: boolean;
  pMemSnapshotSupported?: boolean;
  cryptoSupported?: boolean;
  oneKVolumeAPIsSupported?: boolean;
  gatewayOnNicSupported?: boolean;
  upitSupported?: boolean;
  cpuHwMmuSupported?: boolean;
  encryptedVMotionSupported?: boolean;
  encryptionChangeOnAddRemoveSupported?: boolean;
  encryptionHotOperationSupported?: boolean;
  encryptionWithSnapshotsSupported?: boolean;
  encryptionFaultToleranceSupported?: boolean;
  encryptionMemorySaveSupported?: boolean;
  encryptionRDMSupported?: boolean;
  encryptionVFlashSupported?: boolean;
  encryptionCBRCSupported?: boolean;
  encryptionHBRSupported?: boolean;
  ftEfiSupported?: boolean;
  unmapMethodSupported?: string;
  maxMemMBPerFtVm?: number;
  virtualMmuUsageIgnored?: boolean;
  virtualExecUsageIgnored?: boolean;
  vmCreateDateSupported?: boolean;
  vmfs3EOLSupported?: boolean;
  ftVmcpSupported?: boolean;
  quickBootSupported?: boolean;
  assignableHardwareSupported?: boolean;
  useFeatureReqsForOldHWv?: boolean;
  markPerenniallyReservedSupported?: boolean;
  hppPspSupported?: boolean;
  deviceRebindWithoutRebootSupported?: boolean;
  storagePolicyChangeSupported?: boolean;
  precisionTimeProtocolSupported?: boolean;
  remoteDeviceVMotionSupported?: boolean;
  maxSupportedVmMemory?: number;
}
export type HostCertificateManagerCertificateInfo = DynamicData &  {
  issuer?: string;
  notBefore?: Date;
  notAfter?: Date;
  subject?: string;
  status: string;
}
export type HostConfigChange = DynamicData &  {
  
}
export type HostConfigManager = DynamicData &  {
  cpuScheduler?: HostCpuSchedulerSystem;
  datastoreSystem?: HostDatastoreSystem;
  memoryManager?: HostMemorySystem;
  storageSystem?: HostStorageSystem;
  networkSystem?: HostNetworkSystem;
  vmotionSystem?: HostVMotionSystem;
  virtualNicManager?: HostVirtualNicManager;
  serviceSystem?: HostServiceSystem;
  firewallSystem?: HostFirewallSystem;
  advancedOption?: OptionManager;
  diagnosticSystem?: HostDiagnosticSystem;
  autoStartManager?: HostAutoStartManager;
  snmpSystem?: HostSnmpSystem;
  dateTimeSystem?: HostDateTimeSystem;
  patchManager?: HostPatchManager;
  imageConfigManager?: HostImageConfigManager;
  bootDeviceSystem?: HostBootDeviceSystem;
  firmwareSystem?: HostFirmwareSystem;
  healthStatusSystem?: HostHealthStatusSystem;
  pciPassthruSystem?: HostPciPassthruSystem;
  licenseManager?: LicenseManager;
  kernelModuleSystem?: HostKernelModuleSystem;
  authenticationManager?: HostAuthenticationManager;
  powerSystem?: HostPowerSystem;
  cacheConfigurationManager?: HostCacheConfigurationManager;
  esxAgentHostManager?: HostEsxAgentHostManager;
  iscsiManager?: IscsiManager;
  vFlashManager?: HostVFlashManager;
  vsanSystem?: HostVsanSystem;
  messageBusProxy?: MessageBusProxy;
  userDirectory?: UserDirectory;
  accountManager?: HostLocalAccountManager;
  hostAccessManager?: HostAccessManager;
  graphicsManager?: HostGraphicsManager;
  vsanInternalSystem?: HostVsanInternalSystem;
  certificateManager?: HostCertificateManager;
  cryptoManager?: CryptoManager;
  nvdimmSystem?: HostNvdimmSystem;
  assignableHardwareManager?: HostAssignableHardwareManager;
}
export type HostCpuIdInfo = DynamicData &  {
  level: number;
  vendor?: string;
  eax?: string;
  ebx?: string;
  ecx?: string;
  edx?: string;
}
export type HostCpuInfo = DynamicData &  {
  numCpuPackages: number;
  numCpuCores: number;
  numCpuThreads: number;
  hz: number;
}
export type HostCpuPackage = DynamicData &  {
  index: number;
  vendor: string;
  hz: number;
  busHz: number;
  description: string;
  threadId: number[];
  cpuFeature?: HostCpuIdInfo[];
}
export type HostCpuPowerManagementInfo = DynamicData &  {
  currentPolicy?: string;
  hardwareSupport?: string;
}
export type HostHyperThreadScheduleInfo = DynamicData &  {
  available: boolean;
  active: boolean;
  config: boolean;
}
export type FileInfo = DynamicData &  {
  path: string;
  friendlyName?: string;
  fileSize?: number;
  modification?: Date;
  owner?: string;
}
export type FileQueryFlags = DynamicData &  {
  fileType: boolean;
  fileSize: boolean;
  modification: boolean;
  fileOwner: boolean;
}
export type FloppyImageFileInfo = FileInfo &  {
  
}
export type FloppyImageFileQuery = FileQuery &  {
  
}
export type FolderFileInfo = FileInfo &  {
  
}
export type FolderFileQuery = FileQuery &  {
  
}
export type IsoImageFileInfo = FileInfo &  {
  
}
export type IsoImageFileQuery = FileQuery &  {
  
}
export type FileQuery = DynamicData &  {
  
}
export type HostDatastoreBrowserSearchResults = DynamicData &  {
  datastore?: Datastore;
  folderPath?: string;
  file?: FileInfo[];
}
export type HostDatastoreBrowserSearchSpec = DynamicData &  {
  query?: FileQuery[];
  details?: FileQueryFlags;
  searchCaseInsensitive?: boolean;
  matchPattern?: string[];
  sortFoldersFirst?: boolean;
}
export type TemplateConfigFileInfo = VmConfigFileInfo &  {
  
}
export type TemplateConfigFileQuery = VmConfigFileQuery &  {
  
}
export type VmConfigFileInfo = FileInfo &  {
  configVersion?: number;
  encryption?: VmConfigFileEncryptionInfo;
}
export type VmConfigFileEncryptionInfo = DynamicData &  {
  keyId?: CryptoKeyId;
}
export type VmConfigFileQuery = FileQuery &  {
  filter?: VmConfigFileQueryFilter;
  details?: VmConfigFileQueryFlags;
}
export type VmConfigFileQueryFlags = DynamicData &  {
  configVersion: boolean;
  encryption?: boolean;
}
export type VmConfigFileQueryFilter = DynamicData &  {
  matchConfigVersion?: number[];
  encrypted?: boolean;
}
export type VmDiskFileInfo = FileInfo &  {
  diskType?: string;
  capacityKb?: number;
  hardwareVersion?: number;
  controllerType?: string;
  diskExtents?: string[];
  thin?: boolean;
  encryption?: VmDiskFileEncryptionInfo;
}
export type VmDiskFileEncryptionInfo = DynamicData &  {
  keyId?: CryptoKeyId;
}
export type VmDiskFileQuery = FileQuery &  {
  filter?: VmDiskFileQueryFilter;
  details?: VmDiskFileQueryFlags;
}
export type VmDiskFileQueryFlags = DynamicData &  {
  diskType: boolean;
  capacityKb: boolean;
  hardwareVersion: boolean;
  controllerType?: boolean;
  diskExtents?: boolean;
  thin?: boolean;
  encryption?: boolean;
}
export type VmDiskFileQueryFilter = DynamicData &  {
  diskType?: string[];
  matchHardwareVersion?: number[];
  controllerType?: string[];
  thin?: boolean;
  encrypted?: boolean;
}
export type VmLogFileInfo = FileInfo &  {
  
}
export type VmLogFileQuery = FileQuery &  {
  
}
export type VmNvramFileInfo = FileInfo &  {
  
}
export type VmNvramFileQuery = FileQuery &  {
  
}
export type VmSnapshotFileInfo = FileInfo &  {
  
}
export type VmSnapshotFileQuery = FileQuery &  {
  
}
export type HostDateTimeConfig = DynamicData &  {
  timeZone?: string;
  ntpConfig?: HostNtpConfig;
}
export type HostDateTimeSystemTimeZone = DynamicData &  {
  key: string;
  name: string;
  description: string;
  gmtOffset: number;
}
export type HostDeploymentInfo = DynamicData &  {
  bootedFromStatelessCache?: boolean;
}
export type HostDevice = DynamicData &  {
  deviceName: string;
  deviceType: string;
}
export type HostDhcpService = DynamicData &  {
  key: string;
  spec: HostDhcpServiceSpec;
}
export type HostDhcpServiceConfig = DynamicData &  {
  changeOperation?: string;
  key: string;
  spec: HostDhcpServiceSpec;
}
export type HostDhcpServiceSpec = DynamicData &  {
  virtualSwitch: string;
  defaultLeaseDuration: number;
  leaseBeginIp: string;
  leaseEndIp: string;
  maxLeaseDuration: number;
  unlimitedLease: boolean;
  ipSubnetAddr: string;
  ipSubnetMask: string;
}
export type HostDigestInfo = DynamicData &  {
  digestMethod: string;
  digestValue: number[];
  objectName?: string;
}
export type HostDirectoryStoreInfo = HostAuthenticationStoreInfo &  {
  
}
export type HostDiskConfigurationResult = DynamicData &  {
  devicePath?: string;
  success?: boolean;
  fault?: MethodFault;
}
export type HostDiskDimensions = DynamicData &  {
  
}
export type HostDiskDimensionsChs = DynamicData &  {
  cylinder: number;
  head: number;
  sector: number;
}
export type HostDiskDimensionsLba = DynamicData &  {
  blockSize: number;
  block: number;
}
export type HostDiskPartitionInfo = DynamicData &  {
  deviceName: string;
  spec: HostDiskPartitionSpec;
  layout: HostDiskPartitionLayout;
}
export type HostDiskPartitionBlockRange = DynamicData &  {
  partition?: number;
  type: string;
  start: HostDiskDimensionsLba;
  end: HostDiskDimensionsLba;
}
export type HostDiskPartitionLayout = DynamicData &  {
  total?: HostDiskDimensionsLba;
  partition: HostDiskPartitionBlockRange[];
}
export type HostDiskPartitionAttributes = DynamicData &  {
  partition: number;
  startSector: number;
  endSector: number;
  type: string;
  guid?: string;
  logical: boolean;
  attributes: number;
  partitionAlignment?: number;
}
export type HostDiskPartitionSpec = DynamicData &  {
  partitionFormat?: string;
  chs?: HostDiskDimensionsChs;
  totalSectors?: number;
  partition?: HostDiskPartitionAttributes[];
}
export type HostDnsConfig = DynamicData &  {
  dhcp: boolean;
  virtualNicDevice?: string;
  ipv6VirtualNicDevice?: string;
  hostName: string;
  domainName: string;
  address?: string[];
  searchDomain?: string[];
}
export type HostDnsConfigSpec = HostDnsConfig &  {
  virtualNicConnection?: HostVirtualNicConnection;
  virtualNicConnectionV6?: HostVirtualNicConnection;
}
export type HostEnterMaintenanceResult = DynamicData &  {
  vmFaults?: FaultsByVM[];
  hostFaults?: FaultsByHost[];
}
export type HostEsxAgentHostManagerConfigInfo = DynamicData &  {
  agentVmDatastore?: Datastore;
  agentVmNetwork?: Network;
}
export type HostFaultToleranceManagerComponentHealthInfo = DynamicData &  {
  isStorageHealthy: boolean;
  isNetworkHealthy: boolean;
}
export type FcoeConfig = DynamicData &  {
  priorityClass: number;
  sourceMac: string;
  vlanRange: FcoeConfigVlanRange[];
  capabilities: FcoeConfigFcoeCapabilities;
  fcoeActive: boolean;
}
export type FcoeConfigFcoeCapabilities = DynamicData &  {
  priorityClass: boolean;
  sourceMacAddress: boolean;
  vlanRange: boolean;
}
export type FcoeConfigFcoeSpecification = DynamicData &  {
  underlyingPnic: string;
  priorityClass?: number;
  sourceMac?: string;
  vlanRange?: FcoeConfigVlanRange[];
}
export type FcoeConfigVlanRange = DynamicData &  {
  vlanLow: number;
  vlanHigh: number;
}
export type HostFeatureCapability = DynamicData &  {
  key: string;
  featureName: string;
  value: string;
}
export type HostFeatureMask = DynamicData &  {
  key: string;
  featureName: string;
  value: string;
}
export type HostFeatureVersionInfo = DynamicData &  {
  key: string;
  value: string;
}
export type HostFileAccess = DynamicData &  {
  who: string;
  what: string;
}
export type ModeInfo = DynamicData &  {
  browse?: string;
  read: string;
  modify: string;
  use: string;
  admin?: string;
  full: string;
}
export type HostFileSystemMountInfo = DynamicData &  {
  mountInfo: HostMountInfo;
  volume: HostFileSystemVolume;
  vStorageSupport?: string;
}
export type HostFileSystemVolume = DynamicData &  {
  type: string;
  name: string;
  capacity: number;
}
export type HostFileSystemVolumeInfo = DynamicData &  {
  volumeTypeList?: string[];
  mountInfo?: HostFileSystemMountInfo[];
}
export type HostFirewallInfo = DynamicData &  {
  defaultPolicy: HostFirewallDefaultPolicy;
  ruleset?: HostFirewallRuleset[];
}
export type HostFirewallDefaultPolicy = DynamicData &  {
  incomingBlocked?: boolean;
  outgoingBlocked?: boolean;
}
export type HostFlagInfo = DynamicData &  {
  backgroundSnapshotsEnabled?: boolean;
}
export type HostForceMountedInfo = DynamicData &  {
  persist: boolean;
  mounted: boolean;
}
export type HostGatewaySpec = DynamicData &  {
  gatewayType: string;
  gatewayId?: string;
  trustVerificationToken?: string;
  hostAuthParams?: KeyValue[];
}
export type HostGraphicsConfig = DynamicData &  {
  hostDefaultGraphicsType: string;
  sharedPassthruAssignmentPolicy: string;
  deviceType?: HostGraphicsConfigDeviceType[];
}
export type HostGraphicsConfigDeviceType = DynamicData &  {
  deviceId: string;
  graphicsType: string;
}
export type HostGraphicsInfo = DynamicData &  {
  deviceName: string;
  vendorName: string;
  pciId: string;
  graphicsType: string;
  memorySizeInKB: number;
  vm?: VirtualMachine[];
}
export type HostHardwareInfo = DynamicData &  {
  systemInfo: HostSystemInfo;
  cpuPowerManagementInfo?: HostCpuPowerManagementInfo;
  cpuInfo: HostCpuInfo;
  cpuPkg: HostCpuPackage[];
  memorySize: number;
  numaInfo?: HostNumaInfo;
  smcPresent: boolean;
  pciDevice?: HostPciDevice[];
  cpuFeature?: HostCpuIdInfo[];
  biosInfo?: HostBIOSInfo;
  reliableMemoryInfo?: HostReliableMemoryInfo;
  persistentMemoryInfo?: HostPersistentMemoryInfo;
  sgxInfo?: HostSgxInfo;
  sevInfo?: HostSevInfo;
}
export type HostHardwareStatusInfo = DynamicData &  {
  memoryStatusInfo?: HostHardwareElementInfo[];
  cpuStatusInfo?: HostHardwareElementInfo[];
  storageStatusInfo?: HostStorageElementInfo[];
}
export type HostHardwareElementInfo = DynamicData &  {
  name: string;
  status: ElementDescription;
}
export type HostStorageElementInfo = HostHardwareElementInfo &  {
  operationalInfo?: HostStorageOperationalInfo[];
}
export type HostStorageOperationalInfo = DynamicData &  {
  property: string;
  value: string;
}
export type HealthSystemRuntime = DynamicData &  {
  systemHealthInfo?: HostSystemHealthInfo;
  hardwareStatusInfo?: HostHardwareStatusInfo;
}
export type HostAccessControlEntry = DynamicData &  {
  principal: string;
  group: boolean;
  accessMode: HostAccessMode;
}
export type HostHostBusAdapter = DynamicData &  {
  key?: string;
  device: string;
  bus: number;
  status: string;
  model: string;
  driver?: string;
  pci?: string;
  storageProtocol?: string;
}
export type HostProxySwitch = DynamicData &  {
  dvsUuid: string;
  dvsName: string;
  key: string;
  numPorts: number;
  configNumPorts?: number;
  numPortsAvailable: number;
  uplinkPort?: KeyValue[];
  mtu?: number;
  pnic?: PhysicalNic[];
  spec: HostProxySwitchSpec;
  hostLag?: HostProxySwitchHostLagConfig[];
  networkReservationSupported?: boolean;
  nsxtEnabled?: boolean;
  ensEnabled?: boolean;
  ensInterruptEnabled?: boolean;
  transportZones?: DistributedVirtualSwitchHostMemberTransportZoneInfo[];
  nsxUsedUplinkPort?: string[];
  nsxtStatus?: string;
  nsxtStatusDetail?: string;
}
export type HostProxySwitchConfig = DynamicData &  {
  changeOperation?: string;
  uuid: string;
  spec?: HostProxySwitchSpec;
}
export type HostProxySwitchHostLagConfig = DynamicData &  {
  lagKey: string;
  lagName?: string;
  uplinkPort?: KeyValue[];
}
export type HostProxySwitchSpec = DynamicData &  {
  backing?: DistributedVirtualSwitchHostMemberBacking;
}
export type HostImageProfileSummary = DynamicData &  {
  name: string;
  vendor: string;
}
export type HostIpConfig = DynamicData &  {
  dhcp: boolean;
  ipAddress?: string;
  subnetMask?: string;
  ipV6Config?: HostIpConfigIpV6AddressConfiguration;
}
export type HostIpConfigIpV6Address = DynamicData &  {
  ipAddress: string;
  prefixLength: number;
  origin?: string;
  dadState?: string;
  lifetime?: Date;
  operation?: string;
}
export type HostIpConfigIpV6AddressConfiguration = DynamicData &  {
  ipV6Address?: HostIpConfigIpV6Address[];
  autoConfigurationEnabled?: boolean;
  dhcpV6Enabled?: boolean;
}
export type HostIpRouteConfig = DynamicData &  {
  defaultGateway?: string;
  gatewayDevice?: string;
  ipV6DefaultGateway?: string;
  ipV6GatewayDevice?: string;
}
export type HostIpRouteConfigSpec = HostIpRouteConfig &  {
  gatewayDeviceConnection?: HostVirtualNicConnection;
  ipV6GatewayDeviceConnection?: HostVirtualNicConnection;
}
export type HostIpRouteEntry = DynamicData &  {
  network: string;
  prefixLength: number;
  gateway: string;
  deviceName?: string;
}
export type HostIpRouteOp = DynamicData &  {
  changeOperation: string;
  route: HostIpRouteEntry;
}
export type HostIpRouteTableConfig = DynamicData &  {
  ipRoute?: HostIpRouteOp[];
  ipv6Route?: HostIpRouteOp[];
}
export type HostIpRouteTableInfo = DynamicData &  {
  ipRoute?: HostIpRouteEntry[];
  ipv6Route?: HostIpRouteEntry[];
}
export type HostIpmiInfo = DynamicData &  {
  bmcIpAddress?: string;
  bmcMacAddress?: string;
  login?: string;
  password?: string;
}
export type IscsiDependencyEntity = DynamicData &  {
  pnicDevice: string;
  vnicDevice: string;
  vmhbaName: string;
}
export type IscsiMigrationDependency = DynamicData &  {
  migrationAllowed: boolean;
  disallowReason?: IscsiStatus;
  dependency?: IscsiDependencyEntity[];
}
export type IscsiPortInfo = DynamicData &  {
  vnicDevice?: string;
  vnic?: HostVirtualNic;
  pnicDevice?: string;
  pnic?: PhysicalNic;
  switchName?: string;
  switchUuid?: string;
  portgroupName?: string;
  portgroupKey?: string;
  portKey?: string;
  opaqueNetworkId?: string;
  opaqueNetworkType?: string;
  opaqueNetworkName?: string;
  externalId?: string;
  complianceStatus?: IscsiStatus;
  pathStatus?: string;
}
export type IscsiStatus = DynamicData &  {
  reason?: MethodFault[];
}
export type KernelModuleInfo = DynamicData &  {
  id: number;
  name: string;
  version: string;
  filename: string;
  optionString: string;
  loaded: boolean;
  enabled: boolean;
  useCount: number;
  readOnlySection: KernelModuleSectionInfo;
  writableSection: KernelModuleSectionInfo;
  textSection: KernelModuleSectionInfo;
  dataSection: KernelModuleSectionInfo;
  bssSection: KernelModuleSectionInfo;
}
export type KernelModuleSectionInfo = DynamicData &  {
  address: number;
  length?: number;
}
export type HostLicenseSpec = DynamicData &  {
  source?: LicenseSource;
  editionKey?: string;
  disabledFeatureKey?: string[];
  enabledFeatureKey?: string[];
}
export type LinkDiscoveryProtocolConfig = DynamicData &  {
  protocol: string;
  operation: string;
}
export type HostAccountSpec = DynamicData &  {
  id: string;
  password?: string;
  description?: string;
}
export type HostPosixAccountSpec = HostAccountSpec &  {
  posixId?: number;
  shellAccess?: boolean;
}
export type HostLocalAuthenticationInfo = HostAuthenticationStoreInfo &  {
  
}
export type HostLocalFileSystemVolume = HostFileSystemVolume &  {
  device: string;
}
export type HostLocalFileSystemVolumeSpec = DynamicData &  {
  device: string;
  localPath: string;
}
export type HostLowLevelProvisioningManagerDiskLayoutSpec = DynamicData &  {
  controllerType: string;
  busNumber: number;
  unitNumber: number;
  srcFilename: string;
  dstFilename: string;
}
export type HostLowLevelProvisioningManagerFileDeleteResult = DynamicData &  {
  fileName: string;
  fault: MethodFault;
}
export type HostLowLevelProvisioningManagerFileDeleteSpec = DynamicData &  {
  fileName: string;
  fileType: string;
}
export type HostLowLevelProvisioningManagerFileReserveResult = DynamicData &  {
  baseName: string;
  parentDir: string;
  reservedName: string;
}
export type HostLowLevelProvisioningManagerFileReserveSpec = DynamicData &  {
  baseName: string;
  parentDir: string;
  fileType: string;
  storageProfile: string;
}
export type HostLowLevelProvisioningManagerSnapshotLayoutSpec = DynamicData &  {
  id: number;
  srcFilename: string;
  dstFilename: string;
  disk?: HostLowLevelProvisioningManagerDiskLayoutSpec[];
}
export type HostLowLevelProvisioningManagerVmMigrationStatus = DynamicData &  {
  migrationId: number;
  type: string;
  source: boolean;
  consideredSuccessful: boolean;
}
export type HostLowLevelProvisioningManagerVmRecoveryInfo = DynamicData &  {
  version: string;
  biosUUID: string;
  instanceUUID: string;
  ftInfo?: FaultToleranceConfigInfo;
}
export type HostMaintenanceSpec = DynamicData &  {
  vsanMode?: VsanHostDecommissionMode;
  purpose?: string;
}
export type ServiceConsoleReservationInfo = DynamicData &  {
  serviceConsoleReservedCfg: number;
  serviceConsoleReserved: number;
  unreserved: number;
}
export type VirtualMachineMemoryReservationInfo = DynamicData &  {
  virtualMachineMin: number;
  virtualMachineMax: number;
  virtualMachineReserved: number;
  allocationPolicy: string;
}
export type VirtualMachineMemoryReservationSpec = DynamicData &  {
  virtualMachineReserved?: number;
  allocationPolicy?: string;
}
export type HostMemorySpec = DynamicData &  {
  serviceConsoleReservation?: number;
}
export type HostMountInfo = DynamicData &  {
  path?: string;
  accessMode: string;
  mounted?: boolean;
  accessible?: boolean;
  inaccessibleReason?: string;
}
export type HostMultipathInfo = DynamicData &  {
  lun?: HostMultipathInfoLogicalUnit[];
}
export type HostMultipathInfoFixedLogicalUnitPolicy = HostMultipathInfoLogicalUnitPolicy &  {
  prefer: string;
}
export type HostMultipathInfoHppLogicalUnitPolicy = HostMultipathInfoLogicalUnitPolicy &  {
  bytes?: number;
  iops?: number;
  path?: string;
  latencyEvalTime?: number;
  samplingIosPerPath?: number;
}
export type HostMultipathInfoLogicalUnit = DynamicData &  {
  key: string;
  id: string;
  lun: ScsiLun;
  path: HostMultipathInfoPath[];
  policy: HostMultipathInfoLogicalUnitPolicy;
  storageArrayTypePolicy?: HostMultipathInfoLogicalUnitStorageArrayTypePolicy;
}
export type HostMultipathInfoLogicalUnitPolicy = DynamicData &  {
  policy: string;
}
export type HostMultipathInfoLogicalUnitStorageArrayTypePolicy = DynamicData &  {
  policy: string;
}
export type HostMultipathInfoPath = DynamicData &  {
  key: string;
  name: string;
  pathState: string;
  state?: string;
  isWorkingPath?: boolean;
  adapter: HostHostBusAdapter;
  lun: HostMultipathInfoLogicalUnit;
  transport?: HostTargetTransport;
}
export type HostMultipathStateInfo = DynamicData &  {
  path?: HostMultipathStateInfoPath[];
}
export type HostMultipathStateInfoPath = DynamicData &  {
  name: string;
  pathState: string;
}
export type HostNasVolume = HostFileSystemVolume &  {
  remoteHost: string;
  remotePath: string;
  userName?: string;
  remoteHostNames?: string[];
  securityType?: string;
  protocolEndpoint?: boolean;
}
export type HostNasVolumeConfig = DynamicData &  {
  changeOperation?: string;
  spec?: HostNasVolumeSpec;
}
export type HostNasVolumeSpec = DynamicData &  {
  remoteHost: string;
  remotePath: string;
  localPath: string;
  accessMode: string;
  type?: string;
  userName?: string;
  password?: string;
  remoteHostNames?: string[];
  securityType?: string;
}
export type HostNasVolumeUserInfo = DynamicData &  {
  user: string;
}
export type HostNatService = DynamicData &  {
  key: string;
  spec: HostNatServiceSpec;
}
export type HostNatServiceConfig = DynamicData &  {
  changeOperation?: string;
  key: string;
  spec: HostNatServiceSpec;
}
export type HostNatServiceNameServiceSpec = DynamicData &  {
  dnsAutoDetect: boolean;
  dnsPolicy: string;
  dnsRetries: number;
  dnsTimeout: number;
  dnsNameServer?: string[];
  nbdsTimeout: number;
  nbnsRetries: number;
  nbnsTimeout: number;
}
export type HostNatServicePortForwardSpec = DynamicData &  {
  type: string;
  name: string;
  hostPort: number;
  guestPort: number;
  guestIpAddress: string;
}
export type HostNatServiceSpec = DynamicData &  {
  virtualSwitch: string;
  activeFtp: boolean;
  allowAnyOui: boolean;
  configPort: boolean;
  ipGatewayAddress: string;
  udpTimeout: number;
  portForward?: HostNatServicePortForwardSpec[];
  nameService?: HostNatServiceNameServiceSpec;
}
export type HostNetCapabilities = DynamicData &  {
  canSetPhysicalNicLinkSpeed: boolean;
  supportsNicTeaming: boolean;
  nicTeamingPolicy?: string[];
  supportsVlan: boolean;
  usesServiceConsoleNic: boolean;
  supportsNetworkHints: boolean;
  maxPortGroupsPerVswitch?: number;
  vswitchConfigSupported: boolean;
  vnicConfigSupported: boolean;
  ipRouteConfigSupported: boolean;
  dnsConfigSupported: boolean;
  dhcpOnVnicSupported: boolean;
  ipV6Supported: boolean;
  backupNfcNiocSupported?: boolean;
}
export type HostNetOffloadCapabilities = DynamicData &  {
  csumOffload?: boolean;
  tcpSegmentation?: boolean;
  zeroCopyXmit?: boolean;
}
export type HostNetStackInstance = DynamicData &  {
  key?: string;
  name?: string;
  dnsConfig?: HostDnsConfig;
  ipRouteConfig?: HostIpRouteConfig;
  requestedMaxNumberOfConnections?: number;
  congestionControlAlgorithm?: string;
  ipV6Enabled?: boolean;
  routeTableConfig?: HostIpRouteTableConfig;
}
export type HostNetworkInfo = DynamicData &  {
  vswitch?: HostVirtualSwitch[];
  proxySwitch?: HostProxySwitch[];
  portgroup?: HostPortGroup[];
  pnic?: PhysicalNic[];
  rdmaDevice?: HostRdmaDevice[];
  vnic?: HostVirtualNic[];
  consoleVnic?: HostVirtualNic[];
  dnsConfig?: HostDnsConfig;
  ipRouteConfig?: HostIpRouteConfig;
  consoleIpRouteConfig?: HostIpRouteConfig;
  routeTableInfo?: HostIpRouteTableInfo;
  dhcp?: HostDhcpService[];
  nat?: HostNatService[];
  ipV6Enabled?: boolean;
  atBootIpV6Enabled?: boolean;
  netStackInstance?: HostNetStackInstance[];
  opaqueSwitch?: HostOpaqueSwitch[];
  opaqueNetwork?: HostOpaqueNetworkInfo[];
  nsxTransportNodeId?: string;
}
export type HostNetworkPolicy = DynamicData &  {
  security?: HostNetworkSecurityPolicy;
  nicTeaming?: HostNicTeamingPolicy;
  offloadPolicy?: HostNetOffloadCapabilities;
  shapingPolicy?: HostNetworkTrafficShapingPolicy;
}
export type HostNicFailureCriteria = DynamicData &  {
  checkSpeed?: string;
  speed?: number;
  checkDuplex?: boolean;
  fullDuplex?: boolean;
  checkErrorPercent?: boolean;
  percentage?: number;
  checkBeacon?: boolean;
}
export type HostNicOrderPolicy = DynamicData &  {
  activeNic?: string[];
  standbyNic?: string[];
}
export type HostNicTeamingPolicy = DynamicData &  {
  policy?: string;
  reversePolicy?: boolean;
  notifySwitches?: boolean;
  rollingOrder?: boolean;
  failureCriteria?: HostNicFailureCriteria;
  nicOrder?: HostNicOrderPolicy;
}
export type HostNetworkSecurityPolicy = DynamicData &  {
  allowPromiscuous?: boolean;
  macChanges?: boolean;
  forgedTransmits?: boolean;
}
export type HostNetworkTrafficShapingPolicy = DynamicData &  {
  enabled?: boolean;
  averageBandwidth?: number;
  peakBandwidth?: number;
  burstSize?: number;
}
export type HostNtpConfig = DynamicData &  {
  server?: string[];
  configFile?: string[];
}
export type HostNumaInfo = DynamicData &  {
  type: string;
  numNodes: number;
  numaNode?: HostNumaNode[];
}
export type HostNumaNode = DynamicData &  {
  typeId: number;
  cpuID: number[];
  memoryRangeBegin: number;
  memoryRangeLength: number;
  pciId?: string[];
}
export type HostNumericSensorInfo = DynamicData &  {
  name: string;
  healthState?: ElementDescription;
  currentReading: number;
  unitModifier: number;
  baseUnits: string;
  rateUnits?: string;
  sensorType: string;
  id?: string;
  timeStamp?: string;
}
export type NvdimmDimmInfo = DynamicData &  {
  dimmHandle: number;
  healthInfo: NvdimmHealthInfo;
  totalCapacity: number;
  persistentCapacity: number;
  availablePersistentCapacity: number;
  volatileCapacity: number;
  availableVolatileCapacity: number;
  blockCapacity: number;
  regionInfo?: NvdimmRegionInfo[];
  representationString: string;
}
export type NvdimmGuid = DynamicData &  {
  uuid: string;
}
export type NvdimmHealthInfo = DynamicData &  {
  healthStatus: string;
  healthInformation: string;
  stateFlagInfo?: string[];
  dimmTemperature: number;
  dimmTemperatureThreshold: number;
  spareBlocksPercentage: number;
  spareBlockThreshold: number;
  dimmLifespanPercentage: number;
  esTemperature?: number;
  esTemperatureThreshold?: number;
  esLifespanPercentage?: number;
}
export type NvdimmInterleaveSetInfo = DynamicData &  {
  setId: number;
  rangeType: string;
  baseAddress: number;
  size: number;
  availableSize: number;
  deviceList?: number[];
  state: string;
}
export type NvdimmNamespaceCreateSpec = DynamicData &  {
  friendlyName?: string;
  blockSize: number;
  blockCount: number;
  type: string;
  locationID: number;
}
export type NvdimmNamespaceDeleteSpec = DynamicData &  {
  uuid: string;
}
export type NvdimmNamespaceDetails = DynamicData &  {
  uuid: string;
  friendlyName: string;
  size: number;
  type: string;
  namespaceHealthStatus: string;
  interleavesetID: number;
  state: string;
}
export type NvdimmNamespaceInfo = DynamicData &  {
  uuid: string;
  friendlyName: string;
  blockSize: number;
  blockCount: number;
  type: string;
  namespaceHealthStatus: string;
  locationID: number;
  state: string;
}
export type NvdimmSystemInfo = DynamicData &  {
  summary?: NvdimmSummary;
  dimms?: number[];
  dimmInfo?: NvdimmDimmInfo[];
  interleaveSet?: number[];
  iSetInfo?: NvdimmInterleaveSetInfo[];
  namespace?: NvdimmGuid[];
  nsInfo?: NvdimmNamespaceInfo[];
  nsDetails?: NvdimmNamespaceDetails[];
}
export type NvdimmPMemNamespaceCreateSpec = DynamicData &  {
  friendlyName?: string;
  size: number;
  interleavesetID: number;
}
export type NvdimmRegionInfo = DynamicData &  {
  regionId: number;
  setId: number;
  rangeType: string;
  startAddr: number;
  size: number;
  offset: number;
}
export type NvdimmSummary = DynamicData &  {
  numDimms: number;
  healthStatus: string;
  totalCapacity: number;
  persistentCapacity: number;
  blockCapacity: number;
  availableCapacity: number;
  numInterleavesets: number;
  numNamespaces: number;
}
export type HostNvmeController = DynamicData &  {
  key: string;
  controllerNumber: number;
  subnqn: string;
  name: string;
  associatedAdapter: HostHostBusAdapter;
  transportType: string;
  fusedOperationSupported: boolean;
  numberOfQueues: number;
  queueSize: number;
  attachedNamespace?: HostNvmeNamespace[];
  vendorId?: string;
  model?: string;
  serialNumber?: string;
  firmwareVersion?: string;
}
export type HostNvmeDisconnectSpec = DynamicData &  {
  hbaName: string;
  subnqn?: string;
  controllerNumber?: number;
}
export type HostNvmeDiscoveryLog = DynamicData &  {
  entry?: HostNvmeDiscoveryLogEntry[];
  complete: boolean;
}
export type HostNvmeDiscoveryLogEntry = DynamicData &  {
  subnqn: string;
  subsystemType: string;
  subsystemPortId: number;
  controllerId: number;
  adminQueueMaxSize: number;
  transportParameters: HostNvmeTransportParameters;
  transportRequirements: string;
  connected: boolean;
}
export type HostNvmeNamespace = DynamicData &  {
  key: string;
  name: string;
  id: number;
  blockSize: number;
  capacityInBlocks: number;
}
export type HostNvmeSpec = DynamicData &  {
  hbaName: string;
  transportParameters: HostNvmeTransportParameters;
}
export type HostNvmeTopology = DynamicData &  {
  adapter?: HostNvmeTopologyInterface[];
}
export type HostNvmeTopologyInterface = DynamicData &  {
  key: string;
  adapter: HostHostBusAdapter;
  connectedController?: HostNvmeController[];
}
export type HostNvmeTransportParameters = DynamicData &  {
  
}
export type HostOpaqueSwitch = DynamicData &  {
  key: string;
  name?: string;
  pnic?: PhysicalNic[];
  pnicZone?: HostOpaqueSwitchPhysicalNicZone[];
  status?: string;
  vtep?: HostVirtualNic[];
  extraConfig?: OptionValue[];
  featureCapability?: HostFeatureCapability[];
}
export type HostOpaqueSwitchPhysicalNicZone = DynamicData &  {
  key: string;
  pnicDevice?: string[];
}
export type HostPMemVolume = HostFileSystemVolume &  {
  uuid: string;
  version: string;
}
export type HostParallelScsiHba = HostHostBusAdapter &  {
  
}
export type HostPatchManagerLocator = DynamicData &  {
  url: string;
  proxy?: string;
}
export type HostPatchManagerPatchManagerOperationSpec = DynamicData &  {
  proxy?: string;
  port?: number;
  userName?: string;
  password?: string;
  cmdOption?: string;
}
export type HostPatchManagerResult = DynamicData &  {
  version: string;
  status?: HostPatchManagerStatus[];
  xmlResult?: string;
}
export type HostPatchManagerStatus = DynamicData &  {
  id: string;
  applicable: boolean;
  reason?: string[];
  integrity?: string;
  installed: boolean;
  installState?: string[];
  prerequisitePatch?: HostPatchManagerStatusPrerequisitePatch[];
  restartRequired: boolean;
  reconnectRequired: boolean;
  vmOffRequired: boolean;
  supersededPatchIds?: string[];
}
export type HostPatchManagerStatusPrerequisitePatch = DynamicData &  {
  id: string;
  installState?: string[];
}
export type HostPathSelectionPolicyOption = DynamicData &  {
  policy: ElementDescription;
}
export type HostPciDevice = DynamicData &  {
  id: string;
  classId: number;
  bus: number;
  slot: number;
  function: number;
  vendorId: number;
  subVendorId: number;
  vendorName: string;
  deviceId: number;
  subDeviceId: number;
  parentBridge?: string;
  deviceName: string;
}
export type HostPciPassthruConfig = DynamicData &  {
  id: string;
  passthruEnabled: boolean;
  applyNow?: boolean;
}
export type HostPciPassthruInfo = DynamicData &  {
  id: string;
  dependentDevice: string;
  passthruEnabled: boolean;
  passthruCapable: boolean;
  passthruActive: boolean;
}
export type HostPcieHba = HostHostBusAdapter &  {
  
}
export type HostPersistentMemoryInfo = DynamicData &  {
  capacityInMB?: number;
  volumeUUID?: string;
}
export type PhysicalNic = DynamicData &  {
  key?: string;
  device: string;
  pci: string;
  driver?: string;
  linkSpeed?: PhysicalNicLinkInfo;
  validLinkSpecification?: PhysicalNicLinkInfo[];
  spec: PhysicalNicSpec;
  wakeOnLanSupported: boolean;
  mac: string;
  fcoeConfiguration?: FcoeConfig;
  vmDirectPathGen2Supported?: boolean;
  vmDirectPathGen2SupportedMode?: string;
  resourcePoolSchedulerAllowed?: boolean;
  resourcePoolSchedulerDisallowedReason?: string[];
  autoNegotiateSupported?: boolean;
  enhancedNetworkingStackSupported?: boolean;
  ensInterruptSupported?: boolean;
  rdmaDevice?: HostRdmaDevice;
}
export type PhysicalNicCdpDeviceCapability = DynamicData &  {
  router: boolean;
  transparentBridge: boolean;
  sourceRouteBridge: boolean;
  networkSwitch: boolean;
  host: boolean;
  igmpEnabled: boolean;
  repeater: boolean;
}
export type PhysicalNicCdpInfo = DynamicData &  {
  cdpVersion?: number;
  timeout?: number;
  ttl?: number;
  samples?: number;
  devId?: string;
  address?: string;
  portId?: string;
  deviceCapability?: PhysicalNicCdpDeviceCapability;
  softwareVersion?: string;
  hardwarePlatform?: string;
  ipPrefix?: string;
  ipPrefixLen?: number;
  vlan?: number;
  fullDuplex?: boolean;
  mtu?: number;
  systemName?: string;
  systemOID?: string;
  mgmtAddr?: string;
  location?: string;
}
export type PhysicalNicConfig = DynamicData &  {
  device: string;
  spec: PhysicalNicSpec;
}
export type PhysicalNicLinkInfo = DynamicData &  {
  speedMb: number;
  duplex: boolean;
}
export type LinkLayerDiscoveryProtocolInfo = DynamicData &  {
  chassisId: string;
  portId: string;
  timeToLive: number;
  parameter?: KeyAnyValue[];
}
export type PhysicalNicHintInfo = DynamicData &  {
  device: string;
  subnet?: PhysicalNicIpHint[];
  network?: PhysicalNicNameHint[];
  connectedSwitchPort?: PhysicalNicCdpInfo;
  lldpInfo?: LinkLayerDiscoveryProtocolInfo;
}
export type PhysicalNicHint = DynamicData &  {
  vlanId?: number;
}
export type PhysicalNicIpHint = PhysicalNicHint &  {
  ipSubnet: string;
}
export type PhysicalNicNameHint = PhysicalNicHint &  {
  network: string;
}
export type PhysicalNicSpec = DynamicData &  {
  ip?: HostIpConfig;
  linkSpeed?: PhysicalNicLinkInfo;
  enableEnhancedNetworkingStack?: boolean;
  ensInterruptEnabled?: boolean;
}
export type HostPlugStoreTopology = DynamicData &  {
  adapter?: HostPlugStoreTopologyAdapter[];
  path?: HostPlugStoreTopologyPath[];
  target?: HostPlugStoreTopologyTarget[];
  device?: HostPlugStoreTopologyDevice[];
  plugin?: HostPlugStoreTopologyPlugin[];
}
export type HostPlugStoreTopologyAdapter = DynamicData &  {
  key: string;
  adapter: HostHostBusAdapter;
  path?: HostPlugStoreTopologyPath[];
}
export type HostPlugStoreTopologyDevice = DynamicData &  {
  key: string;
  lun: ScsiLun;
  path?: HostPlugStoreTopologyPath[];
}
export type HostPlugStoreTopologyPath = DynamicData &  {
  key: string;
  name: string;
  channelNumber?: number;
  targetNumber?: number;
  lunNumber?: number;
  adapter?: HostPlugStoreTopologyAdapter;
  target?: HostPlugStoreTopologyTarget;
  device?: HostPlugStoreTopologyDevice;
}
export type HostPlugStoreTopologyPlugin = DynamicData &  {
  key: string;
  name: string;
  device?: HostPlugStoreTopologyDevice[];
  claimedPath?: HostPlugStoreTopologyPath[];
}
export type HostPlugStoreTopologyTarget = DynamicData &  {
  key: string;
  transport?: HostTargetTransport;
}
export type HostPortGroup = DynamicData &  {
  key?: string;
  port?: HostPortGroupPort[];
  vswitch?: HostVirtualSwitch;
  computedPolicy: HostNetworkPolicy;
  spec: HostPortGroupSpec;
}
export type HostPortGroupConfig = DynamicData &  {
  changeOperation?: string;
  spec?: HostPortGroupSpec;
}
export type HostPortGroupPort = DynamicData &  {
  key?: string;
  mac?: string[];
  type: string;
}
export type HostPortGroupSpec = DynamicData &  {
  name: string;
  vlanId: number;
  vswitchName: string;
  policy: HostNetworkPolicy;
}
export type PowerSystemCapability = DynamicData &  {
  availablePolicy: HostPowerPolicy[];
}
export type PowerSystemInfo = DynamicData &  {
  currentPolicy: HostPowerPolicy;
}
export type HostPowerPolicy = DynamicData &  {
  key: number;
  name: string;
  shortName: string;
  description: string;
}
export type HostProtocolEndpoint = DynamicData &  {
  peType: string;
  type?: string;
  uuid: string;
  hostKey?: HostSystem[];
  storageArray?: string;
  nfsServer?: string;
  nfsDir?: string;
  nfsServerScope?: string;
  nfsServerMajor?: string;
  nfsServerAuthType?: string;
  nfsServerUser?: string;
  deviceId?: string;
}
export type HostRdmaDevice = DynamicData &  {
  key: string;
  device: string;
  driver?: string;
  description?: string;
  backing?: HostRdmaDeviceBacking;
  connectionInfo: HostRdmaDeviceConnectionInfo;
  capability: HostRdmaDeviceCapability;
}
export type HostRdmaDeviceBacking = DynamicData &  {
  
}
export type HostRdmaDeviceCapability = DynamicData &  {
  roceV1Capable: boolean;
  roceV2Capable: boolean;
  iWarpCapable: boolean;
}
export type HostRdmaDeviceConnectionInfo = DynamicData &  {
  state: string;
  mtu: number;
  speedInMbps: number;
}
export type HostRdmaDevicePnicBacking = HostRdmaDeviceBacking &  {
  pairedUplink: PhysicalNic;
}
export type HostRdmaHba = HostHostBusAdapter &  {
  associatedRdmaDevice?: string;
}
export type HostReliableMemoryInfo = DynamicData &  {
  memorySize: number;
}
export type HostResignatureRescanResult = DynamicData &  {
  rescan?: HostVmfsRescanResult[];
  result: Datastore;
}
export type HostFirewallRuleset = DynamicData &  {
  key: string;
  label: string;
  required: boolean;
  rule: HostFirewallRule[];
  service?: string;
  enabled: boolean;
  allowedHosts?: HostFirewallRulesetIpList;
}
export type HostFirewallRulesetIpList = DynamicData &  {
  ipAddress?: string[];
  ipNetwork?: HostFirewallRulesetIpNetwork[];
  allIp: boolean;
}
export type HostFirewallRulesetIpNetwork = DynamicData &  {
  network: string;
  prefixLength: number;
}
export type HostFirewallRule = DynamicData &  {
  port: number;
  endPort?: number;
  direction: HostFirewallRuleDirection;
  portType?: HostFirewallRulePortType;
  protocol: string;
}
export type HostFirewallRulesetRulesetSpec = DynamicData &  {
  allowedHosts: HostFirewallRulesetIpList;
}
export type ScsiLun = HostDevice &  {
  key?: string;
  uuid: string;
  descriptor?: ScsiLunDescriptor[];
  canonicalName?: string;
  displayName?: string;
  lunType: string;
  vendor?: string;
  model?: string;
  revision?: string;
  scsiLevel?: number;
  serialNumber?: string;
  durableName?: ScsiLunDurableName;
  alternateName?: ScsiLunDurableName[];
  standardInquiry?: number[];
  queueDepth?: number;
  operationalState: string[];
  capabilities?: ScsiLunCapabilities;
  vStorageSupport?: string;
  protocolEndpoint?: boolean;
  perenniallyReserved?: boolean;
  clusteredVmdkSupported?: boolean;
}
export type ScsiLunCapabilities = DynamicData &  {
  updateDisplayNameSupported: boolean;
}
export type ScsiLunDescriptor = DynamicData &  {
  quality: string;
  id: string;
}
export type ScsiLunDurableName = DynamicData &  {
  namespace: string;
  namespaceId: number;
  data?: number[];
}
export type HostScsiTopology = DynamicData &  {
  adapter?: HostScsiTopologyInterface[];
}
export type HostScsiTopologyInterface = DynamicData &  {
  key: string;
  adapter: HostHostBusAdapter;
  target?: HostScsiTopologyTarget[];
}
export type HostScsiTopologyLun = DynamicData &  {
  key: string;
  lun: number;
  scsiLun: ScsiLun;
}
export type HostScsiTopologyTarget = DynamicData &  {
  key: string;
  target: number;
  lun?: HostScsiTopologyLun[];
  transport?: HostTargetTransport;
}
export type HostSerialAttachedHba = HostHostBusAdapter &  {
  nodeWorldWideName: string;
}
export type HostService = DynamicData &  {
  key: string;
  label: string;
  required: boolean;
  uninstallable: boolean;
  running: boolean;
  ruleset?: string[];
  policy: string;
  sourcePackage?: HostServiceSourcePackage;
}
export type HostServiceSourcePackage = DynamicData &  {
  sourcePackageName: string;
  description: string;
}
export type HostServiceConfig = DynamicData &  {
  serviceId: string;
  startupPolicy: string;
}
export type HostServiceInfo = DynamicData &  {
  service?: HostService[];
}
export type HostSevInfo = DynamicData &  {
  sevState: string;
  maxSevEsGuests: number;
}
export type HostSgxInfo = DynamicData &  {
  sgxState: string;
  totalEpcMemory: number;
  flcMode: string;
  lePubKeyHash?: string;
}
export type HostSharedGpuCapabilities = DynamicData &  {
  vgpu: string;
  diskSnapshotSupported: boolean;
  memorySnapshotSupported: boolean;
  suspendSupported: boolean;
  migrateSupported: boolean;
}
export type HostSnmpSystemAgentLimits = DynamicData &  {
  maxReadOnlyCommunities: number;
  maxTrapDestinations: number;
  maxCommunityLength: number;
  maxBufferSize: number;
  capability: HostSnmpAgentCapability;
}
export type HostSnmpConfigSpec = DynamicData &  {
  enabled?: boolean;
  port?: number;
  readOnlyCommunities?: string[];
  trapTargets?: HostSnmpDestination[];
  option?: KeyValue[];
}
export type HostSnmpDestination = DynamicData &  {
  hostName: string;
  port: number;
  community: string;
}
export type SoftwarePackage = DynamicData &  {
  name: string;
  version: string;
  type: string;
  vendor: string;
  acceptanceLevel: string;
  summary: string;
  description: string;
  referenceURL?: string[];
  creationDate?: Date;
  depends?: Relation[];
  conflicts?: Relation[];
  replaces?: Relation[];
  provides?: string[];
  maintenanceModeRequired?: boolean;
  hardwarePlatformsRequired?: string[];
  capability: SoftwarePackageCapability;
  tag?: string[];
  payload?: string[];
}
export type SoftwarePackageCapability = DynamicData &  {
  liveInstallAllowed?: boolean;
  liveRemoveAllowed?: boolean;
  statelessReady?: boolean;
  overlay?: boolean;
}
export type Relation = DynamicData &  {
  constraint?: string;
  name: string;
  version?: string;
}
export type HostSriovConfig = HostPciPassthruConfig &  {
  sriovEnabled: boolean;
  numVirtualFunction: number;
}
export type HostSriovDevicePoolInfo = DynamicData &  {
  key: string;
}
export type HostSriovInfo = HostPciPassthruInfo &  {
  sriovEnabled: boolean;
  sriovCapable: boolean;
  sriovActive: boolean;
  numVirtualFunctionRequested: number;
  numVirtualFunction: number;
  maxVirtualFunctionSupported: number;
}
export type HostSriovNetworkDevicePoolInfo = HostSriovDevicePoolInfo &  {
  switchKey?: string;
  switchUuid?: string;
  pnic?: PhysicalNic[];
}
export type HostSslThumbprintInfo = DynamicData &  {
  principal: string;
  ownerTag: string;
  sslThumbprints?: string[];
}
export type HostStorageArrayTypePolicyOption = DynamicData &  {
  policy: ElementDescription;
}
export type HostStorageDeviceInfo = DynamicData &  {
  hostBusAdapter?: HostHostBusAdapter[];
  scsiLun?: ScsiLun[];
  scsiTopology?: HostScsiTopology;
  nvmeTopology?: HostNvmeTopology;
  multipathInfo?: HostMultipathInfo;
  plugStoreTopology?: HostPlugStoreTopology;
  softwareInternetScsiEnabled: boolean;
}
export type SystemEventInfo = DynamicData &  {
  recordId: number;
  when: string;
  selType: number;
  message: string;
  sensorNumber: number;
}
export type HostSystemHealthInfo = DynamicData &  {
  numericSensorInfo?: HostNumericSensorInfo[];
}
export type HostSystemIdentificationInfo = DynamicData &  {
  identifierValue: string;
  identifierType: ElementDescription;
}
export type HostSystemInfo = DynamicData &  {
  vendor: string;
  model: string;
  uuid: string;
  otherIdentifyingInfo?: HostSystemIdentificationInfo[];
  serialNumber?: string;
}
export type HostSystemResourceInfo = DynamicData &  {
  key: string;
  config?: ResourceConfigSpec;
  child?: HostSystemResourceInfo[];
}
export type HostSystemSwapConfiguration = DynamicData &  {
  option?: HostSystemSwapConfigurationSystemSwapOption[];
}
export type HostSystemSwapConfigurationDatastoreOption = HostSystemSwapConfigurationSystemSwapOption &  {
  datastore: string;
}
export type HostSystemSwapConfigurationDisabledOption = HostSystemSwapConfigurationSystemSwapOption &  {
  
}
export type HostSystemSwapConfigurationHostCacheOption = HostSystemSwapConfigurationSystemSwapOption &  {
  
}
export type HostSystemSwapConfigurationHostLocalSwapOption = HostSystemSwapConfigurationSystemSwapOption &  {
  
}
export type HostSystemSwapConfigurationSystemSwapOption = DynamicData &  {
  key: number;
}
export type HostTargetTransport = DynamicData &  {
  
}
export type HostTpmAttestationInfo = DynamicData &  {
  time: Date;
  status: HostTpmAttestationInfoAcceptanceStatus;
  message?: LocalizableMessage;
}
export type HostTpmAttestationReport = DynamicData &  {
  tpmPcrValues: HostTpmDigestInfo[];
  tpmEvents: HostTpmEventLogEntry[];
  tpmLogReliable: boolean;
}
export type HostTpmDigestInfo = HostDigestInfo &  {
  pcrNumber: number;
}
export type HostTpmEventDetails = DynamicData &  {
  dataHash: number[];
  dataHashMethod?: string;
}
export type HostTpmEventLogEntry = DynamicData &  {
  pcrIndex: number;
  eventDetails: HostTpmEventDetails;
}
export type HostTpmOptionEventDetails = HostTpmEventDetails &  {
  optionsFileName: string;
  bootOptions?: number[];
}
export type HostTpmSoftwareComponentEventDetails = HostTpmEventDetails &  {
  componentName: string;
  vibName: string;
  vibVersion: string;
  vibVendor: string;
}
export type HostTrustAuthorityAttestationInfo = DynamicData &  {
  attestationStatus: string;
  serviceId?: string;
  attestedAt?: Date;
  attestedUntil?: Date;
  messages?: LocalizableMessage[];
}
export type HostUnresolvedVmfsResignatureSpec = DynamicData &  {
  extentDevicePath: string[];
}
export type HostUnresolvedVmfsResolutionResult = DynamicData &  {
  spec: HostUnresolvedVmfsResolutionSpec;
  vmfs?: HostVmfsVolume;
  fault?: MethodFault;
}
export type HostUnresolvedVmfsResolutionSpec = DynamicData &  {
  extentDevicePath: string[];
  uuidResolution: string;
}
export type HostUnresolvedVmfsVolume = DynamicData &  {
  extent: HostUnresolvedVmfsExtent[];
  vmfsLabel: string;
  vmfsUuid: string;
  totalBlocks: number;
  resolveStatus: HostUnresolvedVmfsVolumeResolveStatus;
}
export type HostUnresolvedVmfsVolumeResolveStatus = DynamicData &  {
  resolvable: boolean;
  incompleteExtents?: boolean;
  multipleCopies?: boolean;
}
export type HostVFlashResourceConfigurationResult = DynamicData &  {
  devicePath?: string[];
  vffs?: HostVffsVolume;
  diskConfigurationResult?: HostDiskConfigurationResult[];
}
export type HostVMotionConfig = DynamicData &  {
  vmotionNicKey?: string;
  enabled: boolean;
}
export type HostVMotionNetConfig = DynamicData &  {
  candidateVnic?: HostVirtualNic[];
  selectedVnic?: HostVirtualNic;
}
export type HostVfatVolume = HostFileSystemVolume &  {
  
}
export type HostVirtualNic = DynamicData &  {
  device: string;
  key: string;
  portgroup: string;
  spec: HostVirtualNicSpec;
  port?: HostPortGroupPort;
}
export type HostVirtualNicConfig = DynamicData &  {
  changeOperation?: string;
  device?: string;
  portgroup: string;
  spec?: HostVirtualNicSpec;
}
export type HostVirtualNicIpRouteSpec = DynamicData &  {
  ipRouteConfig?: HostIpRouteConfig;
}
export type HostVirtualNicOpaqueNetworkSpec = DynamicData &  {
  opaqueNetworkId: string;
  opaqueNetworkType: string;
}
export type HostVirtualNicSpec = DynamicData &  {
  ip?: HostIpConfig;
  mac?: string;
  distributedVirtualPort?: DistributedVirtualSwitchPortConnection;
  portgroup?: string;
  mtu?: number;
  tsoEnabled?: boolean;
  netStackInstanceKey?: string;
  opaqueNetwork?: HostVirtualNicOpaqueNetworkSpec;
  externalId?: string;
  pinnedPnic?: string;
  ipRouteSpec?: HostVirtualNicIpRouteSpec;
  systemOwned?: boolean;
}
export type HostVirtualNicConnection = DynamicData &  {
  portgroup?: string;
  dvPort?: DistributedVirtualSwitchPortConnection;
  opNetwork?: HostVirtualNicOpaqueNetworkSpec;
}
export type VirtualNicManagerNetConfig = DynamicData &  {
  nicType: string;
  multiSelectAllowed: boolean;
  candidateVnic?: HostVirtualNic[];
  selectedVnic?: HostVirtualNic[];
}
export type HostVirtualNicManagerNicTypeSelection = DynamicData &  {
  vnic: HostVirtualNicConnection;
  nicType?: string[];
}
export type HostVirtualNicManagerInfo = DynamicData &  {
  netConfig?: VirtualNicManagerNetConfig[];
}
export type HostVirtualSwitch = DynamicData &  {
  name: string;
  key: string;
  numPorts: number;
  numPortsAvailable: number;
  mtu?: number;
  portgroup?: HostPortGroup[];
  pnic?: PhysicalNic[];
  spec: HostVirtualSwitchSpec;
}
export type HostVirtualSwitchAutoBridge = HostVirtualSwitchBridge &  {
  excludedNicDevice?: string[];
}
export type HostVirtualSwitchBeaconConfig = DynamicData &  {
  interval: number;
}
export type HostVirtualSwitchBondBridge = HostVirtualSwitchBridge &  {
  nicDevice: string[];
  beacon?: HostVirtualSwitchBeaconConfig;
  linkDiscoveryProtocolConfig?: LinkDiscoveryProtocolConfig;
}
export type HostVirtualSwitchBridge = DynamicData &  {
  
}
export type HostVirtualSwitchConfig = DynamicData &  {
  changeOperation?: string;
  name: string;
  spec?: HostVirtualSwitchSpec;
}
export type HostVirtualSwitchSimpleBridge = HostVirtualSwitchBridge &  {
  nicDevice: string;
}
export type HostVirtualSwitchSpec = DynamicData &  {
  numPorts: number;
  bridge?: HostVirtualSwitchBridge;
  policy?: HostNetworkPolicy;
  mtu?: number;
}
export type HostVmciAccessManagerAccessSpec = DynamicData &  {
  vm: VirtualMachine;
  services?: string[];
  mode: string;
}
export type VmfsDatastoreOption = DynamicData &  {
  info: VmfsDatastoreBaseOption;
  spec: VmfsDatastoreSpec;
}
export type VmfsDatastoreAllExtentOption = VmfsDatastoreSingleExtentOption &  {
  
}
export type VmfsDatastoreBaseOption = DynamicData &  {
  layout: HostDiskPartitionLayout;
  partitionFormatChange?: boolean;
}
export type VmfsDatastoreMultipleExtentOption = VmfsDatastoreBaseOption &  {
  vmfsExtent: HostDiskPartitionBlockRange[];
}
export type VmfsDatastoreSingleExtentOption = VmfsDatastoreBaseOption &  {
  vmfsExtent: HostDiskPartitionBlockRange;
}
export type VmfsDatastoreSpec = DynamicData &  {
  diskUuid: string;
}
export type HostVmfsRescanResult = DynamicData &  {
  host: HostSystem;
  fault?: MethodFault;
}
export type HostVsanInternalSystemCmmdsQuery = DynamicData &  {
  type?: string;
  uuid?: string;
  owner?: string;
}
export type HostVsanInternalSystemDeleteVsanObjectsResult = DynamicData &  {
  uuid: string;
  success: boolean;
  failureReason?: LocalizableMessage[];
}
export type VsanNewPolicyBatch = DynamicData &  {
  size?: number[];
  policy?: string;
}
export type VsanPolicyChangeBatch = DynamicData &  {
  uuid?: string[];
  policy?: string;
}
export type VsanPolicyCost = DynamicData &  {
  changeDataSize?: number;
  currentDataSize?: number;
  tempDataSize?: number;
  copyDataSize?: number;
  changeFlashReadCacheSize?: number;
  currentFlashReadCacheSize?: number;
  currentDiskSpaceToAddressSpaceRatio?: number;
  diskSpaceToAddressSpaceRatio?: number;
}
export type VsanPolicySatisfiability = DynamicData &  {
  uuid?: string;
  isSatisfiable: boolean;
  reason?: LocalizableMessage;
  cost?: VsanPolicyCost;
}
export type HostVsanInternalSystemVsanObjectOperationResult = DynamicData &  {
  uuid: string;
  failureReason?: LocalizableMessage[];
}
export type HostVsanInternalSystemVsanPhysicalDiskDiagnosticsResult = DynamicData &  {
  diskUuid: string;
  success: boolean;
  failureReason?: string;
}
export type HostVvolVolume = HostFileSystemVolume &  {
  scId: string;
  hostPE?: VVolHostPE[];
  vasaProviderInfo?: VimVasaProviderInfo[];
  storageArray?: VASAStorageArray[];
}
export type VVolHostPE = DynamicData &  {
  key: HostSystem;
  protocolEndpoint: HostProtocolEndpoint[];
}
export type HostVvolVolumeSpecification = DynamicData &  {
  maxSizeInMB: number;
  volumeName: string;
  vasaProviderInfo?: VimVasaProviderInfo[];
  storageArray?: VASAStorageArray[];
  uuid: string;
}
export type NetDhcpConfigInfo = DynamicData &  {
  ipv6?: NetDhcpConfigInfoDhcpOptions;
  ipv4?: NetDhcpConfigInfoDhcpOptions;
}
export type NetDhcpConfigInfoDhcpOptions = DynamicData &  {
  enable: boolean;
  config?: KeyValue[];
}
export type NetDhcpConfigSpec = DynamicData &  {
  ipv6?: NetDhcpConfigSpecDhcpOptionsSpec;
  ipv4?: NetDhcpConfigSpecDhcpOptionsSpec;
}
export type NetDhcpConfigSpecDhcpOptionsSpec = DynamicData &  {
  enable?: boolean;
  config: KeyValue[];
  operation: string;
}
export type NetDnsConfigInfo = DynamicData &  {
  dhcp: boolean;
  hostName: string;
  domainName: string;
  ipAddress?: string[];
  searchDomain?: string[];
}
export type NetDnsConfigSpec = DynamicData &  {
  dhcp?: boolean;
  hostName?: string;
  domainName?: string;
  ipAddress?: string[];
  searchDomain?: string[];
}
export type NetIpConfigInfo = DynamicData &  {
  ipAddress?: NetIpConfigInfoIpAddress[];
  dhcp?: NetDhcpConfigInfo;
  autoConfigurationEnabled?: boolean;
}
export type NetIpConfigInfoIpAddress = DynamicData &  {
  ipAddress: string;
  prefixLength: number;
  origin?: string;
  state?: string;
  lifetime?: Date;
}
export type NetIpConfigSpec = DynamicData &  {
  ipAddress?: NetIpConfigSpecIpAddressSpec[];
  dhcp?: NetDhcpConfigSpec;
  autoConfigurationEnabled?: boolean;
}
export type NetIpConfigSpecIpAddressSpec = DynamicData &  {
  ipAddress: string;
  prefixLength: number;
  operation: string;
}
export type NetIpRouteConfigInfo = DynamicData &  {
  ipRoute?: NetIpRouteConfigInfoIpRoute[];
}
export type NetIpRouteConfigInfoGateway = DynamicData &  {
  ipAddress?: string;
  device?: string;
}
export type NetIpRouteConfigInfoIpRoute = DynamicData &  {
  network: string;
  prefixLength: number;
  gateway: NetIpRouteConfigInfoGateway;
}
export type NetIpRouteConfigSpec = DynamicData &  {
  ipRoute?: NetIpRouteConfigSpecIpRouteSpec[];
}
export type NetIpRouteConfigSpecGatewaySpec = DynamicData &  {
  ipAddress?: string;
  device?: string;
}
export type NetIpRouteConfigSpecIpRouteSpec = DynamicData &  {
  network: string;
  prefixLength: number;
  gateway: NetIpRouteConfigSpecGatewaySpec;
  operation: string;
}
export type NetIpStackInfo = DynamicData &  {
  neighbor?: NetIpStackInfoNetToMedia[];
  defaultRouter?: NetIpStackInfoDefaultRouter[];
}
export type NetIpStackInfoDefaultRouter = DynamicData &  {
  ipAddress: string;
  device: string;
  lifetime: Date;
  preference: string;
}
export type NetIpStackInfoNetToMedia = DynamicData &  {
  ipAddress: string;
  physicalAddress: string;
  device: string;
  type: string;
}
export type NetBIOSConfigInfo = DynamicData &  {
  mode: string;
}
export type WinNetBIOSConfigInfo = NetBIOSConfigInfo &  {
  primaryWINS: string;
  secondaryWINS?: string;
}
export type ArrayUpdateSpec = DynamicData &  {
  operation: ArrayUpdateOperation;
  removeKey?: any;
}
export type OptionDef = ElementDescription &  {
  optionType: OptionType;
}
export type OptionType = DynamicData &  {
  valueIsReadonly?: boolean;
}
export type OptionValue = DynamicData &  {
  key: string;
  value?: any;
}
export type StringOption = OptionType &  {
  defaultValue: string;
  validCharacters?: string;
}
export type ApplyProfile = DynamicData &  {
  enabled: boolean;
  policy?: ProfilePolicy[];
  profileTypeName?: string;
  profileVersion?: string;
  property?: ProfileApplyProfileProperty[];
  favorite?: boolean;
  toBeMerged?: boolean;
  toReplaceWith?: boolean;
  toBeDeleted?: boolean;
  copyEnableStatus?: boolean;
  hidden?: boolean;
}
export type ProfileApplyProfileElement = ApplyProfile &  {
  key: string;
}
export type ProfileApplyProfileProperty = DynamicData &  {
  propertyName: string;
  array: boolean;
  profile?: ApplyProfile[];
}
export type ComplianceLocator = DynamicData &  {
  expressionName: string;
  applyPath: ProfilePropertyPath;
}
export type ComplianceProfile = DynamicData &  {
  expression: ProfileExpression[];
  rootExpression: string;
}
export type ComplianceResult = DynamicData &  {
  profile?: Profile;
  complianceStatus: string;
  entity?: ManagedEntity;
  checkTime?: Date;
  failure?: ComplianceFailure[];
}
export type ComplianceFailure = DynamicData &  {
  failureType: string;
  message: LocalizableMessage;
  expressionName?: string;
  failureValues?: ComplianceFailureComplianceFailureValues[];
}
export type ComplianceFailureComplianceFailureValues = DynamicData &  {
  comparisonIdentifier: string;
  profileInstance?: string;
  hostValue?: any;
  profileValue?: any;
}
export type ProfileDeferredPolicyOptionParameter = DynamicData &  {
  inputPath: ProfilePropertyPath;
  parameter?: KeyAnyValue[];
}
export type ProfileExpression = DynamicData &  {
  id: string;
  displayName: string;
  negated: boolean;
}
export type ProfileExpressionMetadata = DynamicData &  {
  expressionId: ExtendedElementDescription;
  parameter?: ProfileParameterMetadata[];
}
export type ProfileParameterMetadata = DynamicData &  {
  id: ExtendedElementDescription;
  type: string;
  optional: boolean;
  defaultValue?: any;
  hidden?: boolean;
  securitySensitive?: boolean;
  readOnly?: boolean;
  parameterRelations?: ProfileParameterMetadataParameterRelationMetadata[];
}
export type ProfileParameterMetadataParameterRelationMetadata = DynamicData &  {
  relationTypes?: string[];
  values?: any[];
  path?: ProfilePropertyPath;
  minCount: number;
  maxCount: number;
}
export type ProfilePolicy = DynamicData &  {
  id: string;
  policyOption: PolicyOption;
}
export type ProfilePolicyMetadata = DynamicData &  {
  id: ExtendedElementDescription;
  possibleOption: ProfilePolicyOptionMetadata[];
}
export type PolicyOption = DynamicData &  {
  id: string;
  parameter?: KeyAnyValue[];
}
export type ProfilePolicyOptionMetadata = DynamicData &  {
  id: ExtendedElementDescription;
  parameter?: ProfileParameterMetadata[];
}
export type ProfileConfigInfo = DynamicData &  {
  name: string;
  annotation?: string;
  enabled: boolean;
}
export type ProfileCreateSpec = DynamicData &  {
  name?: string;
  annotation?: string;
  enabled?: boolean;
}
export type ProfileDescription = DynamicData &  {
  section: ProfileDescriptionSection[];
}
export type ProfileDescriptionSection = DynamicData &  {
  description: ExtendedElementDescription;
  message?: LocalizableMessage[];
}
export type ProfileSerializedCreateSpec = ProfileCreateSpec &  {
  profileConfigString: string;
}
export type ProfileMetadata = DynamicData &  {
  key: string;
  profileTypeName?: string;
  description?: ExtendedDescription;
  sortSpec?: ProfileMetadataProfileSortSpec[];
  profileCategory?: string;
  profileComponent?: string;
  operationMessages?: ProfileMetadataProfileOperationMessage[];
}
export type ProfileMetadataProfileOperationMessage = DynamicData &  {
  operationName: string;
  message: LocalizableMessage;
}
export type ProfileMetadataProfileSortSpec = DynamicData &  {
  policyId: string;
  parameter: string;
}
export type ProfilePropertyPath = DynamicData &  {
  profilePath: string;
  policyId?: string;
  parameterId?: string;
  policyOptionId?: string;
}
export type ProfileProfileStructure = DynamicData &  {
  profileTypeName: string;
  child?: ProfileProfileStructureProperty[];
}
export type ProfileProfileStructureProperty = DynamicData &  {
  propertyName: string;
  array: boolean;
  element: ProfileProfileStructure;
}
export type ProfileSimpleExpression = ProfileExpression &  {
  expressionType: string;
  parameter?: KeyAnyValue[];
}
export type UserInputRequiredParameterMetadata = ProfilePolicyOptionMetadata &  {
  userInputParameter?: ProfileParameterMetadata[];
}
export type ClusterProfileCompleteConfigSpec = ClusterProfileConfigSpec &  {
  complyProfile?: ComplianceProfile;
}
export type ClusterProfileConfigInfo = ProfileConfigInfo &  {
  complyProfile?: ComplianceProfile;
}
export type ClusterProfileConfigServiceCreateSpec = ClusterProfileConfigSpec &  {
  serviceType?: string[];
}
export type ClusterProfileConfigSpec = ClusterProfileCreateSpec &  {
  
}
export type ClusterProfileCreateSpec = ProfileCreateSpec &  {
  
}
export type ActiveDirectoryProfile = ApplyProfile &  {
  
}
export type AnswerFile = DynamicData &  {
  userInput?: ProfileDeferredPolicyOptionParameter[];
  createdTime: Date;
  modifiedTime: Date;
}
export type AnswerFileStatusResult = DynamicData &  {
  checkedTime: Date;
  host: HostSystem;
  status: string;
  error?: AnswerFileStatusError[];
}
export type AnswerFileStatusError = DynamicData &  {
  userInputPath: ProfilePropertyPath;
  errMsg: LocalizableMessage;
}
export type AuthenticationProfile = ApplyProfile &  {
  activeDirectory?: ActiveDirectoryProfile;
}
export type DateTimeProfile = ApplyProfile &  {
  
}
export type DvsProfile = ApplyProfile &  {
  key: string;
  name: string;
  uplink?: PnicUplinkProfile[];
}
export type DvsVNicProfile = ApplyProfile &  {
  key: string;
  ipConfig: IpAddressProfile;
}
export type ProfileExecuteResult = DynamicData &  {
  status: string;
  configSpec?: HostConfigSpec;
  inapplicablePath?: string[];
  requireInput?: ProfileDeferredPolicyOptionParameter[];
  error?: ProfileExecuteError[];
}
export type ProfileExecuteError = DynamicData &  {
  path?: ProfilePropertyPath;
  message: LocalizableMessage;
}
export type FirewallProfile = ApplyProfile &  {
  ruleset?: FirewallProfileRulesetProfile[];
}
export type FirewallProfileRulesetProfile = ApplyProfile &  {
  key: string;
}
export type HostApplyProfile = ApplyProfile &  {
  memory?: HostMemoryProfile;
  storage?: StorageProfile;
  network?: NetworkProfile;
  datetime?: DateTimeProfile;
  firewall?: FirewallProfile;
  security?: SecurityProfile;
  service?: ServiceProfile[];
  option?: OptionProfile[];
  userAccount?: UserProfile[];
  usergroupAccount?: UserGroupProfile[];
  authentication?: AuthenticationProfile;
}
export type HostMemoryProfile = ApplyProfile &  {
  
}
export type HostSpecification = DynamicData &  {
  createdTime: Date;
  lastModified?: Date;
  host: HostSystem;
  subSpecs?: HostSubSpecification[];
  changeID?: string;
}
export type HostSubSpecification = DynamicData &  {
  name: string;
  createdTime: Date;
  data?: number[];
  binaryData?: Buffer;
}
export type IpAddressProfile = ApplyProfile &  {
  
}
export type IpRouteProfile = ApplyProfile &  {
  staticRoute?: StaticRouteProfile[];
}
export type NasStorageProfile = ApplyProfile &  {
  key: string;
}
export type NetworkPolicyProfile = ApplyProfile &  {
  
}
export type NetworkProfile = ApplyProfile &  {
  vswitch?: VirtualSwitchProfile[];
  vmPortGroup?: VmPortGroupProfile[];
  hostPortGroup?: HostPortGroupProfile[];
  serviceConsolePortGroup?: ServiceConsolePortGroupProfile[];
  dnsConfig?: NetworkProfileDnsConfigProfile;
  ipRouteConfig?: IpRouteProfile;
  consoleIpRouteConfig?: IpRouteProfile;
  pnic?: PhysicalNicProfile[];
  dvswitch?: DvsProfile[];
  dvsServiceConsoleNic?: DvsServiceConsoleVNicProfile[];
  dvsHostNic?: DvsHostVNicProfile[];
  nsxHostNic?: NsxHostVNicProfile[];
  netStackInstance?: NetStackInstanceProfile[];
  opaqueSwitch?: OpaqueSwitchProfile;
}
export type NetworkProfileDnsConfigProfile = ApplyProfile &  {
  
}
export type NsxHostVNicProfile = ApplyProfile &  {
  key: string;
  ipConfig: IpAddressProfile;
}
export type OpaqueSwitchProfile = ApplyProfile &  {
  
}
export type OptionProfile = ApplyProfile &  {
  key: string;
}
export type PermissionProfile = ApplyProfile &  {
  key: string;
}
export type PhysicalNicProfile = ApplyProfile &  {
  key: string;
}
export type PnicUplinkProfile = ApplyProfile &  {
  key: string;
}
export type PortGroupProfile = ApplyProfile &  {
  key: string;
  name: string;
  vlan: VlanProfile;
  vswitch: VirtualSwitchSelectionProfile;
  networkPolicy: NetworkPolicyProfile;
}
export type VirtualSwitchSelectionProfile = ApplyProfile &  {
  
}
export type VlanProfile = ApplyProfile &  {
  
}
export type SecurityProfile = ApplyProfile &  {
  permission?: PermissionProfile[];
}
export type ServiceConsolePortGroupProfile = PortGroupProfile &  {
  ipConfig: IpAddressProfile;
}
export type ServiceProfile = ApplyProfile &  {
  key: string;
}
export type StaticRouteProfile = ApplyProfile &  {
  key?: string;
}
export type StorageProfile = ApplyProfile &  {
  nasStorage?: NasStorageProfile[];
}
export type UserGroupProfile = ApplyProfile &  {
  key: string;
}
export type UserProfile = ApplyProfile &  {
  key: string;
}
export type VirtualSwitchProfile = ApplyProfile &  {
  key: string;
  name: string;
  link: LinkProfile;
  numPorts: NumPortsProfile;
  networkPolicy: NetworkPolicyProfile;
}
export type LinkProfile = ApplyProfile &  {
  
}
export type NumPortsProfile = ApplyProfile &  {
  
}
export type VmPortGroupProfile = PortGroupProfile &  {
  
}
export type ScheduledTaskDescription = DynamicData &  {
  action: TypeDescription[];
  schedulerInfo: ScheduledTaskDetail[];
  state: ElementDescription[];
  dayOfWeek: ElementDescription[];
  weekOfMonth: ElementDescription[];
}
export type ScheduledTaskDetail = TypeDescription &  {
  frequency: string;
}
export type ScheduledTaskSpec = DynamicData &  {
  name: string;
  description: string;
  enabled: boolean;
  scheduler: TaskScheduler;
  action: Action;
  notification?: string;
}
export type TaskScheduler = DynamicData &  {
  activeTime?: Date;
  expireTime?: Date;
}
export type ApplyStorageRecommendationResult = DynamicData &  {
  vm?: VirtualMachine;
}
export type StorageDrsAutomationConfig = DynamicData &  {
  spaceLoadBalanceAutomationMode?: string;
  ioLoadBalanceAutomationMode?: string;
  ruleEnforcementAutomationMode?: string;
  policyEnforcementAutomationMode?: string;
  vmEvacuationAutomationMode?: string;
}
export type StorageDrsConfigInfo = DynamicData &  {
  podConfig: StorageDrsPodConfigInfo;
  vmConfig?: StorageDrsVmConfigInfo[];
}
export type StorageDrsConfigSpec = DynamicData &  {
  podConfigSpec?: StorageDrsPodConfigSpec;
  vmConfigSpec?: StorageDrsVmConfigSpec[];
}
export type HbrDiskMigrationAction = ClusterAction &  {
  collectionId: string;
  collectionName: string;
  diskIds: string[];
  source: Datastore;
  destination: Datastore;
  sizeTransferred: number;
  spaceUtilSrcBefore?: number;
  spaceUtilDstBefore?: number;
  spaceUtilSrcAfter?: number;
  spaceUtilDstAfter?: number;
  ioLatencySrcBefore?: number;
  ioLatencyDstBefore?: number;
}
export type StorageDrsIoLoadBalanceConfig = DynamicData &  {
  reservablePercentThreshold?: number;
  reservableIopsThreshold?: number;
  reservableThresholdMode?: string;
  ioLatencyThreshold?: number;
  ioLoadImbalanceThreshold?: number;
}
export type StorageDrsOptionSpec = ArrayUpdateSpec &  {
  option?: OptionValue;
}
export type PlacementAffinityRule = DynamicData &  {
  ruleType: string;
  ruleScope: string;
  vms?: VirtualMachine[];
  keys?: string[];
}
export type PlacementRankResult = DynamicData &  {
  key: string;
  candidate: ClusterComputeResource;
  reservedSpaceMB: number;
  usedSpaceMB: number;
  totalSpaceMB: number;
  utilization: number;
  faults?: MethodFault[];
}
export type PlacementRankSpec = DynamicData &  {
  specs: PlacementSpec[];
  clusters: ClusterComputeResource[];
  rules?: PlacementAffinityRule[];
  placementRankByVm?: StorageDrsPlacementRankVmSpec[];
}
export type StorageDrsPlacementRankVmSpec = DynamicData &  {
  vmPlacementSpec: PlacementSpec;
  vmClusters: ClusterComputeResource[];
}
export type StorageDrsPodConfigInfo = DynamicData &  {
  enabled: boolean;
  ioLoadBalanceEnabled: boolean;
  defaultVmBehavior: string;
  loadBalanceInterval?: number;
  defaultIntraVmAffinity?: boolean;
  spaceLoadBalanceConfig?: StorageDrsSpaceLoadBalanceConfig;
  ioLoadBalanceConfig?: StorageDrsIoLoadBalanceConfig;
  automationOverrides?: StorageDrsAutomationConfig;
  rule?: ClusterRuleInfo[];
  option?: OptionValue[];
}
export type StorageDrsPodConfigSpec = DynamicData &  {
  enabled?: boolean;
  ioLoadBalanceEnabled?: boolean;
  defaultVmBehavior?: string;
  loadBalanceInterval?: number;
  defaultIntraVmAffinity?: boolean;
  spaceLoadBalanceConfig?: StorageDrsSpaceLoadBalanceConfig;
  ioLoadBalanceConfig?: StorageDrsIoLoadBalanceConfig;
  automationOverrides?: StorageDrsAutomationConfig;
  rule?: ClusterRuleSpec[];
  option?: StorageDrsOptionSpec[];
}
export type StorageDrsSpaceLoadBalanceConfig = DynamicData &  {
  spaceThresholdMode?: string;
  spaceUtilizationThreshold?: number;
  freeSpaceThresholdGB?: number;
  minSpaceUtilizationDifference?: number;
}
export type StorageMigrationAction = ClusterAction &  {
  vm: VirtualMachine;
  relocateSpec: VirtualMachineRelocateSpec;
  source: Datastore;
  destination: Datastore;
  sizeTransferred: number;
  spaceUtilSrcBefore?: number;
  spaceUtilDstBefore?: number;
  spaceUtilSrcAfter?: number;
  spaceUtilDstAfter?: number;
  ioLatencySrcBefore?: number;
  ioLatencyDstBefore?: number;
}
export type StoragePlacementAction = ClusterAction &  {
  vm?: VirtualMachine;
  relocateSpec: VirtualMachineRelocateSpec;
  destination: Datastore;
  spaceUtilBefore?: number;
  spaceDemandBefore?: number;
  spaceUtilAfter?: number;
  spaceDemandAfter?: number;
  ioLatencyBefore?: number;
}
export type StoragePlacementResult = DynamicData &  {
  recommendations?: ClusterRecommendation[];
  drsFault?: ClusterDrsFaults;
  task?: Task;
}
export type StorageDrsVmConfigInfo = DynamicData &  {
  vm?: VirtualMachine;
  enabled?: boolean;
  behavior?: string;
  intraVmAffinity?: boolean;
  intraVmAntiAffinity?: VirtualDiskAntiAffinityRuleSpec;
  virtualDiskRules?: VirtualDiskRuleSpec[];
}
export type StorageDrsVmConfigSpec = ArrayUpdateSpec &  {
  info?: StorageDrsVmConfigInfo;
}
export type VAppCloneSpec = DynamicData &  {
  location: Datastore;
  host?: HostSystem;
  resourceSpec?: ResourceConfigSpec;
  vmFolder?: Folder;
  networkMapping?: VAppCloneSpecNetworkMappingPair[];
  property?: KeyValue[];
  resourceMapping?: VAppCloneSpecResourceMap[];
  provisioning?: string;
}
export type VAppCloneSpecNetworkMappingPair = DynamicData &  {
  source: Network;
  destination: Network;
}
export type VAppCloneSpecResourceMap = DynamicData &  {
  source: ManagedEntity;
  parent?: ResourcePool;
  resourceSpec?: ResourceConfigSpec;
  location?: Datastore;
}
export type VAppEntityConfigInfo = DynamicData &  {
  key?: ManagedEntity;
  tag?: string;
  startOrder?: number;
  startDelay?: number;
  waitingForGuest?: boolean;
  startAction?: string;
  stopDelay?: number;
  stopAction?: string;
  destroyWithParent?: boolean;
}
export type VAppIPAssignmentInfo = DynamicData &  {
  supportedAllocationScheme?: string[];
  ipAllocationPolicy?: string;
  supportedIpProtocol?: string[];
  ipProtocol?: string;
}
export type IpPool = DynamicData &  {
  id?: number;
  name?: string;
  ipv4Config?: IpPoolIpPoolConfigInfo;
  ipv6Config?: IpPoolIpPoolConfigInfo;
  dnsDomain?: string;
  dnsSearchPath?: string;
  hostPrefix?: string;
  httpProxy?: string;
  networkAssociation?: IpPoolAssociation[];
  availableIpv4Addresses?: number;
  availableIpv6Addresses?: number;
  allocatedIpv4Addresses?: number;
  allocatedIpv6Addresses?: number;
}
export type IpPoolAssociation = DynamicData &  {
  network?: Network;
  networkName: string;
}
export type IpPoolIpPoolConfigInfo = DynamicData &  {
  subnetAddress?: string;
  netmask?: string;
  gateway?: string;
  range?: string;
  dns?: string[];
  dhcpServerAvailable?: boolean;
  ipPoolEnabled?: boolean;
}
export type VAppOvfSectionInfo = DynamicData &  {
  key?: number;
  namespace?: string;
  type?: string;
  atEnvelopeLevel?: boolean;
  contents?: string;
}
export type VAppOvfSectionSpec = ArrayUpdateSpec &  {
  info?: VAppOvfSectionInfo;
}
export type VAppProductInfo = DynamicData &  {
  key: number;
  classId?: string;
  instanceId?: string;
  name?: string;
  vendor?: string;
  version?: string;
  fullVersion?: string;
  vendorUrl?: string;
  productUrl?: string;
  appUrl?: string;
}
export type VAppProductSpec = ArrayUpdateSpec &  {
  info?: VAppProductInfo;
}
export type VAppPropertyInfo = DynamicData &  {
  key: number;
  classId?: string;
  instanceId?: string;
  id?: string;
  category?: string;
  label?: string;
  type?: string;
  typeReference?: string;
  userConfigurable?: boolean;
  defaultValue?: string;
  value?: string;
  description?: string;
}
export type VAppPropertySpec = ArrayUpdateSpec &  {
  info?: VAppPropertyInfo;
}
export type VmConfigInfo = DynamicData &  {
  product?: VAppProductInfo[];
  property?: VAppPropertyInfo[];
  ipAssignment: VAppIPAssignmentInfo;
  eula?: string[];
  ovfSection?: VAppOvfSectionInfo[];
  ovfEnvironmentTransport?: string[];
  installBootRequired: boolean;
  installBootStopDelay: number;
}
export type VmConfigSpec = DynamicData &  {
  product?: VAppProductSpec[];
  property?: VAppPropertySpec[];
  ipAssignment?: VAppIPAssignmentInfo;
  eula?: string[];
  ovfSection?: VAppOvfSectionSpec[];
  ovfEnvironmentTransport?: string[];
  installBootRequired?: boolean;
  installBootStopDelay?: number;
}
export type ClusterNetworkConfigSpec = DynamicData &  {
  networkPortGroup: Network;
  ipSettings: CustomizationIPSettings;
}
export type FailoverNodeInfo = DynamicData &  {
  clusterIpSettings: CustomizationIPSettings;
  failoverIp?: CustomizationIPSettings;
  biosUuid?: string;
}
export type NodeDeploymentSpec = DynamicData &  {
  esxHost?: HostSystem;
  datastore?: Datastore;
  publicNetworkPortGroup?: Network;
  clusterNetworkPortGroup?: Network;
  folder: Folder;
  resourcePool?: ResourcePool;
  managementVc?: ServiceLocator;
  nodeName: string;
  ipSettings: CustomizationIPSettings;
}
export type NodeNetworkSpec = DynamicData &  {
  ipSettings: CustomizationIPSettings;
}
export type PassiveNodeDeploymentSpec = NodeDeploymentSpec &  {
  failoverIpSettings?: CustomizationIPSettings;
}
export type PassiveNodeNetworkSpec = NodeNetworkSpec &  {
  failoverIpSettings?: CustomizationIPSettings;
}
export type SourceNodeSpec = DynamicData &  {
  managementVc: ServiceLocator;
  activeVc: VirtualMachine;
}
export type VchaClusterConfigInfo = DynamicData &  {
  failoverNodeInfo1?: FailoverNodeInfo;
  failoverNodeInfo2?: FailoverNodeInfo;
  witnessNodeInfo?: WitnessNodeInfo;
  state: string;
}
export type VchaClusterConfigSpec = DynamicData &  {
  passiveIp: string;
  witnessIp: string;
}
export type VchaClusterDeploymentSpec = DynamicData &  {
  passiveDeploymentSpec: PassiveNodeDeploymentSpec;
  witnessDeploymentSpec: NodeDeploymentSpec;
  activeVcSpec: SourceNodeSpec;
  activeVcNetworkConfig?: ClusterNetworkConfigSpec;
}
export type VchaClusterNetworkSpec = DynamicData &  {
  witnessNetworkSpec: NodeNetworkSpec;
  passiveNetworkSpec: PassiveNodeNetworkSpec;
}
export type WitnessNodeInfo = DynamicData &  {
  ipSettings: CustomizationIPSettings;
  biosUuid?: string;
}
export type VchaClusterHealth = DynamicData &  {
  runtimeInfo: VchaClusterRuntimeInfo;
  healthMessages?: LocalizableMessage[];
  additionalInformation?: LocalizableMessage[];
}
export type VchaClusterRuntimeInfo = DynamicData &  {
  clusterState: string;
  nodeInfo?: VchaNodeRuntimeInfo[];
  clusterMode: string;
}
export type VchaNodeRuntimeInfo = DynamicData &  {
  nodeState: string;
  nodeRole: string;
  nodeIp: string;
}
export type VirtualMachineAffinityInfo = DynamicData &  {
  affinitySet?: number[];
}
export type VirtualMachineBootOptions = DynamicData &  {
  bootDelay?: number;
  enterBIOSSetup?: boolean;
  efiSecureBootEnabled?: boolean;
  bootRetryEnabled?: boolean;
  bootRetryDelay?: number;
  bootOrder?: VirtualMachineBootOptionsBootableDevice[];
  networkBootProtocol?: string;
}
export type VirtualMachineBootOptionsBootableCdromDevice = VirtualMachineBootOptionsBootableDevice &  {
  
}
export type VirtualMachineBootOptionsBootableDevice = DynamicData &  {
  
}
export type VirtualMachineBootOptionsBootableDiskDevice = VirtualMachineBootOptionsBootableDevice &  {
  deviceKey: number;
}
export type VirtualMachineBootOptionsBootableEthernetDevice = VirtualMachineBootOptionsBootableDevice &  {
  deviceKey: number;
}
export type VirtualMachineBootOptionsBootableFloppyDevice = VirtualMachineBootOptionsBootableDevice &  {
  
}
export type VirtualMachineCapability = DynamicData &  {
  snapshotOperationsSupported: boolean;
  multipleSnapshotsSupported: boolean;
  snapshotConfigSupported: boolean;
  poweredOffSnapshotsSupported: boolean;
  memorySnapshotsSupported: boolean;
  revertToSnapshotSupported: boolean;
  quiescedSnapshotsSupported: boolean;
  disableSnapshotsSupported: boolean;
  lockSnapshotsSupported: boolean;
  consolePreferencesSupported: boolean;
  cpuFeatureMaskSupported: boolean;
  s1AcpiManagementSupported: boolean;
  settingScreenResolutionSupported: boolean;
  toolsAutoUpdateSupported: boolean;
  vmNpivWwnSupported: boolean;
  npivWwnOnNonRdmVmSupported: boolean;
  vmNpivWwnDisableSupported: boolean;
  vmNpivWwnUpdateSupported: boolean;
  swapPlacementSupported: boolean;
  toolsSyncTimeSupported: boolean;
  virtualMmuUsageSupported: boolean;
  diskSharesSupported: boolean;
  bootOptionsSupported: boolean;
  bootRetryOptionsSupported: boolean;
  settingVideoRamSizeSupported: boolean;
  settingDisplayTopologySupported: boolean;
  recordReplaySupported: boolean;
  changeTrackingSupported: boolean;
  multipleCoresPerSocketSupported: boolean;
  hostBasedReplicationSupported: boolean;
  guestAutoLockSupported: boolean;
  memoryReservationLockSupported: boolean;
  featureRequirementSupported: boolean;
  poweredOnMonitorTypeChangeSupported: boolean;
  seSparseDiskSupported: boolean;
  nestedHVSupported: boolean;
  vPMCSupported: boolean;
  secureBootSupported?: boolean;
  perVmEvcSupported?: boolean;
  virtualMmuUsageIgnored?: boolean;
  virtualExecUsageIgnored?: boolean;
  diskOnlySnapshotOnSuspendedVMSupported?: boolean;
  toolsSyncTimeAllowSupported?: boolean;
  sevSupported?: boolean;
}
export type VirtualMachineCloneSpec = DynamicData &  {
  location: VirtualMachineRelocateSpec;
  template: boolean;
  config?: VirtualMachineConfigSpec;
  customization?: CustomizationSpec;
  powerOn: boolean;
  snapshot?: VirtualMachineSnapshot;
  memory?: boolean;
}
export type VirtualMachineConfigInfo = DynamicData &  {
  changeVersion: string;
  modified: Date;
  name: string;
  guestFullName: string;
  version: string;
  uuid: string;
  createDate?: Date;
  instanceUuid?: string;
  npivNodeWorldWideName?: number[];
  npivPortWorldWideName?: number[];
  npivWorldWideNameType?: string;
  npivDesiredNodeWwns?: number;
  npivDesiredPortWwns?: number;
  npivTemporaryDisabled?: boolean;
  npivOnNonRdmDisks?: boolean;
  locationId?: string;
  template: boolean;
  guestId: string;
  alternateGuestName: string;
  annotation?: string;
  files: VirtualMachineFileInfo;
  tools?: ToolsConfigInfo;
  flags: VirtualMachineFlagInfo;
  consolePreferences?: VirtualMachineConsolePreferences;
  defaultPowerOps: VirtualMachineDefaultPowerOpInfo;
  hardware: VirtualHardware;
  vcpuConfig?: VirtualMachineVcpuConfig[];
  cpuAllocation?: ResourceAllocationInfo;
  memoryAllocation?: ResourceAllocationInfo;
  latencySensitivity?: LatencySensitivity;
  memoryHotAddEnabled?: boolean;
  cpuHotAddEnabled?: boolean;
  cpuHotRemoveEnabled?: boolean;
  hotPlugMemoryLimit?: number;
  hotPlugMemoryIncrementSize?: number;
  cpuAffinity?: VirtualMachineAffinityInfo;
  memoryAffinity?: VirtualMachineAffinityInfo;
  networkShaper?: VirtualMachineNetworkShaperInfo;
  extraConfig?: OptionValue[];
  cpuFeatureMask?: HostCpuIdInfo[];
  datastoreUrl?: VirtualMachineConfigInfoDatastoreUrlPair[];
  swapPlacement?: string;
  bootOptions?: VirtualMachineBootOptions;
  ftInfo?: FaultToleranceConfigInfo;
  repConfig?: ReplicationConfigSpec;
  vAppConfig?: VmConfigInfo;
  vAssertsEnabled?: boolean;
  changeTrackingEnabled?: boolean;
  firmware?: string;
  maxMksConnections?: number;
  guestAutoLockEnabled?: boolean;
  managedBy?: ManagedByInfo;
  memoryReservationLockedToMax?: boolean;
  initialOverhead?: VirtualMachineConfigInfoOverheadInfo;
  nestedHVEnabled?: boolean;
  vPMCEnabled?: boolean;
  scheduledHardwareUpgradeInfo?: ScheduledHardwareUpgradeInfo;
  forkConfigInfo?: VirtualMachineForkConfigInfo;
  vFlashCacheReservation?: number;
  vmxConfigChecksum?: Buffer;
  messageBusTunnelEnabled?: boolean;
  vmStorageObjectId?: string;
  swapStorageObjectId?: string;
  keyId?: CryptoKeyId;
  guestIntegrityInfo?: VirtualMachineGuestIntegrityInfo;
  migrateEncryption?: string;
  sgxInfo?: VirtualMachineSgxInfo;
  contentLibItemInfo?: VirtualMachineContentLibraryItemInfo;
  guestMonitoringModeInfo?: VirtualMachineGuestMonitoringModeInfo;
  sevEnabled?: boolean;
}
export type VirtualMachineConfigInfoDatastoreUrlPair = DynamicData &  {
  name: string;
  url: string;
}
export type VirtualMachineConfigInfoOverheadInfo = DynamicData &  {
  initialMemoryReservation?: number;
  initialSwapReservation?: number;
}
export type VirtualMachineConfigOption = DynamicData &  {
  version: string;
  description: string;
  guestOSDescriptor: GuestOsDescriptor[];
  guestOSDefaultIndex: number;
  hardwareOptions: VirtualHardwareOption;
  capabilities: VirtualMachineCapability;
  datastore: DatastoreOption;
  defaultDevice?: VirtualDevice[];
  supportedMonitorType: string[];
  supportedOvfEnvironmentTransport?: string[];
  supportedOvfInstallTransport?: string[];
  propertyRelations?: VirtualMachinePropertyRelation[];
}
export type VirtualMachineConfigOptionDescriptor = DynamicData &  {
  key: string;
  description?: string;
  host?: HostSystem[];
  createSupported: boolean;
  defaultConfigOption: boolean;
  runSupported: boolean;
  upgradeSupported: boolean;
}
export type VirtualMachineConfigSpec = DynamicData &  {
  changeVersion?: string;
  name?: string;
  version?: string;
  createDate?: Date;
  uuid?: string;
  instanceUuid?: string;
  npivNodeWorldWideName?: number[];
  npivPortWorldWideName?: number[];
  npivWorldWideNameType?: string;
  npivDesiredNodeWwns?: number;
  npivDesiredPortWwns?: number;
  npivTemporaryDisabled?: boolean;
  npivOnNonRdmDisks?: boolean;
  npivWorldWideNameOp?: string;
  locationId?: string;
  guestId?: string;
  alternateGuestName?: string;
  annotation?: string;
  files?: VirtualMachineFileInfo;
  tools?: ToolsConfigInfo;
  flags?: VirtualMachineFlagInfo;
  consolePreferences?: VirtualMachineConsolePreferences;
  powerOpInfo?: VirtualMachineDefaultPowerOpInfo;
  numCPUs?: number;
  vcpuConfig?: VirtualMachineVcpuConfig[];
  numCoresPerSocket?: number;
  memoryMB?: number;
  memoryHotAddEnabled?: boolean;
  cpuHotAddEnabled?: boolean;
  cpuHotRemoveEnabled?: boolean;
  virtualICH7MPresent?: boolean;
  virtualSMCPresent?: boolean;
  deviceChange?: VirtualDeviceConfigSpec[];
  cpuAllocation?: ResourceAllocationInfo;
  memoryAllocation?: ResourceAllocationInfo;
  latencySensitivity?: LatencySensitivity;
  cpuAffinity?: VirtualMachineAffinityInfo;
  memoryAffinity?: VirtualMachineAffinityInfo;
  networkShaper?: VirtualMachineNetworkShaperInfo;
  cpuFeatureMask?: VirtualMachineCpuIdInfoSpec[];
  extraConfig?: OptionValue[];
  swapPlacement?: string;
  bootOptions?: VirtualMachineBootOptions;
  vAppConfig?: VmConfigSpec;
  ftInfo?: FaultToleranceConfigInfo;
  repConfig?: ReplicationConfigSpec;
  vAppConfigRemoved?: boolean;
  vAssertsEnabled?: boolean;
  changeTrackingEnabled?: boolean;
  firmware?: string;
  maxMksConnections?: number;
  guestAutoLockEnabled?: boolean;
  managedBy?: ManagedByInfo;
  memoryReservationLockedToMax?: boolean;
  nestedHVEnabled?: boolean;
  vPMCEnabled?: boolean;
  scheduledHardwareUpgradeInfo?: ScheduledHardwareUpgradeInfo;
  vmProfile?: VirtualMachineProfileSpec[];
  messageBusTunnelEnabled?: boolean;
  crypto?: CryptoSpec;
  migrateEncryption?: string;
  sgxInfo?: VirtualMachineSgxInfo;
  guestMonitoringModeInfo?: VirtualMachineGuestMonitoringModeInfo;
  sevEnabled?: boolean;
}
export type VirtualMachineCpuIdInfoSpec = ArrayUpdateSpec &  {
  info?: HostCpuIdInfo;
}
export type VirtualMachineConsolePreferences = DynamicData &  {
  powerOnWhenOpened?: boolean;
  enterFullScreenOnPowerOn?: boolean;
  closeOnPowerOffOrSuspend?: boolean;
}
export type VirtualMachineContentLibraryItemInfo = DynamicData &  {
  contentLibraryItemUuid: string;
  contentLibraryItemVersion?: string;
}
export type DatastoreOption = DynamicData &  {
  unsupportedVolumes?: VirtualMachineDatastoreVolumeOption[];
}
export type VirtualMachineDatastoreVolumeOption = DynamicData &  {
  fileSystemType: string;
  majorVersion?: number;
}
export type VirtualMachineDefaultPowerOpInfo = DynamicData &  {
  powerOffType?: string;
  suspendType?: string;
  resetType?: string;
  defaultPowerOffType?: string;
  defaultSuspendType?: string;
  defaultResetType?: string;
  standbyAction?: string;
}
export type VirtualMachineDeviceRuntimeInfo = DynamicData &  {
  runtimeState: VirtualMachineDeviceRuntimeInfoDeviceRuntimeState;
  key: number;
}
export type VirtualMachineDeviceRuntimeInfoDeviceRuntimeState = DynamicData &  {
  
}
export type VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeState = VirtualMachineDeviceRuntimeInfoDeviceRuntimeState &  {
  vmDirectPathGen2Active: boolean;
  vmDirectPathGen2InactiveReasonVm?: string[];
  vmDirectPathGen2InactiveReasonOther?: string[];
  vmDirectPathGen2InactiveReasonExtended?: string;
  reservationStatus?: string;
  attachmentStatus?: string;
  featureRequirement?: VirtualMachineFeatureRequirement[];
}
export type FaultToleranceConfigInfo = DynamicData &  {
  role: number;
  instanceUuids: string[];
  configPaths: string[];
  orphaned?: boolean;
}
export type FaultToleranceConfigSpec = DynamicData &  {
  metaDataPath?: FaultToleranceMetaSpec;
  secondaryVmSpec?: FaultToleranceVMConfigSpec;
}
export type FaultToleranceMetaSpec = DynamicData &  {
  metaDataDatastore: Datastore;
}
export type FaultTolerancePrimaryConfigInfo = FaultToleranceConfigInfo &  {
  secondaries: VirtualMachine[];
}
export type FaultToleranceSecondaryConfigInfo = FaultToleranceConfigInfo &  {
  primaryVM: VirtualMachine;
}
export type FaultToleranceSecondaryOpResult = DynamicData &  {
  vm: VirtualMachine;
  powerOnAttempted: boolean;
  powerOnResult?: ClusterPowerOnVmResult;
}
export type FaultToleranceVMConfigSpec = DynamicData &  {
  vmConfig?: Datastore;
  disks?: FaultToleranceDiskSpec[];
}
export type FaultToleranceDiskSpec = DynamicData &  {
  disk: VirtualDevice;
  datastore: Datastore;
}
export type VirtualMachineFeatureRequirement = DynamicData &  {
  key: string;
  featureName: string;
  value: string;
}
export type VirtualMachineFileInfo = DynamicData &  {
  vmPathName?: string;
  snapshotDirectory?: string;
  suspendDirectory?: string;
  logDirectory?: string;
  ftMetadataDirectory?: string;
}
export type VirtualMachineFileLayout = DynamicData &  {
  configFile?: string[];
  logFile?: string[];
  disk?: VirtualMachineFileLayoutDiskLayout[];
  snapshot?: VirtualMachineFileLayoutSnapshotLayout[];
  swapFile?: string;
}
export type VirtualMachineFileLayoutDiskLayout = DynamicData &  {
  key: number;
  diskFile: string[];
}
export type VirtualMachineFileLayoutSnapshotLayout = DynamicData &  {
  key: VirtualMachineSnapshot;
  snapshotFile: string[];
}
export type VirtualMachineFileLayoutEx = DynamicData &  {
  file?: VirtualMachineFileLayoutExFileInfo[];
  disk?: VirtualMachineFileLayoutExDiskLayout[];
  snapshot?: VirtualMachineFileLayoutExSnapshotLayout[];
  timestamp: Date;
}
export type VirtualMachineFileLayoutExDiskLayout = DynamicData &  {
  key: number;
  chain?: VirtualMachineFileLayoutExDiskUnit[];
}
export type VirtualMachineFileLayoutExDiskUnit = DynamicData &  {
  fileKey: number[];
}
export type VirtualMachineFileLayoutExFileInfo = DynamicData &  {
  key: number;
  name: string;
  type: string;
  size: number;
  uniqueSize?: number;
  backingObjectId?: string;
  accessible?: boolean;
}
export type VirtualMachineFileLayoutExSnapshotLayout = DynamicData &  {
  key: VirtualMachineSnapshot;
  dataKey: number;
  memoryKey: number;
  disk?: VirtualMachineFileLayoutExDiskLayout[];
}
export type VirtualMachineFlagInfo = DynamicData &  {
  disableAcceleration?: boolean;
  enableLogging?: boolean;
  useToe?: boolean;
  runWithDebugInfo?: boolean;
  monitorType?: string;
  htSharing?: string;
  snapshotDisabled?: boolean;
  snapshotLocked?: boolean;
  diskUuidEnabled?: boolean;
  virtualMmuUsage?: string;
  virtualExecUsage?: string;
  snapshotPowerOffBehavior?: string;
  recordReplayEnabled?: boolean;
  faultToleranceType?: string;
  cbrcCacheEnabled?: boolean;
  vvtdEnabled?: boolean;
  vbsEnabled?: boolean;
}
export type VirtualMachineForkConfigInfo = DynamicData &  {
  parentEnabled?: boolean;
  childForkGroupId?: string;
  parentForkGroupId?: string;
  childType?: string;
}
export type GuestInfo = DynamicData &  {
  toolsStatus?: VirtualMachineToolsStatus;
  toolsVersionStatus?: string;
  toolsVersionStatus2?: string;
  toolsRunningStatus?: string;
  toolsVersion?: string;
  toolsInstallType?: string;
  guestId?: string;
  guestFamily?: string;
  guestFullName?: string;
  hostName?: string;
  ipAddress?: string;
  net?: GuestNicInfo[];
  ipStack?: GuestStackInfo[];
  disk?: GuestDiskInfo[];
  screen?: GuestScreenInfo;
  guestState: string;
  appHeartbeatStatus?: string;
  guestKernelCrashed?: boolean;
  appState?: string;
  guestOperationsReady?: boolean;
  interactiveGuestOperationsReady?: boolean;
  guestStateChangeSupported?: boolean;
  generationInfo?: GuestInfoNamespaceGenerationInfo[];
  hwVersion?: string;
}
export type GuestDiskInfo = DynamicData &  {
  diskPath?: string;
  capacity?: number;
  freeSpace?: number;
  filesystemType?: string;
  mappings?: GuestInfoVirtualDiskMapping[];
}
export type GuestInfoNamespaceGenerationInfo = DynamicData &  {
  key: string;
  generationNo: number;
}
export type GuestNicInfo = DynamicData &  {
  network?: string;
  ipAddress?: string[];
  macAddress?: string;
  connected: boolean;
  deviceConfigId: number;
  dnsConfig?: NetDnsConfigInfo;
  ipConfig?: NetIpConfigInfo;
  netBIOSConfig?: NetBIOSConfigInfo;
}
export type GuestScreenInfo = DynamicData &  {
  width: number;
  height: number;
}
export type GuestStackInfo = DynamicData &  {
  dnsConfig?: NetDnsConfigInfo;
  ipRouteConfig?: NetIpRouteConfigInfo;
  ipStackConfig?: KeyValue[];
  dhcpConfig?: NetDhcpConfigInfo;
}
export type GuestInfoVirtualDiskMapping = DynamicData &  {
  key: number;
}
export type VirtualMachineGuestIntegrityInfo = DynamicData &  {
  enabled?: boolean;
}
export type VirtualMachineGuestMonitoringModeInfo = DynamicData &  {
  gmmFile?: string;
  gmmAppliance?: string;
}
export type GuestOsDescriptor = DynamicData &  {
  id: string;
  family: string;
  fullName: string;
  supportedMaxCPUs: number;
  numSupportedPhysicalSockets: number;
  numSupportedCoresPerSocket: number;
  supportedMinMemMB: number;
  supportedMaxMemMB: number;
  recommendedMemMB: number;
  recommendedColorDepth: number;
  supportedDiskControllerList: string[];
  recommendedSCSIController?: string;
  recommendedDiskController: string;
  supportedNumDisks: number;
  recommendedDiskSizeMB: number;
  recommendedCdromController: string;
  supportedEthernetCard: string[];
  recommendedEthernetCard?: string;
  supportsSlaveDisk?: boolean;
  cpuFeatureMask?: HostCpuIdInfo[];
  smcRequired: boolean;
  supportsWakeOnLan: boolean;
  supportsVMI: boolean;
  supportsMemoryHotAdd: boolean;
  supportsCpuHotAdd: boolean;
  supportsCpuHotRemove: boolean;
  supportedFirmware: string[];
  recommendedFirmware: string;
  supportedUSBControllerList?: string[];
  recommendedUSBController?: string;
  supports3D: boolean;
  recommended3D: boolean;
  smcRecommended: boolean;
  ich7mRecommended: boolean;
  usbRecommended: boolean;
  supportLevel: string;
  supportedForCreate: boolean;
  vRAMSizeInKB: IntOption;
  numSupportedFloppyDevices: number;
  wakeOnLanEthernetCard?: string[];
  supportsPvscsiControllerForBoot: boolean;
  diskUuidEnabled: boolean;
  supportsHotPlugPCI: boolean;
  supportsSecureBoot?: boolean;
  defaultSecureBoot?: boolean;
  persistentMemorySupported?: boolean;
  supportedMinPersistentMemoryMB?: number;
  supportedMaxPersistentMemoryMB?: number;
  recommendedPersistentMemoryMB?: number;
  persistentMemoryHotAddSupported?: boolean;
  persistentMemoryHotRemoveSupported?: boolean;
  persistentMemoryColdGrowthSupported?: boolean;
  persistentMemoryColdGrowthGranularityMB?: number;
  persistentMemoryHotGrowthSupported?: boolean;
  persistentMemoryHotGrowthGranularityMB?: number;
  numRecommendedPhysicalSockets?: number;
  numRecommendedCoresPerSocket?: number;
  vvtdSupported?: BoolOption;
  vbsSupported?: BoolOption;
  vsgxSupported?: BoolOption;
  supportsTPM20?: boolean;
  vwdtSupported?: boolean;
}
export type VirtualMachineGuestQuiesceSpec = DynamicData &  {
  timeout?: number;
}
export type VirtualMachineInstantCloneSpec = DynamicData &  {
  name: string;
  location: VirtualMachineRelocateSpec;
  config?: OptionValue[];
  biosUuid?: string;
}
export type VirtualMachineLegacyNetworkSwitchInfo = DynamicData &  {
  name: string;
}
export type VirtualMachineMessage = DynamicData &  {
  id: string;
  argument?: any[];
  text?: string;
}
export type VirtualMachineMetadataManagerVmMetadata = DynamicData &  {
  vmId: string;
  metadata?: string;
}
export type VirtualMachineMetadataManagerVmMetadataInput = DynamicData &  {
  operation: string;
  vmMetadata: VirtualMachineMetadataManagerVmMetadata;
}
export type VirtualMachineMetadataManagerVmMetadataOwner = DynamicData &  {
  name: string;
}
export type VirtualMachineMetadataManagerVmMetadataResult = DynamicData &  {
  vmMetadata: VirtualMachineMetadataManagerVmMetadata;
  error?: MethodFault;
}
export type VirtualMachineNetworkShaperInfo = DynamicData &  {
  enabled?: boolean;
  peakBps?: number;
  averageBps?: number;
  burstSize?: number;
}
export type VirtualMachineProfileDetails = DynamicData &  {
  profile?: VirtualMachineProfileSpec[];
  diskProfileDetails?: VirtualMachineProfileDetailsDiskProfileDetails[];
}
export type VirtualMachineProfileDetailsDiskProfileDetails = DynamicData &  {
  diskId: number;
  profile?: VirtualMachineProfileSpec[];
}
export type VirtualMachineProfileRawData = DynamicData &  {
  extensionKey: string;
  objectData?: string;
}
export type VirtualMachineProfileSpec = DynamicData &  {
  
}
export type VirtualMachinePropertyRelation = DynamicData &  {
  key: DynamicProperty;
  relations?: DynamicProperty[];
}
export type VirtualMachineQuestionInfo = DynamicData &  {
  id: string;
  text: string;
  choice: ChoiceOption;
  message?: VirtualMachineMessage[];
}
export type ReplicationConfigSpec = DynamicData &  {
  generation: number;
  vmReplicationId: string;
  destination: string;
  port: number;
  rpo: number;
  quiesceGuestEnabled: boolean;
  paused: boolean;
  oppUpdatesEnabled: boolean;
  netCompressionEnabled?: boolean;
  netEncryptionEnabled?: boolean;
  encryptionDestination?: string;
  encryptionPort?: number;
  remoteCertificateThumbprint?: string;
  disk?: ReplicationInfoDiskSettings[];
}
export type ReplicationInfoDiskSettings = DynamicData &  {
  key: number;
  diskReplicationId: string;
}
export type ScheduledHardwareUpgradeInfo = DynamicData &  {
  upgradePolicy?: string;
  versionKey?: string;
  scheduledHardwareUpgradeStatus?: string;
  fault?: MethodFault;
}
export type VirtualMachineSgxInfo = DynamicData &  {
  epcSize: number;
  flcMode?: string;
  lePubKeyHash?: string;
}
export type VirtualMachineSnapshotInfo = DynamicData &  {
  currentSnapshot?: VirtualMachineSnapshot;
  rootSnapshotList: VirtualMachineSnapshotTree[];
}
export type VirtualMachineSriovDevicePoolInfo = DynamicData &  {
  key: string;
}
export type VirtualMachineSriovNetworkDevicePoolInfo = VirtualMachineSriovDevicePoolInfo &  {
  switchKey?: string;
  switchUuid?: string;
}
export type VirtualMachineStorageInfo = DynamicData &  {
  perDatastoreUsage?: VirtualMachineUsageOnDatastore[];
  timestamp: Date;
}
export type VirtualMachineUsageOnDatastore = DynamicData &  {
  datastore: Datastore;
  committed: number;
  uncommitted: number;
  unshared: number;
}
export type VirtualMachineTargetInfo = DynamicData &  {
  name: string;
  configurationTag?: string[];
}
export type ToolsConfigInfo = DynamicData &  {
  toolsVersion?: number;
  toolsInstallType?: string;
  afterPowerOn?: boolean;
  afterResume?: boolean;
  beforeGuestStandby?: boolean;
  beforeGuestShutdown?: boolean;
  beforeGuestReboot?: boolean;
  toolsUpgradePolicy?: string;
  pendingCustomization?: string;
  customizationKeyId?: CryptoKeyId;
  syncTimeWithHostAllowed?: boolean;
  syncTimeWithHost?: boolean;
  lastInstallInfo?: ToolsConfigInfoToolsLastInstallInfo;
}
export type ToolsConfigInfoToolsLastInstallInfo = DynamicData &  {
  counter: number;
  fault?: MethodFault;
}
export type VirtualMachineUsbInfo = VirtualMachineTargetInfo &  {
  description: string;
  vendor: number;
  product: number;
  physicalPath: string;
  family?: string[];
  speed?: string[];
  summary?: VirtualMachineSummary;
}
export type UsbScanCodeSpec = DynamicData &  {
  keyEvents: UsbScanCodeSpecKeyEvent[];
}
export type UsbScanCodeSpecKeyEvent = DynamicData &  {
  usbHidCode: number;
  modifiers?: UsbScanCodeSpecModifierType;
}
export type UsbScanCodeSpecModifierType = DynamicData &  {
  leftControl?: boolean;
  leftShift?: boolean;
  leftAlt?: boolean;
  leftGui?: boolean;
  rightControl?: boolean;
  rightShift?: boolean;
  rightAlt?: boolean;
  rightGui?: boolean;
}
export type VirtualMachineVcpuConfig = DynamicData &  {
  latencySensitivity?: LatencySensitivity;
}
export type VirtualHardware = DynamicData &  {
  numCPU: number;
  numCoresPerSocket?: number;
  memoryMB: number;
  virtualICH7MPresent?: boolean;
  virtualSMCPresent?: boolean;
  device?: VirtualDevice[];
}
export type VirtualHardwareOption = DynamicData &  {
  hwVersion: number;
  virtualDeviceOption: VirtualDeviceOption[];
  deviceListReadonly: boolean;
  numCPU: number[];
  numCoresPerSocket: IntOption;
  numCpuReadonly: boolean;
  memoryMB: LongOption;
  numPCIControllers: IntOption;
  numIDEControllers: IntOption;
  numUSBControllers: IntOption;
  numUSBXHCIControllers: IntOption;
  numSIOControllers: IntOption;
  numPS2Controllers: IntOption;
  licensingLimit?: string[];
  numSupportedWwnPorts?: IntOption;
  numSupportedWwnNodes?: IntOption;
  resourceConfigOption: ResourceConfigOption;
  numNVDIMMControllers?: IntOption;
  numTPMDevices?: IntOption;
  numWDTDevices?: IntOption;
  numPrecisionClockDevices?: IntOption;
  epcMemoryMB?: LongOption;
}
export type VirtualMachineWindowsQuiesceSpec = VirtualMachineGuestQuiesceSpec &  {
  vssBackupType?: number;
  vssBootableSystemState?: boolean;
  vssPartialFileSupport?: boolean;
  vssBackupContext?: string;
}
export type CheckResult = DynamicData &  {
  vm?: VirtualMachine;
  host?: HostSystem;
  warning?: MethodFault[];
  error?: MethodFault[];
}
export type CustomizationAdapterMapping = DynamicData &  {
  macAddress?: string;
  adapter: CustomizationIPSettings;
}
export type CustomizationGlobalIPSettings = DynamicData &  {
  dnsSuffixList?: string[];
  dnsServerList?: string[];
}
export type CustomizationGuiRunOnce = DynamicData &  {
  commandList: string[];
}
export type CustomizationGuiUnattended = DynamicData &  {
  password?: CustomizationPassword;
  timeZone: number;
  autoLogon: boolean;
  autoLogonCount: number;
}
export type CustomizationIPSettings = DynamicData &  {
  ip: CustomizationIpGenerator;
  subnetMask?: string;
  gateway?: string[];
  ipV6Spec?: CustomizationIPSettingsIpV6AddressSpec;
  dnsServerList?: string[];
  dnsDomain?: string;
  primaryWINS?: string;
  secondaryWINS?: string;
  netBIOS?: CustomizationNetBIOSMode;
}
export type CustomizationIPSettingsIpV6AddressSpec = DynamicData &  {
  ip: CustomizationIpV6Generator[];
  gateway?: string[];
}
export type CustomizationIdentification = DynamicData &  {
  joinWorkgroup?: string;
  joinDomain?: string;
  domainAdmin?: string;
  domainAdminPassword?: CustomizationPassword;
}
export type CustomizationIdentitySettings = DynamicData &  {
  
}
export type CustomizationIpGenerator = DynamicData &  {
  
}
export type CustomizationIpV6Generator = DynamicData &  {
  
}
export type CustomizationLicenseFilePrintData = DynamicData &  {
  autoMode: CustomizationLicenseDataMode;
  autoUsers?: number;
}
export type CustomizationLinuxPrep = CustomizationIdentitySettings &  {
  hostName: CustomizationName;
  domain: string;
  timeZone?: string;
  hwClockUTC?: boolean;
  scriptText?: string;
}
export type CustomizationName = DynamicData &  {
  
}
export type CustomizationOptions = DynamicData &  {
  
}
export type CustomizationPassword = DynamicData &  {
  value: string;
  plainText: boolean;
}
export type CustomizationPrefixName = CustomizationName &  {
  base: string;
}
export type CustomizationSpec = DynamicData &  {
  options?: CustomizationOptions;
  identity: CustomizationIdentitySettings;
  globalIPSettings: CustomizationGlobalIPSettings;
  nicSettingMap?: CustomizationAdapterMapping[];
  encryptionKey?: number[];
}
export type CustomizationStatelessIpV6Generator = CustomizationIpV6Generator &  {
  
}
export type CustomizationSysprep = CustomizationIdentitySettings &  {
  guiUnattended: CustomizationGuiUnattended;
  userData: CustomizationUserData;
  guiRunOnce?: CustomizationGuiRunOnce;
  identification: CustomizationIdentification;
  licenseFilePrintData?: CustomizationLicenseFilePrintData;
}
export type CustomizationSysprepText = CustomizationIdentitySettings &  {
  value: string;
}
export type CustomizationUnknownIpGenerator = CustomizationIpGenerator &  {
  
}
export type CustomizationUnknownIpV6Generator = CustomizationIpV6Generator &  {
  
}
export type CustomizationUnknownName = CustomizationName &  {
  
}
export type CustomizationUserData = DynamicData &  {
  fullName: string;
  orgName: string;
  computerName: CustomizationName;
  productId: string;
}
export type CustomizationVirtualMachineName = CustomizationName &  {
  
}
export type CustomizationWinOptions = CustomizationOptions &  {
  changeSID: boolean;
  deleteAccounts: boolean;
  reboot?: CustomizationSysprepRebootOption;
}
export type HostDiskMappingInfo = DynamicData &  {
  physicalPartition?: HostDiskMappingPartitionInfo;
  name: string;
  exclusive?: boolean;
}
export type HostDiskMappingPartitionInfo = DynamicData &  {
  name: string;
  fileSystem: string;
  capacityInKb: number;
}
export type HostDiskMappingOption = DynamicData &  {
  physicalPartition?: HostDiskMappingPartitionOption[];
  name: string;
}
export type HostDiskMappingPartitionOption = DynamicData &  {
  name: string;
  fileSystem: string;
  capacityInKb: number;
}
export type VirtualDevice = DynamicData &  {
  key: number;
  deviceInfo?: Description;
  backing?: VirtualDeviceBackingInfo;
  connectable?: VirtualDeviceConnectInfo;
  slotInfo?: VirtualDeviceBusSlotInfo;
  controllerKey?: number;
  unitNumber?: number;
}
export type VirtualDeviceBackingInfo = DynamicData &  {
  
}
export type VirtualDeviceBusSlotInfo = DynamicData &  {
  
}
export type VirtualDeviceConnectInfo = DynamicData &  {
  migrateConnect?: string;
  startConnected: boolean;
  allowGuestControl: boolean;
  connected: boolean;
  status?: string;
}
export type VirtualDeviceDeviceBackingInfo = VirtualDeviceBackingInfo &  {
  deviceName: string;
  useAutoDetect?: boolean;
}
export type VirtualDeviceFileBackingInfo = VirtualDeviceBackingInfo &  {
  fileName: string;
  datastore?: Datastore;
  backingObjectId?: string;
}
export type VirtualDevicePciBusSlotInfo = VirtualDeviceBusSlotInfo &  {
  pciSlotNumber: number;
}
export type VirtualDevicePipeBackingInfo = VirtualDeviceBackingInfo &  {
  pipeName: string;
}
export type VirtualDeviceRemoteDeviceBackingInfo = VirtualDeviceBackingInfo &  {
  deviceName: string;
  useAutoDetect?: boolean;
}
export type VirtualDeviceURIBackingInfo = VirtualDeviceBackingInfo &  {
  serviceURI: string;
  direction: string;
  proxyURI?: string;
}
export type VirtualDeviceOption = DynamicData &  {
  type: string;
  connectOption?: VirtualDeviceConnectOption;
  busSlotOption?: VirtualDeviceBusSlotOption;
  controllerType?: string;
  autoAssignController?: BoolOption;
  backingOption?: VirtualDeviceBackingOption[];
  defaultBackingOptionIndex?: number;
  licensingLimit?: string[];
  deprecated: boolean;
  plugAndPlay: boolean;
  hotRemoveSupported: boolean;
}
export type VirtualDeviceBackingOption = DynamicData &  {
  type: string;
}
export type VirtualDeviceBusSlotOption = DynamicData &  {
  type: string;
}
export type VirtualDeviceConnectOption = DynamicData &  {
  startConnected: BoolOption;
  allowGuestControl: BoolOption;
}
export type VirtualDeviceDeviceBackingOption = VirtualDeviceBackingOption &  {
  autoDetectAvailable: BoolOption;
}
export type VirtualDeviceFileBackingOption = VirtualDeviceBackingOption &  {
  fileNameExtensions?: ChoiceOption;
}
export type VirtualDevicePipeBackingOption = VirtualDeviceBackingOption &  {
  
}
export type VirtualDeviceRemoteDeviceBackingOption = VirtualDeviceBackingOption &  {
  autoDetectAvailable: BoolOption;
}
export type VirtualDeviceURIBackingOption = VirtualDeviceBackingOption &  {
  directions: ChoiceOption;
}
export type VirtualDeviceConfigSpec = DynamicData &  {
  operation?: VirtualDeviceConfigSpecOperation;
  fileOperation?: VirtualDeviceConfigSpecFileOperation;
  device: VirtualDevice;
  profile?: VirtualMachineProfileSpec[];
  backing?: VirtualDeviceConfigSpecBackingSpec;
}
export type VirtualDeviceConfigSpecBackingSpec = DynamicData &  {
  parent?: VirtualDeviceConfigSpecBackingSpec;
  crypto?: CryptoSpec;
}
export type VirtualDisk = VirtualDevice &  {
  capacityInKB: number;
  capacityInBytes?: number;
  shares?: SharesInfo;
  storageIOAllocation?: StorageIOAllocationInfo;
  diskObjectId?: string;
  vFlashCacheConfigInfo?: VirtualDiskVFlashCacheConfigInfo;
  iofilter?: string[];
  vDiskId?: ID;
  nativeUnmanagedLinkedClone?: boolean;
}
export type VirtualDiskFlatVer1BackingInfo = VirtualDeviceFileBackingInfo &  {
  diskMode: string;
  split?: boolean;
  writeThrough?: boolean;
  contentId?: string;
  parent?: VirtualDiskFlatVer1BackingInfo;
}
export type VirtualDiskFlatVer2BackingInfo = VirtualDeviceFileBackingInfo &  {
  diskMode: string;
  split?: boolean;
  writeThrough?: boolean;
  thinProvisioned?: boolean;
  eagerlyScrub?: boolean;
  uuid?: string;
  contentId?: string;
  changeId?: string;
  parent?: VirtualDiskFlatVer2BackingInfo;
  deltaDiskFormat?: string;
  digestEnabled?: boolean;
  deltaGrainSize?: number;
  deltaDiskFormatVariant?: string;
  sharing?: string;
  keyId?: CryptoKeyId;
}
export type VirtualDiskLocalPMemBackingInfo = VirtualDeviceFileBackingInfo &  {
  diskMode: string;
  uuid?: string;
  volumeUUID?: string;
  contentId?: string;
}
export type VirtualDiskPartitionedRawDiskVer2BackingInfo = VirtualDiskRawDiskVer2BackingInfo &  {
  partition: number[];
}
export type VirtualDiskRawDiskMappingVer1BackingInfo = VirtualDeviceFileBackingInfo &  {
  lunUuid?: string;
  deviceName?: string;
  compatibilityMode?: string;
  diskMode?: string;
  uuid?: string;
  contentId?: string;
  changeId?: string;
  parent?: VirtualDiskRawDiskMappingVer1BackingInfo;
  deltaDiskFormat?: string;
  deltaGrainSize?: number;
  sharing?: string;
}
export type VirtualDiskRawDiskVer2BackingInfo = VirtualDeviceDeviceBackingInfo &  {
  descriptorFileName: string;
  uuid?: string;
  changeId?: string;
  sharing?: string;
}
export type VirtualDiskSeSparseBackingInfo = VirtualDeviceFileBackingInfo &  {
  diskMode: string;
  writeThrough?: boolean;
  uuid?: string;
  contentId?: string;
  changeId?: string;
  parent?: VirtualDiskSeSparseBackingInfo;
  deltaDiskFormat?: string;
  digestEnabled?: boolean;
  grainSize?: number;
  keyId?: CryptoKeyId;
}
export type VirtualDiskSparseVer1BackingInfo = VirtualDeviceFileBackingInfo &  {
  diskMode: string;
  split?: boolean;
  writeThrough?: boolean;
  spaceUsedInKB?: number;
  contentId?: string;
  parent?: VirtualDiskSparseVer1BackingInfo;
}
export type VirtualDiskSparseVer2BackingInfo = VirtualDeviceFileBackingInfo &  {
  diskMode: string;
  split?: boolean;
  writeThrough?: boolean;
  spaceUsedInKB?: number;
  uuid?: string;
  contentId?: string;
  changeId?: string;
  parent?: VirtualDiskSparseVer2BackingInfo;
  keyId?: CryptoKeyId;
}
export type VirtualDiskVFlashCacheConfigInfo = DynamicData &  {
  vFlashModule?: string;
  reservationInMB?: number;
  cacheConsistencyType?: string;
  cacheMode?: string;
  blockSizeInKB?: number;
}
export type VirtualDiskId = DynamicData &  {
  vm: VirtualMachine;
  diskId: number;
}
export type VirtualDiskOption = VirtualDeviceOption &  {
  capacityInKB: LongOption;
  ioAllocationOption: StorageIOAllocationOption;
  vFlashCacheConfigOption?: VirtualDiskOptionVFlashCacheConfigOption;
}
export type VirtualDiskDeltaDiskFormatsSupported = DynamicData &  {
  datastoreType: string;
  deltaDiskFormat: ChoiceOption;
}
export type VirtualDiskFlatVer1BackingOption = VirtualDeviceFileBackingOption &  {
  diskMode: ChoiceOption;
  split: BoolOption;
  writeThrough: BoolOption;
  growable: boolean;
}
export type VirtualDiskFlatVer2BackingOption = VirtualDeviceFileBackingOption &  {
  diskMode: ChoiceOption;
  split: BoolOption;
  writeThrough: BoolOption;
  growable: boolean;
  hotGrowable: boolean;
  uuid: boolean;
  thinProvisioned: BoolOption;
  eagerlyScrub: BoolOption;
  deltaDiskFormat: ChoiceOption;
  deltaDiskFormatsSupported: VirtualDiskDeltaDiskFormatsSupported[];
}
export type VirtualDiskLocalPMemBackingOption = VirtualDeviceFileBackingOption &  {
  diskMode: ChoiceOption;
  growable: boolean;
  hotGrowable: boolean;
  uuid: boolean;
}
export type VirtualDiskPartitionedRawDiskVer2BackingOption = VirtualDiskRawDiskVer2BackingOption &  {
  
}
export type VirtualDiskRawDiskMappingVer1BackingOption = VirtualDeviceDeviceBackingOption &  {
  descriptorFileNameExtensions?: ChoiceOption;
  compatibilityMode: ChoiceOption;
  diskMode: ChoiceOption;
  uuid: boolean;
}
export type VirtualDiskRawDiskVer2BackingOption = VirtualDeviceDeviceBackingOption &  {
  descriptorFileNameExtensions: ChoiceOption;
  uuid: boolean;
}
export type VirtualDiskSeSparseBackingOption = VirtualDeviceFileBackingOption &  {
  diskMode: ChoiceOption;
  writeThrough: BoolOption;
  growable: boolean;
  hotGrowable: boolean;
  uuid: boolean;
  deltaDiskFormatsSupported: VirtualDiskDeltaDiskFormatsSupported[];
}
export type VirtualDiskSparseVer1BackingOption = VirtualDeviceFileBackingOption &  {
  diskModes: ChoiceOption;
  split: BoolOption;
  writeThrough: BoolOption;
  growable: boolean;
}
export type VirtualDiskSparseVer2BackingOption = VirtualDeviceFileBackingOption &  {
  diskMode: ChoiceOption;
  split: BoolOption;
  writeThrough: BoolOption;
  growable: boolean;
  hotGrowable: boolean;
  uuid: boolean;
}
export type VirtualDiskOptionVFlashCacheConfigOption = DynamicData &  {
  cacheConsistencyType: ChoiceOption;
  cacheMode: ChoiceOption;
  reservationInMB: LongOption;
  blockSizeInKB: LongOption;
}
export type VirtualDiskConfigSpec = VirtualDeviceConfigSpec &  {
  diskMoveType?: string;
  migrateCache?: boolean;
}
export type VirtualEthernetCard = VirtualDevice &  {
  addressType?: string;
  macAddress?: string;
  wakeOnLanEnabled?: boolean;
  resourceAllocation?: VirtualEthernetCardResourceAllocation;
  externalId?: string;
  uptCompatibilityEnabled?: boolean;
}
export type VirtualEthernetCardDistributedVirtualPortBackingInfo = VirtualDeviceBackingInfo &  {
  port: DistributedVirtualSwitchPortConnection;
}
export type VirtualEthernetCardLegacyNetworkBackingInfo = VirtualDeviceDeviceBackingInfo &  {
  
}
export type VirtualEthernetCardNetworkBackingInfo = VirtualDeviceDeviceBackingInfo &  {
  network?: Network;
  inPassthroughMode?: boolean;
}
export type VirtualEthernetCardOpaqueNetworkBackingInfo = VirtualDeviceBackingInfo &  {
  opaqueNetworkId: string;
  opaqueNetworkType: string;
}
export type VirtualEthernetCardResourceAllocation = DynamicData &  {
  reservation?: number;
  share: SharesInfo;
  limit?: number;
}
export type VirtualEthernetCardOption = VirtualDeviceOption &  {
  supportedOUI: ChoiceOption;
  macType: ChoiceOption;
  wakeOnLanEnabled: BoolOption;
  vmDirectPathGen2Supported: boolean;
  uptCompatibilityEnabled?: BoolOption;
}
export type VirtualEthernetCardDVPortBackingOption = VirtualDeviceBackingOption &  {
  
}
export type VirtualEthernetCardLegacyNetworkBackingOption = VirtualDeviceDeviceBackingOption &  {
  
}
export type VirtualEthernetCardNetworkBackingOption = VirtualDeviceDeviceBackingOption &  {
  
}
export type VirtualEthernetCardOpaqueNetworkBackingOption = VirtualDeviceBackingOption &  {
  
}
export type VirtualFloppy = VirtualDevice &  {
  
}
export type VirtualFloppyDeviceBackingInfo = VirtualDeviceDeviceBackingInfo &  {
  
}
export type VirtualFloppyImageBackingInfo = VirtualDeviceFileBackingInfo &  {
  
}
export type VirtualFloppyRemoteDeviceBackingInfo = VirtualDeviceRemoteDeviceBackingInfo &  {
  
}
export type VirtualFloppyOption = VirtualDeviceOption &  {
  
}
export type VirtualFloppyDeviceBackingOption = VirtualDeviceDeviceBackingOption &  {
  
}
export type VirtualFloppyImageBackingOption = VirtualDeviceFileBackingOption &  {
  
}
export type VirtualFloppyRemoteDeviceBackingOption = VirtualDeviceRemoteDeviceBackingOption &  {
  
}
export type VirtualKeyboard = VirtualDevice &  {
  
}
export type VirtualKeyboardOption = VirtualDeviceOption &  {
  
}
export type VirtualNVDIMM = VirtualDevice &  {
  capacityInMB: number;
}
export type VirtualNVDIMMBackingInfo = VirtualDeviceFileBackingInfo &  {
  parent?: VirtualNVDIMMBackingInfo;
  changeId?: string;
}
export type VirtualNVDIMMOption = VirtualDeviceOption &  {
  capacityInMB: LongOption;
  growable: boolean;
  hotGrowable: boolean;
  granularityInMB: number;
}
export type VirtualPCIPassthrough = VirtualDevice &  {
  
}
export type VirtualPCIPassthroughAllowedDevice = DynamicData &  {
  vendorId: number;
  deviceId: number;
  subVendorId?: number;
  subDeviceId?: number;
  revisionId?: number;
}
export type VirtualPCIPassthroughDeviceBackingInfo = VirtualDeviceDeviceBackingInfo &  {
  id: string;
  deviceId: string;
  systemId: string;
  vendorId: number;
}
export type VirtualPCIPassthroughDynamicBackingInfo = VirtualDeviceDeviceBackingInfo &  {
  allowedDevice?: VirtualPCIPassthroughAllowedDevice[];
  customLabel?: string;
  assignedId?: string;
}
export type VirtualPCIPassthroughPluginBackingInfo = VirtualDeviceBackingInfo &  {
  
}
export type VirtualPCIPassthroughVmiopBackingInfo = VirtualPCIPassthroughPluginBackingInfo &  {
  vgpu?: string;
}
export type VirtualPCIPassthroughOption = VirtualDeviceOption &  {
  
}
export type VirtualPCIPassthroughDeviceBackingOption = VirtualDeviceDeviceBackingOption &  {
  
}
export type VirtualPCIPassthroughDynamicBackingOption = VirtualDeviceDeviceBackingOption &  {
  
}
export type VirtualPCIPassthroughPluginBackingOption = VirtualDeviceBackingOption &  {
  
}
export type VirtualPCIPassthroughVmiopBackingOption = VirtualPCIPassthroughPluginBackingOption &  {
  vgpu: StringOption;
  maxInstances: number;
}
export type VirtualPCNet32 = VirtualEthernetCard &  {
  
}
export type VirtualPCNet32Option = VirtualEthernetCardOption &  {
  supportsMorphing: boolean;
}
export type VirtualParallelPort = VirtualDevice &  {
  
}
export type VirtualParallelPortDeviceBackingInfo = VirtualDeviceDeviceBackingInfo &  {
  
}
export type VirtualParallelPortFileBackingInfo = VirtualDeviceFileBackingInfo &  {
  
}
export type VirtualParallelPortOption = VirtualDeviceOption &  {
  
}
export type VirtualParallelPortDeviceBackingOption = VirtualDeviceDeviceBackingOption &  {
  
}
export type VirtualParallelPortFileBackingOption = VirtualDeviceFileBackingOption &  {
  
}
export type VirtualPointingDevice = VirtualDevice &  {
  
}
export type VirtualPointingDeviceDeviceBackingInfo = VirtualDeviceDeviceBackingInfo &  {
  hostPointingDevice: string;
}
export type VirtualPointingDeviceOption = VirtualDeviceOption &  {
  
}
export type VirtualPointingDeviceBackingOption = VirtualDeviceDeviceBackingOption &  {
  hostPointingDevice: ChoiceOption;
}
export type VirtualPrecisionClock = VirtualDevice &  {
  
}
export type VirtualPrecisionClockSystemClockBackingInfo = VirtualDeviceBackingInfo &  {
  protocol?: string;
}
export type VirtualPrecisionClockOption = VirtualDeviceOption &  {
  
}
export type VirtualPrecisionClockSystemClockBackingOption = VirtualDeviceBackingOption &  {
  protocol: ChoiceOption;
}
export type VirtualSCSIPassthrough = VirtualDevice &  {
  
}
export type VirtualSCSIPassthroughDeviceBackingInfo = VirtualDeviceDeviceBackingInfo &  {
  
}
export type VirtualSCSIPassthroughOption = VirtualDeviceOption &  {
  
}
export type VirtualSCSIPassthroughDeviceBackingOption = VirtualDeviceDeviceBackingOption &  {
  
}
export type VirtualSerialPort = VirtualDevice &  {
  yieldOnPoll: boolean;
}
export type VirtualSerialPortDeviceBackingInfo = VirtualDeviceDeviceBackingInfo &  {
  
}
export type VirtualSerialPortFileBackingInfo = VirtualDeviceFileBackingInfo &  {
  
}
export type VirtualSerialPortPipeBackingInfo = VirtualDevicePipeBackingInfo &  {
  endpoint: string;
  noRxLoss?: boolean;
}
export type VirtualSerialPortThinPrintBackingInfo = VirtualDeviceBackingInfo &  {
  
}
export type VirtualSerialPortURIBackingInfo = VirtualDeviceURIBackingInfo &  {
  
}
export type VirtualSerialPortOption = VirtualDeviceOption &  {
  yieldOnPoll: BoolOption;
}
export type VirtualSerialPortDeviceBackingOption = VirtualDeviceDeviceBackingOption &  {
  
}
export type VirtualSerialPortFileBackingOption = VirtualDeviceFileBackingOption &  {
  
}
export type VirtualSerialPortPipeBackingOption = VirtualDevicePipeBackingOption &  {
  endpoint: ChoiceOption;
  noRxLoss: BoolOption;
}
export type VirtualSerialPortThinPrintBackingOption = VirtualDeviceBackingOption &  {
  
}
export type VirtualSerialPortURIBackingOption = VirtualDeviceURIBackingOption &  {
  
}
export type VirtualSoundCard = VirtualDevice &  {
  
}
export type VirtualSoundCardDeviceBackingInfo = VirtualDeviceDeviceBackingInfo &  {
  
}
export type VirtualSoundCardOption = VirtualDeviceOption &  {
  
}
export type VirtualSoundCardDeviceBackingOption = VirtualDeviceDeviceBackingOption &  {
  
}
export type VirtualSriovEthernetCard = VirtualEthernetCard &  {
  allowGuestOSMtuChange?: boolean;
  sriovBacking?: VirtualSriovEthernetCardSriovBackingInfo;
}
export type VirtualSriovEthernetCardSriovBackingInfo = VirtualDeviceBackingInfo &  {
  physicalFunctionBacking?: VirtualPCIPassthroughDeviceBackingInfo;
  virtualFunctionBacking?: VirtualPCIPassthroughDeviceBackingInfo;
  virtualFunctionIndex?: number;
}
export type VirtualSriovEthernetCardOption = VirtualEthernetCardOption &  {
  
}
export type VirtualSriovEthernetCardSriovBackingOption = VirtualDeviceBackingOption &  {
  
}
export type VirtualTPM = VirtualDevice &  {
  endorsementKeyCertificateSigningRequest?: Buffer[];
  endorsementKeyCertificate?: Buffer[];
}
export type VirtualTPMOption = VirtualDeviceOption &  {
  supportedFirmware?: string[];
}
export type VirtualUSB = VirtualDevice &  {
  connected: boolean;
  vendor?: number;
  product?: number;
  family?: string[];
  speed?: string[];
}
export type VirtualUSBRemoteClientBackingInfo = VirtualDeviceRemoteDeviceBackingInfo &  {
  hostname: string;
}
export type VirtualUSBRemoteHostBackingInfo = VirtualDeviceDeviceBackingInfo &  {
  hostname: string;
}
export type VirtualUSBUSBBackingInfo = VirtualDeviceDeviceBackingInfo &  {
  
}
export type VirtualUSBOption = VirtualDeviceOption &  {
  
}
export type VirtualUSBRemoteClientBackingOption = VirtualDeviceRemoteDeviceBackingOption &  {
  
}
export type VirtualUSBRemoteHostBackingOption = VirtualDeviceDeviceBackingOption &  {
  
}
export type VirtualUSBUSBBackingOption = VirtualDeviceDeviceBackingOption &  {
  
}
export type VirtualMachineVMCIDevice = VirtualDevice &  {
  id?: number;
  allowUnrestrictedCommunication?: boolean;
  filterEnable?: boolean;
  filterInfo?: VirtualMachineVMCIDeviceFilterInfo;
}
export type VirtualMachineVMCIDeviceFilterInfo = DynamicData &  {
  filters?: VirtualMachineVMCIDeviceFilterSpec[];
}
export type VirtualMachineVMCIDeviceFilterSpec = DynamicData &  {
  rank: number;
  action: string;
  protocol: string;
  direction: string;
  lowerDstPortBoundary?: number;
  upperDstPortBoundary?: number;
}
export type VirtualMachineVMCIDeviceOption = VirtualDeviceOption &  {
  allowUnrestrictedCommunication: BoolOption;
  filterSpecOption?: VirtualMachineVMCIDeviceOptionFilterSpecOption;
  filterSupported?: BoolOption;
}
export type VirtualMachineVMCIDeviceOptionFilterSpecOption = DynamicData &  {
  action: ChoiceOption;
  protocol: ChoiceOption;
  direction: ChoiceOption;
  lowerDstPortBoundary: LongOption;
  upperDstPortBoundary: LongOption;
}
export type VirtualMachineVMIROM = VirtualDevice &  {
  
}
export type VirtualVMIROMOption = VirtualDeviceOption &  {
  
}
export type VirtualMachineVideoCard = VirtualDevice &  {
  videoRamSizeInKB?: number;
  numDisplays?: number;
  useAutoDetect?: boolean;
  enable3DSupport?: boolean;
  use3dRenderer?: string;
  graphicsMemorySizeInKB?: number;
}
export type VirtualVideoCardOption = VirtualDeviceOption &  {
  videoRamSizeInKB?: LongOption;
  numDisplays?: IntOption;
  useAutoDetect?: BoolOption;
  support3D?: BoolOption;
  use3dRendererSupported?: BoolOption;
  graphicsMemorySizeInKB?: LongOption;
  graphicsMemorySizeSupported?: BoolOption;
}
export type VirtualVmxnet = VirtualEthernetCard &  {
  
}
export type VirtualVmxnet2 = VirtualVmxnet &  {
  
}
export type VirtualVmxnet3 = VirtualVmxnet &  {
  
}
export type VirtualVmxnet3Vrdma = VirtualVmxnet3 &  {
  deviceProtocol?: string;
}
export type VirtualVmxnetOption = VirtualEthernetCardOption &  {
  
}
export type VirtualWDT = VirtualDevice &  {
  runOnBoot: boolean;
  running: boolean;
}
export type VirtualWDTOption = VirtualDeviceOption &  {
  runOnBoot: BoolOption;
}
export type GuestAliases = DynamicData &  {
  base64Cert: string;
  aliases: GuestAuthAliasInfo[];
}
export type GuestAuthAliasInfo = DynamicData &  {
  subject: GuestAuthSubject;
  comment: string;
}
export type GuestAuthAnySubject = GuestAuthSubject &  {
  
}
export type GuestAuthNamedSubject = GuestAuthSubject &  {
  name: string;
}
export type GuestAuthSubject = DynamicData &  {
  
}
export type GuestMappedAliases = DynamicData &  {
  base64Cert: string;
  username: string;
  subjects: GuestAuthSubject[];
}
export type GuestFileAttributes = DynamicData &  {
  modificationTime?: Date;
  accessTime?: Date;
  symlinkTarget?: string;
}
export type GuestFileInfo = DynamicData &  {
  path: string;
  type: string;
  size: number;
  attributes: GuestFileAttributes;
}
export type FileTransferInformation = DynamicData &  {
  attributes: GuestFileAttributes;
  size: number;
  url: string;
}
export type GuestListFileInfo = DynamicData &  {
  files?: GuestFileInfo[];
  remaining: number;
}
export type GuestPosixFileAttributes = GuestFileAttributes &  {
  ownerId?: number;
  groupId?: number;
  permissions?: number;
}
export type GuestWindowsFileAttributes = GuestFileAttributes &  {
  hidden?: boolean;
  readOnly?: boolean;
  createTime?: Date;
}
export type GuestAuthentication = DynamicData &  {
  interactiveSession: boolean;
}
export type NamePasswordAuthentication = GuestAuthentication &  {
  username: string;
  password: string;
}
export type GuestProcessInfo = DynamicData &  {
  name: string;
  pid: number;
  owner: string;
  cmdLine: string;
  startTime: Date;
  endTime?: Date;
  exitCode?: number;
}
export type GuestProgramSpec = DynamicData &  {
  programPath: string;
  arguments: string;
  workingDirectory?: string;
  envVariables?: string[];
}
export type GuestWindowsProgramSpec = GuestProgramSpec &  {
  startMinimized: boolean;
}
export type SAMLTokenAuthentication = GuestAuthentication &  {
  token: string;
  username?: string;
}
export type SSPIAuthentication = GuestAuthentication &  {
  sspiToken: string;
}
export type TicketedSessionAuthentication = GuestAuthentication &  {
  ticket: string;
}
export type GuestRegKeySpec = DynamicData &  {
  keyName: GuestRegKeyNameSpec;
  classType: string;
  lastWritten: Date;
}
export type GuestRegKeyNameSpec = DynamicData &  {
  registryPath: string;
  wowBitness: string;
}
export type GuestRegKeyRecordSpec = DynamicData &  {
  key: GuestRegKeySpec;
  fault?: MethodFault;
}
export type GuestRegValueSpec = DynamicData &  {
  name: GuestRegValueNameSpec;
  data: GuestRegValueDataSpec;
}
export type GuestRegValueBinarySpec = GuestRegValueDataSpec &  {
  value?: Buffer;
}
export type GuestRegValueDataSpec = DynamicData &  {
  
}
export type GuestRegValueDwordSpec = GuestRegValueDataSpec &  {
  value: number;
}
export type GuestRegValueExpandStringSpec = GuestRegValueDataSpec &  {
  value?: string;
}
export type GuestRegValueMultiStringSpec = GuestRegValueDataSpec &  {
  value?: string[];
}
export type GuestRegValueNameSpec = DynamicData &  {
  keyName: GuestRegKeyNameSpec;
  name: string;
}
export type GuestRegValueQwordSpec = GuestRegValueDataSpec &  {
  value: number;
}
export type GuestRegValueStringSpec = GuestRegValueDataSpec &  {
  value?: string;
}
export type DeviceGroupId = DynamicData &  {
  id: string;
}
export type FaultDomainId = DynamicData &  {
  id: string;
}
export type ReplicationGroupId = DynamicData &  {
  faultDomainId: FaultDomainId;
  deviceGroupId: DeviceGroupId;
}
export type ReplicationSpec = DynamicData &  {
  replicationGroupId: ReplicationGroupId;
}
export type VsanClusterConfigInfo = DynamicData &  {
  enabled?: boolean;
  defaultConfig?: VsanClusterConfigInfoHostDefaultInfo;
}
export type VsanClusterConfigInfoHostDefaultInfo = DynamicData &  {
  uuid?: string;
  autoClaimStorage?: boolean;
  checksumEnabled?: boolean;
}
export type VsanHostClusterStatus = DynamicData &  {
  uuid?: string;
  nodeUuid?: string;
  health: string;
  nodeState: VsanHostClusterStatusState;
  memberUuid?: string[];
}
export type VsanHostClusterStatusState = DynamicData &  {
  state: string;
  completion?: VsanHostClusterStatusStateCompletionEstimate;
}
export type VsanHostClusterStatusStateCompletionEstimate = DynamicData &  {
  completeTime?: Date;
  percentComplete?: number;
}
export type VsanHostConfigInfo = DynamicData &  {
  enabled?: boolean;
  hostSystem?: HostSystem;
  clusterInfo?: VsanHostConfigInfoClusterInfo;
  storageInfo?: VsanHostConfigInfoStorageInfo;
  networkInfo?: VsanHostConfigInfoNetworkInfo;
  faultDomainInfo?: VsanHostFaultDomainInfo;
}
export type VsanHostConfigInfoClusterInfo = DynamicData &  {
  uuid?: string;
  nodeUuid?: string;
}
export type VsanHostFaultDomainInfo = DynamicData &  {
  name: string;
}
export type VsanHostConfigInfoNetworkInfo = DynamicData &  {
  port?: VsanHostConfigInfoNetworkInfoPortConfig[];
}
export type VsanHostConfigInfoNetworkInfoPortConfig = DynamicData &  {
  ipConfig?: VsanHostIpConfig;
  device: string;
}
export type VsanHostConfigInfoStorageInfo = DynamicData &  {
  autoClaimStorage?: boolean;
  diskMapping?: VsanHostDiskMapping[];
  diskMapInfo?: VsanHostDiskMapInfo[];
  checksumEnabled?: boolean;
}
export type VsanHostDecommissionMode = DynamicData &  {
  objectAction: string;
}
export type VsanHostDiskMapInfo = DynamicData &  {
  mapping: VsanHostDiskMapping;
  mounted: boolean;
}
export type VsanHostDiskMapResult = DynamicData &  {
  mapping: VsanHostDiskMapping;
  diskResult?: VsanHostDiskResult[];
  error?: MethodFault;
}
export type VsanHostDiskMapping = DynamicData &  {
  ssd: HostScsiDisk;
  nonSsd: HostScsiDisk[];
}
export type VsanHostDiskResult = DynamicData &  {
  disk: HostScsiDisk;
  state: string;
  vsanUuid?: string;
  error?: MethodFault;
  degraded?: boolean;
}
export type VsanHostIpConfig = DynamicData &  {
  upstreamIpAddress: string;
  downstreamIpAddress: string;
}
export type VsanHostMembershipInfo = DynamicData &  {
  nodeUuid: string;
  hostname: string;
}
export type VsanHostVsanDiskInfo = DynamicData &  {
  vsanUuid: string;
  formatVersion: number;
}
export type VsanHostRuntimeInfo = DynamicData &  {
  membershipList?: VsanHostMembershipInfo[];
  diskIssues?: VsanHostRuntimeInfoDiskIssue[];
  accessGenNo?: number;
}
export type VsanHostRuntimeInfoDiskIssue = DynamicData &  {
  diskId: string;
  issue: string;
}
export type BaseConfigInfo = DynamicData &  {
  id: ID;
  name: string;
  createTime: Date;
  keepAfterDeleteVm?: boolean;
  relocationDisabled?: boolean;
  nativeSnapshotSupported?: boolean;
  changedBlockTrackingEnabled?: boolean;
  backing: BaseConfigInfoBackingInfo;
  iofilter?: string[];
}
export type BaseConfigInfoBackingInfo = DynamicData &  {
  datastore: Datastore;
}
export type BaseConfigInfoDiskFileBackingInfo = BaseConfigInfoFileBackingInfo &  {
  provisioningType: string;
}
export type BaseConfigInfoFileBackingInfo = BaseConfigInfoBackingInfo &  {
  filePath: string;
  backingObjectId?: string;
  parent?: BaseConfigInfoFileBackingInfo;
  deltaSizeInMB?: number;
  keyId?: CryptoKeyId;
}
export type BaseConfigInfoRawDiskMappingBackingInfo = BaseConfigInfoFileBackingInfo &  {
  lunUuid: string;
  compatibilityMode: string;
}
export type VslmCreateSpec = DynamicData &  {
  name: string;
  keepAfterDeleteVm?: boolean;
  backingSpec: VslmCreateSpecBackingSpec;
  capacityInMB: number;
  profile?: VirtualMachineProfileSpec[];
  crypto?: CryptoSpec;
  metadata?: KeyValue[];
}
export type VslmCreateSpecBackingSpec = DynamicData &  {
  datastore: Datastore;
  path?: string;
}
export type VslmCreateSpecDiskFileBackingSpec = VslmCreateSpecBackingSpec &  {
  provisioningType?: string;
}
export type VslmCreateSpecRawDiskMappingBackingSpec = VslmCreateSpecBackingSpec &  {
  lunUuid: string;
  compatibilityMode: string;
}
export type DiskCryptoSpec = DynamicData &  {
  parent?: DiskCryptoSpec;
  crypto: CryptoSpec;
}
export type ID = DynamicData &  {
  id: string;
}
export type vslmInfrastructureObjectPolicy = DynamicData &  {
  name: string;
  backingObjectId: string;
  profileId: string;
  error?: MethodFault;
}
export type vslmInfrastructureObjectPolicySpec = DynamicData &  {
  datastore: Datastore;
  profile?: VirtualMachineProfileSpec[];
}
export type VslmMigrateSpec = DynamicData &  {
  backingSpec: VslmCreateSpecBackingSpec;
  profile?: VirtualMachineProfileSpec[];
  consolidate?: boolean;
  disksCrypto?: DiskCryptoSpec;
}
export type VslmRelocateSpec = VslmMigrateSpec &  {
  
}
export type VStorageObjectStateInfo = DynamicData &  {
  tentative?: boolean;
}
export type VslmTagEntry = DynamicData &  {
  tagName: string;
  parentCategoryName: string;
}
export type VStorageObject = DynamicData &  {
  config: VStorageObjectConfigInfo;
}
export type VStorageObjectConfigInfo = BaseConfigInfo &  {
  capacityInMB: number;
  consumptionType?: string[];
  consumerId?: ID[];
}
export type VStorageObjectSnapshotDetails = DynamicData &  {
  path?: string;
  changedBlockTrackingId?: string;
}
export type VStorageObjectSnapshotInfo = DynamicData &  {
  snapshots?: VStorageObjectSnapshotInfoVStorageObjectSnapshot[];
}
export type VStorageObjectSnapshotInfoVStorageObjectSnapshot = DynamicData &  {
  id?: ID;
  backingObjectId?: string;
  createTime: Date;
  description: string;
}
export type RetrieveVStorageObjSpec = DynamicData &  {
  id: ID;
  datastore: Datastore;
}
export type VStorageObjectAssociations = DynamicData &  {
  id: ID;
  vmDiskAssociations?: VStorageObjectAssociationsVmDiskAssociations[];
  fault?: MethodFault;
}
export type VStorageObjectAssociationsVmDiskAssociations = DynamicData &  {
  vmId: string;
  diskKey: number;
}
export type EntityPrivilege = DynamicData &  {
  entity: ManagedEntity;
  privAvailability: PrivilegeAvailability[];
}
export type Permission = DynamicData &  {
  entity?: ManagedEntity;
  principal: string;
  group: boolean;
  roleId: number;
  propagate: boolean;
}
export type AuthorizationPrivilege = DynamicData &  {
  privId: string;
  onParent: boolean;
  name: string;
  privGroupName: string;
}
export type PrivilegeAvailability = DynamicData &  {
  privId: string;
  isGranted: boolean;
}
export type AuthorizationRole = DynamicData &  {
  roleId: number;
  system: boolean;
  name: string;
  info: Description;
  privilege?: string[];
}
export type UserPrivilegeResult = DynamicData &  {
  entity: ManagedEntity;
  privileges?: string[];
}
export type BoolPolicy = InheritablePolicy &  {
  value?: boolean;
}
export type EVCMode = ElementDescription &  {
  guaranteedCPUFeatures?: HostCpuIdInfo[];
  featureCapability?: HostFeatureCapability[];
  featureMask?: HostFeatureMask[];
  featureRequirement?: VirtualMachineFeatureRequirement[];
  vendor: string;
  track: string[];
  vendorTier: number;
}
export type ImportSpec = DynamicData &  {
  entityConfig?: VAppEntityConfigInfo;
  instantiationOst?: OvfConsumerOstNode;
}
export type IntExpression = NegatableExpression &  {
  value?: number;
}
export type IpAddress = NegatableExpression &  {
  
}
export type IpRange = IpAddress &  {
  addressPrefix: string;
  prefixLength?: number;
}
export type LicenseAssignmentManagerLicenseAssignment = DynamicData &  {
  entityId: string;
  scope?: string;
  entityDisplayName?: string;
  assignedLicense: LicenseManagerLicenseInfo;
  properties?: KeyAnyValue[];
}
export type MacAddress = NegatableExpression &  {
  
}
export type MacRange = MacAddress &  {
  address: string;
  mask: string;
}
export type NetworkSummary = DynamicData &  {
  network?: Network;
  name: string;
  accessible: boolean;
  ipPoolName: string;
  ipPoolId?: number;
}
export type OpaqueNetworkCapability = DynamicData &  {
  networkReservationSupported: boolean;
}
export type OpaqueNetworkSummary = NetworkSummary &  {
  opaqueNetworkId: string;
  opaqueNetworkType: string;
}
export type PosixUserSearchResult = UserSearchResult &  {
  id: number;
  shellAccess?: boolean;
}
export type ResourcePoolResourceUsage = DynamicData &  {
  reservationUsed: number;
  reservationUsedForVm: number;
  unreservedForPool: number;
  unreservedForVm: number;
  overallUsage: number;
  maxUsage: number;
}
export type ResourcePoolRuntimeInfo = DynamicData &  {
  memory: ResourcePoolResourceUsage;
  cpu: ResourcePoolResourceUsage;
  overallStatus: ManagedEntityStatus;
  sharesScalable?: string;
}
export type ResourcePoolSummary = DynamicData &  {
  name: string;
  config: ResourceConfigSpec;
  runtime: ResourcePoolRuntimeInfo;
  quickStats?: ResourcePoolQuickStats;
  configuredMemoryMB?: number;
}
export type ResourcePoolQuickStats = DynamicData &  {
  overallCpuUsage?: number;
  overallCpuDemand?: number;
  guestMemoryUsage?: number;
  hostMemoryUsage?: number;
  distributedCpuEntitlement?: number;
  distributedMemoryEntitlement?: number;
  staticCpuEntitlement?: number;
  staticMemoryEntitlement?: number;
  privateMemory?: number;
  sharedMemory?: number;
  swappedMemory?: number;
  balloonedMemory?: number;
  overheadMemory?: number;
  consumedOverheadMemory?: number;
  compressedMemory?: number;
}
export type SingleIp = IpAddress &  {
  address: string;
}
export type SingleMac = MacAddress &  {
  address: string;
}
export type TaskFilterSpec = DynamicData &  {
  entity?: TaskFilterSpecByEntity;
  time?: TaskFilterSpecByTime;
  userName?: TaskFilterSpecByUsername;
  activationId?: string[];
  state?: TaskInfoState[];
  alarm?: Alarm;
  scheduledTask?: ScheduledTask;
  eventChainId?: number[];
  tag?: string[];
  parentTaskKey?: string[];
  rootTaskKey?: string[];
}
export type TaskFilterSpecByEntity = DynamicData &  {
  entity: ManagedEntity;
  recursion: TaskFilterSpecRecursionOption;
}
export type TaskFilterSpecByTime = DynamicData &  {
  timeType: TaskFilterSpecTimeOption;
  beginTime?: Date;
  endTime?: Date;
}
export type TaskFilterSpecByUsername = DynamicData &  {
  systemUser: boolean;
  userList?: string[];
}
export type VirtualAppLinkInfo = DynamicData &  {
  key: ManagedEntity;
  destroyWithParent?: boolean;
}
export type VirtualAppSummary = ResourcePoolSummary &  {
  product?: VAppProductInfo;
  vAppState?: VirtualAppVAppState;
  suspended?: boolean;
  installBootRequired?: boolean;
  instanceUuid?: string;
}
export type DeviceBackedVirtualDiskSpec = VirtualDiskSpec &  {
  device: string;
}
export type FileBackedVirtualDiskSpec = VirtualDiskSpec &  {
  capacityKb: number;
  profile?: VirtualMachineProfileSpec[];
  crypto?: CryptoSpec;
}
export type SeSparseVirtualDiskSpec = FileBackedVirtualDiskSpec &  {
  grainSizeKb?: number;
}
export type VirtualDiskSpec = DynamicData &  {
  diskType: string;
  adapterType: string;
}
export type VirtualMachineConnection = DynamicData &  {
  label: string;
  client: string;
  userName: string;
}
export type DiskChangeInfo = DynamicData &  {
  startOffset: number;
  length: number;
  changedArea?: DiskChangeExtent[];
}
export type DiskChangeExtent = DynamicData &  {
  start: number;
  length: number;
}
export type VirtualMachineDisplayTopology = DynamicData &  {
  x: number;
  y: number;
  width: number;
  height: number;
}
export type VirtualMachineMksConnection = VirtualMachineConnection &  {
  
}
export type VirtualMachineMksTicket = DynamicData &  {
  ticket: string;
  cfgFile: string;
  host?: string;
  port?: number;
  sslThumbprint?: string;
}
export type StorageRequirement = DynamicData &  {
  datastore: Datastore;
  freeSpaceRequiredInKb: number;
}
export type VirtualMachineTicket = DynamicData &  {
  ticket: string;
  cfgFile: string;
  host?: string;
  port?: number;
  sslThumbprint?: string;
  url?: string;
}
export type VirtualMachineWipeResult = DynamicData &  {
  diskId: number;
  shrinkableDiskSpace: number;
}
export type AlarmFilterSpec = DynamicData &  {
  status?: ManagedEntityStatus[];
  typeEntity?: string;
  typeTrigger?: string;
}
export type AlarmInfo = AlarmSpec &  {
  key: string;
  alarm: Alarm;
  entity: ManagedEntity;
  lastModifiedTime: Date;
  lastModifiedUser: string;
  creationEventId: number;
}
export type AlarmState = DynamicData &  {
  key: string;
  entity: ManagedEntity;
  alarm: Alarm;
  overallStatus: ManagedEntityStatus;
  time: Date;
  acknowledged?: boolean;
  acknowledgedByUser?: string;
  acknowledgedTime?: Date;
  eventKey?: number;
  disabled?: boolean;
}
export type AlarmTriggeringAction = AlarmAction &  {
  action: Action;
  transitionSpecs?: AlarmTriggeringActionTransitionSpec[];
  green2yellow: boolean;
  yellow2red: boolean;
  red2yellow: boolean;
  yellow2green: boolean;
}
export type AlarmTriggeringActionTransitionSpec = DynamicData &  {
  startState: ManagedEntityStatus;
  finalState: ManagedEntityStatus;
  repeats: boolean;
}
export type EventAlarmExpression = AlarmExpression &  {
  comparisons?: EventAlarmExpressionComparison[];
  eventType: string;
  eventTypeId?: string;
  objectType?: string;
  status?: ManagedEntityStatus;
}
export type EventAlarmExpressionComparison = DynamicData &  {
  attributeName: string;
  operator: string;
  value: string;
}
export type ClusterDasAamHostInfo = ClusterDasHostInfo &  {
  hostDasState?: ClusterDasAamNodeState[];
  primaryHosts?: string[];
}
export type ClusterDasVmConfigSpec = ArrayUpdateSpec &  {
  info?: ClusterDasVmConfigInfo;
}
export type ClusterDpmHostConfigSpec = ArrayUpdateSpec &  {
  info?: ClusterDpmHostConfigInfo;
}
export type ClusterDrsVmConfigSpec = ArrayUpdateSpec &  {
  info?: ClusterDrsVmConfigInfo;
}
export type ClusterFailoverHostAdmissionControlInfo = ClusterDasAdmissionControlInfo &  {
  hostStatus?: ClusterFailoverHostAdmissionControlInfoHostStatus[];
}
export type ClusterFailoverHostAdmissionControlInfoHostStatus = DynamicData &  {
  host: HostSystem;
  status: ManagedEntityStatus;
}
export type ClusterFixedSizeSlotPolicy = ClusterSlotPolicy &  {
  cpu: number;
  memory: number;
}
export type ClusterGroupSpec = ArrayUpdateSpec &  {
  info?: ClusterGroupInfo;
}
export type PlacementSpec = DynamicData &  {
  priority?: VirtualMachineMovePriority;
  vm?: VirtualMachine;
  configSpec?: VirtualMachineConfigSpec;
  relocateSpec?: VirtualMachineRelocateSpec;
  hosts?: HostSystem[];
  datastores?: Datastore[];
  storagePods?: StoragePod[];
  disallowPrerequisiteMoves?: boolean;
  rules?: ClusterRuleInfo[];
  key?: string;
  placementType?: string;
  cloneSpec?: VirtualMachineCloneSpec;
  cloneName?: string;
}
export type ClusterRuleInfo = DynamicData &  {
  key?: number;
  status?: ManagedEntityStatus;
  enabled?: boolean;
  name?: string;
  mandatory?: boolean;
  userCreated?: boolean;
  inCompliance?: boolean;
  ruleUuid?: string;
}
export type ClusterRuleSpec = ArrayUpdateSpec &  {
  info?: ClusterRuleInfo;
}
export type ClusterVmHostRuleInfo = ClusterRuleInfo &  {
  vmGroupName?: string;
  affineHostGroupName?: string;
  antiAffineHostGroupName?: string;
}
export type ClusterVmOrchestrationSpec = ArrayUpdateSpec &  {
  info?: ClusterVmOrchestrationInfo;
}
export type DVPortgroupConfigInfo = DynamicData &  {
  key: string;
  name: string;
  numPorts: number;
  distributedVirtualSwitch?: DistributedVirtualSwitch;
  defaultPortConfig?: DVPortSetting;
  description?: string;
  type: string;
  backingType?: string;
  policy: DVPortgroupPolicy;
  portNameFormat?: string;
  scope?: ManagedEntity[];
  vendorSpecificConfig?: DistributedVirtualSwitchKeyedOpaqueBlob[];
  configVersion?: string;
  autoExpand?: boolean;
  vmVnicNetworkResourcePoolKey?: string;
  uplink?: boolean;
  transportZoneUuid?: string;
  transportZoneName?: string;
  logicalSwitchUuid?: string;
  segmentId?: string;
}
export type DVPortgroupConfigSpec = DynamicData &  {
  configVersion?: string;
  name?: string;
  numPorts?: number;
  portNameFormat?: string;
  defaultPortConfig?: DVPortSetting;
  description?: string;
  type?: string;
  backingType?: string;
  scope?: ManagedEntity[];
  policy?: DVPortgroupPolicy;
  vendorSpecificConfig?: DistributedVirtualSwitchKeyedOpaqueBlob[];
  autoExpand?: boolean;
  vmVnicNetworkResourcePoolKey?: string;
  transportZoneUuid?: string;
  transportZoneName?: string;
  logicalSwitchUuid?: string;
  segmentId?: string;
}
export type DistributedVirtualPortgroupNsxPortgroupOperationResult = DynamicData &  {
  portgroups?: DistributedVirtualPortgroup[];
  problems?: DistributedVirtualPortgroupProblem[];
}
export type DVPortgroupPolicy = DynamicData &  {
  blockOverrideAllowed: boolean;
  shapingOverrideAllowed: boolean;
  vendorConfigOverrideAllowed: boolean;
  livePortMovingAllowed: boolean;
  portConfigResetAtDisconnect: boolean;
  networkResourcePoolOverrideAllowed?: boolean;
  trafficFilterOverrideAllowed?: boolean;
}
export type DistributedVirtualPortgroupProblem = DynamicData &  {
  logicalSwitchUuid: string;
  fault: MethodFault;
}
export type CryptoManagerKmipCertificateInfo = DynamicData &  {
  subject: string;
  issuer: string;
  serialNumber: string;
  notBefore: Date;
  notAfter: Date;
  fingerprint: string;
  checkTime: Date;
  secondsSinceValid?: number;
  secondsBeforeExpire?: number;
}
export type CryptoManagerKmipClusterStatus = DynamicData &  {
  clusterId: KeyProviderId;
  overallStatus?: ManagedEntityStatus;
  managementType?: string;
  servers: CryptoManagerKmipServerStatus[];
  clientCertInfo?: CryptoManagerKmipCertificateInfo;
}
export type CryptoManagerKmipCryptoKeyStatus = DynamicData &  {
  keyId: CryptoKeyId;
  keyAvailable?: boolean;
  reason?: string;
  encryptedVMs?: VirtualMachine[];
  affectedHosts?: HostSystem[];
  referencedByTags?: string[];
}
export type CryptoManagerKmipServerCertInfo = DynamicData &  {
  certificate: string;
  certInfo?: CryptoManagerKmipCertificateInfo;
  clientTrustServer?: boolean;
}
export type CryptoManagerKmipServerStatus = DynamicData &  {
  name: string;
  status: ManagedEntityStatus;
  connectionStatus: string;
  certInfo?: CryptoManagerKmipCertificateInfo;
  clientTrustServer?: boolean;
  serverTrustClient?: boolean;
}
export type KmipServerStatus = DynamicData &  {
  clusterId: KeyProviderId;
  name: string;
  status: ManagedEntityStatus;
  description: string;
}
export type AccountCreatedEvent = HostEvent &  {
  spec: HostAccountSpec;
  group: boolean;
}
export type AccountRemovedEvent = HostEvent &  {
  account: string;
  group: boolean;
}
export type AccountUpdatedEvent = HostEvent &  {
  spec: HostAccountSpec;
  group: boolean;
  prevDescription?: string;
}
export type AdminPasswordNotChangedEvent = HostEvent &  {
  
}
export type AlarmEvent = Event &  {
  alarm: AlarmEventArgument;
}
export type AlarmReconfiguredEvent = AlarmEvent &  {
  entity: ManagedEntityEventArgument;
  configChanges?: ChangesInfoEventArgument;
}
export type AlarmRemovedEvent = AlarmEvent &  {
  entity: ManagedEntityEventArgument;
}
export type AlarmScriptCompleteEvent = AlarmEvent &  {
  entity: ManagedEntityEventArgument;
  script: string;
}
export type AlarmScriptFailedEvent = AlarmEvent &  {
  entity: ManagedEntityEventArgument;
  script: string;
  reason: MethodFault;
}
export type AlarmSnmpCompletedEvent = AlarmEvent &  {
  entity: ManagedEntityEventArgument;
}
export type AlarmSnmpFailedEvent = AlarmEvent &  {
  entity: ManagedEntityEventArgument;
  reason: MethodFault;
}
export type AlarmStatusChangedEvent = AlarmEvent &  {
  source: ManagedEntityEventArgument;
  entity: ManagedEntityEventArgument;
  from: string;
  to: string;
}
export type AllVirtualMachinesLicensedEvent = LicenseEvent &  {
  
}
export type AlreadyAuthenticatedSessionEvent = SessionEvent &  {
  
}
export type AuthorizationEvent = Event &  {
  
}
export type BadUsernameSessionEvent = SessionEvent &  {
  ipAddress: string;
}
export type CanceledHostOperationEvent = HostEvent &  {
  
}
export type ClusterEvent = Event &  {
  
}
export type ClusterOvercommittedEvent = ClusterEvent &  {
  
}
export type ClusterReconfiguredEvent = ClusterEvent &  {
  configChanges?: ChangesInfoEventArgument;
}
export type ClusterStatusChangedEvent = ClusterEvent &  {
  oldStatus: string;
  newStatus: string;
}
export type CustomFieldEvent = Event &  {
  
}
export type CustomFieldValueChangedEvent = CustomFieldEvent &  {
  entity: ManagedEntityEventArgument;
  fieldKey: number;
  name: string;
  value: string;
  prevState?: string;
}
export type CustomizationEvent = VmEvent &  {
  logLocation?: string;
}
export type CustomizationFailed = CustomizationEvent &  {
  reason?: string;
}
export type CustomizationLinuxIdentityFailed = CustomizationFailed &  {
  
}
export type CustomizationNetworkSetupFailed = CustomizationFailed &  {
  
}
export type CustomizationStartedEvent = CustomizationEvent &  {
  
}
export type CustomizationSucceeded = CustomizationEvent &  {
  
}
export type CustomizationSysprepFailed = CustomizationFailed &  {
  sysprepVersion: string;
  systemVersion: string;
}
export type CustomizationUnknownFailure = CustomizationFailed &  {
  
}
export type DVPortgroupEvent = Event &  {
  
}
export type DVPortgroupReconfiguredEvent = DVPortgroupEvent &  {
  configSpec: DVPortgroupConfigSpec;
  configChanges?: ChangesInfoEventArgument;
}
export type DVPortgroupRenamedEvent = DVPortgroupEvent &  {
  oldName: string;
  newName: string;
}
export type DasAdmissionControlDisabledEvent = ClusterEvent &  {
  
}
export type DasAdmissionControlEnabledEvent = ClusterEvent &  {
  
}
export type DasAgentFoundEvent = ClusterEvent &  {
  
}
export type DasAgentUnavailableEvent = ClusterEvent &  {
  
}
export type DasClusterIsolatedEvent = ClusterEvent &  {
  
}
export type DasDisabledEvent = ClusterEvent &  {
  
}
export type DasEnabledEvent = ClusterEvent &  {
  
}
export type DasHostFailedEvent = ClusterEvent &  {
  failedHost: HostEventArgument;
}
export type DasHostIsolatedEvent = ClusterEvent &  {
  isolatedHost: HostEventArgument;
}
export type DatacenterEvent = Event &  {
  
}
export type DatacenterRenamedEvent = DatacenterEvent &  {
  oldName: string;
  newName: string;
}
export type DatastoreDiscoveredEvent = HostEvent &  {
  datastore: DatastoreEventArgument;
}
export type DatastoreEvent = Event &  {
  datastore?: DatastoreEventArgument;
}
export type DatastoreFileEvent = DatastoreEvent &  {
  targetFile: string;
  sourceOfOperation?: string;
  succeeded?: boolean;
}
export type DatastoreFileMovedEvent = DatastoreFileEvent &  {
  sourceDatastore: DatastoreEventArgument;
  sourceFile: string;
}
export type DatastoreIORMReconfiguredEvent = DatastoreEvent &  {
  
}
export type DatastorePrincipalConfigured = HostEvent &  {
  datastorePrincipal: string;
}
export type DatastoreRemovedOnHostEvent = HostEvent &  {
  datastore: DatastoreEventArgument;
}
export type DatastoreRenamedEvent = DatastoreEvent &  {
  oldName: string;
  newName: string;
}
export type DatastoreRenamedOnHostEvent = HostEvent &  {
  oldName: string;
  newName: string;
}
export type DrsDisabledEvent = ClusterEvent &  {
  
}
export type DrsEnabledEvent = ClusterEvent &  {
  behavior: string;
}
export type DrsInvocationFailedEvent = ClusterEvent &  {
  
}
export type DrsRecoveredFromFailureEvent = ClusterEvent &  {
  
}
export type DrsResourceConfigureFailedEvent = HostEvent &  {
  reason: MethodFault;
}
export type DrsResourceConfigureSyncedEvent = HostEvent &  {
  
}
export type DrsRuleComplianceEvent = VmEvent &  {
  
}
export type DrsRuleViolationEvent = VmEvent &  {
  
}
export type DrsSoftRuleViolationEvent = VmEvent &  {
  
}
export type DrsVmMigratedEvent = VmMigratedEvent &  {
  
}
export type DrsVmPoweredOnEvent = VmPoweredOnEvent &  {
  
}
export type DuplicateIpDetectedEvent = HostEvent &  {
  duplicateIP: string;
  macAddress: string;
}
export type DvpgImportEvent = DVPortgroupEvent &  {
  importType: string;
}
export type DvpgRestoreEvent = DVPortgroupEvent &  {
  
}
export type DvsEvent = Event &  {
  
}
export type DvsHealthStatusChangeEvent = HostEvent &  {
  switchUuid: string;
  healthResult?: HostMemberHealthCheckResult;
}
export type DvsHostBackInSyncEvent = DvsEvent &  {
  hostBackInSync: HostEventArgument;
}
export type DvsHostJoinedEvent = DvsEvent &  {
  hostJoined: HostEventArgument;
}
export type DvsHostLeftEvent = DvsEvent &  {
  hostLeft: HostEventArgument;
}
export type DvsHostStatusUpdated = DvsEvent &  {
  hostMember: HostEventArgument;
  oldStatus?: string;
  newStatus?: string;
  oldStatusDetail?: string;
  newStatusDetail?: string;
}
export type DvsHostWentOutOfSyncEvent = DvsEvent &  {
  hostOutOfSync: DvsOutOfSyncHostArgument;
}
export type DvsImportEvent = DvsEvent &  {
  importType: string;
}
export type DvsMergedEvent = DvsEvent &  {
  sourceDvs: DvsEventArgument;
  destinationDvs: DvsEventArgument;
}
export type DvsPortBlockedEvent = DvsEvent &  {
  portKey: string;
  statusDetail?: string;
  runtimeInfo?: DVPortStatus;
  prevBlockState?: string;
}
export type DvsPortConnectedEvent = DvsEvent &  {
  portKey: string;
  connectee?: DistributedVirtualSwitchPortConnectee;
}
export type DvsPortCreatedEvent = DvsEvent &  {
  portKey: string[];
}
export type DvsPortDeletedEvent = DvsEvent &  {
  portKey: string[];
}
export type DvsPortDisconnectedEvent = DvsEvent &  {
  portKey: string;
  connectee?: DistributedVirtualSwitchPortConnectee;
}
export type DvsPortEnteredPassthruEvent = DvsEvent &  {
  portKey: string;
  runtimeInfo?: DVPortStatus;
}
export type DvsPortExitedPassthruEvent = DvsEvent &  {
  portKey: string;
  runtimeInfo?: DVPortStatus;
}
export type DvsPortJoinPortgroupEvent = DvsEvent &  {
  portKey: string;
  portgroupKey: string;
  portgroupName: string;
}
export type DvsPortLeavePortgroupEvent = DvsEvent &  {
  portKey: string;
  portgroupKey: string;
  portgroupName: string;
}
export type DvsPortLinkDownEvent = DvsEvent &  {
  portKey: string;
  runtimeInfo?: DVPortStatus;
}
export type DvsPortLinkUpEvent = DvsEvent &  {
  portKey: string;
  runtimeInfo?: DVPortStatus;
}
export type DvsPortReconfiguredEvent = DvsEvent &  {
  portKey: string[];
  configChanges?: ChangesInfoEventArgument[];
}
export type DvsPortRuntimeChangeEvent = DvsEvent &  {
  portKey: string;
  runtimeInfo: DVPortStatus;
}
export type DvsPortUnblockedEvent = DvsEvent &  {
  portKey: string;
  runtimeInfo?: DVPortStatus;
  prevBlockState?: string;
}
export type DvsPortVendorSpecificStateChangeEvent = DvsEvent &  {
  portKey: string;
}
export type DvsRenamedEvent = DvsEvent &  {
  oldName: string;
  newName: string;
}
export type DvsRestoreEvent = DvsEvent &  {
  
}
export type DvsUpgradeAvailableEvent = DvsEvent &  {
  productInfo: DistributedVirtualSwitchProductSpec;
}
export type DvsUpgradeInProgressEvent = DvsEvent &  {
  productInfo: DistributedVirtualSwitchProductSpec;
}
export type DvsUpgradeRejectedEvent = DvsEvent &  {
  productInfo: DistributedVirtualSwitchProductSpec;
}
export type DvsUpgradedEvent = DvsEvent &  {
  productInfo: DistributedVirtualSwitchProductSpec;
}
export type EnteredMaintenanceModeEvent = HostEvent &  {
  
}
export type EnteredStandbyModeEvent = HostEvent &  {
  
}
export type EnteringMaintenanceModeEvent = HostEvent &  {
  
}
export type EnteringStandbyModeEvent = HostEvent &  {
  
}
export type EntityEventArgument = EventArgument &  {
  name: string;
}
export type ErrorUpgradeEvent = UpgradeEvent &  {
  
}
export type ExitMaintenanceModeEvent = HostEvent &  {
  
}
export type ExitStandbyModeFailedEvent = HostEvent &  {
  
}
export type ExitedStandbyModeEvent = HostEvent &  {
  
}
export type ExitingStandbyModeEvent = HostEvent &  {
  
}
export type ExtendedEvent = GeneralEvent &  {
  eventTypeId: string;
  managedObject: ManagedObject;
  data?: ExtendedEventPair[];
}
export type ExtendedEventPair = DynamicData &  {
  key: string;
  value: string;
}
export type FailoverLevelRestored = ClusterEvent &  {
  
}
export type FolderEventArgument = EntityEventArgument &  {
  folder: Folder;
}
export type GhostDvsProxySwitchDetectedEvent = HostEvent &  {
  switchUuid: string[];
}
export type GhostDvsProxySwitchRemovedEvent = HostEvent &  {
  switchUuid: string[];
}
export type GlobalMessageChangedEvent = SessionEvent &  {
  message: string;
  prevMessage?: string;
}
export type HostAddFailedEvent = HostEvent &  {
  hostname: string;
}
export type HostAddedEvent = HostEvent &  {
  
}
export type HostAdminDisableEvent = HostEvent &  {
  
}
export type HostAdminEnableEvent = HostEvent &  {
  
}
export type HostCnxFailedAccountFailedEvent = HostEvent &  {
  
}
export type HostCnxFailedAlreadyManagedEvent = HostEvent &  {
  serverName: string;
}
export type HostCnxFailedBadCcagentEvent = HostEvent &  {
  
}
export type HostCnxFailedBadUsernameEvent = HostEvent &  {
  
}
export type HostCnxFailedBadVersionEvent = HostEvent &  {
  
}
export type HostCnxFailedCcagentUpgradeEvent = HostEvent &  {
  
}
export type HostCnxFailedEvent = HostEvent &  {
  
}
export type HostCnxFailedNetworkErrorEvent = HostEvent &  {
  
}
export type HostCnxFailedNoAccessEvent = HostEvent &  {
  
}
export type HostCnxFailedNoConnectionEvent = HostEvent &  {
  
}
export type HostCnxFailedNoLicenseEvent = HostEvent &  {
  
}
export type HostCnxFailedNotFoundEvent = HostEvent &  {
  
}
export type HostCnxFailedTimeoutEvent = HostEvent &  {
  
}
export type HostComplianceCheckedEvent = HostEvent &  {
  profile: ProfileEventArgument;
}
export type HostCompliantEvent = HostEvent &  {
  
}
export type HostConfigAppliedEvent = HostEvent &  {
  
}
export type HostConnectedEvent = HostEvent &  {
  
}
export type HostConnectionLostEvent = HostEvent &  {
  
}
export type HostDasDisabledEvent = HostEvent &  {
  
}
export type HostDasDisablingEvent = HostEvent &  {
  
}
export type HostDasEnabledEvent = HostEvent &  {
  
}
export type HostDasEnablingEvent = HostEvent &  {
  
}
export type HostDasErrorEvent = HostEvent &  {
  message?: string;
  reason?: string;
}
export type HostDasEvent = HostEvent &  {
  
}
export type HostDasOkEvent = HostEvent &  {
  
}
export type HostDisconnectedEvent = HostEvent &  {
  reason?: string;
}
export type HostEnableAdminFailedEvent = HostEvent &  {
  permissions: Permission[];
}
export type HostEventArgument = EntityEventArgument &  {
  host: HostSystem;
}
export type HostExtraNetworksEvent = HostDasEvent &  {
  ips?: string;
}
export type HostInventoryFullEvent = LicenseEvent &  {
  capacity: number;
}
export type HostIsolationIpPingFailedEvent = HostDasEvent &  {
  isolationIp: string;
}
export type HostLicenseExpiredEvent = LicenseEvent &  {
  
}
export type HostLocalPortCreatedEvent = DvsEvent &  {
  hostLocalPort: DVSHostLocalPortInfo;
}
export type HostMissingNetworksEvent = HostDasEvent &  {
  ips?: string;
}
export type HostMonitoringStateChangedEvent = ClusterEvent &  {
  state: string;
  prevState?: string;
}
export type HostNoAvailableNetworksEvent = HostDasEvent &  {
  ips?: string;
}
export type HostNoHAEnabledPortGroupsEvent = HostDasEvent &  {
  
}
export type HostNoRedundantManagementNetworkEvent = HostDasEvent &  {
  
}
export type HostNotInClusterEvent = HostDasEvent &  {
  
}
export type HostOvercommittedEvent = ClusterOvercommittedEvent &  {
  
}
export type HostPrimaryAgentNotShortNameEvent = HostDasEvent &  {
  primaryAgent: string;
}
export type HostShortNameInconsistentEvent = HostDasEvent &  {
  shortName: string;
  shortName2: string;
}
export type HostStatusChangedEvent = ClusterStatusChangedEvent &  {
  
}
export type IncorrectHostInformationEvent = LicenseEvent &  {
  
}
export type InfoUpgradeEvent = UpgradeEvent &  {
  
}
export type InsufficientFailoverResourcesEvent = ClusterEvent &  {
  
}
export type InvalidEditionEvent = LicenseEvent &  {
  feature: string;
}
export type ManagedEntityEventArgument = EntityEventArgument &  {
  entity: ManagedEntity;
}
export type MigrationEvent = VmEvent &  {
  fault: MethodFault;
}
export type MigrationHostErrorEvent = MigrationEvent &  {
  dstHost: HostEventArgument;
}
export type MigrationHostWarningEvent = MigrationEvent &  {
  dstHost: HostEventArgument;
}
export type MigrationResourceErrorEvent = MigrationEvent &  {
  dstPool: ResourcePoolEventArgument;
  dstHost: HostEventArgument;
}
export type MigrationResourceWarningEvent = MigrationEvent &  {
  dstPool: ResourcePoolEventArgument;
  dstHost: HostEventArgument;
}
export type MigrationWarningEvent = MigrationEvent &  {
  
}
export type MtuMatchEvent = DvsHealthStatusChangeEvent &  {
  
}
export type MtuMismatchEvent = DvsHealthStatusChangeEvent &  {
  
}
export type NetworkEventArgument = EntityEventArgument &  {
  network: Network;
}
export type NoAccessUserEvent = SessionEvent &  {
  ipAddress: string;
}
export type NoMaintenanceModeDrsRecommendationForVM = VmEvent &  {
  
}
export type NonVIWorkloadDetectedOnDatastoreEvent = DatastoreEvent &  {
  
}
export type NotEnoughResourcesToStartVmEvent = VmEvent &  {
  reason: string;
}
export type OutOfSyncDvsHost = DvsEvent &  {
  hostOutOfSync: DvsOutOfSyncHostArgument[];
}
export type PermissionEvent = AuthorizationEvent &  {
  entity: ManagedEntityEventArgument;
  principal: string;
  group: boolean;
}
export type PermissionRemovedEvent = PermissionEvent &  {
  
}
export type PermissionUpdatedEvent = PermissionEvent &  {
  role: RoleEventArgument;
  propagate: boolean;
  prevRole?: RoleEventArgument;
  prevPropagate?: boolean;
}
export type ProfileAssociatedEvent = ProfileEvent &  {
  
}
export type ProfileChangedEvent = ProfileEvent &  {
  
}
export type ProfileCreatedEvent = ProfileEvent &  {
  
}
export type ProfileDissociatedEvent = ProfileEvent &  {
  
}
export type RecoveryEvent = DvsEvent &  {
  hostName: string;
  portKey: string;
  dvsUuid?: string;
  vnic?: string;
}
export type ResourcePoolCreatedEvent = ResourcePoolEvent &  {
  parent: ResourcePoolEventArgument;
}
export type ResourcePoolDestroyedEvent = ResourcePoolEvent &  {
  
}
export type ResourcePoolEventArgument = EntityEventArgument &  {
  resourcePool: ResourcePool;
}
export type RoleEvent = AuthorizationEvent &  {
  role: RoleEventArgument;
}
export type RoleRemovedEvent = RoleEvent &  {
  
}
export type RoleUpdatedEvent = RoleEvent &  {
  privilegeList?: string[];
  prevRoleName?: string;
  privilegesAdded?: string[];
  privilegesRemoved?: string[];
}
export type RollbackEvent = DvsEvent &  {
  hostName: string;
  methodName?: string;
}
export type ScheduledTaskCompletedEvent = ScheduledTaskEvent &  {
  
}
export type ScheduledTaskCreatedEvent = ScheduledTaskEvent &  {
  
}
export type ScheduledTaskEmailCompletedEvent = ScheduledTaskEvent &  {
  to: string;
}
export type ScheduledTaskEmailFailedEvent = ScheduledTaskEvent &  {
  to: string;
  reason: MethodFault;
}
export type ScheduledTaskEventArgument = EntityEventArgument &  {
  scheduledTask: ScheduledTask;
}
export type ServerStartedSessionEvent = SessionEvent &  {
  
}
export type TeamingMatchEvent = DvsHealthStatusChangeEvent &  {
  
}
export type TeamingMisMatchEvent = DvsHealthStatusChangeEvent &  {
  
}
export type TemplateBeingUpgradedEvent = TemplateUpgradeEvent &  {
  
}
export type UplinkPortMtuNotSupportEvent = DvsHealthStatusChangeEvent &  {
  
}
export type UplinkPortMtuSupportEvent = DvsHealthStatusChangeEvent &  {
  
}
export type UplinkPortVlanTrunkedEvent = DvsHealthStatusChangeEvent &  {
  
}
export type UplinkPortVlanUntrunkedEvent = DvsHealthStatusChangeEvent &  {
  
}
export type VmAcquiredMksTicketEvent = VmEvent &  {
  
}
export type VmAcquiredTicketEvent = VmEvent &  {
  ticketType: string;
}
export type VmAutoRenameEvent = VmEvent &  {
  oldName: string;
  newName: string;
}
export type VmBeingCreatedEvent = VmEvent &  {
  configSpec?: VirtualMachineConfigSpec;
}
export type VmBeingDeployedEvent = VmEvent &  {
  srcTemplate: VmEventArgument;
}
export type VmBeingHotMigratedEvent = VmEvent &  {
  destHost: HostEventArgument;
  destDatacenter?: DatacenterEventArgument;
  destDatastore?: DatastoreEventArgument;
}
export type VmBeingMigratedEvent = VmEvent &  {
  destHost: HostEventArgument;
  destDatacenter?: DatacenterEventArgument;
  destDatastore?: DatastoreEventArgument;
}
export type VmBeingRelocatedEvent = VmRelocateSpecEvent &  {
  destHost: HostEventArgument;
  destDatacenter?: DatacenterEventArgument;
  destDatastore?: DatastoreEventArgument;
}
export type VmCloneEvent = VmEvent &  {
  
}
export type VmCloneFailedEvent = VmCloneEvent &  {
  destFolder: FolderEventArgument;
  destName: string;
  destHost: HostEventArgument;
  reason: MethodFault;
}
export type VmClonedEvent = VmCloneEvent &  {
  sourceVm: VmEventArgument;
}
export type VmConfigMissingEvent = VmEvent &  {
  
}
export type VmConnectedEvent = VmEvent &  {
  
}
export type VmCreatedEvent = VmEvent &  {
  
}
export type VmDasBeingResetEvent = VmEvent &  {
  reason?: string;
}
export type VmDasBeingResetWithScreenshotEvent = VmDasBeingResetEvent &  {
  screenshotFilePath: string;
}
export type VmDasResetFailedEvent = VmEvent &  {
  
}
export type VmDasUpdateErrorEvent = VmEvent &  {
  
}
export type VmDasUpdateOkEvent = VmEvent &  {
  
}
export type VmDateRolledBackEvent = VmEvent &  {
  
}
export type VmDeployFailedEvent = VmEvent &  {
  destDatastore: EntityEventArgument;
  reason: MethodFault;
}
export type VmDeployedEvent = VmEvent &  {
  srcTemplate: VmEventArgument;
}
export type VmDisconnectedEvent = VmEvent &  {
  
}
export type VmDiscoveredEvent = VmEvent &  {
  
}
export type VmDiskFailedEvent = VmEvent &  {
  disk: string;
  reason: MethodFault;
}
export type VmEmigratingEvent = VmEvent &  {
  
}
export type VmEndRecordingEvent = VmEvent &  {
  
}
export type VmEndReplayingEvent = VmEvent &  {
  
}
export type VmEventArgument = EntityEventArgument &  {
  vm: VirtualMachine;
}
export type VmFaultToleranceStateChangedEvent = VmEvent &  {
  oldState: VirtualMachineFaultToleranceState;
  newState: VirtualMachineFaultToleranceState;
}
export type VmHealthMonitoringStateChangedEvent = ClusterEvent &  {
  state: string;
  prevState?: string;
}
export type VmPowerOffOnIsolationEvent = VmPoweredOffEvent &  {
  isolatedHost: HostEventArgument;
}
export type VmRelocateFailedEvent = VmRelocateSpecEvent &  {
  destHost: HostEventArgument;
  reason: MethodFault;
  destDatacenter?: DatacenterEventArgument;
  destDatastore?: DatastoreEventArgument;
}
export type VmVnicPoolReservationViolationClearEvent = DvsEvent &  {
  vmVnicResourcePoolKey: string;
  vmVnicResourcePoolName?: string;
}
export type VmVnicPoolReservationViolationRaiseEvent = DvsEvent &  {
  vmVnicResourcePoolKey: string;
  vmVnicResourcePoolName?: string;
}
export type ActiveDirectoryFault = VimFault &  {
  errorCode?: number;
}
export type AlreadyExists = VimFault &  {
  name?: string;
}
export type AlreadyUpgraded = VimFault &  {
  
}
export type AnswerFileUpdateFailed = VimFault &  {
  failure: AnswerFileUpdateFailure[];
}
export type AnswerFileUpdateFailure = DynamicData &  {
  userInputPath: ProfilePropertyPath;
  errMsg: LocalizableMessage;
}
export type AuthMinimumAdminPermission = VimFault &  {
  
}
export type CannotAccessLocalSource = VimFault &  {
  
}
export type CannotAccessVmComponent = VmConfigFault &  {
  
}
export type CannotAccessVmConfig = CannotAccessVmComponent &  {
  reason: MethodFault;
}
export type CannotAccessVmDevice = CannotAccessVmComponent &  {
  device: string;
  backing: string;
  connected: boolean;
}
export type CannotAccessVmDisk = CannotAccessVmDevice &  {
  fault: MethodFault;
}
export type CannotChangeDrsBehaviorForFtSecondary = VmFaultToleranceIssue &  {
  vm: VirtualMachine;
  vmName: string;
}
export type CannotChangeHaSettingsForFtSecondary = VmFaultToleranceIssue &  {
  vm: VirtualMachine;
  vmName: string;
}
export type CannotChangeVsanClusterUuid = VsanFault &  {
  
}
export type CannotChangeVsanNodeUuid = VsanFault &  {
  
}
export type CannotComputeFTCompatibleHosts = VmFaultToleranceIssue &  {
  vm: VirtualMachine;
  vmName: string;
}
export type CannotDisableSnapshot = VmConfigFault &  {
  
}
export type CannotDisconnectHostWithFaultToleranceVm = VimFault &  {
  hostName: string;
}
export type CannotEnableVmcpForCluster = VimFault &  {
  host?: HostSystem;
  hostName?: string;
  reason?: string;
}
export type CannotMoveFaultToleranceVm = VimFault &  {
  moveType: string;
  vmName: string;
}
export type CannotMoveHostWithFaultToleranceVm = VimFault &  {
  
}
export type CannotMoveVsanEnabledHost = VsanFault &  {
  
}
export type CannotPlaceWithoutPrerequisiteMoves = VimFault &  {
  
}
export type CannotReconfigureVsanWhenHaEnabled = VsanFault &  {
  
}
export type CannotUseNetwork = VmConfigFault &  {
  device: string;
  backing: string;
  connected: boolean;
  reason: string;
  network?: Network;
}
export type ConcurrentAccess = VimFault &  {
  
}
export type CpuHotPlugNotSupported = VmConfigFault &  {
  
}
export type CustomizationFault = VimFault &  {
  
}
export type CustomizationPending = CustomizationFault &  {
  
}
export type DasConfigFault = VimFault &  {
  reason?: string;
  output?: string;
  event?: Event[];
}
export type DeltaDiskFormatNotSupported = VmConfigFault &  {
  datastore?: Datastore[];
  deltaDiskFormat: string;
}
export type DestinationVsanDisabled = CannotMoveVsanEnabledHost &  {
  destinationCluster: string;
}
export type DomainNotFound = ActiveDirectoryFault &  {
  domainName: string;
}
export type DrsDisabledOnVm = VimFault &  {
  
}
export type DuplicateName = VimFault &  {
  name: string;
  object: ManagedObject;
}
export type DuplicateVsanNetworkInterface = VsanFault &  {
  device: string;
}
export type DvsFault = VimFault &  {
  
}
export type DvsNotAuthorized = DvsFault &  {
  sessionExtensionKey?: string;
  dvsExtensionKey?: string;
}
export type DvsOperationBulkFault = DvsFault &  {
  hostFault: DvsOperationBulkFaultFaultOnHost[];
}
export type DvsOperationBulkFaultFaultOnHost = DynamicData &  {
  host: HostSystem;
  fault: MethodFault;
}
export type DvsScopeViolated = DvsFault &  {
  scope: ManagedEntity[];
  entity: ManagedEntity;
}
export type EVCConfigFault = VimFault &  {
  faults?: MethodFault[];
}
export type EVCModeIllegalByVendor = EVCConfigFault &  {
  clusterCPUVendor: string;
  modeCPUVendor: string;
}
export type EVCModeUnsupportedByHosts = EVCConfigFault &  {
  evcMode?: string;
  host?: HostSystem[];
  hostName?: string[];
}
export type EVCUnsupportedByHostHardware = EVCConfigFault &  {
  host: HostSystem[];
  hostName: string[];
}
export type EVCUnsupportedByHostSoftware = EVCConfigFault &  {
  host: HostSystem[];
  hostName: string[];
}
export type EightHostLimitViolated = VmConfigFault &  {
  
}
export type ExpiredAddonLicense = ExpiredFeatureLicense &  {
  
}
export type ExpiredEditionLicense = ExpiredFeatureLicense &  {
  
}
export type ExtendedFault = VimFault &  {
  faultTypeId: string;
  data?: KeyValue[];
}
export type FaultToleranceCannotEditMem = VmConfigFault &  {
  vmName: string;
  vm: VirtualMachine;
}
export type FaultToleranceNotLicensed = VmFaultToleranceIssue &  {
  hostName?: string;
}
export type FaultTolerancePrimaryPowerOnNotAttempted = VmFaultToleranceIssue &  {
  secondaryVm: VirtualMachine;
  primaryVm: VirtualMachine;
}
export type FaultToleranceVmNotDasProtected = VimFault &  {
  vm: VirtualMachine;
  vmName: string;
}
export type FcoeFault = VimFault &  {
  
}
export type FcoeFaultPnicHasNoPortSet = FcoeFault &  {
  nicDevice: string;
}
export type FileFault = VimFault &  {
  file: string;
}
export type FileLocked = FileFault &  {
  
}
export type FileNameTooLong = FileFault &  {
  
}
export type FileNotFound = FileFault &  {
  
}
export type FileNotWritable = FileFault &  {
  
}
export type FileTooLarge = FileFault &  {
  datastore: string;
  fileSize: number;
  maxFileSize?: number;
}
export type FtIssuesOnHost = VmFaultToleranceIssue &  {
  host: HostSystem;
  hostName: string;
  errors?: MethodFault[];
}
export type GenericDrsFault = VimFault &  {
  hostFaults?: MethodFault[];
}
export type GenericVmConfigFault = VmConfigFault &  {
  reason: string;
}
export type GuestOperationsFault = VimFault &  {
  
}
export type GuestOperationsUnavailable = GuestOperationsFault &  {
  
}
export type GuestPermissionDenied = GuestOperationsFault &  {
  
}
export type GuestProcessNotFound = GuestOperationsFault &  {
  pid: number;
}
export type GuestRegistryFault = GuestOperationsFault &  {
  windowsSystemErrorCode: number;
}
export type GuestRegistryKeyFault = GuestRegistryFault &  {
  keyName: string;
}
export type GuestRegistryKeyHasSubkeys = GuestRegistryKeyFault &  {
  
}
export type GuestRegistryKeyInvalid = GuestRegistryKeyFault &  {
  
}
export type GuestRegistryKeyParentVolatile = GuestRegistryKeyFault &  {
  
}
export type GuestRegistryValueFault = GuestRegistryFault &  {
  keyName: string;
  valueName: string;
}
export type GuestRegistryValueNotFound = GuestRegistryValueFault &  {
  
}
export type HeterogenousHostsBlockingEVC = EVCConfigFault &  {
  
}
export type HostConfigFault = VimFault &  {
  
}
export type HostConnectFault = VimFault &  {
  
}
export type HostHasComponentFailure = VimFault &  {
  hostName: string;
  componentType: string;
  componentName: string;
}
export type HostInDomain = HostConfigFault &  {
  
}
export type HostIncompatibleForFaultTolerance = VmFaultToleranceIssue &  {
  hostName?: string;
  reason?: string;
}
export type HostIncompatibleForRecordReplay = VimFault &  {
  hostName?: string;
  reason?: string;
}
export type HostPowerOpFailed = VimFault &  {
  
}
export type HostSpecificationOperationFailed = VimFault &  {
  host: HostSystem;
}
export type HttpFault = VimFault &  {
  statusCode: number;
  statusMessage: string;
}
export type IORMNotSupportedHostOnDatastore = VimFault &  {
  datastore: Datastore;
  datastoreName: string;
  host?: HostSystem[];
}
export type ImportHostAddFailure = DvsFault &  {
  hostIp: string[];
}
export type ImportOperationBulkFault = DvsFault &  {
  importFaults: ImportOperationBulkFaultFaultOnImport[];
}
export type ImportOperationBulkFaultFaultOnImport = DynamicData &  {
  entityType?: string;
  key?: string;
  fault: MethodFault;
}
export type InaccessibleVFlashSource = VimFault &  {
  hostName: string;
}
export type IncompatibleHostForFtSecondary = VmFaultToleranceIssue &  {
  host: HostSystem;
  error?: MethodFault[];
}
export type IncorrectFileType = FileFault &  {
  
}
export type InsufficientResourcesFault = VimFault &  {
  
}
export type InsufficientStandbyResource = InsufficientResourcesFault &  {
  
}
export type InsufficientStorageIops = VimFault &  {
  unreservedIops: number;
  requestedIops: number;
  datastoreName: string;
}
export type InsufficientStorageSpace = InsufficientResourcesFault &  {
  
}
export type InsufficientVFlashResourcesFault = InsufficientResourcesFault &  {
  freeSpaceInMB?: number;
  freeSpace: number;
  requestedSpaceInMB?: number;
  requestedSpace: number;
}
export type InvalidAffinitySettingFault = VimFault &  {
  
}
export type InvalidBmcRole = VimFault &  {
  
}
export type InvalidCAMServer = ActiveDirectoryFault &  {
  camServer: string;
}
export type InvalidDatastore = VimFault &  {
  datastore?: Datastore;
  name?: string;
}
export type InvalidDatastorePath = InvalidDatastore &  {
  datastorePath: string;
}
export type InvalidEvent = VimFault &  {
  
}
export type InvalidFolder = VimFault &  {
  target: ManagedEntity;
}
export type InvalidFormat = VmConfigFault &  {
  
}
export type InvalidGuestLogin = GuestOperationsFault &  {
  
}
export type InvalidHostName = HostConfigFault &  {
  
}
export type InvalidIpfixConfig = DvsFault &  {
  property?: string;
}
export type InvalidIpmiLoginInfo = VimFault &  {
  
}
export type InvalidIpmiMacAddress = VimFault &  {
  userProvidedMacAddress: string;
  observedMacAddress: string;
}
export type InvalidLicense = VimFault &  {
  licenseContent: string;
}
export type InvalidLocale = VimFault &  {
  
}
export type InvalidLogin = VimFault &  {
  
}
export type InvalidName = VimFault &  {
  name: string;
  entity?: ManagedEntity;
}
export type InvalidOperationOnSecondaryVm = VmFaultToleranceIssue &  {
  instanceUuid: string;
}
export type InvalidPrivilege = VimFault &  {
  privilege: string;
}
export type InvalidResourcePoolStructureFault = InsufficientResourcesFault &  {
  
}
export type InvalidSnapshotFormat = InvalidFormat &  {
  
}
export type InvalidState = VimFault &  {
  
}
export type InvalidVmConfig = VmConfigFault &  {
  property?: string;
}
export type InvalidVmState = InvalidState &  {
  vm: VirtualMachine;
}
export type IpHostnameGeneratorError = CustomizationFault &  {
  
}
export type IscsiFault = VimFault &  {
  
}
export type IscsiFaultInvalidVnic = IscsiFault &  {
  vnicDevice: string;
}
export type IscsiFaultPnicInUse = IscsiFault &  {
  pnicDevice: string;
}
export type IscsiFaultVnicAlreadyBound = IscsiFault &  {
  vnicDevice: string;
}
export type IscsiFaultVnicHasActivePaths = IscsiFault &  {
  vnicDevice: string;
}
export type IscsiFaultVnicHasMultipleUplinks = IscsiFault &  {
  vnicDevice: string;
}
export type IscsiFaultVnicHasNoUplinks = IscsiFault &  {
  vnicDevice: string;
}
export type IscsiFaultVnicHasWrongUplink = IscsiFault &  {
  vnicDevice: string;
}
export type IscsiFaultVnicInUse = IscsiFault &  {
  vnicDevice: string;
}
export type IscsiFaultVnicIsLastPath = IscsiFault &  {
  vnicDevice: string;
}
export type IscsiFaultVnicNotBound = IscsiFault &  {
  vnicDevice: string;
}
export type IscsiFaultVnicNotFound = IscsiFault &  {
  vnicDevice: string;
}
export type KeyNotFound = VimFault &  {
  key: string;
}
export type LargeRDMNotSupportedOnDatastore = VmConfigFault &  {
  device: string;
  datastore: Datastore;
  datastoreName: string;
}
export type LicenseEntityNotFound = VimFault &  {
  entityId: string;
}
export type LicenseServerUnavailable = VimFault &  {
  licenseServer: string;
}
export type LimitExceeded = VimFault &  {
  property?: string;
  limit?: number;
}
export type LinuxVolumeNotClean = CustomizationFault &  {
  
}
export type LogBundlingFailed = VimFault &  {
  
}
export type MemoryHotPlugNotSupported = VmConfigFault &  {
  
}
export type MigrationFault = VimFault &  {
  
}
export type MigrationFeatureNotSupported = MigrationFault &  {
  atSourceHost: boolean;
  failedHostName: string;
  failedHost: HostSystem;
}
export type MigrationNotReady = MigrationFault &  {
  reason: string;
}
export type MismatchedBundle = VimFault &  {
  bundleUuid: string;
  hostUuid: string;
  bundleBuildNumber: number;
  hostBuildNumber: number;
}
export type MismatchedNetworkPolicies = MigrationFault &  {
  device: string;
  backing: string;
  connected: boolean;
}
export type MismatchedVMotionNetworkNames = MigrationFault &  {
  sourceNetwork: string;
  destNetwork: string;
}
export type MissingBmcSupport = VimFault &  {
  
}
export type MissingLinuxCustResources = CustomizationFault &  {
  
}
export type MissingWindowsCustResources = CustomizationFault &  {
  
}
export type MksConnectionLimitReached = InvalidState &  {
  connectionLimit: number;
}
export type MountError = CustomizationFault &  {
  vm: VirtualMachine;
  diskIndex: number;
}
export type MultipleCertificatesVerifyFault = HostConnectFault &  {
  thumbprintData: MultipleCertificatesVerifyFaultThumbprintData[];
}
export type MultipleCertificatesVerifyFaultThumbprintData = DynamicData &  {
  port: number;
  thumbprint: string;
}
export type NamespaceFull = VimFault &  {
  name: string;
  currentMaxSize: number;
  requiredSize?: number;
}
export type NamespaceLimitReached = VimFault &  {
  limit?: number;
}
export type NamespaceWriteProtected = VimFault &  {
  name: string;
}
export type NasConfigFault = HostConfigFault &  {
  name: string;
}
export type NasConnectionLimitReached = NasConfigFault &  {
  remoteHost: string;
  remotePath: string;
}
export type NasSessionCredentialConflict = NasConfigFault &  {
  remoteHost: string;
  remotePath: string;
  userName: string;
}
export type NasVolumeNotMounted = NasConfigFault &  {
  remoteHost: string;
  remotePath: string;
}
export type NetworkCopyFault = FileFault &  {
  
}
export type NetworkDisruptedAndConfigRolledBack = VimFault &  {
  host: string;
}
export type NetworkInaccessible = NasConfigFault &  {
  
}
export type NetworksMayNotBeTheSame = MigrationFault &  {
  name?: string;
}
export type NicSettingMismatch = CustomizationFault &  {
  numberOfNicsInSpec: number;
  numberOfNicsInVM: number;
}
export type NoActiveHostInCluster = InvalidState &  {
  computeResource: ComputeResource;
}
export type NoClientCertificate = VimFault &  {
  
}
export type NoCompatibleDatastore = VimFault &  {
  
}
export type NoCompatibleHardAffinityHost = VmConfigFault &  {
  vmName: string;
}
export type NoCompatibleHost = VimFault &  {
  host?: HostSystem[];
  error?: MethodFault[];
}
export type NoCompatibleHostWithAccessToDevice = NoCompatibleHost &  {
  
}
export type NoCompatibleSoftAffinityHost = VmConfigFault &  {
  vmName: string;
}
export type NoConnectedDatastore = VimFault &  {
  
}
export type NoDiskFound = VimFault &  {
  
}
export type NoDiskSpace = FileFault &  {
  datastore: string;
}
export type NoDisksToCustomize = CustomizationFault &  {
  
}
export type NoGateway = HostConfigFault &  {
  
}
export type NoGuestHeartbeat = MigrationFault &  {
  
}
export type NoHost = HostConnectFault &  {
  name?: string;
}
export type NoHostSuitableForFtSecondary = VmFaultToleranceIssue &  {
  vm: VirtualMachine;
  vmName: string;
}
export type NoPeerHostFound = HostPowerOpFailed &  {
  
}
export type NoPermissionOnAD = ActiveDirectoryFault &  {
  
}
export type NoPermissionOnHost = HostConnectFault &  {
  
}
export type NoPermissionOnNasVolume = NasConfigFault &  {
  userName?: string;
}
export type NoSubjectName = VimFault &  {
  
}
export type NoVirtualNic = HostConfigFault &  {
  
}
export type NonADUserRequired = ActiveDirectoryFault &  {
  
}
export type NonHomeRDMVMotionNotSupported = MigrationFeatureNotSupported &  {
  device: string;
}
export type NotADirectory = FileFault &  {
  
}
export type NotAFile = FileFault &  {
  
}
export type NotFound = VimFault &  {
  
}
export type NotSupportedDeviceForFT = VmFaultToleranceIssue &  {
  host: HostSystem;
  hostName?: string;
  vm: VirtualMachine;
  vmName?: string;
  deviceType: string;
  deviceLabel?: string;
}
export type NotSupportedHost = HostConnectFault &  {
  productName?: string;
  productVersion?: string;
}
export type NotSupportedHostForChecksum = VimFault &  {
  
}
export type NotSupportedHostForVFlash = NotSupportedHost &  {
  hostName: string;
}
export type NotSupportedHostForVmcp = NotSupportedHost &  {
  hostName: string;
}
export type NotSupportedHostForVmemFile = NotSupportedHost &  {
  hostName: string;
}
export type NotSupportedHostForVsan = NotSupportedHost &  {
  hostName: string;
}
export type NotSupportedHostInCluster = NotSupportedHost &  {
  
}
export type NotSupportedHostInDvs = NotSupportedHost &  {
  switchProductSpec: DistributedVirtualSwitchProductSpec;
}
export type NotSupportedHostInHACluster = NotSupportedHost &  {
  hostName: string;
  build: string;
}
export type NumVirtualCpusExceedsLimit = InsufficientResourcesFault &  {
  maxSupportedVcpus: number;
}
export type NumVirtualCpusIncompatible = VmConfigFault &  {
  reason: string;
  numCpu: number;
}
export type OperationDisabledByGuest = GuestOperationsFault &  {
  
}
export type OperationNotSupportedByGuest = GuestOperationsFault &  {
  
}
export type OutOfBounds = VimFault &  {
  argumentName: string;
}
export type OvfConsumerPowerOnFault = InvalidState &  {
  extensionKey: string;
  extensionName: string;
  description: string;
}
export type OvfConsumerValidationFault = VmConfigFault &  {
  extensionKey: string;
  extensionName: string;
  message: string;
}
export type OvfFault = VimFault &  {
  
}
export type OvfImport = OvfFault &  {
  
}
export type OvfImportFailed = OvfImport &  {
  
}
export type OvfInvalidPackage = OvfFault &  {
  lineNumber: number;
}
export type OvfMappedOsId = OvfImport &  {
  ovfId: number;
  ovfDescription: string;
  targetDescription: string;
}
export type OvfMissingHardware = OvfImport &  {
  name: string;
  resourceType: number;
}
export type OvfNetworkMappingNotSupported = OvfImport &  {
  
}
export type OvfProperty = OvfInvalidPackage &  {
  type: string;
  value: string;
}
export type OvfPropertyNetwork = OvfProperty &  {
  
}
export type OvfPropertyQualifier = OvfProperty &  {
  qualifier: string;
}
export type OvfPropertyQualifierDuplicate = OvfProperty &  {
  qualifier: string;
}
export type OvfPropertyQualifierIgnored = OvfProperty &  {
  qualifier: string;
}
export type OvfPropertyType = OvfProperty &  {
  
}
export type OvfPropertyValue = OvfProperty &  {
  
}
export type OvfSystemFault = OvfFault &  {
  
}
export type OvfToXmlUnsupportedElement = OvfSystemFault &  {
  name?: string;
}
export type OvfUnknownDevice = OvfSystemFault &  {
  device?: VirtualDevice;
  vmName: string;
}
export type OvfUnknownEntity = OvfSystemFault &  {
  lineNumber: number;
}
export type OvfUnsupportedDeviceBackingInfo = OvfSystemFault &  {
  elementName?: string;
  instanceId?: string;
  deviceName: string;
  backingName?: string;
}
export type OvfUnsupportedDeviceBackingOption = OvfSystemFault &  {
  elementName?: string;
  instanceId?: string;
  deviceName: string;
  backingName?: string;
}
export type OvfUnsupportedDiskProvisioning = OvfImport &  {
  diskProvisioning: string;
  supportedDiskProvisioning: string;
}
export type OvfUnsupportedPackage = OvfFault &  {
  lineNumber?: number;
}
export type OvfUnsupportedSubType = OvfUnsupportedPackage &  {
  elementName: string;
  instanceId: string;
  deviceType: number;
  deviceSubType: string;
}
export type OvfUnsupportedType = OvfUnsupportedPackage &  {
  name: string;
  instanceId: string;
  deviceType: number;
}
export type OvfWrongNamespace = OvfInvalidPackage &  {
  namespaceName: string;
}
export type OvfXmlFormat = OvfInvalidPackage &  {
  description: string;
}
export type PasswordExpired = InvalidLogin &  {
  
}
export type PatchBinariesNotFound = VimFault &  {
  patchID: string;
  binary?: string[];
}
export type PatchMetadataInvalid = VimFault &  {
  patchID: string;
  metaData?: string[];
}
export type PatchMetadataNotFound = PatchMetadataInvalid &  {
  
}
export type PatchNotApplicable = VimFault &  {
  patchID: string;
}
export type PatchSuperseded = PatchNotApplicable &  {
  supersede?: string[];
}
export type PlatformConfigFault = HostConfigFault &  {
  text: string;
}
export type PowerOnFtSecondaryFailed = VmFaultToleranceIssue &  {
  vm: VirtualMachine;
  vmName: string;
  hostSelectionBy: FtIssuesOnHostHostSelectionType;
  hostErrors?: MethodFault[];
  rootCause: MethodFault;
}
export type ProfileUpdateFailed = VimFault &  {
  failure: ProfileUpdateFailedUpdateFailure[];
  warnings?: ProfileUpdateFailedUpdateFailure[];
}
export type ProfileUpdateFailedUpdateFailure = DynamicData &  {
  profilePath: ProfilePropertyPath;
  errMsg: LocalizableMessage;
}
export type QuarantineModeFault = VmConfigFault &  {
  vmName: string;
  faultType: string;
}
export type QuestionPending = InvalidState &  {
  text: string;
}
export type RDMConversionNotSupported = MigrationFault &  {
  device: string;
}
export type RDMNotPreserved = MigrationFault &  {
  device: string;
}
export type RDMNotSupportedOnDatastore = VmConfigFault &  {
  device: string;
  datastore: Datastore;
  datastoreName: string;
}
export type RDMPointsToInaccessibleDisk = CannotAccessVmDisk &  {
  
}
export type ReadHostResourcePoolTreeFailed = HostConnectFault &  {
  
}
export type ReadOnlyDisksWithLegacyDestination = MigrationFault &  {
  roDiskCount: number;
  timeoutDanger: boolean;
}
export type RebootRequired = VimFault &  {
  patch?: string;
}
export type RecordReplayDisabled = VimFault &  {
  
}
export type RemoveFailed = VimFault &  {
  
}
export type ReplicationFault = VimFault &  {
  
}
export type ReplicationIncompatibleWithFT = ReplicationFault &  {
  
}
export type ReplicationInvalidOptions = ReplicationFault &  {
  options: string;
  entity?: ManagedEntity;
}
export type ReplicationNotSupportedOnHost = ReplicationFault &  {
  
}
export type ReplicationVmFault = ReplicationFault &  {
  reason: string;
  state?: string;
  instanceId?: string;
  vm: VirtualMachine;
}
export type ReplicationVmInProgressFault = ReplicationVmFault &  {
  requestedActivity: string;
  inProgressActivity: string;
}
export type ResourceInUse = VimFault &  {
  type?: string;
  name?: string;
}
export type ResourceNotAvailable = VimFault &  {
  containerType?: string;
  containerName?: string;
  type?: string;
}
export type RollbackFailure = DvsFault &  {
  entityName: string;
  entityType: string;
}
export type RuleViolation = VmConfigFault &  {
  host?: HostSystem;
  rule: ClusterRuleInfo;
}
export type SSLDisabledFault = HostConnectFault &  {
  
}
export type SSLVerifyFault = HostConnectFault &  {
  selfSigned: boolean;
  thumbprint: string;
}
export type SSPIChallenge = VimFault &  {
  base64Token: string;
}
export type SecondaryVmAlreadyDisabled = VmFaultToleranceIssue &  {
  instanceUuid: string;
}
export type SecondaryVmAlreadyEnabled = VmFaultToleranceIssue &  {
  instanceUuid: string;
}
export type SecondaryVmAlreadyRegistered = VmFaultToleranceIssue &  {
  instanceUuid: string;
}
export type SecondaryVmNotRegistered = VmFaultToleranceIssue &  {
  instanceUuid: string;
}
export type ShrinkDiskFault = VimFault &  {
  diskId?: number;
}
export type SnapshotCopyNotSupported = MigrationFault &  {
  
}
export type SnapshotFault = VimFault &  {
  
}
export type SnapshotIncompatibleDeviceInVm = SnapshotFault &  {
  fault: MethodFault;
}
export type SnapshotLocked = SnapshotFault &  {
  
}
export type SnapshotMoveFromNonHomeNotSupported = SnapshotCopyNotSupported &  {
  
}
export type SnapshotMoveNotSupported = SnapshotCopyNotSupported &  {
  
}
export type SnapshotMoveToNonHomeNotSupported = SnapshotCopyNotSupported &  {
  
}
export type SnapshotNoChange = SnapshotFault &  {
  
}
export type SnapshotRevertIssue = MigrationFault &  {
  snapshotName?: string;
  event?: Event[];
  errors: boolean;
}
export type SoftRuleVioCorrectionDisallowed = VmConfigFault &  {
  vmName: string;
}
export type SoftRuleVioCorrectionImpact = VmConfigFault &  {
  vmName: string;
}
export type SsdDiskNotAvailable = VimFault &  {
  devicePath: string;
}
export type StorageDrsCannotMoveDiskInMultiWriterMode = VimFault &  {
  
}
export type StorageDrsCannotMoveFTVm = VimFault &  {
  
}
export type StorageDrsCannotMoveIndependentDisk = VimFault &  {
  
}
export type StorageDrsCannotMoveManuallyPlacedSwapFile = VimFault &  {
  
}
export type StorageDrsCannotMoveManuallyPlacedVm = VimFault &  {
  
}
export type StorageDrsCannotMoveSharedDisk = VimFault &  {
  
}
export type StorageDrsCannotMoveTemplate = VimFault &  {
  
}
export type StorageDrsCannotMoveVmInUserFolder = VimFault &  {
  
}
export type StorageDrsCannotMoveVmWithMountedCDROM = VimFault &  {
  
}
export type StorageDrsCannotMoveVmWithNoFilesInLayout = VimFault &  {
  
}
export type StorageDrsDatacentersCannotShareDatastore = VimFault &  {
  
}
export type StorageDrsDisabledOnVm = VimFault &  {
  
}
export type StorageDrsHbrDiskNotMovable = VimFault &  {
  nonMovableDiskIds: string;
}
export type StorageDrsHmsMoveInProgress = VimFault &  {
  
}
export type StorageDrsHmsUnreachable = VimFault &  {
  
}
export type StorageDrsIolbDisabledInternally = VimFault &  {
  
}
export type StorageDrsRelocateDisabled = VimFault &  {
  
}
export type StorageDrsStaleHmsCollection = VimFault &  {
  
}
export type StorageDrsUnableToMoveFiles = VimFault &  {
  
}
export type StorageVMotionNotSupported = MigrationFeatureNotSupported &  {
  
}
export type SuspendedRelocateNotSupported = MigrationFault &  {
  
}
export type SwapDatastoreUnset = VimFault &  {
  
}
export type SwapPlacementOverrideNotSupported = InvalidVmConfig &  {
  
}
export type SwitchIpUnset = DvsFault &  {
  
}
export type SwitchNotInUpgradeMode = DvsFault &  {
  
}
export type TaskInProgress = VimFault &  {
  task: Task;
}
export type Timedout = VimFault &  {
  
}
export type TooManyConcurrentNativeClones = FileFault &  {
  
}
export type TooManyConsecutiveOverrides = VimFault &  {
  
}
export type TooManyDevices = InvalidVmConfig &  {
  
}
export type TooManyDisksOnLegacyHost = MigrationFault &  {
  diskCount: number;
  timeoutDanger: boolean;
}
export type TooManyGuestLogons = GuestOperationsFault &  {
  
}
export type TooManyHosts = HostConnectFault &  {
  
}
export type TooManyNativeCloneLevels = FileFault &  {
  
}
export type TooManyNativeClonesOnFile = FileFault &  {
  
}
export type TooManySnapshotLevels = SnapshotFault &  {
  
}
export type ToolsAlreadyUpgraded = VmToolsUpgradeFault &  {
  
}
export type ToolsAutoUpgradeNotSupported = VmToolsUpgradeFault &  {
  
}
export type ToolsImageCopyFailed = VmToolsUpgradeFault &  {
  
}
export type ToolsImageNotAvailable = VmToolsUpgradeFault &  {
  
}
export type ToolsImageSignatureCheckFailed = VmToolsUpgradeFault &  {
  
}
export type ToolsInstallationInProgress = MigrationFault &  {
  
}
export type ToolsUnavailable = VimFault &  {
  
}
export type ToolsUpgradeCancelled = VmToolsUpgradeFault &  {
  
}
export type UncommittedUndoableDisk = MigrationFault &  {
  
}
export type UncustomizableGuest = CustomizationFault &  {
  uncustomizableGuestOS: string;
}
export type UnexpectedCustomizationFault = CustomizationFault &  {
  
}
export type UnrecognizedHost = VimFault &  {
  hostName: string;
}
export type UnsharedSwapVMotionNotSupported = MigrationFeatureNotSupported &  {
  
}
export type UnsupportedDatastore = VmConfigFault &  {
  datastore?: Datastore;
}
export type UnsupportedGuest = InvalidVmConfig &  {
  unsupportedGuestOS: string;
}
export type UnsupportedVimApiVersion = VimFault &  {
  version?: string;
}
export type UnsupportedVmxLocation = VmConfigFault &  {
  
}
export type UserNotFound = VimFault &  {
  principal: string;
  unresolved: boolean;
}
export type VAppConfigFault = VimFault &  {
  
}
export type VAppNotRunning = VmConfigFault &  {
  
}
export type VAppPropertyFault = VmConfigFault &  {
  id: string;
  category: string;
  label: string;
  type: string;
  value: string;
}
export type VAppTaskInProgress = TaskInProgress &  {
  
}
export type VFlashCacheHotConfigNotSupported = VmConfigFault &  {
  
}
export type VFlashModuleNotSupported = VmConfigFault &  {
  vmName: string;
  moduleName: string;
  reason: string;
  hostName: string;
}
export type VFlashModuleVersionIncompatible = VimFault &  {
  moduleName: string;
  vmRequestModuleVersion: string;
  hostMinSupportedVerson: string;
  hostModuleVersion: string;
}
export type VMotionAcrossNetworkNotSupported = MigrationFeatureNotSupported &  {
  
}
export type VMotionInterfaceIssue = MigrationFault &  {
  atSourceHost: boolean;
  failedHost: string;
  failedHostEntity?: HostSystem;
}
export type VMotionLinkCapacityLow = VMotionInterfaceIssue &  {
  network: string;
}
export type VMotionLinkDown = VMotionInterfaceIssue &  {
  network: string;
}
export type VMotionNotConfigured = VMotionInterfaceIssue &  {
  
}
export type VMotionNotLicensed = VMotionInterfaceIssue &  {
  
}
export type VMotionNotSupported = VMotionInterfaceIssue &  {
  
}
export type VMotionProtocolIncompatible = MigrationFault &  {
  
}
export type VirtualHardwareCompatibilityIssue = VmConfigFault &  {
  
}
export type VirtualHardwareVersionNotSupported = VirtualHardwareCompatibilityIssue &  {
  hostName: string;
  host: HostSystem;
}
export type VmAlreadyExistsInDatacenter = InvalidFolder &  {
  host: HostSystem;
  hostname: string;
  vm: VirtualMachine[];
}
export type VmFaultToleranceConfigIssue = VmFaultToleranceIssue &  {
  reason?: string;
  entityName?: string;
  entity?: ManagedEntity;
}
export type VmFaultToleranceConfigIssueWrapper = VmFaultToleranceIssue &  {
  entityName?: string;
  entity?: ManagedEntity;
  error?: MethodFault;
}
export type VmFaultToleranceInvalidFileBacking = VmFaultToleranceIssue &  {
  backingType?: string;
  backingFilename?: string;
}
export type VmFaultToleranceTooManyFtVcpusOnHost = InsufficientResourcesFault &  {
  hostName?: string;
  maxNumFtVcpus: number;
}
export type VmFaultToleranceTooManyVMsOnHost = InsufficientResourcesFault &  {
  hostName?: string;
  maxNumFtVms: number;
}
export type VmPowerOnDisabled = InvalidState &  {
  
}
export type VmSmpFaultToleranceTooManyVMsOnHost = InsufficientResourcesFault &  {
  hostName?: string;
  maxNumSmpFtVms: number;
}
export type VmWwnConflict = InvalidVmConfig &  {
  vm?: VirtualMachine;
  host?: HostSystem;
  name?: string;
  wwn?: number;
}
export type VmfsMountFault = HostConfigFault &  {
  uuid: string;
}
export type VmotionInterfaceNotEnabled = HostPowerOpFailed &  {
  
}
export type VolumeEditorError = CustomizationFault &  {
  
}
export type VsanClusterUuidMismatch = CannotMoveVsanEnabledHost &  {
  hostClusterUuid: string;
  destinationClusterUuid: string;
}
export type VsanDiskFault = VsanFault &  {
  device?: string;
}
export type VsanIncompatibleDiskMapping = VsanDiskFault &  {
  
}
export type VspanDestPortConflict = DvsFault &  {
  vspanSessionKey1: string;
  vspanSessionKey2: string;
  portKey: string;
}
export type VspanPortConflict = DvsFault &  {
  vspanSessionKey1: string;
  vspanSessionKey2: string;
  portKey: string;
}
export type VspanPortMoveFault = DvsFault &  {
  srcPortgroupName: string;
  destPortgroupName: string;
  portKey: string;
}
export type VspanPortPromiscChangeFault = DvsFault &  {
  portKey: string;
}
export type VspanPortgroupPromiscChangeFault = DvsFault &  {
  portgroupName: string;
}
export type VspanPortgroupTypeChangeFault = DvsFault &  {
  portgroupName: string;
}
export type VspanPromiscuousPortNotSupported = DvsFault &  {
  vspanSessionKey: string;
  portKey: string;
}
export type VspanSameSessionPortConflict = DvsFault &  {
  vspanSessionKey: string;
  portKey: string;
}
export type WakeOnLanNotSupported = VirtualHardwareCompatibilityIssue &  {
  
}
export type WakeOnLanNotSupportedByVmotionNIC = HostPowerOpFailed &  {
  
}
export type WillLoseHAProtection = MigrationFault &  {
  resolution: string;
}
export type WillModifyConfigCpuRequirements = MigrationFault &  {
  
}
export type WillResetSnapshotDirectory = MigrationFault &  {
  
}
export type HostActiveDirectoryInfo = HostDirectoryStoreInfo &  {
  joinedDomain?: string;
  trustedDomain?: string[];
  domainMembershipStatus?: string;
  smartCardAuthenticationEnabled?: boolean;
}
export type HostBlockAdapterTargetTransport = HostTargetTransport &  {
  
}
export type HostBlockHba = HostHostBusAdapter &  {
  
}
export type HostBootDeviceInfo = DynamicData &  {
  bootDevices?: HostBootDevice[];
  currentBootDeviceKey?: string;
}
export type HostConfigSpec = DynamicData &  {
  nasDatastore?: HostNasVolumeConfig[];
  network?: HostNetworkConfig;
  nicTypeSelection?: HostVirtualNicManagerNicTypeSelection[];
  service?: HostServiceConfig[];
  firewall?: HostFirewallConfig;
  option?: OptionValue[];
  datastorePrincipal?: string;
  datastorePrincipalPasswd?: string;
  datetime?: HostDateTimeConfig;
  storageDevice?: HostStorageDeviceInfo;
  license?: HostLicenseSpec;
  security?: HostSecuritySpec;
  userAccount?: HostAccountSpec[];
  usergroupAccount?: HostAccountSpec[];
  memory?: HostMemorySpec;
  activeDirectory?: HostActiveDirectory[];
  genericConfig?: KeyAnyValue[];
  graphicsConfig?: HostGraphicsConfig;
  assignableHardwareConfig?: HostAssignableHardwareConfig;
}
export type HostConnectSpec = DynamicData &  {
  hostName?: string;
  port?: number;
  sslThumbprint?: string;
  userName?: string;
  password?: string;
  vmFolder?: Folder;
  force: boolean;
  vimAccountName?: string;
  vimAccountPassword?: string;
  managementIp?: string;
  lockdownMode?: HostLockdownMode;
  hostGateway?: HostGatewaySpec;
}
export type HostDatastoreSystemCapabilities = DynamicData &  {
  nfsMountCreationRequired: boolean;
  nfsMountCreationSupported: boolean;
  localDatastoreSupported: boolean;
  vmfsExtentExpansionSupported: boolean;
}
export type HostDatastoreSystemDatastoreResult = DynamicData &  {
  key: Datastore;
  fault?: MethodFault;
}
export type HostDatastoreSystemVvolDatastoreSpec = DynamicData &  {
  name: string;
  scId: string;
}
export type HostDateTimeInfo = DynamicData &  {
  timeZone: HostDateTimeSystemTimeZone;
  systemClockProtocol?: string;
  ntpConfig?: HostNtpConfig;
}
export type HostFibreChannelHba = HostHostBusAdapter &  {
  portWorldWideName: number;
  nodeWorldWideName: number;
  portType: FibreChannelPortType;
  speed: number;
}
export type HostFibreChannelOverEthernetHba = HostFibreChannelHba &  {
  underlyingNic: string;
  linkInfo: HostFibreChannelOverEthernetHbaLinkInfo;
  isSoftwareFcoe: boolean;
  markedForRemoval: boolean;
}
export type HostFibreChannelOverEthernetHbaLinkInfo = DynamicData &  {
  vnportMac: string;
  fcfMac: string;
  vlanId: number;
}
export type HostFibreChannelTargetTransport = HostTargetTransport &  {
  portWorldWideName: number;
  nodeWorldWideName: number;
}
export type HostFirewallConfig = DynamicData &  {
  rule?: HostFirewallConfigRuleSetConfig[];
  defaultBlockingPolicy: HostFirewallDefaultPolicy;
}
export type HostFirewallConfigRuleSetConfig = DynamicData &  {
  rulesetId: string;
  enabled: boolean;
  allowedHosts?: HostFirewallRulesetIpList;
}
export type HostInternetScsiHba = HostHostBusAdapter &  {
  isSoftwareBased: boolean;
  canBeDisabled?: boolean;
  networkBindingSupport?: HostInternetScsiHbaNetworkBindingSupportType;
  discoveryCapabilities: HostInternetScsiHbaDiscoveryCapabilities;
  discoveryProperties: HostInternetScsiHbaDiscoveryProperties;
  authenticationCapabilities: HostInternetScsiHbaAuthenticationCapabilities;
  authenticationProperties: HostInternetScsiHbaAuthenticationProperties;
  digestCapabilities?: HostInternetScsiHbaDigestCapabilities;
  digestProperties?: HostInternetScsiHbaDigestProperties;
  ipCapabilities: HostInternetScsiHbaIPCapabilities;
  ipProperties: HostInternetScsiHbaIPProperties;
  supportedAdvancedOptions?: OptionDef[];
  advancedOptions?: HostInternetScsiHbaParamValue[];
  iScsiName: string;
  iScsiAlias?: string;
  configuredSendTarget?: HostInternetScsiHbaSendTarget[];
  configuredStaticTarget?: HostInternetScsiHbaStaticTarget[];
  maxSpeedMb?: number;
  currentSpeedMb?: number;
}
export type HostInternetScsiHbaAuthenticationCapabilities = DynamicData &  {
  chapAuthSettable: boolean;
  krb5AuthSettable: boolean;
  srpAuthSettable: boolean;
  spkmAuthSettable: boolean;
  mutualChapSettable?: boolean;
  targetChapSettable?: boolean;
  targetMutualChapSettable?: boolean;
}
export type HostInternetScsiHbaAuthenticationProperties = DynamicData &  {
  chapAuthEnabled: boolean;
  chapName?: string;
  chapSecret?: string;
  chapAuthenticationType?: string;
  chapInherited?: boolean;
  mutualChapName?: string;
  mutualChapSecret?: string;
  mutualChapAuthenticationType?: string;
  mutualChapInherited?: boolean;
}
export type HostInternetScsiHbaDigestCapabilities = DynamicData &  {
  headerDigestSettable?: boolean;
  dataDigestSettable?: boolean;
  targetHeaderDigestSettable?: boolean;
  targetDataDigestSettable?: boolean;
}
export type HostInternetScsiHbaDigestProperties = DynamicData &  {
  headerDigestType?: string;
  headerDigestInherited?: boolean;
  dataDigestType?: string;
  dataDigestInherited?: boolean;
}
export type HostInternetScsiHbaDiscoveryCapabilities = DynamicData &  {
  iSnsDiscoverySettable: boolean;
  slpDiscoverySettable: boolean;
  staticTargetDiscoverySettable: boolean;
  sendTargetsDiscoverySettable: boolean;
}
export type HostInternetScsiHbaDiscoveryProperties = DynamicData &  {
  iSnsDiscoveryEnabled: boolean;
  iSnsDiscoveryMethod?: string;
  iSnsHost?: string;
  slpDiscoveryEnabled: boolean;
  slpDiscoveryMethod?: string;
  slpHost?: string;
  staticTargetDiscoveryEnabled: boolean;
  sendTargetsDiscoveryEnabled: boolean;
}
export type HostInternetScsiHbaIPCapabilities = DynamicData &  {
  addressSettable: boolean;
  ipConfigurationMethodSettable: boolean;
  subnetMaskSettable: boolean;
  defaultGatewaySettable: boolean;
  primaryDnsServerAddressSettable: boolean;
  alternateDnsServerAddressSettable: boolean;
  ipv6Supported?: boolean;
  arpRedirectSettable?: boolean;
  mtuSettable?: boolean;
  hostNameAsTargetAddress?: boolean;
  nameAliasSettable?: boolean;
  ipv4EnableSettable?: boolean;
  ipv6EnableSettable?: boolean;
  ipv6PrefixLengthSettable?: boolean;
  ipv6PrefixLength?: number;
  ipv6DhcpConfigurationSettable?: boolean;
  ipv6LinkLocalAutoConfigurationSettable?: boolean;
  ipv6RouterAdvertisementConfigurationSettable?: boolean;
  ipv6DefaultGatewaySettable?: boolean;
  ipv6MaxStaticAddressesSupported?: number;
}
export type HostInternetScsiHbaIPProperties = DynamicData &  {
  mac?: string;
  address?: string;
  dhcpConfigurationEnabled: boolean;
  subnetMask?: string;
  defaultGateway?: string;
  primaryDnsServerAddress?: string;
  alternateDnsServerAddress?: string;
  ipv6Address?: string;
  ipv6SubnetMask?: string;
  ipv6DefaultGateway?: string;
  arpRedirectEnabled?: boolean;
  mtu?: number;
  jumboFramesEnabled?: boolean;
  ipv4Enabled?: boolean;
  ipv6Enabled?: boolean;
  ipv6properties?: HostInternetScsiHbaIPv6Properties;
}
export type HostInternetScsiHbaIPv6Properties = DynamicData &  {
  iscsiIpv6Address?: HostInternetScsiHbaIscsiIpv6Address[];
  ipv6DhcpConfigurationEnabled?: boolean;
  ipv6LinkLocalAutoConfigurationEnabled?: boolean;
  ipv6RouterAdvertisementConfigurationEnabled?: boolean;
  ipv6DefaultGateway?: string;
}
export type HostInternetScsiHbaIscsiIpv6Address = DynamicData &  {
  address: string;
  prefixLength: number;
  origin: string;
  operation?: string;
}
export type HostInternetScsiHbaParamValue = OptionValue &  {
  isInherited?: boolean;
}
export type HostInternetScsiHbaSendTarget = DynamicData &  {
  address: string;
  port?: number;
  authenticationProperties?: HostInternetScsiHbaAuthenticationProperties;
  digestProperties?: HostInternetScsiHbaDigestProperties;
  supportedAdvancedOptions?: OptionDef[];
  advancedOptions?: HostInternetScsiHbaParamValue[];
  parent?: string;
}
export type HostInternetScsiHbaStaticTarget = DynamicData &  {
  address: string;
  port?: number;
  iScsiName: string;
  discoveryMethod?: string;
  authenticationProperties?: HostInternetScsiHbaAuthenticationProperties;
  digestProperties?: HostInternetScsiHbaDigestProperties;
  supportedAdvancedOptions?: OptionDef[];
  advancedOptions?: HostInternetScsiHbaParamValue[];
  parent?: string;
}
export type HostInternetScsiHbaTargetSet = DynamicData &  {
  staticTargets?: HostInternetScsiHbaStaticTarget[];
  sendTargets?: HostInternetScsiHbaSendTarget[];
}
export type HostInternetScsiTargetTransport = HostTargetTransport &  {
  iScsiName: string;
  iScsiAlias: string;
  address?: string[];
}
export type HostNetworkConfig = DynamicData &  {
  vswitch?: HostVirtualSwitchConfig[];
  proxySwitch?: HostProxySwitchConfig[];
  portgroup?: HostPortGroupConfig[];
  pnic?: PhysicalNicConfig[];
  vnic?: HostVirtualNicConfig[];
  consoleVnic?: HostVirtualNicConfig[];
  dnsConfig?: HostDnsConfig;
  ipRouteConfig?: HostIpRouteConfig;
  consoleIpRouteConfig?: HostIpRouteConfig;
  routeTableConfig?: HostIpRouteTableConfig;
  dhcp?: HostDhcpServiceConfig[];
  nat?: HostNatServiceConfig[];
  ipV6Enabled?: boolean;
  netStackSpec?: HostNetworkConfigNetStackSpec[];
}
export type HostNetworkConfigNetStackSpec = DynamicData &  {
  netStackInstance: HostNetStackInstance;
  operation?: string;
}
export type HostNetworkConfigResult = DynamicData &  {
  vnicDevice?: string[];
  consoleVnicDevice?: string[];
}
export type HostNvmeConnectSpec = HostNvmeSpec &  {
  subnqn: string;
  controllerId?: number;
  adminQueueSize?: number;
  keepAliveTimeout?: number;
}
export type HostNvmeDiscoverSpec = HostNvmeSpec &  {
  autoConnect?: boolean;
}
export type HostNvmeOpaqueTransportParameters = HostNvmeTransportParameters &  {
  trtype: string;
  traddr: string;
  adrfam: string;
  trsvcid: string;
  tsas: Buffer;
}
export type HostNvmeOverFibreChannelParameters = HostNvmeTransportParameters &  {
  nodeWorldWideName: number;
  portWorldWideName: number;
}
export type HostNvmeOverRdmaParameters = HostNvmeTransportParameters &  {
  address: string;
  addressFamily?: string;
  portNumber?: number;
}
export type HostOpaqueNetworkInfo = DynamicData &  {
  opaqueNetworkId: string;
  opaqueNetworkName: string;
  opaqueNetworkType: string;
  pnicZone?: string[];
  capability?: OpaqueNetworkCapability;
  extraConfig?: OptionValue[];
}
export type HostParallelScsiTargetTransport = HostTargetTransport &  {
  
}
export type HostPcieTargetTransport = HostTargetTransport &  {
  
}
export type HostRdmaTargetTransport = HostTargetTransport &  {
  
}
export type HostScsiDisk = ScsiLun &  {
  capacity: HostDiskDimensionsLba;
  devicePath: string;
  ssd?: boolean;
  localDisk?: boolean;
  physicalLocation?: string[];
  emulatedDIXDIFEnabled?: boolean;
  vsanDiskInfo?: VsanHostVsanDiskInfo;
  scsiDiskType?: string;
}
export type HostScsiDiskPartition = DynamicData &  {
  diskName: string;
  partition: number;
}
export type HostSecuritySpec = DynamicData &  {
  adminPassword?: string;
  removePermission?: Permission[];
  addPermission?: Permission[];
}
export type HostSerialAttachedTargetTransport = HostTargetTransport &  {
  
}
export type HostListSummary = DynamicData &  {
  host?: HostSystem;
  hardware?: HostHardwareSummary;
  runtime?: HostRuntimeInfo;
  config: HostConfigSummary;
  quickStats: HostListSummaryQuickStats;
  overallStatus: ManagedEntityStatus;
  rebootRequired: boolean;
  customValue?: CustomFieldValue[];
  managementServerIp?: string;
  maxEVCModeKey?: string;
  currentEVCModeKey?: string;
  currentEVCGraphicsModeKey?: string;
  gateway?: HostListSummaryGatewaySummary;
  tpmAttestation?: HostTpmAttestationInfo;
  trustAuthorityAttestationInfos?: HostTrustAuthorityAttestationInfo[];
}
export type HostConfigSummary = DynamicData &  {
  name: string;
  port: number;
  sslThumbprint?: string;
  product?: AboutInfo;
  vmotionEnabled: boolean;
  faultToleranceEnabled: boolean;
  featureVersion?: HostFeatureVersionInfo[];
  agentVmDatastore?: Datastore;
  agentVmNetwork?: Network;
}
export type HostListSummaryGatewaySummary = DynamicData &  {
  gatewayType: string;
  gatewayId: string;
}
export type HostHardwareSummary = DynamicData &  {
  vendor: string;
  model: string;
  uuid: string;
  otherIdentifyingInfo?: HostSystemIdentificationInfo[];
  memorySize: number;
  cpuModel: string;
  cpuMhz: number;
  numCpuPkgs: number;
  numCpuCores: number;
  numCpuThreads: number;
  numNics: number;
  numHBAs: number;
}
export type HostListSummaryQuickStats = DynamicData &  {
  overallCpuUsage?: number;
  overallMemoryUsage?: number;
  distributedCpuFairness?: number;
  distributedMemoryFairness?: number;
  availablePMemCapacity?: number;
  uptime?: number;
}
export type HostTpmBootSecurityOptionEventDetails = HostTpmEventDetails &  {
  bootSecurityOption: string;
}
export type HostTpmCommandEventDetails = HostTpmEventDetails &  {
  commandLine: string;
}
export type HostUnresolvedVmfsExtent = DynamicData &  {
  device: HostScsiDiskPartition;
  devicePath: string;
  vmfsUuid: string;
  isHeadExtent: boolean;
  ordinal: number;
  startBlock: number;
  endBlock: number;
  reason: string;
}
export type HostVFlashManagerVFlashCacheConfigInfo = DynamicData &  {
  vFlashModuleConfigOption?: HostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption[];
  defaultVFlashModule?: string;
  swapCacheReservationInGB?: number;
}
export type HostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption = DynamicData &  {
  vFlashModule: string;
  vFlashModuleVersion: string;
  minSupportedModuleVersion: string;
  cacheConsistencyType: ChoiceOption;
  cacheMode: ChoiceOption;
  blockSizeInKBOption: LongOption;
  reservationInMBOption: LongOption;
  maxDiskSizeInKB: number;
}
export type HostVFlashManagerVFlashCacheConfigSpec = DynamicData &  {
  defaultVFlashModule: string;
  swapCacheReservationInGB: number;
}
export type HostVFlashManagerVFlashConfigInfo = DynamicData &  {
  vFlashResourceConfigInfo?: HostVFlashManagerVFlashResourceConfigInfo;
  vFlashCacheConfigInfo?: HostVFlashManagerVFlashCacheConfigInfo;
}
export type HostVFlashManagerVFlashResourceConfigInfo = DynamicData &  {
  vffs?: HostVffsVolume;
  capacity: number;
}
export type HostVFlashManagerVFlashResourceConfigSpec = DynamicData &  {
  vffsUuid: string;
}
export type HostVFlashManagerVFlashResourceRunTimeInfo = DynamicData &  {
  usage: number;
  capacity: number;
  accessible: boolean;
  capacityForVmCache: number;
  freeForVmCache: number;
}
export type HostVMotionInfo = DynamicData &  {
  netConfig?: HostVMotionNetConfig;
  ipConfig?: HostIpConfig;
}
export type HostVffsVolume = HostFileSystemVolume &  {
  majorVersion: number;
  version: string;
  uuid: string;
  extent: HostScsiDiskPartition[];
}
export type HostVffsSpec = DynamicData &  {
  devicePath: string;
  partition?: HostDiskPartitionSpec;
  majorVersion: number;
  volumeName: string;
}
export type VmfsDatastoreExpandSpec = VmfsDatastoreSpec &  {
  partition: HostDiskPartitionSpec;
  extent: HostScsiDiskPartition;
}
export type VmfsDatastoreExtendSpec = VmfsDatastoreSpec &  {
  partition: HostDiskPartitionSpec;
  extent: HostScsiDiskPartition[];
}
export type HostVmfsVolume = HostFileSystemVolume &  {
  blockSizeMb: number;
  blockSize?: number;
  unmapGranularity?: number;
  unmapPriority?: string;
  unmapBandwidthSpec?: VmfsUnmapBandwidthSpec;
  maxBlocks: number;
  majorVersion: number;
  version: string;
  uuid: string;
  extent: HostScsiDiskPartition[];
  vmfsUpgradable: boolean;
  forceMountedInfo?: HostForceMountedInfo;
  ssd?: boolean;
  local?: boolean;
  scsiDiskType?: string;
}
export type VmfsConfigOption = DynamicData &  {
  blockSizeOption: number;
  unmapGranularityOption?: number[];
  unmapBandwidthFixedValue?: LongOption;
  unmapBandwidthDynamicMin?: LongOption;
  unmapBandwidthDynamicMax?: LongOption;
  unmapBandwidthIncrement?: number;
}
export type HostVmfsSpec = DynamicData &  {
  extent: HostScsiDiskPartition;
  blockSizeMb?: number;
  majorVersion: number;
  volumeName: string;
  blockSize?: number;
  unmapGranularity?: number;
  unmapPriority?: string;
  unmapBandwidthSpec?: VmfsUnmapBandwidthSpec;
}
export type VmfsUnmapBandwidthSpec = DynamicData &  {
  policy: string;
  fixedValue: number;
  dynamicMin: number;
  dynamicMax: number;
}
export type BoolOption = OptionType &  {
  supported: boolean;
  defaultValue: boolean;
}
export type ChoiceOption = OptionType &  {
  choiceInfo: ElementDescription[];
  defaultIndex?: number;
}
export type FloatOption = OptionType &  {
  min: number;
  max: number;
  defaultValue: number;
}
export type IntOption = OptionType &  {
  min: number;
  max: number;
  defaultValue: number;
}
export type LongOption = OptionType &  {
  min: number;
  max: number;
  defaultValue: number;
}
export type ProfileCompositeExpression = ProfileExpression &  {
  operator: string;
  expressionName: string[];
}
export type CompositePolicyOption = PolicyOption &  {
  option?: PolicyOption[];
}
export type ProfileCompositePolicyOptionMetadata = ProfilePolicyOptionMetadata &  {
  option: string[];
}
export type DvsHostVNicProfile = DvsVNicProfile &  {
  
}
export type DvsServiceConsoleVNicProfile = DvsVNicProfile &  {
  
}
export type HostPortGroupProfile = PortGroupProfile &  {
  ipConfig: IpAddressProfile;
}
export type HostProfileCompleteConfigSpec = HostProfileConfigSpec &  {
  applyProfile?: HostApplyProfile;
  customComplyProfile?: ComplianceProfile;
  disabledExpressionListChanged: boolean;
  disabledExpressionList?: string[];
  validatorHost?: HostSystem;
  validating?: boolean;
  hostConfig?: HostProfileConfigInfo;
}
export type HostProfileConfigInfo = ProfileConfigInfo &  {
  applyProfile?: HostApplyProfile;
  defaultComplyProfile?: ComplianceProfile;
  defaultComplyLocator?: ComplianceLocator[];
  customComplyProfile?: ComplianceProfile;
  disabledExpressionList?: string[];
  description?: ProfileDescription;
}
export type HostProfileConfigSpec = ProfileCreateSpec &  {
  
}
export type HostProfileHostBasedConfigSpec = HostProfileConfigSpec &  {
  host: HostSystem;
  useHostProfileEngine?: boolean;
}
export type HostProfileSerializedHostProfileSpec = ProfileSerializedCreateSpec &  {
  validatorHost?: HostSystem;
  validating?: boolean;
}
export type HostProfileValidationFailureInfo = DynamicData &  {
  name: string;
  annotation: string;
  updateType: string;
  host?: HostSystem;
  applyProfile?: HostApplyProfile;
  failures?: ProfileUpdateFailedUpdateFailure[];
  faults?: MethodFault[];
}
export type NetStackInstanceProfile = ApplyProfile &  {
  key: string;
  dnsConfig: NetworkProfileDnsConfigProfile;
  ipRouteConfig: IpRouteProfile;
}
export type AnswerFileCreateSpec = DynamicData &  {
  validating?: boolean;
}
export type AnswerFileOptionsCreateSpec = AnswerFileCreateSpec &  {
  userInput?: ProfileDeferredPolicyOptionParameter[];
}
export type AnswerFileSerializedCreateSpec = AnswerFileCreateSpec &  {
  answerFileConfigString: string;
}
export type ApplyHostProfileConfigurationResult = DynamicData &  {
  startTime: Date;
  completeTime: Date;
  host: HostSystem;
  status: string;
  errors?: MethodFault[];
}
export type ApplyHostProfileConfigurationSpec = ProfileExecuteResult &  {
  host: HostSystem;
  taskListRequirement?: string[];
  taskDescription?: LocalizableMessage[];
  rebootStateless?: boolean;
  rebootHost?: boolean;
  faultData?: MethodFault;
}
export type HostProfileManagerCompositionResult = DynamicData &  {
  errors?: LocalizableMessage[];
  results?: HostProfileManagerCompositionResultResultElement[];
}
export type HostProfileManagerCompositionResultResultElement = DynamicData &  {
  target: Profile;
  status: string;
  errors?: LocalizableMessage[];
}
export type HostProfileManagerCompositionValidationResult = DynamicData &  {
  results?: HostProfileManagerCompositionValidationResultResultElement[];
  errors?: LocalizableMessage[];
}
export type HostProfileManagerCompositionValidationResultResultElement = DynamicData &  {
  target: Profile;
  status: string;
  errors?: LocalizableMessage[];
  sourceDiffForToBeMerged?: HostApplyProfile;
  targetDiffForToBeMerged?: HostApplyProfile;
  toBeAdded?: HostApplyProfile;
  toBeDeleted?: HostApplyProfile;
  toBeDisabled?: HostApplyProfile;
  toBeEnabled?: HostApplyProfile;
  toBeReenableCC?: HostApplyProfile;
}
export type HostProfileManagerConfigTaskList = DynamicData &  {
  configSpec?: HostConfigSpec;
  taskDescription?: LocalizableMessage[];
  taskListRequirement?: string[];
}
export type HostProfilesEntityCustomizations = DynamicData &  {
  
}
export type HostProfileManagerHostToConfigSpecMap = DynamicData &  {
  host: HostSystem;
  configSpec: AnswerFileCreateSpec;
}
export type StructuredCustomizations = HostProfilesEntityCustomizations &  {
  entity: ManagedEntity;
  customizations?: AnswerFile;
}
export type AfterStartupTaskScheduler = TaskScheduler &  {
  minute: number;
}
export type OnceTaskScheduler = TaskScheduler &  {
  runAt?: Date;
}
export type RecurrentTaskScheduler = TaskScheduler &  {
  interval: number;
}
export type ScheduledTaskInfo = ScheduledTaskSpec &  {
  scheduledTask: ScheduledTask;
  entity: ManagedEntity;
  lastModifiedTime: Date;
  lastModifiedUser: string;
  nextRunTime?: Date;
  prevRunTime?: Date;
  state: TaskInfoState;
  error?: MethodFault;
  result?: any;
  progress?: number;
  activeTask?: Task;
  taskObject: ManagedObject;
}
export type StorageDrsPodSelectionSpec = DynamicData &  {
  initialVmConfig?: VmPodConfigForPlacement[];
  storagePod?: StoragePod;
}
export type PodDiskLocator = DynamicData &  {
  diskId: number;
  diskMoveType?: string;
  diskBackingInfo?: VirtualDeviceBackingInfo;
  profile?: VirtualMachineProfileSpec[];
}
export type VmPodConfigForPlacement = DynamicData &  {
  storagePod: StoragePod;
  disk?: PodDiskLocator[];
  vmConfig?: StorageDrsVmConfigInfo;
  interVmRule?: ClusterRuleInfo[];
}
export type StoragePlacementSpec = DynamicData &  {
  type: string;
  priority?: VirtualMachineMovePriority;
  vm?: VirtualMachine;
  podSelectionSpec: StorageDrsPodSelectionSpec;
  cloneSpec?: VirtualMachineCloneSpec;
  cloneName?: string;
  configSpec?: VirtualMachineConfigSpec;
  relocateSpec?: VirtualMachineRelocateSpec;
  resourcePool?: ResourcePool;
  host?: HostSystem;
  folder?: Folder;
  disallowPrerequisiteMoves?: boolean;
  resourceLeaseDurationSec?: number;
}
export type VirtualDiskAntiAffinityRuleSpec = ClusterRuleInfo &  {
  diskId: number[];
}
export type VirtualDiskRuleSpec = ClusterRuleInfo &  {
  diskRuleType: string;
  diskId?: number[];
}
export type VAppConfigInfo = VmConfigInfo &  {
  entityConfig?: VAppEntityConfigInfo[];
  annotation: string;
  instanceUuid?: string;
  managedBy?: ManagedByInfo;
}
export type VAppConfigSpec = VmConfigSpec &  {
  entityConfig?: VAppEntityConfigInfo[];
  annotation?: string;
  instanceUuid?: string;
  managedBy?: ManagedByInfo;
}
export type VirtualAppImportSpec = ImportSpec &  {
  name: string;
  vAppConfigSpec: VAppConfigSpec;
  resourcePoolSpec: ResourceConfigSpec;
  child?: ImportSpec[];
}
export type VirtualMachineCdromInfo = VirtualMachineTargetInfo &  {
  description?: string;
}
export type ConfigTarget = DynamicData &  {
  numCpus: number;
  numCpuCores: number;
  numNumaNodes: number;
  maxCpusPerHost?: number;
  smcPresent: boolean;
  datastore?: VirtualMachineDatastoreInfo[];
  network?: VirtualMachineNetworkInfo[];
  opaqueNetwork?: OpaqueNetworkTargetInfo[];
  distributedVirtualPortgroup?: DistributedVirtualPortgroupInfo[];
  distributedVirtualSwitch?: DistributedVirtualSwitchInfo[];
  cdRom?: VirtualMachineCdromInfo[];
  serial?: VirtualMachineSerialInfo[];
  parallel?: VirtualMachineParallelInfo[];
  sound?: VirtualMachineSoundInfo[];
  usb?: VirtualMachineUsbInfo[];
  floppy?: VirtualMachineFloppyInfo[];
  legacyNetworkInfo?: VirtualMachineLegacyNetworkSwitchInfo[];
  scsiPassthrough?: VirtualMachineScsiPassthroughInfo[];
  scsiDisk?: VirtualMachineScsiDiskDeviceInfo[];
  ideDisk?: VirtualMachineIdeDiskDeviceInfo[];
  maxMemMBOptimalPerf: number;
  supportedMaxMemMB?: number;
  resourcePool?: ResourcePoolRuntimeInfo;
  autoVmotion?: boolean;
  pciPassthrough?: VirtualMachinePciPassthroughInfo[];
  sriov?: VirtualMachineSriovInfo[];
  vFlashModule?: VirtualMachineVFlashModuleInfo[];
  sharedGpuPassthroughTypes?: VirtualMachinePciSharedGpuPassthroughInfo[];
  availablePersistentMemoryReservationMB?: number;
  dynamicPassthrough?: VirtualMachineDynamicPassthroughInfo[];
  sgxTargetInfo?: VirtualMachineSgxTargetInfo;
  precisionClockInfo?: VirtualMachinePrecisionClockInfo[];
  sevSupported?: boolean;
}
export type VirtualMachineDefaultProfileSpec = VirtualMachineProfileSpec &  {
  
}
export type VirtualMachineDefinedProfileSpec = VirtualMachineProfileSpec &  {
  profileId: string;
  replicationSpec?: ReplicationSpec;
  profileData?: VirtualMachineProfileRawData;
  profileParams?: KeyValue[];
}
export type VirtualMachineDiskDeviceInfo = VirtualMachineTargetInfo &  {
  capacity?: number;
  vm?: VirtualMachine[];
}
export type VirtualMachineDynamicPassthroughInfo = VirtualMachineTargetInfo &  {
  vendorName: string;
  deviceName: string;
  customLabel?: string;
  vendorId: number;
  deviceId: number;
}
export type VirtualMachineEmptyProfileSpec = VirtualMachineProfileSpec &  {
  
}
export type VirtualMachineFloppyInfo = VirtualMachineTargetInfo &  {
  
}
export type VirtualMachineIdeDiskDeviceInfo = VirtualMachineDiskDeviceInfo &  {
  partitionTable?: VirtualMachineIdeDiskDevicePartitionInfo[];
}
export type VirtualMachineIdeDiskDevicePartitionInfo = DynamicData &  {
  id: number;
  capacity: number;
}
export type VirtualMachineNetworkInfo = VirtualMachineTargetInfo &  {
  network: NetworkSummary;
  vswitch?: string;
}
export type OpaqueNetworkTargetInfo = VirtualMachineTargetInfo &  {
  network: OpaqueNetworkSummary;
  networkReservationSupported?: boolean;
}
export type VirtualMachineParallelInfo = VirtualMachineTargetInfo &  {
  
}
export type VirtualMachinePciPassthroughInfo = VirtualMachineTargetInfo &  {
  pciDevice: HostPciDevice;
  systemId: string;
}
export type VirtualMachinePciSharedGpuPassthroughInfo = VirtualMachineTargetInfo &  {
  vgpu: string;
}
export type VirtualMachinePrecisionClockInfo = VirtualMachineTargetInfo &  {
  systemClockProtocol?: string;
}
export type VirtualMachineRelocateSpec = DynamicData &  {
  service?: ServiceLocator;
  folder?: Folder;
  datastore?: Datastore;
  diskMoveType?: string;
  pool?: ResourcePool;
  host?: HostSystem;
  disk?: VirtualMachineRelocateSpecDiskLocator[];
  transform?: VirtualMachineRelocateTransformation;
  deviceChange?: VirtualDeviceConfigSpec[];
  profile?: VirtualMachineProfileSpec[];
  cryptoSpec?: CryptoSpec;
}
export type VirtualMachineRelocateSpecDiskLocator = DynamicData &  {
  diskId: number;
  datastore: Datastore;
  diskMoveType?: string;
  diskBackingInfo?: VirtualDeviceBackingInfo;
  profile?: VirtualMachineProfileSpec[];
  backing?: VirtualMachineRelocateSpecDiskLocatorBackingSpec;
}
export type VirtualMachineRelocateSpecDiskLocatorBackingSpec = DynamicData &  {
  parent?: VirtualMachineRelocateSpecDiskLocatorBackingSpec;
  crypto?: CryptoSpec;
}
export type VirtualMachineRuntimeInfo = DynamicData &  {
  device?: VirtualMachineDeviceRuntimeInfo[];
  host?: HostSystem;
  connectionState: VirtualMachineConnectionState;
  powerState: VirtualMachinePowerState;
  faultToleranceState: VirtualMachineFaultToleranceState;
  dasVmProtection?: VirtualMachineRuntimeInfoDasProtectionState;
  toolsInstallerMounted: boolean;
  suspendTime?: Date;
  bootTime?: Date;
  suspendInterval?: number;
  question?: VirtualMachineQuestionInfo;
  memoryOverhead?: number;
  maxCpuUsage?: number;
  maxMemoryUsage?: number;
  numMksConnections: number;
  recordReplayState: VirtualMachineRecordReplayState;
  cleanPowerOff?: boolean;
  needSecondaryReason?: string;
  onlineStandby: boolean;
  minRequiredEVCModeKey?: string;
  consolidationNeeded: boolean;
  offlineFeatureRequirement?: VirtualMachineFeatureRequirement[];
  featureRequirement?: VirtualMachineFeatureRequirement[];
  featureMask?: HostFeatureMask[];
  vFlashCacheAllocation?: number;
  paused?: boolean;
  snapshotInBackground?: boolean;
  quiescedForkParent?: boolean;
  instantCloneFrozen?: boolean;
  cryptoState?: string;
}
export type VirtualMachineRuntimeInfoDasProtectionState = DynamicData &  {
  dasProtected: boolean;
}
export type VirtualMachineScsiDiskDeviceInfo = VirtualMachineDiskDeviceInfo &  {
  disk?: HostScsiDisk;
  transportHint?: string;
  lunNumber?: number;
}
export type VirtualMachineScsiPassthroughInfo = VirtualMachineTargetInfo &  {
  scsiClass: string;
  vendor: string;
  physicalUnitNumber: number;
}
export type VirtualMachineSerialInfo = VirtualMachineTargetInfo &  {
  
}
export type VirtualMachineSgxTargetInfo = VirtualMachineTargetInfo &  {
  maxEpcSize: number;
  flcModes?: string[];
  lePubKeyHashes?: string[];
}
export type VirtualMachineSnapshotTree = DynamicData &  {
  snapshot: VirtualMachineSnapshot;
  vm: VirtualMachine;
  name: string;
  description: string;
  id: number;
  createTime: Date;
  state: VirtualMachinePowerState;
  quiesced: boolean;
  backupManifest?: string;
  childSnapshotList?: VirtualMachineSnapshotTree[];
  replaySupported?: boolean;
}
export type VirtualMachineSoundInfo = VirtualMachineTargetInfo &  {
  
}
export type VirtualMachineSriovInfo = VirtualMachinePciPassthroughInfo &  {
  virtualFunction: boolean;
  pnic?: string;
  devicePool?: VirtualMachineSriovDevicePoolInfo;
}
export type VirtualMachineSummary = DynamicData &  {
  vm?: VirtualMachine;
  runtime: VirtualMachineRuntimeInfo;
  guest?: VirtualMachineGuestSummary;
  config: VirtualMachineConfigSummary;
  storage?: VirtualMachineStorageSummary;
  quickStats: VirtualMachineQuickStats;
  overallStatus: ManagedEntityStatus;
  customValue?: CustomFieldValue[];
}
export type VirtualMachineConfigSummary = DynamicData &  {
  name: string;
  template: boolean;
  vmPathName: string;
  memorySizeMB?: number;
  cpuReservation?: number;
  memoryReservation?: number;
  numCpu?: number;
  numEthernetCards?: number;
  numVirtualDisks?: number;
  uuid?: string;
  instanceUuid?: string;
  guestId?: string;
  guestFullName?: string;
  annotation?: string;
  product?: VAppProductInfo;
  installBootRequired?: boolean;
  ftInfo?: FaultToleranceConfigInfo;
  managedBy?: ManagedByInfo;
  tpmPresent?: boolean;
  numVmiopBackings?: number;
  hwVersion?: string;
}
export type VirtualMachineGuestSummary = DynamicData &  {
  guestId?: string;
  guestFullName?: string;
  toolsStatus?: VirtualMachineToolsStatus;
  toolsVersionStatus?: string;
  toolsVersionStatus2?: string;
  toolsRunningStatus?: string;
  hostName?: string;
  ipAddress?: string;
  hwVersion?: string;
}
export type VirtualMachineQuickStats = DynamicData &  {
  overallCpuUsage?: number;
  overallCpuDemand?: number;
  overallCpuReadiness?: number;
  guestMemoryUsage?: number;
  hostMemoryUsage?: number;
  guestHeartbeatStatus: ManagedEntityStatus;
  distributedCpuEntitlement?: number;
  distributedMemoryEntitlement?: number;
  staticCpuEntitlement?: number;
  staticMemoryEntitlement?: number;
  grantedMemory?: number;
  privateMemory?: number;
  sharedMemory?: number;
  swappedMemory?: number;
  balloonedMemory?: number;
  consumedOverheadMemory?: number;
  ftLogBandwidth?: number;
  ftSecondaryLatency?: number;
  ftLatencyStatus?: ManagedEntityStatus;
  compressedMemory?: number;
  uptimeSeconds?: number;
  ssdSwappedMemory?: number;
}
export type VirtualMachineStorageSummary = DynamicData &  {
  committed: number;
  uncommitted: number;
  unshared: number;
  timestamp: Date;
}
export type VirtualMachineVFlashModuleInfo = VirtualMachineTargetInfo &  {
  vFlashModule: HostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption;
}
export type VirtualMachineImportSpec = ImportSpec &  {
  configSpec: VirtualMachineConfigSpec;
  resPoolEntity?: ResourcePool;
}
export type CustomizationAutoIpV6Generator = CustomizationIpV6Generator &  {
  
}
export type CustomizationCustomIpGenerator = CustomizationIpGenerator &  {
  argument?: string;
}
export type CustomizationCustomIpV6Generator = CustomizationIpV6Generator &  {
  argument?: string;
}
export type CustomizationCustomName = CustomizationName &  {
  argument?: string;
}
export type CustomizationDhcpIpGenerator = CustomizationIpGenerator &  {
  
}
export type CustomizationDhcpIpV6Generator = CustomizationIpV6Generator &  {
  
}
export type CustomizationFixedIp = CustomizationIpGenerator &  {
  ipAddress: string;
}
export type CustomizationFixedIpV6 = CustomizationIpV6Generator &  {
  ipAddress: string;
  subnetMask: number;
}
export type CustomizationFixedName = CustomizationName &  {
  name: string;
}
export type CustomizationLinuxOptions = CustomizationOptions &  {
  
}
export type VirtualCdrom = VirtualDevice &  {
  
}
export type VirtualCdromAtapiBackingInfo = VirtualDeviceDeviceBackingInfo &  {
  
}
export type VirtualCdromIsoBackingInfo = VirtualDeviceFileBackingInfo &  {
  
}
export type VirtualCdromPassthroughBackingInfo = VirtualDeviceDeviceBackingInfo &  {
  exclusive: boolean;
}
export type VirtualCdromRemoteAtapiBackingInfo = VirtualDeviceRemoteDeviceBackingInfo &  {
  
}
export type VirtualCdromRemotePassthroughBackingInfo = VirtualDeviceRemoteDeviceBackingInfo &  {
  exclusive: boolean;
}
export type VirtualCdromOption = VirtualDeviceOption &  {
  
}
export type VirtualCdromAtapiBackingOption = VirtualDeviceDeviceBackingOption &  {
  
}
export type VirtualCdromIsoBackingOption = VirtualDeviceFileBackingOption &  {
  
}
export type VirtualCdromPassthroughBackingOption = VirtualDeviceDeviceBackingOption &  {
  exclusive: BoolOption;
}
export type VirtualCdromRemoteAtapiBackingOption = VirtualDeviceDeviceBackingOption &  {
  
}
export type VirtualCdromRemotePassthroughBackingOption = VirtualDeviceRemoteDeviceBackingOption &  {
  exclusive: BoolOption;
}
export type VirtualController = VirtualDevice &  {
  busNumber: number;
  device?: number[];
}
export type VirtualControllerOption = VirtualDeviceOption &  {
  devices: IntOption;
  supportedDevice?: string[];
}
export type VirtualE1000 = VirtualEthernetCard &  {
  
}
export type VirtualE1000Option = VirtualEthernetCardOption &  {
  
}
export type VirtualE1000e = VirtualEthernetCard &  {
  
}
export type VirtualE1000eOption = VirtualEthernetCardOption &  {
  
}
export type VirtualEnsoniq1371 = VirtualSoundCard &  {
  
}
export type VirtualEnsoniq1371Option = VirtualSoundCardOption &  {
  
}
export type VirtualHdAudioCard = VirtualSoundCard &  {
  
}
export type VirtualHdAudioCardOption = VirtualSoundCardOption &  {
  
}
export type VirtualIDEController = VirtualController &  {
  
}
export type VirtualIDEControllerOption = VirtualControllerOption &  {
  numIDEDisks: IntOption;
  numIDECdroms: IntOption;
}
export type VirtualNVDIMMController = VirtualController &  {
  
}
export type VirtualNVDIMMControllerOption = VirtualControllerOption &  {
  numNVDIMMControllers: IntOption;
}
export type VirtualNVMEController = VirtualController &  {
  
}
export type VirtualNVMEControllerOption = VirtualControllerOption &  {
  numNVMEDisks: IntOption;
}
export type VirtualPCIController = VirtualController &  {
  
}
export type VirtualPCIControllerOption = VirtualControllerOption &  {
  numSCSIControllers: IntOption;
  numEthernetCards: IntOption;
  numVideoCards: IntOption;
  numSoundCards: IntOption;
  numVmiRoms: IntOption;
  numVmciDevices: IntOption;
  numPCIPassthroughDevices: IntOption;
  numSasSCSIControllers: IntOption;
  numVmxnet3EthernetCards: IntOption;
  numParaVirtualSCSIControllers: IntOption;
  numSATAControllers: IntOption;
  numNVMEControllers?: IntOption;
  numVmxnet3VrdmaEthernetCards?: IntOption;
}
export type VirtualPS2Controller = VirtualController &  {
  
}
export type VirtualPS2ControllerOption = VirtualControllerOption &  {
  numKeyboards: IntOption;
  numPointingDevices: IntOption;
}
export type VirtualSATAController = VirtualController &  {
  
}
export type VirtualSATAControllerOption = VirtualControllerOption &  {
  numSATADisks: IntOption;
  numSATACdroms: IntOption;
}
export type VirtualSCSIController = VirtualController &  {
  hotAddRemove?: boolean;
  sharedBus: VirtualSCSISharing;
  scsiCtlrUnitNumber?: number;
}
export type VirtualSCSIControllerOption = VirtualControllerOption &  {
  numSCSIDisks: IntOption;
  numSCSICdroms: IntOption;
  numSCSIPassthrough: IntOption;
  sharing: VirtualSCSISharing[];
  defaultSharedIndex: number;
  hotAddRemove: BoolOption;
  scsiCtlrUnitNumber: number;
}
export type VirtualSIOController = VirtualController &  {
  
}
export type VirtualSIOControllerOption = VirtualControllerOption &  {
  numFloppyDrives: IntOption;
  numSerialPorts: IntOption;
  numParallelPorts: IntOption;
}
export type VirtualSoundBlaster16 = VirtualSoundCard &  {
  
}
export type VirtualSoundBlaster16Option = VirtualSoundCardOption &  {
  
}
export type VirtualUSBController = VirtualController &  {
  autoConnectDevices?: boolean;
  ehciEnabled?: boolean;
}
export type VirtualUSBControllerPciBusSlotInfo = VirtualDevicePciBusSlotInfo &  {
  ehciPciSlotNumber?: number;
}
export type VirtualUSBControllerOption = VirtualControllerOption &  {
  autoConnectDevices: BoolOption;
  ehciSupported: BoolOption;
  supportedSpeeds: string[];
}
export type VirtualUSBXHCIController = VirtualController &  {
  autoConnectDevices?: boolean;
}
export type VirtualUSBXHCIControllerOption = VirtualControllerOption &  {
  autoConnectDevices: BoolOption;
  supportedSpeeds: string[];
}
export type VirtualVmxnet2Option = VirtualVmxnetOption &  {
  
}
export type VirtualVmxnet3Option = VirtualVmxnetOption &  {
  
}
export type VirtualVmxnet3VrdmaOption = VirtualVmxnet3Option &  {
  deviceProtocol?: ChoiceOption;
}
export type VslmCloneSpec = VslmMigrateSpec &  {
  name: string;
  keepAfterDeleteVm?: boolean;
  metadata?: KeyValue[];
}
export type ComputeResourceConfigInfo = DynamicData &  {
  vmSwapPlacement: string;
  spbmEnabled?: boolean;
  defaultHardwareVersionKey?: string;
}
export type ComputeResourceConfigSpec = DynamicData &  {
  vmSwapPlacement?: string;
  spbmEnabled?: boolean;
  defaultHardwareVersionKey?: string;
  desiredSoftwareSpec?: DesiredSoftwareSpec;
}
export type ComputeResourceHostSPBMLicenseInfo = DynamicData &  {
  host: HostSystem;
  licenseState: ComputeResourceHostSPBMLicenseInfoHostSPBMLicenseState;
}
export type ComputeResourceSummary = DynamicData &  {
  totalCpu: number;
  totalMemory: number;
  numCpuCores: number;
  numCpuThreads: number;
  effectiveCpu: number;
  effectiveMemory: number;
  numHosts: number;
  numEffectiveHosts: number;
  overallStatus: ManagedEntityStatus;
}
export type DatacenterBasicConnectInfo = DynamicData &  {
  hostname?: string;
  error?: MethodFault;
  serverIp?: string;
  numVm?: number;
  numPoweredOnVm?: number;
  hostProductInfo?: AboutInfo;
  hardwareVendor?: string;
  hardwareModel?: string;
}
export type DatacenterConfigInfo = DynamicData &  {
  defaultHardwareVersionKey?: string;
}
export type DatacenterConfigSpec = DynamicData &  {
  defaultHardwareVersionKey?: string;
}
export type DatastoreCapability = DynamicData &  {
  directoryHierarchySupported: boolean;
  rawDiskMappingsSupported: boolean;
  perFileThinProvisioningSupported: boolean;
  storageIORMSupported: boolean;
  nativeSnapshotSupported: boolean;
  topLevelDirectoryCreateSupported?: boolean;
  seSparseSupported?: boolean;
  vmfsSparseSupported?: boolean;
  vsanSparseSupported?: boolean;
  upitSupported?: boolean;
  vmdkExpandSupported?: boolean;
  clusteredVmdkSupported?: boolean;
}
export type DatastoreHostMount = DynamicData &  {
  key: HostSystem;
  mountInfo: HostMountInfo;
}
export type DatastoreInfo = DynamicData &  {
  name: string;
  url: string;
  freeSpace: number;
  maxFileSize: number;
  maxVirtualDiskCapacity?: number;
  maxMemoryFileSize: number;
  timestamp?: Date;
  containerId?: string;
  aliasOf?: string;
}
export type DatastoreMountPathDatastorePair = DynamicData &  {
  oldMountPath: string;
  datastore: Datastore;
}
export type DatastoreSummary = DynamicData &  {
  datastore?: Datastore;
  name: string;
  url: string;
  capacity: number;
  freeSpace: number;
  uncommitted?: number;
  accessible: boolean;
  multipleHostAccess?: boolean;
  type: string;
  maintenanceMode?: string;
}
export type DatastoreVVolContainerFailoverPair = DynamicData &  {
  srcContainer?: string;
  tgtContainer: string;
  vvolMapping?: KeyValue[];
}
export type DVSBackupRestoreCapability = DynamicData &  {
  backupRestoreSupported: boolean;
}
export type DVSCapability = DynamicData &  {
  dvsOperationSupported?: boolean;
  dvPortGroupOperationSupported?: boolean;
  dvPortOperationSupported?: boolean;
  compatibleHostComponentProductInfo?: DistributedVirtualSwitchHostProductSpec[];
  featuresSupported?: DVSFeatureCapability;
}
export type DVSConfigInfo = DynamicData &  {
  uuid: string;
  name: string;
  numStandalonePorts: number;
  numPorts: number;
  maxPorts: number;
  uplinkPortPolicy: DVSUplinkPortPolicy;
  uplinkPortgroup?: DistributedVirtualPortgroup[];
  defaultPortConfig: DVPortSetting;
  host?: DistributedVirtualSwitchHostMember[];
  productInfo: DistributedVirtualSwitchProductSpec;
  targetInfo?: DistributedVirtualSwitchProductSpec;
  extensionKey?: string;
  vendorSpecificConfig?: DistributedVirtualSwitchKeyedOpaqueBlob[];
  policy?: DVSPolicy;
  description?: string;
  configVersion: string;
  contact: DVSContactInfo;
  switchIpAddress?: string;
  createTime: Date;
  networkResourceManagementEnabled: boolean;
  defaultProxySwitchMaxNumPorts?: number;
  healthCheckConfig?: DVSHealthCheckConfig[];
  infrastructureTrafficResourceConfig?: DvsHostInfrastructureTrafficResource[];
  netResourcePoolTrafficResourceConfig?: DvsHostInfrastructureTrafficResource[];
  networkResourceControlVersion?: string;
  vmVnicNetworkResourcePool?: DVSVmVnicNetworkResourcePool[];
  pnicCapacityRatioForReservation?: number;
}
export type DVSConfigSpec = DynamicData &  {
  configVersion?: string;
  name?: string;
  numStandalonePorts?: number;
  maxPorts?: number;
  uplinkPortPolicy?: DVSUplinkPortPolicy;
  uplinkPortgroup?: DistributedVirtualPortgroup[];
  defaultPortConfig?: DVPortSetting;
  host?: DistributedVirtualSwitchHostMemberConfigSpec[];
  extensionKey?: string;
  description?: string;
  policy?: DVSPolicy;
  vendorSpecificConfig?: DistributedVirtualSwitchKeyedOpaqueBlob[];
  contact?: DVSContactInfo;
  switchIpAddress?: string;
  defaultProxySwitchMaxNumPorts?: number;
  infrastructureTrafficResourceConfig?: DvsHostInfrastructureTrafficResource[];
  netResourcePoolTrafficResourceConfig?: DvsHostInfrastructureTrafficResource[];
  networkResourceControlVersion?: string;
}
export type DVSContactInfo = DynamicData &  {
  name?: string;
  contact?: string;
}
export type DVSCreateSpec = DynamicData &  {
  configSpec: DVSConfigSpec;
  productInfo?: DistributedVirtualSwitchProductSpec;
  capability?: DVSCapability;
}
export type DVSFeatureCapability = DynamicData &  {
  networkResourceManagementSupported: boolean;
  vmDirectPathGen2Supported: boolean;
  nicTeamingPolicy?: string[];
  networkResourcePoolHighShareValue?: number;
  networkResourceManagementCapability?: DVSNetworkResourceManagementCapability;
  healthCheckCapability?: DVSHealthCheckCapability;
  rollbackCapability?: DVSRollbackCapability;
  backupRestoreCapability?: DVSBackupRestoreCapability;
  networkFilterSupported?: boolean;
  macLearningSupported?: boolean;
}
export type DVSHealthCheckConfig = DynamicData &  {
  enable?: boolean;
  interval?: number;
}
export type DVSHealthCheckCapability = DynamicData &  {
  
}
export type DvsHostInfrastructureTrafficResource = DynamicData &  {
  key: string;
  description?: string;
  allocationInfo: DvsHostInfrastructureTrafficResourceAllocation;
}
export type DvsHostInfrastructureTrafficResourceAllocation = DynamicData &  {
  limit?: number;
  shares?: SharesInfo;
  reservation?: number;
}
export type DVSNameArrayUplinkPortPolicy = DVSUplinkPortPolicy &  {
  uplinkPortName: string[];
}
export type DVSNetworkResourceManagementCapability = DynamicData &  {
  networkResourceManagementSupported: boolean;
  networkResourcePoolHighShareValue: number;
  qosSupported: boolean;
  userDefinedNetworkResourcePoolsSupported: boolean;
  networkResourceControlVersion3Supported?: boolean;
  userDefinedInfraTrafficPoolSupported?: boolean;
}
export type DvsResourceRuntimeInfo = DynamicData &  {
  capacity?: number;
  usage?: number;
  available?: number;
  allocatedResource?: DvsVnicAllocatedResource[];
  vmVnicNetworkResourcePoolRuntime?: DvsVmVnicNetworkResourcePoolRuntimeInfo[];
}
export type DVSRollbackCapability = DynamicData &  {
  rollbackSupported: boolean;
}
export type DVSRuntimeInfo = DynamicData &  {
  hostMemberRuntime?: HostMemberRuntimeInfo[];
  resourceRuntimeInfo?: DvsResourceRuntimeInfo;
}
export type DVSSummary = DynamicData &  {
  name: string;
  uuid: string;
  numPorts: number;
  productInfo?: DistributedVirtualSwitchProductSpec;
  hostMember?: HostSystem[];
  vm?: VirtualMachine[];
  host?: HostSystem[];
  portgroupName?: string[];
  description?: string;
  contact?: DVSContactInfo;
  numHosts?: number;
}
export type DVSPolicy = DynamicData &  {
  autoPreInstallAllowed?: boolean;
  autoUpgradeAllowed?: boolean;
  partialUpgradeAllowed?: boolean;
}
export type DVSUplinkPortPolicy = DynamicData &  {
  
}
export type FolderBatchAddHostsToClusterResult = DynamicData &  {
  hostsAddedToCluster?: HostSystem[];
  hostsFailedInventoryAdd?: FolderFailedHostResult[];
  hostsFailedMoveToCluster?: FolderFailedHostResult[];
}
export type FolderBatchAddStandaloneHostsResult = DynamicData &  {
  addedHosts?: HostSystem[];
  hostsFailedInventoryAdd?: FolderFailedHostResult[];
}
export type FolderFailedHostResult = DynamicData &  {
  hostName?: string;
  host?: HostSystem;
  context: LocalizableMessage;
  fault: MethodFault;
}
export type FolderNewHostSpec = DynamicData &  {
  hostCnxSpec: HostConnectSpec;
  esxLicense?: string;
}
export type HealthUpdate = DynamicData &  {
  entity: ManagedEntity;
  healthUpdateInfoId: string;
  id: string;
  status: ManagedEntityStatus;
  remediation: string;
}
export type HostSystemComplianceCheckState = DynamicData &  {
  state: string;
  checkTime: Date;
}
export type HostSystemReconnectSpec = DynamicData &  {
  syncState?: boolean;
}
export type HostSystemRemediationState = DynamicData &  {
  state: string;
  operationTime: Date;
}
export type HostVMotionCompatibility = DynamicData &  {
  host: HostSystem;
  compatibility?: string[];
}
export type ProductComponentInfo = DynamicData &  {
  id: string;
  name: string;
  version: string;
  release: number;
}
export type StoragePodSummary = DynamicData &  {
  name: string;
  capacity: number;
  freeSpace: number;
}
export type VasaProviderContainerSpec = DynamicData &  {
  vasaProviderInfo?: VimVasaProviderInfo[];
  scId: string;
  deleted: boolean;
}
export type ClusterAffinityRuleSpec = ClusterRuleInfo &  {
  vm: VirtualMachine[];
}
export type ClusterAntiAffinityRuleSpec = ClusterRuleInfo &  {
  vm: VirtualMachine[];
}
export type ClusterConfigInfoEx = ComputeResourceConfigInfo &  {
  dasConfig: ClusterDasConfigInfo;
  dasVmConfig?: ClusterDasVmConfigInfo[];
  drsConfig: ClusterDrsConfigInfo;
  drsVmConfig?: ClusterDrsVmConfigInfo[];
  rule?: ClusterRuleInfo[];
  orchestration?: ClusterOrchestrationInfo;
  vmOrchestration?: ClusterVmOrchestrationInfo[];
  dpmConfigInfo?: ClusterDpmConfigInfo;
  dpmHostConfig?: ClusterDpmHostConfigInfo[];
  vsanConfigInfo?: VsanClusterConfigInfo;
  vsanHostConfig?: VsanHostConfigInfo[];
  group?: ClusterGroupInfo[];
  infraUpdateHaConfig?: ClusterInfraUpdateHaConfigInfo;
  proactiveDrsConfig?: ClusterProactiveDrsConfigInfo;
  cryptoConfig?: ClusterCryptoConfigInfo;
}
export type ClusterConfigSpecEx = ComputeResourceConfigSpec &  {
  dasConfig?: ClusterDasConfigInfo;
  dasVmConfigSpec?: ClusterDasVmConfigSpec[];
  drsConfig?: ClusterDrsConfigInfo;
  drsVmConfigSpec?: ClusterDrsVmConfigSpec[];
  rulesSpec?: ClusterRuleSpec[];
  orchestration?: ClusterOrchestrationInfo;
  vmOrchestrationSpec?: ClusterVmOrchestrationSpec[];
  dpmConfig?: ClusterDpmConfigInfo;
  dpmHostConfigSpec?: ClusterDpmHostConfigSpec[];
  vsanConfig?: VsanClusterConfigInfo;
  vsanHostConfigSpec?: VsanHostConfigInfo[];
  groupSpec?: ClusterGroupSpec[];
  infraUpdateHaConfig?: ClusterInfraUpdateHaConfigInfo;
  proactiveDrsConfig?: ClusterProactiveDrsConfigInfo;
  inHciWorkflow?: boolean;
  cryptoConfig?: ClusterCryptoConfigInfo;
}
export type ClusterDependencyRuleInfo = ClusterRuleInfo &  {
  vmGroup: string;
  dependsOnVmGroup: string;
}
export type DistributedVirtualSwitchManagerCompatibilityResult = DynamicData &  {
  host: HostSystem;
  error?: MethodFault[];
}
export type DVSManagerDvsConfigTarget = DynamicData &  {
  distributedVirtualPortgroup?: DistributedVirtualPortgroupInfo[];
  distributedVirtualSwitch?: DistributedVirtualSwitchInfo[];
}
export type DistributedVirtualSwitchManagerDvsProductSpec = DynamicData &  {
  newSwitchProductSpec?: DistributedVirtualSwitchProductSpec;
  distributedVirtualSwitch?: DistributedVirtualSwitch;
}
export type DistributedVirtualSwitchManagerHostArrayFilter = DistributedVirtualSwitchManagerHostDvsFilterSpec &  {
  host: HostSystem[];
}
export type DistributedVirtualSwitchManagerHostContainer = DynamicData &  {
  container: ManagedEntity;
  recursive: boolean;
}
export type DistributedVirtualSwitchManagerHostContainerFilter = DistributedVirtualSwitchManagerHostDvsFilterSpec &  {
  hostContainer: DistributedVirtualSwitchManagerHostContainer;
}
export type DistributedVirtualSwitchManagerHostDvsFilterSpec = DynamicData &  {
  inclusive: boolean;
}
export type DistributedVirtualSwitchManagerHostDvsMembershipFilter = DistributedVirtualSwitchManagerHostDvsFilterSpec &  {
  distributedVirtualSwitch: DistributedVirtualSwitch;
}
export type DistributedVirtualSwitchManagerImportResult = DynamicData &  {
  distributedVirtualSwitch?: DistributedVirtualSwitch[];
  distributedVirtualPortgroup?: DistributedVirtualPortgroup[];
  importFault?: ImportOperationBulkFaultFaultOnImport[];
}
export type VMwareDVSConfigInfo = DVSConfigInfo &  {
  vspanSession?: VMwareVspanSession[];
  pvlanConfig?: VMwareDVSPvlanMapEntry[];
  maxMtu: number;
  linkDiscoveryProtocolConfig?: LinkDiscoveryProtocolConfig;
  ipfixConfig?: VMwareIpfixConfig;
  lacpGroupConfig?: VMwareDvsLacpGroupConfig[];
  lacpApiVersion?: string;
  multicastFilteringMode?: string;
}
export type VMwareDVSConfigSpec = DVSConfigSpec &  {
  pvlanConfigSpec?: VMwareDVSPvlanConfigSpec[];
  vspanConfigSpec?: VMwareDVSVspanConfigSpec[];
  maxMtu?: number;
  linkDiscoveryProtocolConfig?: LinkDiscoveryProtocolConfig;
  ipfixConfig?: VMwareIpfixConfig;
  lacpApiVersion?: string;
  multicastFilteringMode?: string;
}
export type DVSFailureCriteria = InheritablePolicy &  {
  checkSpeed?: StringPolicy;
  speed?: IntPolicy;
  checkDuplex?: BoolPolicy;
  fullDuplex?: BoolPolicy;
  checkErrorPercent?: BoolPolicy;
  percentage?: IntPolicy;
  checkBeacon?: BoolPolicy;
}
export type VMwareDVSFeatureCapability = DVSFeatureCapability &  {
  vspanSupported?: boolean;
  lldpSupported?: boolean;
  ipfixSupported?: boolean;
  ipfixCapability?: VMwareDvsIpfixCapability;
  multicastSnoopingSupported?: boolean;
  vspanCapability?: VMwareDVSVspanCapability;
  lacpCapability?: VMwareDvsLacpCapability;
  nsxSupported?: boolean;
}
export type VMwareIpfixConfig = DynamicData &  {
  collectorIpAddress?: string;
  collectorPort?: number;
  observationDomainId?: number;
  activeFlowTimeout: number;
  idleFlowTimeout: number;
  samplingRate: number;
  internalFlowsOnly: boolean;
}
export type VMwareDvsIpfixCapability = DynamicData &  {
  ipfixSupported?: boolean;
  ipv6ForIpfixSupported?: boolean;
  observationDomainIdSupported?: boolean;
}
export type VMwareDvsLacpCapability = DynamicData &  {
  lacpSupported?: boolean;
  multiLacpGroupSupported?: boolean;
}
export type VMwareDvsLacpGroupConfig = DynamicData &  {
  key?: string;
  name?: string;
  mode?: string;
  uplinkNum?: number;
  loadbalanceAlgorithm?: string;
  vlan?: VMwareDvsLagVlanConfig;
  ipfix?: VMwareDvsLagIpfixConfig;
  uplinkName?: string[];
  uplinkPortKey?: string[];
}
export type VMwareDvsLacpGroupSpec = DynamicData &  {
  lacpGroupConfig: VMwareDvsLacpGroupConfig;
  operation: string;
}
export type VMwareDvsLagIpfixConfig = DynamicData &  {
  ipfixEnabled?: boolean;
}
export type VMwareDvsLagVlanConfig = DynamicData &  {
  vlanId?: NumericRange[];
}
export type DVSMacLearningPolicy = InheritablePolicy &  {
  enabled: boolean;
  allowUnicastFlooding?: boolean;
  limit?: number;
  limitPolicy?: string;
}
export type DVSMacManagementPolicy = InheritablePolicy &  {
  allowPromiscuous?: boolean;
  macChanges?: boolean;
  forgedTransmits?: boolean;
  macLearningPolicy?: DVSMacLearningPolicy;
}
export type VMwareDVSMtuHealthCheckResult = HostMemberUplinkHealthCheckResult &  {
  mtuMismatch: boolean;
  vlanSupportSwitchMtu?: NumericRange[];
  vlanNotSupportSwitchMtu?: NumericRange[];
}
export type VMwareDVSPvlanConfigSpec = DynamicData &  {
  pvlanEntry: VMwareDVSPvlanMapEntry;
  operation: string;
}
export type VMwareDVSPvlanMapEntry = DynamicData &  {
  primaryVlanId: number;
  secondaryVlanId: number;
  pvlanType: string;
}
export type VmwareDistributedVirtualSwitchPvlanSpec = VmwareDistributedVirtualSwitchVlanSpec &  {
  pvlanId: number;
}
export type DVSSecurityPolicy = InheritablePolicy &  {
  allowPromiscuous?: BoolPolicy;
  macChanges?: BoolPolicy;
  forgedTransmits?: BoolPolicy;
}
export type VMwareDVSTeamingHealthCheckConfig = VMwareDVSHealthCheckConfig &  {
  
}
export type VMwareDVSTeamingHealthCheckResult = HostMemberHealthCheckResult &  {
  teamingStatus: string;
}
export type VmwareDistributedVirtualSwitchTrunkVlanSpec = VmwareDistributedVirtualSwitchVlanSpec &  {
  vlanId?: NumericRange[];
}
export type VMwareUplinkLacpPolicy = InheritablePolicy &  {
  enable?: BoolPolicy;
  mode?: StringPolicy;
}
export type VMwareUplinkPortOrderPolicy = InheritablePolicy &  {
  activeUplinkPort?: string[];
  standbyUplinkPort?: string[];
}
export type VmwareUplinkPortTeamingPolicy = InheritablePolicy &  {
  policy?: StringPolicy;
  reversePolicy?: BoolPolicy;
  notifySwitches?: BoolPolicy;
  rollingOrder?: BoolPolicy;
  failureCriteria?: DVSFailureCriteria;
  uplinkPortOrder?: VMwareUplinkPortOrderPolicy;
}
export type VMwareDVSPortgroupPolicy = DVPortgroupPolicy &  {
  vlanOverrideAllowed: boolean;
  uplinkTeamingOverrideAllowed: boolean;
  securityPolicyOverrideAllowed: boolean;
  ipfixOverrideAllowed?: boolean;
  macManagementOverrideAllowed?: boolean;
}
export type VMwareDVSVlanHealthCheckResult = HostMemberUplinkHealthCheckResult &  {
  trunkedVlan?: NumericRange[];
  untrunkedVlan?: NumericRange[];
}
export type VmwareDistributedVirtualSwitchVlanIdSpec = VmwareDistributedVirtualSwitchVlanSpec &  {
  vlanId: number;
}
export type VMwareDVSVlanMtuHealthCheckConfig = VMwareDVSHealthCheckConfig &  {
  
}
export type VmwareDistributedVirtualSwitchVlanSpec = InheritablePolicy &  {
  
}
export type VMwareDVSHealthCheckConfig = DVSHealthCheckConfig &  {
  
}
export type VMwareDVSHealthCheckCapability = DVSHealthCheckCapability &  {
  vlanMtuSupported: boolean;
  teamingSupported: boolean;
}
export type VMwareDVSPortSetting = DVPortSetting &  {
  vlan?: VmwareDistributedVirtualSwitchVlanSpec;
  qosTag?: IntPolicy;
  uplinkTeamingPolicy?: VmwareUplinkPortTeamingPolicy;
  securityPolicy?: DVSSecurityPolicy;
  ipfixEnabled?: BoolPolicy;
  txUplink?: BoolPolicy;
  lacpPolicy?: VMwareUplinkLacpPolicy;
  macManagementPolicy?: DVSMacManagementPolicy;
  VNI?: IntPolicy;
}
export type VMwareDVSVspanConfigSpec = DynamicData &  {
  vspanSession: VMwareVspanSession;
  operation: string;
}
export type VMwareDVSVspanCapability = DynamicData &  {
  mixedDestSupported: boolean;
  dvportSupported: boolean;
  remoteSourceSupported: boolean;
  remoteDestSupported: boolean;
  encapRemoteSourceSupported: boolean;
  erspanProtocolSupported?: boolean;
  mirrorNetstackSupported?: boolean;
}
export type VMwareVspanPort = DynamicData &  {
  portKey?: string[];
  uplinkPortName?: string[];
  wildcardPortConnecteeType?: string[];
  vlans?: number[];
  ipAddress?: string[];
}
export type VMwareVspanSession = DynamicData &  {
  key?: string;
  name?: string;
  description?: string;
  enabled: boolean;
  sourcePortTransmitted?: VMwareVspanPort;
  sourcePortReceived?: VMwareVspanPort;
  destinationPort?: VMwareVspanPort;
  encapsulationVlanId?: number;
  stripOriginalVlan: boolean;
  mirroredPacketLength?: number;
  normalTrafficAllowed: boolean;
  sessionType?: string;
  samplingRate?: number;
  encapType?: string;
  erspanId?: number;
  erspanCOS?: number;
  erspanGraNanosec?: boolean;
  netstack?: string;
}
export type AlarmAcknowledgedEvent = AlarmEvent &  {
  source: ManagedEntityEventArgument;
  entity: ManagedEntityEventArgument;
}
export type AlarmActionTriggeredEvent = AlarmEvent &  {
  source: ManagedEntityEventArgument;
  entity: ManagedEntityEventArgument;
}
export type AlarmClearedEvent = AlarmEvent &  {
  source: ManagedEntityEventArgument;
  entity: ManagedEntityEventArgument;
  from: string;
}
export type AlarmCreatedEvent = AlarmEvent &  {
  entity: ManagedEntityEventArgument;
}
export type AlarmEmailCompletedEvent = AlarmEvent &  {
  entity: ManagedEntityEventArgument;
  to: string;
}
export type AlarmEmailFailedEvent = AlarmEvent &  {
  entity: ManagedEntityEventArgument;
  to: string;
  reason: MethodFault;
}
export type AlarmEventArgument = EntityEventArgument &  {
  alarm: Alarm;
}
export type ClusterComplianceCheckedEvent = ClusterEvent &  {
  profile: ProfileEventArgument;
}
export type ClusterCreatedEvent = ClusterEvent &  {
  parent: FolderEventArgument;
}
export type ClusterDestroyedEvent = ClusterEvent &  {
  
}
export type ComputeResourceEventArgument = EntityEventArgument &  {
  computeResource: ComputeResource;
}
export type CustomFieldDefEvent = CustomFieldEvent &  {
  fieldKey: number;
  name: string;
}
export type CustomFieldDefRemovedEvent = CustomFieldDefEvent &  {
  
}
export type CustomFieldDefRenamedEvent = CustomFieldDefEvent &  {
  newName: string;
}
export type DVPortgroupCreatedEvent = DVPortgroupEvent &  {
  
}
export type DVPortgroupDestroyedEvent = DVPortgroupEvent &  {
  
}
export type DatacenterCreatedEvent = DatacenterEvent &  {
  parent: FolderEventArgument;
}
export type DatacenterEventArgument = EntityEventArgument &  {
  datacenter: Datacenter;
}
export type DatastoreCapacityIncreasedEvent = DatastoreEvent &  {
  oldCapacity: number;
  newCapacity: number;
}
export type DatastoreDestroyedEvent = DatastoreEvent &  {
  
}
export type DatastoreDuplicatedEvent = DatastoreEvent &  {
  
}
export type DatastoreEventArgument = EntityEventArgument &  {
  datastore: Datastore;
}
export type DatastoreFileCopiedEvent = DatastoreFileEvent &  {
  sourceDatastore: DatastoreEventArgument;
  sourceFile: string;
}
export type DatastoreFileDeletedEvent = DatastoreFileEvent &  {
  
}
export type DrsEnteredStandbyModeEvent = EnteredStandbyModeEvent &  {
  
}
export type DrsEnteringStandbyModeEvent = EnteringStandbyModeEvent &  {
  
}
export type DrsExitStandbyModeFailedEvent = ExitStandbyModeFailedEvent &  {
  
}
export type DrsExitedStandbyModeEvent = ExitedStandbyModeEvent &  {
  
}
export type DrsExitingStandbyModeEvent = ExitingStandbyModeEvent &  {
  
}
export type DvsCreatedEvent = DvsEvent &  {
  parent: FolderEventArgument;
}
export type DvsDestroyedEvent = DvsEvent &  {
  
}
export type DvsEventArgument = EntityEventArgument &  {
  dvs: DistributedVirtualSwitch;
}
export type DvsReconfiguredEvent = DvsEvent &  {
  configSpec: DVSConfigSpec;
  configChanges?: ChangesInfoEventArgument;
}
export type MigrationErrorEvent = MigrationEvent &  {
  
}
export type PermissionAddedEvent = PermissionEvent &  {
  role: RoleEventArgument;
  propagate: boolean;
}
export type RoleAddedEvent = RoleEvent &  {
  privilegeList?: string[];
}
export type VmBeingClonedEvent = VmCloneEvent &  {
  destFolder: FolderEventArgument;
  destName: string;
  destHost: HostEventArgument;
}
export type VmBeingClonedNoFolderEvent = VmCloneEvent &  {
  destName: string;
  destHost: HostEventArgument;
}
export type ActiveVMsBlockingEVC = EVCConfigFault &  {
  evcMode?: string;
  host?: HostSystem[];
  hostName?: string[];
}
export type AdminDisabled = HostConfigFault &  {
  
}
export type AdminNotDisabled = HostConfigFault &  {
  
}
export type AffinityConfigured = MigrationFault &  {
  configuredAffinity: string[];
}
export type AgentInstallFailed = HostConnectFault &  {
  reason?: string;
  statusCode?: number;
  installerOutput?: string;
}
export type AlreadyBeingManaged = HostConnectFault &  {
  ipAddress: string;
}
export type AlreadyConnected = HostConnectFault &  {
  name: string;
}
export type ApplicationQuiesceFault = SnapshotFault &  {
  
}
export type BackupBlobReadFailure = DvsFault &  {
  entityName: string;
  entityType: string;
  fault: MethodFault;
}
export type BackupBlobWriteFailure = DvsFault &  {
  entityName: string;
  entityType: string;
  fault: MethodFault;
}
export type BlockedByFirewall = HostConfigFault &  {
  
}
export type CAMServerRefusedConnection = InvalidCAMServer &  {
  
}
export type CannotAccessFile = FileFault &  {
  
}
export type CannotAccessNetwork = CannotAccessVmDevice &  {
  network?: Network;
}
export type CannotAddHostWithFTVmAsStandalone = HostConnectFault &  {
  
}
export type CannotAddHostWithFTVmToDifferentCluster = HostConnectFault &  {
  
}
export type CannotAddHostWithFTVmToNonHACluster = HostConnectFault &  {
  
}
export type CannotCreateFile = FileFault &  {
  
}
export type CannotDecryptPasswords = CustomizationFault &  {
  
}
export type CannotDeleteFile = FileFault &  {
  
}
export type CannotModifyConfigCpuRequirements = MigrationFault &  {
  
}
export type CannotMoveVmWithDeltaDisk = MigrationFault &  {
  device: string;
}
export type CannotMoveVmWithNativeDeltaDisk = MigrationFault &  {
  
}
export type CannotPowerOffVmInCluster = InvalidState &  {
  operation: string;
  vm: VirtualMachine;
  vmName: string;
}
export type ClockSkew = HostConfigFault &  {
  
}
export type CloneFromSnapshotNotSupported = MigrationFault &  {
  
}
export type CollectorAddressUnset = DvsFault &  {
  
}
export type ConflictingConfiguration = DvsFault &  {
  configInConflict: ConflictingConfigurationConfig[];
}
export type ConflictingConfigurationConfig = DynamicData &  {
  entity?: ManagedEntity;
  propertyPath: string;
}
export type CpuIncompatible = VirtualHardwareCompatibilityIssue &  {
  level: number;
  registerName: string;
  registerBits?: string;
  desiredBits?: string;
  host?: HostSystem;
}
export type CpuIncompatible1ECX = CpuIncompatible &  {
  sse3: boolean;
  pclmulqdq: boolean;
  ssse3: boolean;
  sse41: boolean;
  sse42: boolean;
  aes: boolean;
  other: boolean;
  otherOnly: boolean;
}
export type CpuIncompatible81EDX = CpuIncompatible &  {
  nx: boolean;
  ffxsr: boolean;
  rdtscp: boolean;
  lm: boolean;
  other: boolean;
  otherOnly: boolean;
}
export type DatacenterMismatch = MigrationFault &  {
  invalidArgument: DatacenterMismatchArgument[];
  expectedDatacenter: Datacenter;
}
export type DatacenterMismatchArgument = DynamicData &  {
  entity: ManagedEntity;
  inputDatacenter?: Datacenter;
}
export type DatastoreNotWritableOnHost = InvalidDatastore &  {
  host: HostSystem;
}
export type DestinationSwitchFull = CannotAccessNetwork &  {
  
}
export type DeviceNotSupported = VirtualHardwareCompatibilityIssue &  {
  device: string;
  reason?: string;
}
export type DigestNotSupported = DeviceNotSupported &  {
  
}
export type DirectoryNotEmpty = FileFault &  {
  
}
export type DisableAdminNotSupported = HostConfigFault &  {
  
}
export type DisallowedMigrationDeviceAttached = MigrationFault &  {
  fault: MethodFault;
}
export type DisconnectedHostsBlockingEVC = EVCConfigFault &  {
  
}
export type DiskHasPartitions = VsanDiskFault &  {
  
}
export type DiskIsLastRemainingNonSSD = VsanDiskFault &  {
  
}
export type DiskIsNonLocal = VsanDiskFault &  {
  
}
export type DiskIsUSB = VsanDiskFault &  {
  
}
export type DiskMoveTypeNotSupported = MigrationFault &  {
  
}
export type DiskNotSupported = VirtualHardwareCompatibilityIssue &  {
  disk: number;
}
export type DiskTooSmall = VsanDiskFault &  {
  
}
export type DrsVmotionIncompatibleFault = VirtualHardwareCompatibilityIssue &  {
  host: HostSystem;
}
export type DuplicateDisks = VsanDiskFault &  {
  
}
export type DvsApplyOperationFault = DvsFault &  {
  objectFault: DvsApplyOperationFaultFaultOnObject[];
}
export type DvsApplyOperationFaultFaultOnObject = DynamicData &  {
  objectId: string;
  type: string;
  fault: MethodFault;
}
export type EVCAdmissionFailed = NotSupportedHostInCluster &  {
  faults?: MethodFault[];
}
export type EVCAdmissionFailedCPUFeaturesForMode = EVCAdmissionFailed &  {
  currentEVCModeKey: string;
}
export type EVCAdmissionFailedCPUModel = EVCAdmissionFailed &  {
  
}
export type EVCAdmissionFailedCPUModelForMode = EVCAdmissionFailed &  {
  currentEVCModeKey: string;
}
export type EVCAdmissionFailedCPUVendor = EVCAdmissionFailed &  {
  clusterCPUVendor: string;
  hostCPUVendor: string;
}
export type EVCAdmissionFailedCPUVendorUnknown = EVCAdmissionFailed &  {
  
}
export type EVCAdmissionFailedHostDisconnected = EVCAdmissionFailed &  {
  
}
export type EVCAdmissionFailedHostSoftware = EVCAdmissionFailed &  {
  
}
export type EVCAdmissionFailedHostSoftwareForMode = EVCAdmissionFailed &  {
  
}
export type EVCAdmissionFailedVmActive = EVCAdmissionFailed &  {
  
}
export type EncryptionKeyRequired = InvalidState &  {
  requiredKey?: CryptoKeyId[];
}
export type FailToEnableSPBM = NotEnoughLicenses &  {
  cs: ComputeResource;
  csName: string;
  hostLicenseStates: ComputeResourceHostSPBMLicenseInfo[];
}
export type FaultToleranceAntiAffinityViolated = MigrationFault &  {
  hostName: string;
  host: HostSystem;
}
export type FaultToleranceCpuIncompatible = CpuIncompatible &  {
  model: boolean;
  family: boolean;
  stepping: boolean;
}
export type FaultToleranceNeedsThickDisk = MigrationFault &  {
  vmName: string;
}
export type FaultToleranceNotSameBuild = MigrationFault &  {
  build: string;
}
export type FeatureRequirementsNotMet = VirtualHardwareCompatibilityIssue &  {
  featureRequirement?: VirtualMachineFeatureRequirement[];
  vm?: VirtualMachine;
  host?: HostSystem;
}
export type FileAlreadyExists = FileFault &  {
  
}
export type FileBackedPortNotSupported = DeviceNotSupported &  {
  
}
export type FilesystemQuiesceFault = SnapshotFault &  {
  
}
export type FilterInUse = ResourceInUse &  {
  disk?: VirtualDiskId[];
}
export type FullStorageVMotionNotSupported = MigrationFeatureNotSupported &  {
  
}
export type GatewayConnectFault = HostConnectFault &  {
  gatewayType: string;
  gatewayId: string;
  gatewayInfo: string;
  details?: LocalizableMessage;
}
export type GatewayNotFound = GatewayConnectFault &  {
  
}
export type GatewayNotReachable = GatewayConnectFault &  {
  
}
export type GatewayOperationRefused = GatewayConnectFault &  {
  
}
export type GatewayToHostConnectFault = GatewayConnectFault &  {
  hostname: string;
  port?: number;
}
export type GatewayToHostTrustVerifyFault = GatewayToHostConnectFault &  {
  verificationToken: string;
  propertiesToVerify: KeyValue[];
}
export type GuestAuthenticationChallenge = GuestOperationsFault &  {
  serverChallenge: GuestAuthentication;
  sessionID: number;
}
export type GuestComponentsOutOfDate = GuestOperationsFault &  {
  
}
export type GuestMultipleMappings = GuestOperationsFault &  {
  
}
export type GuestRegistryKeyAlreadyExists = GuestRegistryKeyFault &  {
  
}
export type HAErrorsAtDest = MigrationFault &  {
  
}
export type HostConfigFailed = HostConfigFault &  {
  failure: MethodFault[];
}
export type HotSnapshotMoveNotSupported = SnapshotCopyNotSupported &  {
  
}
export type IDEDiskNotSupported = DiskNotSupported &  {
  
}
export type InaccessibleDatastore = InvalidDatastore &  {
  detail?: string;
}
export type InaccessibleFTMetadataDatastore = InaccessibleDatastore &  {
  
}
export type IncompatibleDefaultDevice = MigrationFault &  {
  device: string;
}
export type IncompatibleHostForVmReplication = ReplicationFault &  {
  vmName: string;
  hostName: string;
  reason: string;
}
export type IndependentDiskVMotionNotSupported = MigrationFeatureNotSupported &  {
  
}
export type InsufficientAgentVmsDeployed = InsufficientResourcesFault &  {
  hostName: string;
  requiredNumAgentVms: number;
  currentNumAgentVms: number;
}
export type InsufficientCpuResourcesFault = InsufficientResourcesFault &  {
  unreserved: number;
  requested: number;
}
export type InsufficientDisks = VsanDiskFault &  {
  
}
export type InsufficientFailoverResourcesFault = InsufficientResourcesFault &  {
  
}
export type InsufficientGraphicsResourcesFault = InsufficientResourcesFault &  {
  
}
export type InsufficientHostCapacityFault = InsufficientResourcesFault &  {
  host?: HostSystem;
}
export type InsufficientHostCpuCapacityFault = InsufficientHostCapacityFault &  {
  unreserved: number;
  requested: number;
}
export type InsufficientHostMemoryCapacityFault = InsufficientHostCapacityFault &  {
  unreserved: number;
  requested: number;
}
export type InsufficientMemoryResourcesFault = InsufficientResourcesFault &  {
  unreserved: number;
  requested: number;
}
export type InsufficientNetworkCapacity = InsufficientResourcesFault &  {
  
}
export type InsufficientNetworkResourcePoolCapacity = InsufficientResourcesFault &  {
  dvsName: string;
  dvsUuid: string;
  resourcePoolKey: string;
  available: number;
  requested: number;
  device: string[];
}
export type InsufficientPerCpuCapacity = InsufficientHostCapacityFault &  {
  
}
export type InsufficientStandbyCpuResource = InsufficientStandbyResource &  {
  available: number;
  requested: number;
}
export type InsufficientStandbyMemoryResource = InsufficientStandbyResource &  {
  available: number;
  requested: number;
}
export type InvalidBundle = PlatformConfigFault &  {
  
}
export type InvalidCAMCertificate = InvalidCAMServer &  {
  
}
export type InvalidClientCertificate = InvalidLogin &  {
  
}
export type InvalidDatastoreState = InvalidState &  {
  datastoreName?: string;
}
export type InvalidDeviceSpec = InvalidVmConfig &  {
  deviceIndex: number;
}
export type InvalidDiskFormat = InvalidFormat &  {
  
}
export type InvalidHostState = InvalidState &  {
  host?: HostSystem;
}
export type InvalidNasCredentials = NasConfigFault &  {
  userName: string;
}
export type InvalidNetworkInType = VAppPropertyFault &  {
  
}
export type InvalidNetworkResource = NasConfigFault &  {
  remoteHost: string;
  remotePath: string;
}
export type InvalidPowerState = InvalidState &  {
  requestedState?: VirtualMachinePowerState;
  existingState: VirtualMachinePowerState;
}
export type InvalidPropertyType = VAppPropertyFault &  {
  
}
export type InvalidPropertyValue = VAppPropertyFault &  {
  
}
export type LargeRDMConversionNotSupported = MigrationFault &  {
  device: string;
}
export type LegacyNetworkInterfaceInUse = CannotAccessNetwork &  {
  
}
export type MaintenanceModeFileMove = MigrationFault &  {
  
}
export type MemoryFileFormatNotSupportedByDatastore = UnsupportedDatastore &  {
  datastoreName: string;
  type: string;
}
export type MemorySizeNotRecommended = VirtualHardwareCompatibilityIssue &  {
  memorySizeMB: number;
  minMemorySizeMB: number;
  maxMemorySizeMB: number;
}
export type MemorySizeNotSupported = VirtualHardwareCompatibilityIssue &  {
  memorySizeMB: number;
  minMemorySizeMB: number;
  maxMemorySizeMB: number;
}
export type MemorySizeNotSupportedByDatastore = VirtualHardwareCompatibilityIssue &  {
  datastore: Datastore;
  memorySizeMB: number;
  maxMemorySizeMB: number;
}
export type MemorySnapshotOnIndependentDisk = SnapshotFault &  {
  
}
export type MigrationDisabled = MigrationFault &  {
  
}
export type MissingController = InvalidDeviceSpec &  {
  
}
export type MissingIpPool = VAppPropertyFault &  {
  
}
export type MissingNetworkIpConfig = VAppPropertyFault &  {
  
}
export type MissingPowerOffConfiguration = VAppConfigFault &  {
  
}
export type MissingPowerOnConfiguration = VAppConfigFault &  {
  
}
export type MultiWriterNotSupported = DeviceNotSupported &  {
  
}
export type MultipleSnapshotsNotSupported = SnapshotFault &  {
  
}
export type NoAvailableIp = VAppPropertyFault &  {
  network: Network;
}
export type NoVcManagedIpConfigured = VAppPropertyFault &  {
  
}
export type NoVmInVApp = VAppConfigFault &  {
  
}
export type NonPersistentDisksNotSupported = DeviceNotSupported &  {
  
}
export type NonVmwareOuiMacNotSupportedHost = NotSupportedHost &  {
  hostName: string;
}
export type NotEnoughCpus = VirtualHardwareCompatibilityIssue &  {
  numCpuDest: number;
  numCpuVm: number;
}
export type NotEnoughLogicalCpus = NotEnoughCpus &  {
  host?: HostSystem;
}
export type NotUserConfigurableProperty = VAppPropertyFault &  {
  
}
export type NumVirtualCoresPerSocketNotSupported = VirtualHardwareCompatibilityIssue &  {
  maxSupportedCoresPerSocketDest: number;
  numCoresPerSocketVm: number;
}
export type NumVirtualCpusNotSupported = VirtualHardwareCompatibilityIssue &  {
  maxSupportedVcpusDest: number;
  numCpuVm: number;
}
export type OvfAttribute = OvfInvalidPackage &  {
  elementName: string;
  attributeName: string;
}
export type OvfConstraint = OvfInvalidPackage &  {
  name: string;
}
export type OvfConsumerCallbackFault = OvfFault &  {
  extensionKey: string;
  extensionName: string;
}
export type OvfConsumerCommunicationError = OvfConsumerCallbackFault &  {
  description: string;
}
export type OvfConsumerFault = OvfConsumerCallbackFault &  {
  errorKey: string;
  message: string;
  params?: KeyValue[];
}
export type OvfConsumerInvalidSection = OvfConsumerCallbackFault &  {
  lineNumber: number;
  description: string;
}
export type OvfConsumerUndeclaredSection = OvfConsumerCallbackFault &  {
  qualifiedSectionType: string;
}
export type OvfConsumerUndefinedPrefix = OvfConsumerCallbackFault &  {
  prefix: string;
}
export type OvfCpuCompatibility = OvfImport &  {
  registerName: string;
  level: number;
  registerValue: string;
  desiredRegisterValue: string;
}
export type OvfCpuCompatibilityCheckNotSupported = OvfImport &  {
  
}
export type OvfDiskMappingNotFound = OvfSystemFault &  {
  diskName: string;
  vmName: string;
}
export type OvfDiskOrderConstraint = OvfConstraint &  {
  
}
export type OvfElement = OvfInvalidPackage &  {
  name: string;
}
export type OvfElementInvalidValue = OvfElement &  {
  value: string;
}
export type OvfExport = OvfFault &  {
  
}
export type OvfExportFailed = OvfExport &  {
  
}
export type OvfHardwareCheck = OvfImport &  {
  
}
export type OvfHardwareExport = OvfExport &  {
  device?: VirtualDevice;
  vmPath: string;
}
export type OvfHostResourceConstraint = OvfConstraint &  {
  value: string;
}
export type OvfHostValueNotParsed = OvfSystemFault &  {
  property: string;
  value: string;
}
export type OvfInternalError = OvfSystemFault &  {
  
}
export type OvfInvalidValue = OvfAttribute &  {
  value: string;
}
export type OvfInvalidValueConfiguration = OvfInvalidValue &  {
  
}
export type OvfInvalidValueEmpty = OvfInvalidValue &  {
  
}
export type OvfInvalidValueFormatMalformed = OvfInvalidValue &  {
  
}
export type OvfInvalidValueReference = OvfInvalidValue &  {
  
}
export type OvfInvalidVmName = OvfUnsupportedPackage &  {
  name: string;
}
export type OvfMissingAttribute = OvfAttribute &  {
  
}
export type OvfMissingElement = OvfElement &  {
  
}
export type OvfMissingElementNormalBoundary = OvfMissingElement &  {
  boundary: string;
}
export type OvfNoHostNic = OvfUnsupportedPackage &  {
  
}
export type OvfNoSupportedHardwareFamily = OvfUnsupportedPackage &  {
  version: string;
}
export type OvfPropertyExport = OvfExport &  {
  type: string;
  value: string;
}
export type OvfPropertyNetworkExport = OvfExport &  {
  network: string;
}
export type OvfUnableToExportDisk = OvfHardwareExport &  {
  diskName: string;
}
export type OvfUnexpectedElement = OvfElement &  {
  
}
export type OvfUnknownDeviceBacking = OvfHardwareExport &  {
  backing: VirtualDeviceBackingInfo;
}
export type OvfUnsupportedAttribute = OvfUnsupportedPackage &  {
  elementName: string;
  attributeName: string;
}
export type OvfUnsupportedAttributeValue = OvfUnsupportedAttribute &  {
  value: string;
}
export type OvfUnsupportedDeviceExport = OvfHardwareExport &  {
  
}
export type OvfUnsupportedElement = OvfUnsupportedPackage &  {
  name: string;
}
export type OvfUnsupportedElementValue = OvfUnsupportedElement &  {
  value: string;
}
export type OvfUnsupportedSection = OvfUnsupportedElement &  {
  info: string;
}
export type OvfWrongElement = OvfElement &  {
  
}
export type PatchAlreadyInstalled = PatchNotApplicable &  {
  
}
export type PatchInstallFailed = PlatformConfigFault &  {
  rolledBack: boolean;
}
export type PatchIntegrityError = PlatformConfigFault &  {
  
}
export type PatchMetadataCorrupted = PatchMetadataInvalid &  {
  
}
export type PatchMissingDependencies = PatchNotApplicable &  {
  prerequisitePatch?: string[];
  prerequisiteLib?: string[];
}
export type PowerOnFtSecondaryTimedout = Timedout &  {
  vm: VirtualMachine;
  vmName: string;
  timeout: number;
}
export type QuiesceDatastoreIOForHAFailed = ResourceInUse &  {
  host: HostSystem;
  hostName: string;
  ds: Datastore;
  dsName: string;
}
export type RDMNotSupported = DeviceNotSupported &  {
  
}
export type RawDiskNotSupported = DeviceNotSupported &  {
  
}
export type RemoteDeviceNotSupported = DeviceNotSupported &  {
  
}
export type ReplicationConfigFault = ReplicationFault &  {
  
}
export type ReplicationDiskConfigFault = ReplicationConfigFault &  {
  reason?: string;
  vmRef?: VirtualMachine;
  key?: number;
}
export type ReplicationVmConfigFault = ReplicationConfigFault &  {
  reason?: string;
  vmRef?: VirtualMachine;
}
export type SharedBusControllerNotSupported = DeviceNotSupported &  {
  
}
export type SnapshotCloneNotSupported = SnapshotCopyNotSupported &  {
  
}
export type SnapshotDisabled = SnapshotFault &  {
  
}
export type StorageVmotionIncompatible = VirtualHardwareCompatibilityIssue &  {
  datastore?: Datastore;
}
export type SwapDatastoreNotWritableOnHost = DatastoreNotWritableOnHost &  {
  
}
export type UnSupportedDatastoreForVFlash = UnsupportedDatastore &  {
  datastoreName: string;
  type: string;
}
export type UnconfiguredPropertyValue = InvalidPropertyValue &  {
  
}
export type VMINotSupported = DeviceNotSupported &  {
  
}
export type VMOnConflictDVPort = CannotAccessNetwork &  {
  
}
export type VMOnVirtualIntranet = CannotAccessNetwork &  {
  
}
export type VirtualDiskModeNotSupported = DeviceNotSupported &  {
  mode: string;
}
export type VirtualEthernetCardNotSupported = DeviceNotSupported &  {
  
}
export type VmfsAlreadyMounted = VmfsMountFault &  {
  
}
export type VmfsAmbiguousMount = VmfsMountFault &  {
  
}
export type HostConfigInfo = DynamicData &  {
  host: HostSystem;
  product: AboutInfo;
  deploymentInfo?: HostDeploymentInfo;
  hyperThread?: HostHyperThreadScheduleInfo;
  consoleReservation?: ServiceConsoleReservationInfo;
  virtualMachineReservation?: VirtualMachineMemoryReservationInfo;
  storageDevice?: HostStorageDeviceInfo;
  multipathState?: HostMultipathStateInfo;
  fileSystemVolume?: HostFileSystemVolumeInfo;
  systemFile?: string[];
  network?: HostNetworkInfo;
  vmotion?: HostVMotionInfo;
  virtualNicManagerInfo?: HostVirtualNicManagerInfo;
  capabilities?: HostNetCapabilities;
  datastoreCapabilities?: HostDatastoreSystemCapabilities;
  offloadCapabilities?: HostNetOffloadCapabilities;
  service?: HostServiceInfo;
  firewall?: HostFirewallInfo;
  autoStart?: HostAutoStartManagerConfig;
  activeDiagnosticPartition?: HostDiagnosticPartition;
  option?: OptionValue[];
  optionDef?: OptionDef[];
  datastorePrincipal?: string;
  localSwapDatastore?: Datastore;
  systemSwapConfiguration?: HostSystemSwapConfiguration;
  systemResources?: HostSystemResourceInfo;
  dateTimeInfo?: HostDateTimeInfo;
  flags?: HostFlagInfo;
  adminDisabled?: boolean;
  lockdownMode?: HostLockdownMode;
  ipmi?: HostIpmiInfo;
  sslThumbprintInfo?: HostSslThumbprintInfo;
  sslThumbprintData?: HostSslThumbprintInfo[];
  certificate?: number[];
  pciPassthruInfo?: HostPciPassthruInfo[];
  authenticationManagerInfo?: HostAuthenticationManagerInfo;
  featureVersion?: HostFeatureVersionInfo[];
  powerSystemCapability?: PowerSystemCapability;
  powerSystemInfo?: PowerSystemInfo;
  cacheConfigurationInfo?: HostCacheConfigurationInfo[];
  wakeOnLanCapable?: boolean;
  featureCapability?: HostFeatureCapability[];
  maskedFeatureCapability?: HostFeatureCapability[];
  vFlashConfigInfo?: HostVFlashManagerVFlashConfigInfo;
  vsanHostConfig?: VsanHostConfigInfo;
  domainList?: string[];
  scriptCheckSum?: Buffer;
  hostConfigCheckSum?: Buffer;
  descriptionTreeCheckSum?: Buffer;
  graphicsInfo?: HostGraphicsInfo[];
  sharedPassthruGpuTypes?: string[];
  graphicsConfig?: HostGraphicsConfig;
  sharedGpuCapabilities?: HostSharedGpuCapabilities[];
  ioFilterInfo?: HostIoFilterInfo[];
  sriovDevicePool?: HostSriovDevicePoolInfo[];
  assignableHardwareBinding?: HostAssignableHardwareBinding[];
  assignableHardwareConfig?: HostAssignableHardwareConfig;
}
export type HostConnectInfo = DynamicData &  {
  serverIp?: string;
  inDasCluster?: boolean;
  host: HostListSummary;
  vm?: VirtualMachineSummary[];
  vimAccountNameRequired?: boolean;
  clusterSupported?: boolean;
  network?: HostConnectInfoNetworkInfo[];
  datastore?: HostDatastoreConnectInfo[];
  license?: HostLicenseConnectInfo;
  capability?: HostCapability;
}
export type HostDatastoreExistsConnectInfo = HostDatastoreConnectInfo &  {
  newDatastoreName: string;
}
export type HostDatastoreConnectInfo = DynamicData &  {
  summary: DatastoreSummary;
}
export type HostDatastoreNameConflictConnectInfo = HostDatastoreConnectInfo &  {
  newDatastoreName: string;
}
export type HostLicenseConnectInfo = DynamicData &  {
  license: LicenseManagerLicenseInfo;
  evaluation: LicenseManagerEvaluationInfo;
  resource?: HostLicensableResourceInfo;
}
export type HostConnectInfoNetworkInfo = DynamicData &  {
  summary: NetworkSummary;
}
export type HostNewNetworkConnectInfo = HostConnectInfoNetworkInfo &  {
  
}
export type HostDiagnosticPartition = DynamicData &  {
  storageType: string;
  diagnosticType: string;
  slots: number;
  id: HostScsiDiskPartition;
}
export type HostDiagnosticPartitionCreateDescription = DynamicData &  {
  layout: HostDiskPartitionLayout;
  diskUuid: string;
  spec: HostDiagnosticPartitionCreateSpec;
}
export type HostDiagnosticPartitionCreateOption = DynamicData &  {
  storageType: string;
  diagnosticType: string;
  disk: HostScsiDisk;
}
export type HostDiagnosticPartitionCreateSpec = DynamicData &  {
  storageType: string;
  diagnosticType: string;
  id: HostScsiDiskPartition;
  partition: HostDiskPartitionSpec;
  active?: boolean;
}
export type HostFibreChannelOverEthernetTargetTransport = HostFibreChannelTargetTransport &  {
  vnportMac: string;
  fcfMac: string;
  vlanId: number;
}
export type LocalDatastoreInfo = DatastoreInfo &  {
  path?: string;
}
export type NasDatastoreInfo = DatastoreInfo &  {
  nas?: HostNasVolume;
}
export type PMemDatastoreInfo = DatastoreInfo &  {
  pmem: HostPMemVolume;
}
export type HostRuntimeInfo = DynamicData &  {
  connectionState: HostSystemConnectionState;
  powerState: HostSystemPowerState;
  standbyMode?: string;
  inMaintenanceMode: boolean;
  inQuarantineMode?: boolean;
  bootTime?: Date;
  healthSystemRuntime?: HealthSystemRuntime;
  dasHostState?: ClusterDasFdmHostState;
  tpmPcrValues?: HostTpmDigestInfo[];
  vsanRuntimeInfo?: VsanHostRuntimeInfo;
  networkRuntimeInfo?: HostRuntimeInfoNetworkRuntimeInfo;
  vFlashResourceRuntimeInfo?: HostVFlashManagerVFlashResourceRunTimeInfo;
  hostMaxVirtualDiskCapacity?: number;
  cryptoState?: string;
  cryptoKeyId?: CryptoKeyId;
}
export type HostRuntimeInfoNetStackInstanceRuntimeInfo = DynamicData &  {
  netStackInstanceKey: string;
  state?: string;
  vmknicKeys?: string[];
  maxNumberOfConnections?: number;
  currentIpV6Enabled?: boolean;
}
export type HostNetworkResourceRuntime = DynamicData &  {
  pnicResourceInfo: HostPnicNetworkResourceInfo[];
}
export type HostRuntimeInfoNetworkRuntimeInfo = DynamicData &  {
  netStackInstanceRuntimeInfo?: HostRuntimeInfoNetStackInstanceRuntimeInfo[];
  networkResourceRuntime?: HostNetworkResourceRuntime;
}
export type HostPlacedVirtualNicIdentifier = DynamicData &  {
  vm: VirtualMachine;
  vnicKey: string;
  reservation?: number;
}
export type HostPnicNetworkResourceInfo = DynamicData &  {
  pnicDevice: string;
  availableBandwidthForVMTraffic?: number;
  unusedBandwidthForVMTraffic?: number;
  placedVirtualNics?: HostPlacedVirtualNicIdentifier[];
}
export type HostStorageSystemDiskLocatorLedResult = DynamicData &  {
  key: string;
  fault: MethodFault;
}
export type HostStorageSystemScsiLunResult = DynamicData &  {
  key: string;
  fault?: MethodFault;
}
export type HostStorageSystemVmfsVolumeResult = DynamicData &  {
  key: string;
  fault?: MethodFault;
}
export type HostVMotionManagerDstInstantCloneResult = DynamicData &  {
  dstVmId?: number;
  startTime?: number;
  cptLoadTime?: number;
  cptLoadDoneTime?: number;
  replicateMemDoneTime?: number;
  endTime?: number;
  cptXferTime?: number;
  cptCacheUsed?: number;
  devCptStreamSize?: number;
  devCptStreamTime?: number;
}
export type HostVMotionManagerSrcInstantCloneResult = DynamicData &  {
  startTime?: number;
  quiesceTime?: number;
  quiesceDoneTime?: number;
  resumeDoneTime?: number;
  endTime?: number;
}
export type VmfsDatastoreCreateSpec = VmfsDatastoreSpec &  {
  partition: HostDiskPartitionSpec;
  vmfs: HostVmfsSpec;
  extent?: HostScsiDiskPartition[];
}
export type VmfsDatastoreInfo = DatastoreInfo &  {
  maxPhysicalRDMFileSize: number;
  maxVirtualRDMFileSize: number;
  vmfs?: HostVmfsVolume;
}
export type VsanDatastoreInfo = DatastoreInfo &  {
  membershipUuid?: string;
  accessGenNo?: number;
}
export type VvolDatastoreInfo = DatastoreInfo &  {
  vvolDS?: HostVvolVolume;
}
export type HourlyTaskScheduler = RecurrentTaskScheduler &  {
  minute: number;
}
export type VirtualMachineDatastoreInfo = VirtualMachineTargetInfo &  {
  datastore: DatastoreSummary;
  capability: DatastoreCapability;
  maxFileSize: number;
  maxVirtualDiskCapacity?: number;
  maxPhysicalRDMFileSize?: number;
  maxVirtualRDMFileSize?: number;
  mode: string;
  vStorageSupport?: string;
}
export type ParaVirtualSCSIController = VirtualSCSIController &  {
  
}
export type ParaVirtualSCSIControllerOption = VirtualSCSIControllerOption &  {
  
}
export type VirtualAHCIController = VirtualSATAController &  {
  
}
export type VirtualAHCIControllerOption = VirtualSATAControllerOption &  {
  
}
export type VirtualBusLogicController = VirtualSCSIController &  {
  
}
export type VirtualBusLogicControllerOption = VirtualSCSIControllerOption &  {
  
}
export type VirtualLsiLogicController = VirtualSCSIController &  {
  
}
export type VirtualLsiLogicControllerOption = VirtualSCSIControllerOption &  {
  
}
export type VirtualLsiLogicSASController = VirtualSCSIController &  {
  
}
export type VirtualLsiLogicSASControllerOption = VirtualSCSIControllerOption &  {
  
}
export type ClusterComputeResourceClusterConfigResult = DynamicData &  {
  failedHosts?: FolderFailedHostResult[];
  configuredHosts?: HostSystem[];
}
export type ClusterComputeResourceDVSConfigurationValidation = ClusterComputeResourceValidationResultBase &  {
  isDvsValid: boolean;
  isDvpgValid: boolean;
}
export type ClusterComputeResourceDVSSetting = DynamicData &  {
  dvSwitch: DistributedVirtualSwitch;
  pnicDevices?: string[];
  dvPortgroupSetting?: ClusterComputeResourceDVSSettingDVPortgroupToServiceMapping[];
}
export type ClusterComputeResourceDVSSettingDVPortgroupToServiceMapping = DynamicData &  {
  dvPortgroup: DistributedVirtualPortgroup;
  service: string;
}
export type ClusterComputeResourceDvsProfile = DynamicData &  {
  dvsName?: string;
  dvSwitch?: DistributedVirtualSwitch;
  pnicDevices?: string[];
  dvPortgroupMapping?: ClusterComputeResourceDvsProfileDVPortgroupSpecToServiceMapping[];
}
export type ClusterComputeResourceDvsProfileDVPortgroupSpecToServiceMapping = DynamicData &  {
  dvPortgroupSpec?: DVPortgroupConfigSpec;
  dvPortgroup?: DistributedVirtualPortgroup;
  service: string;
}
export type ClusterComputeResourceHCIConfigInfo = DynamicData &  {
  workflowState: string;
  dvsSetting?: ClusterComputeResourceDVSSetting[];
  configuredHosts?: HostSystem[];
  hostConfigProfile?: ClusterComputeResourceHostConfigurationProfile;
}
export type ClusterComputeResourceHCIConfigSpec = DynamicData &  {
  dvsProf?: ClusterComputeResourceDvsProfile[];
  hostConfigProfile?: ClusterComputeResourceHostConfigurationProfile;
  vSanConfigSpec?: SDDCBase;
  vcProf?: ClusterComputeResourceVCProfile;
}
export type ClusterComputeResourceHostConfigurationInput = DynamicData &  {
  host: HostSystem;
  hostVmkNics?: ClusterComputeResourceHostVmkNicInfo[];
  allowedInNonMaintenanceMode?: boolean;
}
export type ClusterComputeResourceHostConfigurationProfile = DynamicData &  {
  dateTimeConfig?: HostDateTimeConfig;
  lockdownMode?: HostLockdownMode;
}
export type ClusterComputeResourceHostConfigurationValidation = ClusterComputeResourceValidationResultBase &  {
  host: HostSystem;
  isDvsSettingValid?: boolean;
  isVmknicSettingValid?: boolean;
  isNtpSettingValid?: boolean;
  isLockdownModeValid?: boolean;
}
export type ClusterComputeResourceHostVmkNicInfo = DynamicData &  {
  nicSpec: HostVirtualNicSpec;
  service: string;
}
export type ClusterComputeResourceSummary = ComputeResourceSummary &  {
  currentFailoverLevel: number;
  admissionControlInfo?: ClusterDasAdmissionControlInfo;
  numVmotions: number;
  targetBalance?: number;
  currentBalance?: number;
  drsScore?: number;
  numVmsPerDrsScoreBucket?: number[];
  usageSummary?: ClusterUsageSummary;
  currentEVCModeKey?: string;
  currentEVCGraphicsModeKey?: string;
  dasData?: ClusterDasData;
  clusterMaintenanceModeStatus?: string;
}
export type ClusterComputeResourceVCProfile = DynamicData &  {
  clusterSpec?: ClusterConfigSpecEx;
  evcModeKey?: string;
  evcGraphicsModeKey?: string;
}
export type ClusterComputeResourceValidationResultBase = DynamicData &  {
  info?: LocalizableMessage[];
}
export type CustomFieldDefAddedEvent = CustomFieldDefEvent &  {
  
}
export type ConnectedIso = OvfExport &  {
  cdrom: VirtualCdrom;
  filename: string;
}
export type CpuCompatibilityUnknown = CpuIncompatible &  {
  
}
export type DeviceBackingNotSupported = DeviceNotSupported &  {
  backing: string;
}
export type DeviceControllerNotSupported = DeviceNotSupported &  {
  controller: string;
}
export type DeviceHotPlugNotSupported = InvalidDeviceSpec &  {
  
}
export type DeviceNotFound = InvalidDeviceSpec &  {
  
}
export type DeviceUnsupportedForVmPlatform = InvalidDeviceSpec &  {
  
}
export type DeviceUnsupportedForVmVersion = InvalidDeviceSpec &  {
  currentVersion: string;
  expectedVersion: string;
}
export type DisallowedDiskModeChange = InvalidDeviceSpec &  {
  
}
export type GatewayHostNotReachable = GatewayToHostConnectFault &  {
  
}
export type GatewayToHostAuthFault = GatewayToHostConnectFault &  {
  invalidProperties: string[];
  missingProperties: string[];
}
export type InvalidController = InvalidDeviceSpec &  {
  controllerKey: number;
}
export type InvalidDeviceBacking = InvalidDeviceSpec &  {
  
}
export type InvalidDeviceOperation = InvalidDeviceSpec &  {
  badOp?: VirtualDeviceConfigSpecOperation;
  badFileOp?: VirtualDeviceConfigSpecFileOperation;
}
export type InvalidHostConnectionState = InvalidHostState &  {
  
}
export type OvfConnectedDevice = OvfHardwareExport &  {
  
}
export type OvfConnectedDeviceFloppy = OvfConnectedDevice &  {
  filename: string;
}
export type OvfConnectedDeviceIso = OvfConnectedDevice &  {
  filename: string;
}
export type OvfDuplicateElement = OvfElement &  {
  
}
export type OvfDuplicatedElementBoundary = OvfElement &  {
  boundary: string;
}
export type OvfDuplicatedPropertyIdExport = OvfExport &  {
  fqid: string;
}
export type OvfDuplicatedPropertyIdImport = OvfExport &  {
  
}
export type OvfNoSpaceOnController = OvfUnsupportedElement &  {
  parent: string;
}
export type PhysCompatRDMNotSupported = RDMNotSupported &  {
  
}
export type UnusedVirtualDiskBlocksNotScrubbed = DeviceBackingNotSupported &  {
  
}
export type VirtualDiskBlocksNotFullyProvisioned = DeviceBackingNotSupported &  {
  
}
export type DailyTaskScheduler = HourlyTaskScheduler &  {
  hour: number;
}
export type MonthlyTaskScheduler = DailyTaskScheduler &  {
  
}
export type WeeklyTaskScheduler = DailyTaskScheduler &  {
  sunday: boolean;
  monday: boolean;
  tuesday: boolean;
  wednesday: boolean;
  thursday: boolean;
  friday: boolean;
  saturday: boolean;
}
export type DVPortNotSupported = DeviceBackingNotSupported &  {
  
}
export type MonthlyByDayTaskScheduler = MonthlyTaskScheduler &  {
  day: number;
}
export type MonthlyByWeekdayTaskScheduler = MonthlyTaskScheduler &  {
  offset: WeekOfMonth;
  weekday: DayOfWeek;
}
export enum ObjectUpdateKind {
  modify = "modify",
  enter = "enter",
  leave = "leave"
}
export enum PropertyChangeOp {
  add = "add",
  remove = "remove",
  assign = "assign",
  indirectRemove = "indirectRemove"
}
export enum BatchResultResult {
  success = "success",
  fail = "fail"
}
export enum ConfigSpecOperation {
  add = "add",
  edit = "edit",
  remove = "remove"
}
export enum DiagnosticManagerLogCreator {
  vpxd = "vpxd",
  vpxa = "vpxa",
  hostd = "hostd",
  serverd = "serverd",
  install = "install",
  vpxClient = "vpxClient",
  recordLog = "recordLog"
}
export enum DiagnosticManagerLogFormat {
  plain = "plain"
}
export enum DrsInjectorWorkloadCorrelationState {
  correlated = "Correlated",
  uncorrelated = "Uncorrelated"
}
export enum ReplicationVmState {
  none = "none",
  paused = "paused",
  syncing = "syncing",
  idle = "idle",
  active = "active",
  error = "error"
}
export enum QuiesceMode {
  application = "application",
  filesystem = "filesystem",
  none = "none"
}
export enum HealthUpdateInfoComponentType {
  memory = "Memory",
  power = "Power",
  fan = "Fan",
  network = "Network",
  storage = "Storage"
}
export enum HttpNfcLeaseManifestEntryChecksumType {
  sha1 = "sha1",
  sha256 = "sha256"
}
export enum HttpNfcLeaseMode {
  pushOrGet = "pushOrGet",
  pull = "pull"
}
export enum HttpNfcLeaseState {
  initializing = "initializing",
  ready = "ready",
  done = "done",
  error = "error"
}
export enum IoFilterType {
  cache = "cache",
  replication = "replication",
  encryption = "encryption",
  compression = "compression",
  inspection = "inspection",
  datastoreIoControl = "datastoreIoControl",
  dataProvider = "dataProvider"
}
export enum IoFilterOperation {
  install = "install",
  uninstall = "uninstall",
  upgrade = "upgrade"
}
export enum LatencySensitivitySensitivityLevel {
  low = "low",
  normal = "normal",
  medium = "medium",
  high = "high",
  custom = "custom"
}
export enum LicenseFeatureInfoUnit {
  host = "host",
  cpuCore = "cpuCore",
  cpuPackage = "cpuPackage",
  server = "server",
  vm = "vm"
}
export enum LicenseFeatureInfoSourceRestriction {
  unrestricted = "unrestricted",
  served = "served",
  file = "file"
}
export enum LicenseFeatureInfoState {
  enabled = "enabled",
  disabled = "disabled",
  optional = "optional"
}
export enum HostLicensableResourceKey {
  numCpuPackages = "numCpuPackages",
  numCpuCores = "numCpuCores",
  memorySize = "memorySize",
  memoryForVms = "memoryForVms",
  numVmsStarted = "numVmsStarted",
  numVmsStarting = "numVmsStarting"
}
export enum LicenseManagerLicenseKey {
  esxFull = "esxFull",
  esxVmtn = "esxVmtn",
  esxExpress = "esxExpress",
  san = "san",
  iscsi = "iscsi",
  nas = "nas",
  vsmp = "vsmp",
  backup = "backup",
  vc = "vc",
  vcExpress = "vcExpress",
  esxHost = "esxHost",
  gsxHost = "gsxHost",
  serverHost = "serverHost",
  drsPower = "drsPower",
  vmotion = "vmotion",
  drs = "drs",
  das = "das"
}
export enum LicenseManagerState {
  initializing = "initializing",
  normal = "normal",
  marginal = "marginal",
  fault = "fault"
}
export enum LicenseReservationInfoState {
  notUsed = "notUsed",
  noLicense = "noLicense",
  unlicensedUse = "unlicensedUse",
  licensed = "licensed"
}
export enum OvfConsumerOstNodeType {
  envelope = "envelope",
  virtualSystem = "virtualSystem",
  virtualSystemCollection = "virtualSystemCollection"
}
export enum OvfCreateImportSpecParamsDiskProvisioningType {
  monolithicSparse = "monolithicSparse",
  monolithicFlat = "monolithicFlat",
  twoGbMaxExtentSparse = "twoGbMaxExtentSparse",
  twoGbMaxExtentFlat = "twoGbMaxExtentFlat",
  thin = "thin",
  thick = "thick",
  seSparse = "seSparse",
  eagerZeroedThick = "eagerZeroedThick",
  sparse = "sparse",
  flat = "flat"
}
export enum PerfSummaryType {
  average = "average",
  maximum = "maximum",
  minimum = "minimum",
  latest = "latest",
  summation = "summation",
  none = "none"
}
export enum PerfStatsType {
  absolute = "absolute",
  delta = "delta",
  rate = "rate"
}
export enum PerformanceManagerUnit {
  percent = "percent",
  kiloBytes = "kiloBytes",
  megaBytes = "megaBytes",
  megaHertz = "megaHertz",
  number = "number",
  microsecond = "microsecond",
  millisecond = "millisecond",
  second = "second",
  kiloBytesPerSecond = "kiloBytesPerSecond",
  megaBytesPerSecond = "megaBytesPerSecond",
  watt = "watt",
  joule = "joule",
  teraBytes = "teraBytes",
  celsius = "celsius"
}
export enum PerfFormat {
  normal = "normal",
  csv = "csv"
}
export enum ResourceConfigSpecScaleSharesBehavior {
  disabled = "disabled",
  scaleCpuAndMemoryShares = "scaleCpuAndMemoryShares"
}
export enum SessionManagerHttpServiceRequestSpecMethod {
  httpOptions = "httpOptions",
  httpGet = "httpGet",
  httpHead = "httpHead",
  httpPost = "httpPost",
  httpPut = "httpPut",
  httpDelete = "httpDelete",
  httpTrace = "httpTrace",
  httpConnect = "httpConnect"
}
export enum SharesLevel {
  low = "low",
  normal = "normal",
  high = "high",
  custom = "custom"
}
export enum SimpleCommandEncoding {
  csv = "CSV",
  hex = "HEX",
  string = "STRING"
}
export enum StorageIORMThresholdMode {
  automatic = "automatic",
  manual = "manual"
}
export enum TaskInfoState {
  queued = "queued",
  running = "running",
  success = "success",
  error = "error"
}
export enum VsanUpgradeSystemUpgradeHistoryDiskGroupOpType {
  add = "add",
  remove = "remove"
}
export enum ActionParameter {
  targetName = "targetName",
  alarmName = "alarmName",
  oldStatus = "oldStatus",
  newStatus = "newStatus",
  triggeringSummary = "triggeringSummary",
  declaringSummary = "declaringSummary",
  eventDescription = "eventDescription",
  target = "target",
  alarm = "alarm"
}
export enum MetricAlarmOperator {
  isAbove = "isAbove",
  isBelow = "isBelow"
}
export enum StateAlarmOperator {
  isEqual = "isEqual",
  isUnequal = "isUnequal"
}
export enum ActionType {
  migrationV1 = "MigrationV1",
  vmPowerV1 = "VmPowerV1",
  hostPowerV1 = "HostPowerV1",
  hostMaintenanceV1 = "HostMaintenanceV1",
  storageMigrationV1 = "StorageMigrationV1",
  storagePlacementV1 = "StoragePlacementV1",
  placementV1 = "PlacementV1",
  hostInfraUpdateHaV1 = "HostInfraUpdateHaV1"
}
export enum ClusterCryptoConfigInfoCryptoMode {
  onDemand = "onDemand",
  forceEnable = "forceEnable"
}
export enum ClusterDasAamNodeStateDasState {
  uninitialized = "uninitialized",
  initialized = "initialized",
  configuring = "configuring",
  unconfiguring = "unconfiguring",
  running = "running",
  error = "error",
  agentShutdown = "agentShutdown",
  nodeFailed = "nodeFailed"
}
export enum ClusterDasConfigInfoHBDatastoreCandidate {
  userSelectedDs = "userSelectedDs",
  allFeasibleDs = "allFeasibleDs",
  allFeasibleDsWithUserPreference = "allFeasibleDsWithUserPreference"
}
export enum ClusterDasConfigInfoServiceState {
  disabled = "disabled",
  enabled = "enabled"
}
export enum ClusterDasConfigInfoVmMonitoringState {
  vmMonitoringDisabled = "vmMonitoringDisabled",
  vmMonitoringOnly = "vmMonitoringOnly",
  vmAndAppMonitoring = "vmAndAppMonitoring"
}
export enum ClusterDasFdmAvailabilityState {
  uninitialized = "uninitialized",
  election = "election",
  master = "master",
  connectedToMaster = "connectedToMaster",
  networkPartitionedFromMaster = "networkPartitionedFromMaster",
  networkIsolated = "networkIsolated",
  hostDown = "hostDown",
  initializationError = "initializationError",
  uninitializationError = "uninitializationError",
  fdmUnreachable = "fdmUnreachable"
}
export enum DasVmPriority {
  disabled = "disabled",
  low = "low",
  medium = "medium",
  high = "high"
}
export enum ClusterDasVmSettingsIsolationResponse {
  none = "none",
  powerOff = "powerOff",
  shutdown = "shutdown",
  clusterIsolationResponse = "clusterIsolationResponse"
}
export enum ClusterDasVmSettingsRestartPriority {
  disabled = "disabled",
  lowest = "lowest",
  low = "low",
  medium = "medium",
  high = "high",
  highest = "highest",
  clusterRestartPriority = "clusterRestartPriority"
}
export enum DpmBehavior {
  manual = "manual",
  automated = "automated"
}
export enum DrsBehavior {
  manual = "manual",
  partiallyAutomated = "partiallyAutomated",
  fullyAutomated = "fullyAutomated"
}
export enum DrsRecommendationReasonCode {
  fairnessCpuAvg = "fairnessCpuAvg",
  fairnessMemAvg = "fairnessMemAvg",
  jointAffin = "jointAffin",
  antiAffin = "antiAffin",
  hostMaint = "hostMaint"
}
export enum ClusterHostInfraUpdateHaModeActionOperationType {
  enterQuarantine = "enterQuarantine",
  exitQuarantine = "exitQuarantine",
  enterMaintenance = "enterMaintenance"
}
export enum HostPowerOperationType {
  powerOn = "powerOn",
  powerOff = "powerOff"
}
export enum ClusterInfraUpdateHaConfigInfoBehaviorType {
  manual = "Manual",
  automated = "Automated"
}
export enum ClusterInfraUpdateHaConfigInfoRemediationType {
  quarantineMode = "QuarantineMode",
  maintenanceMode = "MaintenanceMode"
}
export enum ClusterPowerOnVmOption {
  overrideAutomationLevel = "OverrideAutomationLevel",
  reserveResources = "ReserveResources"
}
export enum RecommendationReasonCode {
  fairnessCpuAvg = "fairnessCpuAvg",
  fairnessMemAvg = "fairnessMemAvg",
  jointAffin = "jointAffin",
  antiAffin = "antiAffin",
  hostMaint = "hostMaint",
  enterStandby = "enterStandby",
  reservationCpu = "reservationCpu",
  reservationMem = "reservationMem",
  powerOnVm = "powerOnVm",
  powerSaving = "powerSaving",
  increaseCapacity = "increaseCapacity",
  checkResource = "checkResource",
  unreservedCapacity = "unreservedCapacity",
  vmHostHardAffinity = "vmHostHardAffinity",
  vmHostSoftAffinity = "vmHostSoftAffinity",
  balanceDatastoreSpaceUsage = "balanceDatastoreSpaceUsage",
  balanceDatastoreIoLoad = "balanceDatastoreIOLoad",
  balanceDatastoreIopsReservation = "balanceDatastoreIOPSReservation",
  datastoreMaint = "datastoreMaint",
  virtualDiskJointAffin = "virtualDiskJointAffin",
  virtualDiskAntiAffin = "virtualDiskAntiAffin",
  datastoreSpaceOutage = "datastoreSpaceOutage",
  storagePlacement = "storagePlacement",
  iolbDisabledInternal = "iolbDisabledInternal",
  xvmotionPlacement = "xvmotionPlacement",
  networkBandwidthReservation = "networkBandwidthReservation",
  hostInDegradation = "hostInDegradation",
  hostExitDegradation = "hostExitDegradation",
  maxVmsConstraint = "maxVmsConstraint",
  ftConstraints = "ftConstraints",
  vmHostAffinityPolicy = "vmHostAffinityPolicy",
  vmHostAntiAffinityPolicy = "vmHostAntiAffinityPolicy",
  vmAntiAffinityPolicy = "vmAntiAffinityPolicy"
}
export enum RecommendationType {
  v1 = "V1"
}
export enum ClusterVmComponentProtectionSettingsStorageVmReaction {
  disabled = "disabled",
  warning = "warning",
  restartConservative = "restartConservative",
  restartAggressive = "restartAggressive",
  clusterDefault = "clusterDefault"
}
export enum ClusterVmComponentProtectionSettingsVmReactionOnAPDCleared {
  none = "none",
  reset = "reset",
  useClusterDefault = "useClusterDefault"
}
export enum ClusterVmReadinessReadyCondition {
  none = "none",
  poweredOn = "poweredOn",
  guestHbStatusGreen = "guestHbStatusGreen",
  appHbStatusGreen = "appHbStatusGreen",
  useClusterDefault = "useClusterDefault"
}
export enum DvsFilterOnFailure {
  failOpen = "failOpen",
  failClosed = "failClosed"
}
export enum DVPortStatusVmDirectPathGen2InactiveReasonNetwork {
  portNptIncompatibleDvs = "portNptIncompatibleDvs",
  portNptNoCompatibleNics = "portNptNoCompatibleNics",
  portNptNoVirtualFunctionsAvailable = "portNptNoVirtualFunctionsAvailable",
  portNptDisabledForPort = "portNptDisabledForPort"
}
export enum DVPortStatusVmDirectPathGen2InactiveReasonOther {
  portNptIncompatibleHost = "portNptIncompatibleHost",
  portNptIncompatibleConnectee = "portNptIncompatibleConnectee"
}
export enum EntityType {
  distributedVirtualSwitch = "distributedVirtualSwitch",
  distributedVirtualPortgroup = "distributedVirtualPortgroup"
}
export enum EntityImportType {
  createEntityWithNewIdentifier = "createEntityWithNewIdentifier",
  createEntityWithOriginalIdentifier = "createEntityWithOriginalIdentifier",
  applyToEntitySpecified = "applyToEntitySpecified"
}
export enum DistributedVirtualSwitchHostMemberHostComponentState {
  up = "up",
  pending = "pending",
  outOfSync = "outOfSync",
  warning = "warning",
  disconnected = "disconnected",
  down = "down"
}
export enum DistributedVirtualSwitchHostMemberTransportZoneType {
  vlan = "vlan",
  overlay = "overlay"
}
export enum DistributedVirtualSwitchPortConnecteeConnecteeType {
  pnic = "pnic",
  vmVnic = "vmVnic",
  hostConsoleVnic = "hostConsoleVnic",
  hostVmkVnic = "hostVmkVnic"
}
export enum DvsNetworkRuleDirectionType {
  incomingPackets = "incomingPackets",
  outgoingPackets = "outgoingPackets",
  both = "both"
}
export enum KmipClusterInfoKmsManagementType {
  unknown = "unknown",
  vCenter = "vCenter",
  trustAuthority = "trustAuthority"
}
export enum EventEventSeverity {
  error = "error",
  warning = "warning",
  info = "info",
  user = "user"
}
export enum EventCategory {
  info = "info",
  warning = "warning",
  error = "error",
  user = "user"
}
export enum EventFilterSpecRecursionOption {
  self = "self",
  children = "children",
  all = "all"
}
export enum VmFailedStartingSecondaryEventFailureReason {
  incompatibleHost = "incompatibleHost",
  loginFailed = "loginFailed",
  registerVmFailed = "registerVmFailed",
  migrateFailed = "migrateFailed"
}
export enum VmShutdownOnIsolationEventOperation {
  shutdown = "shutdown",
  poweredOff = "poweredOff"
}
export enum DisallowedChangeByServiceDisallowedChange {
  hotExtendDisk = "hotExtendDisk"
}
export enum InvalidDasConfigArgumentEntryForInvalidArgument {
  admissionControl = "admissionControl",
  userHeartbeatDs = "userHeartbeatDs",
  vmConfig = "vmConfig"
}
export enum InvalidProfileReferenceHostReason {
  incompatibleVersion = "incompatibleVersion",
  missingReferenceHost = "missingReferenceHost"
}
export enum LicenseAssignmentFailedReason {
  keyEntityMismatch = "keyEntityMismatch",
  downgradeDisallowed = "downgradeDisallowed",
  inventoryNotManageableByVirtualCenter = "inventoryNotManageableByVirtualCenter",
  hostsUnmanageableByVirtualCenterWithoutLicenseServer = "hostsUnmanageableByVirtualCenterWithoutLicenseServer"
}
export enum ThirdPartyLicenseAssignmentFailedReason {
  licenseAssignmentFailed = "licenseAssignmentFailed",
  moduleNotInstalled = "moduleNotInstalled"
}
export enum AutoStartAction {
  none = "none",
  systemDefault = "systemDefault",
  powerOn = "powerOn",
  powerOff = "powerOff",
  guestShutdown = "guestShutdown",
  suspend = "suspend"
}
export enum AutoStartWaitHeartbeatSetting {
  yes = "yes",
  no = "no",
  systemDefault = "systemDefault"
}
export enum HostCapabilityFtUnsupportedReason {
  vMotionNotLicensed = "vMotionNotLicensed",
  missingVMotionNic = "missingVMotionNic",
  missingFtLoggingNic = "missingFTLoggingNic",
  ftNotLicensed = "ftNotLicensed",
  haAgentIssue = "haAgentIssue",
  unsupportedProduct = "unsupportedProduct",
  cpuHvUnsupported = "cpuHvUnsupported",
  cpuHwmmuUnsupported = "cpuHwmmuUnsupported",
  cpuHvDisabled = "cpuHvDisabled"
}
export enum HostReplayUnsupportedReason {
  incompatibleProduct = "incompatibleProduct",
  incompatibleCpu = "incompatibleCpu",
  hvDisabled = "hvDisabled",
  cpuidLimitSet = "cpuidLimitSet",
  oldBios = "oldBIOS",
  unknown = "unknown"
}
export enum HostCapabilityUnmapMethodSupported {
  priority = "priority",
  fixed = "fixed",
  dynamic = "dynamic"
}
export enum HostCapabilityVmDirectPathGen2UnsupportedReason {
  hostNptIncompatibleProduct = "hostNptIncompatibleProduct",
  hostNptIncompatibleHardware = "hostNptIncompatibleHardware",
  hostNptDisabled = "hostNptDisabled"
}
export enum HostCertificateManagerCertificateInfoCertificateStatus {
  unknown = "unknown",
  expired = "expired",
  expiring = "expiring",
  expiringShortly = "expiringShortly",
  expirationImminent = "expirationImminent",
  good = "good"
}
export enum HostConfigChangeMode {
  modify = "modify",
  replace = "replace"
}
export enum HostConfigChangeOperation {
  add = "add",
  remove = "remove",
  edit = "edit",
  ignore = "ignore"
}
export enum HostCpuPackageVendor {
  unknown = "unknown",
  intel = "intel",
  amd = "amd",
  hygon = "hygon"
}
export enum HostCpuPowerManagementInfoPolicyType {
  off = "off",
  staticPolicy = "staticPolicy",
  dynamicPolicy = "dynamicPolicy"
}
export enum HostDigestInfoDigestMethodType {
  sha1 = "SHA1",
  md5 = "MD5",
  sha256 = "SHA256",
  sha384 = "SHA384",
  sha512 = "SHA512",
  sm3256 = "SM3_256"
}
export enum HostDiskPartitionInfoPartitionFormat {
  gpt = "gpt",
  mbr = "mbr",
  unknown = "unknown"
}
export enum HostDiskPartitionInfoType {
  none = "none",
  vmfs = "vmfs",
  linuxNative = "linuxNative",
  linuxSwap = "linuxSwap",
  extended = "extended",
  ntfs = "ntfs",
  vmkDiagnostic = "vmkDiagnostic",
  vffs = "vffs"
}
export enum HostFeatureVersionKey {
  faultTolerance = "faultTolerance"
}
export enum FileSystemMountInfoVStorageSupportStatus {
  vStorageSupported = "vStorageSupported",
  vStorageUnsupported = "vStorageUnsupported",
  vStorageUnknown = "vStorageUnknown"
}
export enum HostFileSystemVolumeFileSystemType {
  vmfs = "VMFS",
  nfs = "NFS",
  nfs41 = "NFS41",
  cifs = "CIFS",
  vsan = "vsan",
  vffs = "VFFS",
  vvol = "VVOL",
  pmem = "PMEM",
  vsanD = "vsanD",
  other = "OTHER"
}
export enum HostGraphicsConfigGraphicsType {
  shared = "shared",
  sharedDirect = "sharedDirect"
}
export enum HostGraphicsConfigSharedPassthruAssignmentPolicy {
  performance = "performance",
  consolidation = "consolidation"
}
export enum HostGraphicsInfoGraphicsType {
  basic = "basic",
  shared = "shared",
  direct = "direct",
  sharedDirect = "sharedDirect"
}
export enum HostHardwareElementStatus {
  unknown = "Unknown",
  green = "Green",
  yellow = "Yellow",
  red = "Red"
}
export enum HostAccessMode {
  accessNone = "accessNone",
  accessAdmin = "accessAdmin",
  accessNoAccess = "accessNoAccess",
  accessReadOnly = "accessReadOnly",
  accessOther = "accessOther"
}
export enum HostLockdownMode {
  lockdownDisabled = "lockdownDisabled",
  lockdownNormal = "lockdownNormal",
  lockdownStrict = "lockdownStrict"
}
export enum HostImageAcceptanceLevel {
  vmwareCertified = "vmware_certified",
  vmwareAccepted = "vmware_accepted",
  partner = "partner",
  community = "community"
}
export enum HostIpConfigIpV6AddressConfigType {
  other = "other",
  manual = "manual",
  dhcp = "dhcp",
  linklayer = "linklayer",
  random = "random"
}
export enum HostIpConfigIpV6AddressStatus {
  preferred = "preferred",
  deprecated = "deprecated",
  invalid = "invalid",
  inaccessible = "inaccessible",
  unknown = "unknown",
  tentative = "tentative",
  duplicate = "duplicate"
}
export enum IscsiPortInfoPathStatus {
  notUsed = "notUsed",
  active = "active",
  standBy = "standBy",
  lastActive = "lastActive"
}
export enum LinkDiscoveryProtocolConfigOperationType {
  none = "none",
  listen = "listen",
  advertise = "advertise",
  both = "both"
}
export enum LinkDiscoveryProtocolConfigProtocolType {
  cdp = "cdp",
  lldp = "lldp"
}
export enum HostLowLevelProvisioningManagerFileType {
  file = "File",
  virtualDisk = "VirtualDisk",
  directory = "Directory"
}
export enum HostLowLevelProvisioningManagerReloadTarget {
  currentConfig = "currentConfig",
  snapshotConfig = "snapshotConfig"
}
export enum HostMaintenanceSpecPurpose {
  hostUpgrade = "hostUpgrade"
}
export enum VirtualMachineMemoryAllocationPolicy {
  swapNone = "swapNone",
  swapSome = "swapSome",
  swapMost = "swapMost"
}
export enum HostMountMode {
  readWrite = "readWrite",
  readOnly = "readOnly"
}
export enum HostMountInfoInaccessibleReason {
  allPathsDownStart = "AllPathsDown_Start",
  allPathsDownTimeout = "AllPathsDown_Timeout",
  permanentDeviceLoss = "PermanentDeviceLoss"
}
export enum MultipathState {
  standby = "standby",
  active = "active",
  disabled = "disabled",
  dead = "dead",
  unknown = "unknown"
}
export enum HostNasVolumeSecurityType {
  authSys = "AUTH_SYS",
  secKrb5 = "SEC_KRB5",
  secKrb5I = "SEC_KRB5I"
}
export enum HostNetStackInstanceCongestionControlAlgorithmType {
  newreno = "newreno",
  cubic = "cubic"
}
export enum HostNetStackInstanceSystemStackKey {
  defaultTcpipStack = "defaultTcpipStack",
  vmotion = "vmotion",
  vSphereProvisioning = "vSphereProvisioning"
}
export enum HostNumericSensorHealthState {
  unknown = "unknown",
  green = "green",
  yellow = "yellow",
  red = "red"
}
export enum HostNumericSensorType {
  fan = "fan",
  power = "power",
  temperature = "temperature",
  voltage = "voltage",
  other = "other",
  processor = "processor",
  memory = "memory",
  storage = "storage",
  systemBoard = "systemBoard",
  battery = "battery",
  bios = "bios",
  cable = "cable",
  watchdog = "watchdog"
}
export enum NvdimmNvdimmHealthInfoState {
  normal = "normal",
  error = "error"
}
export enum NvdimmInterleaveSetState {
  invalid = "invalid",
  active = "active"
}
export enum NvdimmNamespaceDetailsHealthStatus {
  normal = "normal",
  missing = "missing",
  labelMissing = "labelMissing",
  interleaveBroken = "interleaveBroken",
  labelInconsistent = "labelInconsistent"
}
export enum NvdimmNamespaceDetailsState {
  invalid = "invalid",
  notInUse = "notInUse",
  inUse = "inUse"
}
export enum NvdimmNamespaceHealthStatus {
  normal = "normal",
  missing = "missing",
  labelMissing = "labelMissing",
  interleaveBroken = "interleaveBroken",
  labelInconsistent = "labelInconsistent",
  bttCorrupt = "bttCorrupt",
  badBlockSize = "badBlockSize"
}
export enum NvdimmNamespaceState {
  invalid = "invalid",
  notInUse = "notInUse",
  inUse = "inUse"
}
export enum NvdimmNamespaceType {
  blockNamespace = "blockNamespace",
  persistentNamespace = "persistentNamespace"
}
export enum NvdimmRangeType {
  volatileRange = "volatileRange",
  persistentRange = "persistentRange",
  controlRange = "controlRange",
  blockRange = "blockRange",
  volatileVirtualDiskRange = "volatileVirtualDiskRange",
  volatileVirtualCdRange = "volatileVirtualCDRange",
  persistentVirtualDiskRange = "persistentVirtualDiskRange",
  persistentVirtualCdRange = "persistentVirtualCDRange"
}
export enum HostNvmeDiscoveryLogSubsystemType {
  discovery = "discovery",
  nvm = "nvm"
}
export enum HostNvmeDiscoveryLogTransportRequirements {
  secureChannelRequired = "secureChannelRequired",
  secureChannelNotRequired = "secureChannelNotRequired",
  requirementsNotSpecified = "requirementsNotSpecified"
}
export enum HostNvmeTransportParametersNvmeAddressFamily {
  ipv4 = "ipv4",
  ipv6 = "ipv6",
  infiniBand = "infiniBand",
  fc = "fc",
  loopback = "loopback",
  unknown = "unknown"
}
export enum HostNvmeTransportType {
  pcie = "pcie",
  fibreChannel = "fibreChannel",
  rdma = "rdma",
  loopback = "loopback",
  unsupported = "unsupported"
}
export enum HostOpaqueSwitchOpaqueSwitchState {
  up = "up",
  warning = "warning",
  down = "down",
  maintenance = "maintenance"
}
export enum HostPatchManagerInstallState {
  hostRestarted = "hostRestarted",
  imageActive = "imageActive"
}
export enum HostPatchManagerIntegrityStatus {
  validated = "validated",
  keyNotFound = "keyNotFound",
  keyRevoked = "keyRevoked",
  keyExpired = "keyExpired",
  digestMismatch = "digestMismatch",
  notEnoughSignatures = "notEnoughSignatures",
  validationError = "validationError"
}
export enum HostPatchManagerReason {
  obsoleted = "obsoleted",
  missingPatch = "missingPatch",
  missingLib = "missingLib",
  hasDependentPatch = "hasDependentPatch",
  conflictPatch = "conflictPatch",
  conflictLib = "conflictLib"
}
export enum PhysicalNicResourcePoolSchedulerDisallowedReason {
  userOptOut = "userOptOut",
  hardwareUnsupported = "hardwareUnsupported"
}
export enum PhysicalNicVmDirectPathGen2SupportedMode {
  upt = "upt"
}
export enum PortGroupConnecteeType {
  virtualMachine = "virtualMachine",
  systemManagement = "systemManagement",
  host = "host",
  unknown = "unknown"
}
export enum HostProtocolEndpointPEType {
  block = "block",
  nas = "nas"
}
export enum HostProtocolEndpointProtocolEndpointType {
  scsi = "scsi",
  nfs = "nfs",
  nfs4X = "nfs4x"
}
export enum HostRdmaDeviceConnectionState {
  unknown = "unknown",
  down = "down",
  init = "init",
  armed = "armed",
  active = "active",
  activeDefer = "activeDefer"
}
export enum HostFirewallRuleDirection {
  inbound = "inbound",
  outbound = "outbound"
}
export enum HostFirewallRulePortType {
  src = "src",
  dst = "dst"
}
export enum HostFirewallRuleProtocol {
  tcp = "tcp",
  udp = "udp"
}
export enum ScsiLunDescriptorQuality {
  highQuality = "highQuality",
  mediumQuality = "mediumQuality",
  lowQuality = "lowQuality",
  unknownQuality = "unknownQuality"
}
export enum ScsiLunType {
  disk = "disk",
  tape = "tape",
  printer = "printer",
  processor = "processor",
  worm = "worm",
  cdrom = "cdrom",
  scanner = "scanner",
  opticalDevice = "opticalDevice",
  mediaChanger = "mediaChanger",
  communications = "communications",
  storageArrayController = "storageArrayController",
  enclosure = "enclosure",
  unknown = "unknown"
}
export enum ScsiLunState {
  unknownState = "unknownState",
  ok = "ok",
  error = "error",
  off = "off",
  quiesced = "quiesced",
  degraded = "degraded",
  lostCommunication = "lostCommunication",
  timeout = "timeout"
}
export enum ScsiLunVStorageSupportStatus {
  vStorageSupported = "vStorageSupported",
  vStorageUnsupported = "vStorageUnsupported",
  vStorageUnknown = "vStorageUnknown"
}
export enum HostServicePolicy {
  on = "on",
  automatic = "automatic",
  off = "off"
}
export enum HostSevInfoSevState {
  uninitialized = "uninitialized",
  initialized = "initialized",
  working = "working"
}
export enum HostSgxInfoFlcModes {
  off = "off",
  locked = "locked",
  unlocked = "unlocked"
}
export enum HostSgxInfoSgxStates {
  notPresent = "notPresent",
  disabledBios = "disabledBIOS",
  disabledCfw101 = "disabledCFW101",
  disabledCpuMismatch = "disabledCPUMismatch",
  disabledNoFlc = "disabledNoFLC",
  disabledNumaUnsup = "disabledNUMAUnsup",
  disabledMaxEpcRegs = "disabledMaxEPCRegs",
  enabled = "enabled"
}
export enum HostSnmpAgentCapability {
  complete = "COMPLETE",
  diagnostics = "DIAGNOSTICS",
  configuration = "CONFIGURATION"
}
export enum SoftwarePackageConstraint {
  equals = "equals",
  lessThan = "lessThan",
  lessThanEqual = "lessThanEqual",
  greaterThanEqual = "greaterThanEqual",
  greaterThan = "greaterThan"
}
export enum SoftwarePackageVibType {
  bootbank = "bootbank",
  tools = "tools",
  meta = "meta"
}
export enum HostStorageProtocol {
  scsi = "scsi",
  nvme = "nvme"
}
export enum HostSystemIdentificationInfoIdentifier {
  assetTag = "AssetTag",
  serviceTag = "ServiceTag",
  oemSpecificString = "OemSpecificString",
  enclosureSerialNumberTag = "EnclosureSerialNumberTag",
  serialNumberTag = "SerialNumberTag"
}
export enum HostTpmAttestationInfoAcceptanceStatus {
  notAccepted = "notAccepted",
  accepted = "accepted"
}
export enum HostTrustAuthorityAttestationInfoAttestationStatus {
  attested = "attested",
  notAttested = "notAttested",
  unknown = "unknown"
}
export enum HostUnresolvedVmfsResolutionSpecVmfsUuidResolution {
  resignature = "resignature",
  forceMount = "forceMount"
}
export enum HostVirtualNicManagerNicType {
  vmotion = "vmotion",
  faultToleranceLogging = "faultToleranceLogging",
  vSphereReplication = "vSphereReplication",
  vSphereReplicationNfc = "vSphereReplicationNFC",
  management = "management",
  vsan = "vsan",
  vSphereProvisioning = "vSphereProvisioning",
  vsanWitness = "vsanWitness",
  vSphereBackupNfc = "vSphereBackupNFC",
  ptp = "ptp"
}
export enum HostVmciAccessManagerMode {
  grant = "grant",
  replace = "replace",
  revoke = "revoke"
}
export enum NetIpConfigInfoIpAddressOrigin {
  other = "other",
  manual = "manual",
  dhcp = "dhcp",
  linklayer = "linklayer",
  random = "random"
}
export enum NetIpConfigInfoIpAddressStatus {
  preferred = "preferred",
  deprecated = "deprecated",
  invalid = "invalid",
  inaccessible = "inaccessible",
  unknown = "unknown",
  tentative = "tentative",
  duplicate = "duplicate"
}
export enum NetIpStackInfoEntryType {
  other = "other",
  invalid = "invalid",
  dynamic = "dynamic",
  manual = "manual"
}
export enum NetIpStackInfoPreference {
  reserved = "reserved",
  low = "low",
  medium = "medium",
  high = "high"
}
export enum NetBIOSConfigInfoMode {
  unknown = "unknown",
  enabled = "enabled",
  disabled = "disabled",
  enabledViaDhcp = "enabledViaDHCP"
}
export enum ArrayUpdateOperation {
  add = "add",
  remove = "remove",
  edit = "edit"
}
export enum ComplianceResultStatus {
  compliant = "compliant",
  nonCompliant = "nonCompliant",
  unknown = "unknown",
  running = "running"
}
export enum ProfileNumericComparator {
  lessThan = "lessThan",
  lessThanEqual = "lessThanEqual",
  equal = "equal",
  notEqual = "notEqual",
  greaterThanEqual = "greaterThanEqual",
  greaterThan = "greaterThan"
}
export enum ProfileParameterMetadataRelationType {
  dynamicRelation = "dynamic_relation",
  extensibleRelation = "extensible_relation",
  localizableRelation = "localizable_relation",
  staticRelation = "static_relation",
  validationRelation = "validation_relation"
}
export enum ClusterProfileServiceType {
  drs = "DRS",
  ha = "HA",
  dpm = "DPM",
  ft = "FT"
}
export enum ProfileExecuteResultStatus {
  success = "success",
  needInput = "needInput",
  error = "error"
}
export enum AnswerFileValidationInfoStatus {
  success = "success",
  failed = "failed",
  failedDefaults = "failed_defaults"
}
export enum PlacementAffinityRuleRuleScope {
  cluster = "cluster",
  host = "host",
  storagePod = "storagePod",
  datastore = "datastore"
}
export enum PlacementAffinityRuleRuleType {
  affinity = "affinity",
  antiAffinity = "antiAffinity",
  softAffinity = "softAffinity",
  softAntiAffinity = "softAntiAffinity"
}
export enum StorageDrsPodConfigInfoBehavior {
  manual = "manual",
  automated = "automated"
}
export enum StorageDrsSpaceLoadBalanceConfigSpaceThresholdMode {
  utilization = "utilization",
  freeSpace = "freeSpace"
}
export enum VAppCloneSpecProvisioningType {
  sameAsSource = "sameAsSource",
  thin = "thin",
  thick = "thick"
}
export enum VAppAutoStartAction {
  none = "none",
  powerOn = "powerOn",
  powerOff = "powerOff",
  guestShutdown = "guestShutdown",
  suspend = "suspend"
}
export enum VAppIPAssignmentInfoAllocationSchemes {
  dhcp = "dhcp",
  ovfenv = "ovfenv"
}
export enum VAppIPAssignmentInfoIpAllocationPolicy {
  dhcpPolicy = "dhcpPolicy",
  transientPolicy = "transientPolicy",
  fixedPolicy = "fixedPolicy",
  fixedAllocatedPolicy = "fixedAllocatedPolicy"
}
export enum VAppIPAssignmentInfoProtocols {
  iPv4 = "IPv4",
  iPv6 = "IPv6"
}
export enum VchaState {
  configured = "configured",
  notConfigured = "notConfigured",
  invalid = "invalid",
  prepared = "prepared"
}
export enum VchaClusterMode {
  enabled = "enabled",
  disabled = "disabled",
  maintenance = "maintenance"
}
export enum VchaClusterState {
  healthy = "healthy",
  degraded = "degraded",
  isolated = "isolated"
}
export enum VchaNodeRole {
  active = "active",
  passive = "passive",
  witness = "witness"
}
export enum VchaNodeState {
  up = "up",
  down = "down"
}
export enum VirtualMachineBootOptionsNetworkBootProtocolType {
  ipv4 = "ipv4",
  ipv6 = "ipv6"
}
export enum VirtualMachineConfigInfoNpivWwnType {
  vc = "vc",
  host = "host",
  external = "external"
}
export enum VirtualMachineConfigInfoSwapPlacementType {
  inherit = "inherit",
  vmDirectory = "vmDirectory",
  hostLocal = "hostLocal"
}
export enum VirtualMachineConfigSpecEncryptedVMotionModes {
  disabled = "disabled",
  opportunistic = "opportunistic",
  required = "required"
}
export enum VirtualMachineConfigSpecNpivWwnOp {
  generate = "generate",
  set = "set",
  remove = "remove",
  extend = "extend"
}
export enum VirtualMachinePowerOpType {
  soft = "soft",
  hard = "hard",
  preset = "preset"
}
export enum VirtualMachineStandbyActionType {
  checkpoint = "checkpoint",
  powerOnSuspend = "powerOnSuspend"
}
export enum VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonOther {
  vmNptIncompatibleHost = "vmNptIncompatibleHost",
  vmNptIncompatibleNetwork = "vmNptIncompatibleNetwork"
}
export enum VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm {
  vmNptIncompatibleGuest = "vmNptIncompatibleGuest",
  vmNptIncompatibleGuestDriver = "vmNptIncompatibleGuestDriver",
  vmNptIncompatibleAdapterType = "vmNptIncompatibleAdapterType",
  vmNptDisabledOrDisconnectedAdapter = "vmNptDisabledOrDisconnectedAdapter",
  vmNptIncompatibleAdapterFeatures = "vmNptIncompatibleAdapterFeatures",
  vmNptIncompatibleBackingType = "vmNptIncompatibleBackingType",
  vmNptInsufficientMemoryReservation = "vmNptInsufficientMemoryReservation",
  vmNptFaultToleranceOrRecordReplayConfigured = "vmNptFaultToleranceOrRecordReplayConfigured",
  vmNptConflictingIoChainConfigured = "vmNptConflictingIOChainConfigured",
  vmNptMonitorBlocks = "vmNptMonitorBlocks",
  vmNptConflictingOperationInProgress = "vmNptConflictingOperationInProgress",
  vmNptRuntimeError = "vmNptRuntimeError",
  vmNptOutOfIntrVector = "vmNptOutOfIntrVector",
  vmNptVmciActive = "vmNptVMCIActive"
}
export enum VirtualMachineFileLayoutExFileType {
  config = "config",
  extendedConfig = "extendedConfig",
  diskDescriptor = "diskDescriptor",
  diskExtent = "diskExtent",
  digestDescriptor = "digestDescriptor",
  digestExtent = "digestExtent",
  diskReplicationState = "diskReplicationState",
  log = "log",
  stat = "stat",
  namespaceData = "namespaceData",
  nvram = "nvram",
  snapshotData = "snapshotData",
  snapshotMemory = "snapshotMemory",
  snapshotList = "snapshotList",
  snapshotManifestList = "snapshotManifestList",
  suspend = "suspend",
  suspendMemory = "suspendMemory",
  swap = "swap",
  uwswap = "uwswap",
  core = "core",
  screenshot = "screenshot",
  ftMetadata = "ftMetadata",
  guestCustomization = "guestCustomization"
}
export enum VirtualMachineHtSharing {
  any = "any",
  none = "none",
  internal = "internal"
}
export enum VirtualMachineFlagInfoMonitorType {
  release = "release",
  debug = "debug",
  stats = "stats"
}
export enum VirtualMachinePowerOffBehavior {
  powerOff = "powerOff",
  revert = "revert",
  prompt = "prompt",
  take = "take"
}
export enum VirtualMachineFlagInfoVirtualExecUsage {
  hvAuto = "hvAuto",
  hvOn = "hvOn",
  hvOff = "hvOff"
}
export enum VirtualMachineFlagInfoVirtualMmuUsage {
  automatic = "automatic",
  on = "on",
  off = "off"
}
export enum VirtualMachineForkConfigInfoChildType {
  none = "none",
  persistent = "persistent",
  nonpersistent = "nonpersistent"
}
export enum GuestInfoAppStateType {
  none = "none",
  appStateOk = "appStateOk",
  appStateNeedReset = "appStateNeedReset"
}
export enum VirtualMachineGuestState {
  running = "running",
  shuttingDown = "shuttingDown",
  resetting = "resetting",
  standby = "standby",
  notRunning = "notRunning",
  unknown = "unknown"
}
export enum VirtualMachineToolsInstallType {
  guestToolsTypeUnknown = "guestToolsTypeUnknown",
  guestToolsTypeMsi = "guestToolsTypeMSI",
  guestToolsTypeTar = "guestToolsTypeTar",
  guestToolsTypeOsp = "guestToolsTypeOSP",
  guestToolsTypeOpenVmTools = "guestToolsTypeOpenVMTools"
}
export enum VirtualMachineToolsRunningStatus {
  guestToolsNotRunning = "guestToolsNotRunning",
  guestToolsRunning = "guestToolsRunning",
  guestToolsExecutingScripts = "guestToolsExecutingScripts"
}
export enum VirtualMachineToolsStatus {
  toolsNotInstalled = "toolsNotInstalled",
  toolsNotRunning = "toolsNotRunning",
  toolsOld = "toolsOld",
  toolsOk = "toolsOk"
}
export enum VirtualMachineToolsVersionStatus {
  guestToolsNotInstalled = "guestToolsNotInstalled",
  guestToolsNeedUpgrade = "guestToolsNeedUpgrade",
  guestToolsCurrent = "guestToolsCurrent",
  guestToolsUnmanaged = "guestToolsUnmanaged",
  guestToolsTooOld = "guestToolsTooOld",
  guestToolsSupportedOld = "guestToolsSupportedOld",
  guestToolsSupportedNew = "guestToolsSupportedNew",
  guestToolsTooNew = "guestToolsTooNew",
  guestToolsBlacklisted = "guestToolsBlacklisted"
}
export enum GuestOsDescriptorFirmwareType {
  bios = "bios",
  efi = "efi"
}
export enum VirtualMachineGuestOsFamily {
  windowsGuest = "windowsGuest",
  linuxGuest = "linuxGuest",
  netwareGuest = "netwareGuest",
  solarisGuest = "solarisGuest",
  darwinGuestFamily = "darwinGuestFamily",
  otherGuestFamily = "otherGuestFamily"
}
export enum VirtualMachineGuestOsIdentifier {
  dosGuest = "dosGuest",
  win31Guest = "win31Guest",
  win95Guest = "win95Guest",
  win98Guest = "win98Guest",
  winMeGuest = "winMeGuest",
  winNtGuest = "winNTGuest",
  win2000ProGuest = "win2000ProGuest",
  win2000ServGuest = "win2000ServGuest",
  win2000AdvServGuest = "win2000AdvServGuest",
  winXpHomeGuest = "winXPHomeGuest",
  winXpProGuest = "winXPProGuest",
  winXpPro64Guest = "winXPPro64Guest",
  winNetWebGuest = "winNetWebGuest",
  winNetStandardGuest = "winNetStandardGuest",
  winNetEnterpriseGuest = "winNetEnterpriseGuest",
  winNetDatacenterGuest = "winNetDatacenterGuest",
  winNetBusinessGuest = "winNetBusinessGuest",
  winNetStandard64Guest = "winNetStandard64Guest",
  winNetEnterprise64Guest = "winNetEnterprise64Guest",
  winLonghornGuest = "winLonghornGuest",
  winLonghorn64Guest = "winLonghorn64Guest",
  winNetDatacenter64Guest = "winNetDatacenter64Guest",
  winVistaGuest = "winVistaGuest",
  winVista64Guest = "winVista64Guest",
  windows7Guest = "windows7Guest",
  windows764Guest = "windows7_64Guest",
  windows7Server64Guest = "windows7Server64Guest",
  windows8Guest = "windows8Guest",
  windows864Guest = "windows8_64Guest",
  windows8Server64Guest = "windows8Server64Guest",
  windows9Guest = "windows9Guest",
  windows964Guest = "windows9_64Guest",
  windows9Server64Guest = "windows9Server64Guest",
  windowsHyperVGuest = "windowsHyperVGuest",
  windows2019Srv64Guest = "windows2019srv_64Guest",
  windows2019SrvNext64Guest = "windows2019srvNext_64Guest",
  freebsdGuest = "freebsdGuest",
  freebsd64Guest = "freebsd64Guest",
  freebsd11Guest = "freebsd11Guest",
  freebsd1164Guest = "freebsd11_64Guest",
  freebsd12Guest = "freebsd12Guest",
  freebsd1264Guest = "freebsd12_64Guest",
  freebsd13Guest = "freebsd13Guest",
  freebsd1364Guest = "freebsd13_64Guest",
  redhatGuest = "redhatGuest",
  rhel2Guest = "rhel2Guest",
  rhel3Guest = "rhel3Guest",
  rhel364Guest = "rhel3_64Guest",
  rhel4Guest = "rhel4Guest",
  rhel464Guest = "rhel4_64Guest",
  rhel5Guest = "rhel5Guest",
  rhel564Guest = "rhel5_64Guest",
  rhel6Guest = "rhel6Guest",
  rhel664Guest = "rhel6_64Guest",
  rhel7Guest = "rhel7Guest",
  rhel764Guest = "rhel7_64Guest",
  rhel864Guest = "rhel8_64Guest",
  rhel964Guest = "rhel9_64Guest",
  centosGuest = "centosGuest",
  centos64Guest = "centos64Guest",
  centos6Guest = "centos6Guest",
  centos664Guest = "centos6_64Guest",
  centos7Guest = "centos7Guest",
  centos764Guest = "centos7_64Guest",
  centos864Guest = "centos8_64Guest",
  centos964Guest = "centos9_64Guest",
  oracleLinuxGuest = "oracleLinuxGuest",
  oracleLinux64Guest = "oracleLinux64Guest",
  oracleLinux6Guest = "oracleLinux6Guest",
  oracleLinux664Guest = "oracleLinux6_64Guest",
  oracleLinux7Guest = "oracleLinux7Guest",
  oracleLinux764Guest = "oracleLinux7_64Guest",
  oracleLinux864Guest = "oracleLinux8_64Guest",
  oracleLinux964Guest = "oracleLinux9_64Guest",
  suseGuest = "suseGuest",
  suse64Guest = "suse64Guest",
  slesGuest = "slesGuest",
  sles64Guest = "sles64Guest",
  sles10Guest = "sles10Guest",
  sles1064Guest = "sles10_64Guest",
  sles11Guest = "sles11Guest",
  sles1164Guest = "sles11_64Guest",
  sles12Guest = "sles12Guest",
  sles1264Guest = "sles12_64Guest",
  sles1564Guest = "sles15_64Guest",
  sles1664Guest = "sles16_64Guest",
  nld9Guest = "nld9Guest",
  oesGuest = "oesGuest",
  sjdsGuest = "sjdsGuest",
  mandrakeGuest = "mandrakeGuest",
  mandrivaGuest = "mandrivaGuest",
  mandriva64Guest = "mandriva64Guest",
  turboLinuxGuest = "turboLinuxGuest",
  turboLinux64Guest = "turboLinux64Guest",
  ubuntuGuest = "ubuntuGuest",
  ubuntu64Guest = "ubuntu64Guest",
  debian4Guest = "debian4Guest",
  debian464Guest = "debian4_64Guest",
  debian5Guest = "debian5Guest",
  debian564Guest = "debian5_64Guest",
  debian6Guest = "debian6Guest",
  debian664Guest = "debian6_64Guest",
  debian7Guest = "debian7Guest",
  debian764Guest = "debian7_64Guest",
  debian8Guest = "debian8Guest",
  debian864Guest = "debian8_64Guest",
  debian9Guest = "debian9Guest",
  debian964Guest = "debian9_64Guest",
  debian10Guest = "debian10Guest",
  debian1064Guest = "debian10_64Guest",
  debian11Guest = "debian11Guest",
  debian1164Guest = "debian11_64Guest",
  asianux3Guest = "asianux3Guest",
  asianux364Guest = "asianux3_64Guest",
  asianux4Guest = "asianux4Guest",
  asianux464Guest = "asianux4_64Guest",
  asianux564Guest = "asianux5_64Guest",
  asianux764Guest = "asianux7_64Guest",
  asianux864Guest = "asianux8_64Guest",
  asianux964Guest = "asianux9_64Guest",
  opensuseGuest = "opensuseGuest",
  opensuse64Guest = "opensuse64Guest",
  fedoraGuest = "fedoraGuest",
  fedora64Guest = "fedora64Guest",
  coreos64Guest = "coreos64Guest",
  vmwarePhoton64Guest = "vmwarePhoton64Guest",
  other24XLinuxGuest = "other24xLinuxGuest",
  other26XLinuxGuest = "other26xLinuxGuest",
  otherLinuxGuest = "otherLinuxGuest",
  other3XLinuxGuest = "other3xLinuxGuest",
  other4XLinuxGuest = "other4xLinuxGuest",
  other5XLinuxGuest = "other5xLinuxGuest",
  genericLinuxGuest = "genericLinuxGuest",
  other24XLinux64Guest = "other24xLinux64Guest",
  other26XLinux64Guest = "other26xLinux64Guest",
  other3XLinux64Guest = "other3xLinux64Guest",
  other4XLinux64Guest = "other4xLinux64Guest",
  other5XLinux64Guest = "other5xLinux64Guest",
  otherLinux64Guest = "otherLinux64Guest",
  solaris6Guest = "solaris6Guest",
  solaris7Guest = "solaris7Guest",
  solaris8Guest = "solaris8Guest",
  solaris9Guest = "solaris9Guest",
  solaris10Guest = "solaris10Guest",
  solaris1064Guest = "solaris10_64Guest",
  solaris1164Guest = "solaris11_64Guest",
  os2Guest = "os2Guest",
  eComStationGuest = "eComStationGuest",
  eComStation2Guest = "eComStation2Guest",
  netware4Guest = "netware4Guest",
  netware5Guest = "netware5Guest",
  netware6Guest = "netware6Guest",
  openServer5Guest = "openServer5Guest",
  openServer6Guest = "openServer6Guest",
  unixWare7Guest = "unixWare7Guest",
  darwinGuest = "darwinGuest",
  darwin64Guest = "darwin64Guest",
  darwin10Guest = "darwin10Guest",
  darwin1064Guest = "darwin10_64Guest",
  darwin11Guest = "darwin11Guest",
  darwin1164Guest = "darwin11_64Guest",
  darwin1264Guest = "darwin12_64Guest",
  darwin1364Guest = "darwin13_64Guest",
  darwin1464Guest = "darwin14_64Guest",
  darwin1564Guest = "darwin15_64Guest",
  darwin1664Guest = "darwin16_64Guest",
  darwin1764Guest = "darwin17_64Guest",
  darwin1864Guest = "darwin18_64Guest",
  darwin1964Guest = "darwin19_64Guest",
  darwin2064Guest = "darwin20_64Guest",
  darwin2164Guest = "darwin21_64Guest",
  vmkernelGuest = "vmkernelGuest",
  vmkernel5Guest = "vmkernel5Guest",
  vmkernel6Guest = "vmkernel6Guest",
  vmkernel65Guest = "vmkernel65Guest",
  vmkernel7Guest = "vmkernel7Guest",
  amazonlinux264Guest = "amazonlinux2_64Guest",
  amazonlinux364Guest = "amazonlinux3_64Guest",
  crxPod1Guest = "crxPod1Guest",
  otherGuest = "otherGuest",
  otherGuest64 = "otherGuest64"
}
export enum GuestOsDescriptorSupportLevel {
  experimental = "experimental",
  legacy = "legacy",
  terminated = "terminated",
  supported = "supported",
  unsupported = "unsupported",
  deprecated = "deprecated",
  techPreview = "techPreview"
}
export enum VirtualMachineMetadataManagerVmMetadataOp {
  update = "Update",
  remove = "Remove"
}
export enum VirtualMachineMetadataManagerVmMetadataOwnerOwner {
  comVmwareVsphereHa = "ComVmwareVsphereHA"
}
export enum ScheduledHardwareUpgradeInfoHardwareUpgradePolicy {
  never = "never",
  onSoftPowerOff = "onSoftPowerOff",
  always = "always"
}
export enum ScheduledHardwareUpgradeInfoHardwareUpgradeStatus {
  none = "none",
  pending = "pending",
  success = "success",
  failed = "failed"
}
export enum VirtualMachineSgxInfoFlcModes {
  locked = "locked",
  unlocked = "unlocked"
}
export enum VirtualMachineTargetInfoConfigurationTag {
  compliant = "compliant",
  clusterWide = "clusterWide"
}
export enum UpgradePolicy {
  manual = "manual",
  upgradeAtPowerCycle = "upgradeAtPowerCycle"
}
export enum VirtualMachineUsbInfoFamily {
  audio = "audio",
  hid = "hid",
  hidBootable = "hid_bootable",
  physical = "physical",
  communication = "communication",
  imaging = "imaging",
  printer = "printer",
  storage = "storage",
  hub = "hub",
  smartCard = "smart_card",
  security = "security",
  video = "video",
  wireless = "wireless",
  bluetooth = "bluetooth",
  wusb = "wusb",
  pda = "pda",
  vendorSpecific = "vendor_specific",
  other = "other",
  unknownFamily = "unknownFamily"
}
export enum VirtualMachineUsbInfoSpeed {
  low = "low",
  full = "full",
  high = "high",
  superSpeed = "superSpeed",
  superSpeedPlus = "superSpeedPlus",
  unknownSpeed = "unknownSpeed"
}
export enum VirtualMachineWindowsQuiesceSpecVssBackupContext {
  ctxAuto = "ctx_auto",
  ctxBackup = "ctx_backup",
  ctxFileShareBackup = "ctx_file_share_backup"
}
export enum CheckTestType {
  sourceTests = "sourceTests",
  hostTests = "hostTests",
  resourcePoolTests = "resourcePoolTests",
  datastoreTests = "datastoreTests",
  networkTests = "networkTests"
}
export enum CustomizationNetBIOSMode {
  enableNetBiosViaDhcp = "enableNetBIOSViaDhcp",
  enableNetBios = "enableNetBIOS",
  disableNetBios = "disableNetBIOS"
}
export enum CustomizationLicenseDataMode {
  perServer = "perServer",
  perSeat = "perSeat"
}
export enum CustomizationSysprepRebootOption {
  reboot = "reboot",
  noreboot = "noreboot",
  shutdown = "shutdown"
}
export enum VirtualDeviceConnectInfoMigrateConnectOp {
  connect = "connect",
  disconnect = "disconnect",
  unset = "unset"
}
export enum VirtualDeviceConnectInfoStatus {
  ok = "ok",
  recoverableError = "recoverableError",
  unrecoverableError = "unrecoverableError",
  untried = "untried"
}
export enum VirtualDeviceFileExtension {
  iso = "iso",
  flp = "flp",
  vmdk = "vmdk",
  dsk = "dsk",
  rdm = "rdm"
}
export enum VirtualDeviceURIBackingOptionDirection {
  server = "server",
  client = "client"
}
export enum VirtualDeviceConfigSpecFileOperation {
  create = "create",
  destroy = "destroy",
  replace = "replace"
}
export enum VirtualDeviceConfigSpecOperation {
  add = "add",
  remove = "remove",
  edit = "edit"
}
export enum VirtualDiskDeltaDiskFormat {
  redoLogFormat = "redoLogFormat",
  nativeFormat = "nativeFormat",
  seSparseFormat = "seSparseFormat"
}
export enum VirtualDiskDeltaDiskFormatVariant {
  vmfsSparseVariant = "vmfsSparseVariant",
  vsanSparseVariant = "vsanSparseVariant"
}
export enum VirtualDiskSharing {
  sharingNone = "sharingNone",
  sharingMultiWriter = "sharingMultiWriter"
}
export enum VirtualDiskVFlashCacheConfigInfoCacheConsistencyType {
  strong = "strong",
  weak = "weak"
}
export enum VirtualDiskVFlashCacheConfigInfoCacheMode {
  writeThru = "write_thru",
  writeBack = "write_back"
}
export enum VirtualDiskCompatibilityMode {
  virtualMode = "virtualMode",
  physicalMode = "physicalMode"
}
export enum VirtualDiskMode {
  persistent = "persistent",
  nonpersistent = "nonpersistent",
  undoable = "undoable",
  independentPersistent = "independent_persistent",
  independentNonpersistent = "independent_nonpersistent",
  append = "append"
}
export enum VirtualEthernetCardLegacyNetworkDeviceName {
  bridged = "bridged",
  nat = "nat",
  hostonly = "hostonly"
}
export enum VirtualEthernetCardMacType {
  manual = "manual",
  generated = "generated",
  assigned = "assigned"
}
export enum VirtualPointingDeviceHostChoice {
  autodetect = "autodetect",
  intellimouseExplorer = "intellimouseExplorer",
  intellimousePs2 = "intellimousePs2",
  logitechMouseman = "logitechMouseman",
  microsoftSerial = "microsoft_serial",
  mouseSystems = "mouseSystems",
  mousemanSerial = "mousemanSerial",
  ps2 = "ps2"
}
export enum VirtualSerialPortEndPoint {
  client = "client",
  server = "server"
}
export enum VirtualMachineVMCIDeviceAction {
  allow = "allow",
  deny = "deny"
}
export enum VirtualMachineVMCIDeviceDirection {
  guest = "guest",
  host = "host",
  anyDirection = "anyDirection"
}
export enum VirtualMachineVMCIDeviceProtocol {
  hypervisor = "hypervisor",
  doorbell = "doorbell",
  queuepair = "queuepair",
  datagram = "datagram",
  stream = "stream",
  anyProtocol = "anyProtocol"
}
export enum VirtualMachineVideoCardUse3dRenderer {
  automatic = "automatic",
  software = "software",
  hardware = "hardware"
}
export enum GuestFileType {
  file = "file",
  directory = "directory",
  symlink = "symlink"
}
export enum GuestRegKeyWowSpec {
  wowNative = "WOWNative",
  wow32 = "WOW32",
  wow64 = "WOW64"
}
export enum VsanHostDecommissionModeObjectAction {
  noAction = "noAction",
  ensureObjectAccessibility = "ensureObjectAccessibility",
  evacuateAllData = "evacuateAllData"
}
export enum VsanHostDiskResultState {
  inUse = "inUse",
  eligible = "eligible",
  ineligible = "ineligible"
}
export enum VsanHostHealthState {
  unknown = "unknown",
  healthy = "healthy",
  unhealthy = "unhealthy"
}
export enum VsanHostNodeState {
  error = "error",
  disabled = "disabled",
  agent = "agent",
  master = "master",
  backup = "backup",
  starting = "starting",
  stopping = "stopping",
  enteringMaintenanceMode = "enteringMaintenanceMode",
  exitingMaintenanceMode = "exitingMaintenanceMode",
  decommissioning = "decommissioning"
}
export enum VsanDiskIssueType {
  nonExist = "nonExist",
  stampMismatch = "stampMismatch",
  unknown = "unknown"
}
export enum BaseConfigInfoDiskFileBackingInfoProvisioningType {
  thin = "thin",
  eagerZeroedThick = "eagerZeroedThick",
  lazyZeroedThick = "lazyZeroedThick"
}
export enum VStorageObjectConsumptionType {
  disk = "disk"
}
export enum vslmVStorageObjectControlFlag {
  keepAfterDeleteVm = "keepAfterDeleteVm",
  disableRelocation = "disableRelocation",
  enableChangedBlockTracking = "enableChangedBlockTracking"
}
export enum ManagedEntityStatus {
  gray = "gray",
  green = "green",
  yellow = "yellow",
  red = "red"
}
export enum TaskFilterSpecRecursionOption {
  self = "self",
  children = "children",
  all = "all"
}
export enum TaskFilterSpecTimeOption {
  queuedTime = "queuedTime",
  startedTime = "startedTime",
  completedTime = "completedTime"
}
export enum VirtualAppVAppState {
  started = "started",
  stopped = "stopped",
  starting = "starting",
  stopping = "stopping"
}
export enum VirtualDiskAdapterType {
  ide = "ide",
  busLogic = "busLogic",
  lsiLogic = "lsiLogic"
}
export enum VirtualDiskType {
  preallocated = "preallocated",
  thin = "thin",
  seSparse = "seSparse",
  rdm = "rdm",
  rdmp = "rdmp",
  raw = "raw",
  delta = "delta",
  sparse2Gb = "sparse2Gb",
  thick2Gb = "thick2Gb",
  eagerZeroedThick = "eagerZeroedThick",
  sparseMonolithic = "sparseMonolithic",
  flatMonolithic = "flatMonolithic",
  thick = "thick"
}
export enum VirtualMachineAppHeartbeatStatusType {
  appStatusGray = "appStatusGray",
  appStatusGreen = "appStatusGreen",
  appStatusRed = "appStatusRed"
}
export enum VirtualMachineConnectionState {
  connected = "connected",
  disconnected = "disconnected",
  orphaned = "orphaned",
  inaccessible = "inaccessible",
  invalid = "invalid"
}
export enum VirtualMachineCryptoState {
  unlocked = "unlocked",
  locked = "locked"
}
export enum VirtualMachineFaultToleranceState {
  notConfigured = "notConfigured",
  disabled = "disabled",
  enabled = "enabled",
  needSecondary = "needSecondary",
  starting = "starting",
  running = "running"
}
export enum VirtualMachineFaultToleranceType {
  unset = "unset",
  recordReplay = "recordReplay",
  checkpointing = "checkpointing"
}
export enum VirtualMachineMovePriority {
  lowPriority = "lowPriority",
  highPriority = "highPriority",
  defaultPriority = "defaultPriority"
}
export enum VirtualMachineNeedSecondaryReason {
  initializing = "initializing",
  divergence = "divergence",
  lostConnection = "lostConnection",
  partialHardwareFailure = "partialHardwareFailure",
  userAction = "userAction",
  checkpointError = "checkpointError",
  other = "other"
}
export enum VirtualMachinePowerState {
  poweredOff = "poweredOff",
  poweredOn = "poweredOn",
  suspended = "suspended"
}
export enum VirtualMachineRecordReplayState {
  recording = "recording",
  replaying = "replaying",
  inactive = "inactive"
}
export enum VirtualMachineTicketType {
  mks = "mks",
  device = "device",
  guestControl = "guestControl",
  webmks = "webmks",
  guestIntegrity = "guestIntegrity",
  webRemoteDevice = "webRemoteDevice"
}
export enum AlarmFilterSpecAlarmTypeByEntity {
  entityTypeAll = "entityTypeAll",
  entityTypeHost = "entityTypeHost",
  entityTypeVm = "entityTypeVm"
}
export enum AlarmFilterSpecAlarmTypeByTrigger {
  triggerTypeAll = "triggerTypeAll",
  triggerTypeEvent = "triggerTypeEvent",
  triggerTypeMetric = "triggerTypeMetric"
}
export enum EventAlarmExpressionComparisonOperator {
  equals = "equals",
  notEqualTo = "notEqualTo",
  startsWith = "startsWith",
  doesNotStartWith = "doesNotStartWith",
  endsWith = "endsWith",
  doesNotEndWith = "doesNotEndWith"
}
export enum PlacementSpecPlacementType {
  create = "create",
  reconfigure = "reconfigure",
  relocate = "relocate",
  clone = "clone"
}
export enum DistributedVirtualPortgroupBackingType {
  standard = "standard",
  nsx = "nsx"
}
export enum DistributedVirtualPortgroupMetaTagName {
  dvsName = "dvsName",
  portgroupName = "portgroupName",
  portIndex = "portIndex"
}
export enum DistributedVirtualPortgroupPortgroupType {
  earlyBinding = "earlyBinding",
  lateBinding = "lateBinding",
  ephemeral = "ephemeral"
}
export enum CryptoManagerKmipCryptoKeyStatusKeyUnavailableReason {
  keyStateMissingInCache = "KeyStateMissingInCache",
  keyStateClusterInvalid = "KeyStateClusterInvalid",
  keyStateClusterUnreachable = "KeyStateClusterUnreachable",
  keyStateMissingInKms = "KeyStateMissingInKMS",
  keyStateNotActiveOrEnabled = "KeyStateNotActiveOrEnabled",
  keyStateManagedByTrustAuthority = "KeyStateManagedByTrustAuthority"
}
export enum CustomizationFailedReasonCode {
  userDefinedScriptDisabled = "userDefinedScriptDisabled",
  customizationDisabled = "customizationDisabled"
}
export enum DvsEventPortBlockState {
  unset = "unset",
  blocked = "blocked",
  unblocked = "unblocked",
  unknown = "unknown"
}
export enum HostDasErrorEventHostDasErrorReason {
  configFailed = "configFailed",
  timeout = "timeout",
  communicationInitFailed = "communicationInitFailed",
  healthCheckScriptFailed = "healthCheckScriptFailed",
  agentFailed = "agentFailed",
  agentShutdown = "agentShutdown",
  isolationAddressUnpingable = "isolationAddressUnpingable",
  other = "other"
}
export enum HostDisconnectedEventReasonCode {
  sslThumbprintVerifyFailed = "sslThumbprintVerifyFailed",
  licenseExpired = "licenseExpired",
  agentUpgrade = "agentUpgrade",
  userRequest = "userRequest",
  insufficientLicenses = "insufficientLicenses",
  agentOutOfDate = "agentOutOfDate",
  passwordDecryptFailure = "passwordDecryptFailure",
  unknown = "unknown",
  vcVramCapacityExceeded = "vcVRAMCapacityExceeded"
}
export enum VmDasBeingResetEventReasonCode {
  vmtoolsHeartbeatFailure = "vmtoolsHeartbeatFailure",
  appHeartbeatFailure = "appHeartbeatFailure",
  appImmediateResetRequest = "appImmediateResetRequest",
  vmcpResetApdCleared = "vmcpResetApdCleared"
}
export enum CannotEnableVmcpForClusterReason {
  apdTimeoutDisabled = "APDTimeoutDisabled"
}
export enum CannotMoveFaultToleranceVmMoveType {
  resourcePool = "resourcePool",
  cluster = "cluster"
}
export enum CannotUseNetworkReason {
  networkReservationNotSupported = "NetworkReservationNotSupported",
  mismatchedNetworkPolicies = "MismatchedNetworkPolicies",
  mismatchedDvsVersionOrVendor = "MismatchedDvsVersionOrVendor",
  vMotionToUnsupportedNetworkType = "VMotionToUnsupportedNetworkType",
  networkUnderMaintenance = "NetworkUnderMaintenance",
  mismatchedEnsMode = "MismatchedEnsMode"
}
export enum DasConfigFaultDasConfigFaultReason {
  hostNetworkMisconfiguration = "HostNetworkMisconfiguration",
  hostMisconfiguration = "HostMisconfiguration",
  insufficientPrivileges = "InsufficientPrivileges",
  noPrimaryAgentAvailable = "NoPrimaryAgentAvailable",
  other = "Other",
  noDatastoresConfigured = "NoDatastoresConfigured",
  createConfigVvolFailed = "CreateConfigVvolFailed",
  vSanNotSupportedOnHost = "VSanNotSupportedOnHost",
  dasNetworkMisconfiguration = "DasNetworkMisconfiguration",
  setDesiredImageSpecFailed = "SetDesiredImageSpecFailed",
  applyHaVibsOnClusterFailed = "ApplyHAVibsOnClusterFailed"
}
export enum FtIssuesOnHostHostSelectionType {
  user = "user",
  vc = "vc",
  drs = "drs"
}
export enum HostHasComponentFailureHostComponentType {
  datastore = "Datastore"
}
export enum HostIncompatibleForFaultToleranceReason {
  product = "product",
  processor = "processor"
}
export enum HostIncompatibleForRecordReplayReason {
  product = "product",
  processor = "processor"
}
export enum NotSupportedDeviceForFTDeviceType {
  virtualVmxnet3 = "virtualVmxnet3",
  paraVirtualScsiController = "paraVirtualSCSIController"
}
export enum NumVirtualCpusIncompatibleReason {
  recordReplay = "recordReplay",
  faultTolerance = "faultTolerance"
}
export enum QuarantineModeFaultFaultType {
  noCompatibleNonQuarantinedHost = "NoCompatibleNonQuarantinedHost",
  correctionDisallowed = "CorrectionDisallowed",
  correctionImpact = "CorrectionImpact"
}
export enum ReplicationVmFaultReasonForFault {
  notConfigured = "notConfigured",
  poweredOff = "poweredOff",
  suspended = "suspended",
  poweredOn = "poweredOn",
  offlineReplicating = "offlineReplicating",
  invalidState = "invalidState",
  invalidInstanceId = "invalidInstanceId",
  closeDiskError = "closeDiskError",
  groupExist = "groupExist"
}
export enum ReplicationVmInProgressFaultActivity {
  fullSync = "fullSync",
  delta = "delta"
}
export enum VFlashModuleNotSupportedReason {
  cacheModeNotSupported = "CacheModeNotSupported",
  cacheConsistencyTypeNotSupported = "CacheConsistencyTypeNotSupported",
  cacheBlockSizeNotSupported = "CacheBlockSizeNotSupported",
  cacheReservationNotSupported = "CacheReservationNotSupported",
  diskSizeNotSupported = "DiskSizeNotSupported"
}
export enum VmFaultToleranceConfigIssueReasonForIssue {
  haNotEnabled = "haNotEnabled",
  moreThanOneSecondary = "moreThanOneSecondary",
  recordReplayNotSupported = "recordReplayNotSupported",
  replayNotSupported = "replayNotSupported",
  templateVm = "templateVm",
  multipleVcpu = "multipleVCPU",
  hostInactive = "hostInactive",
  ftUnsupportedHardware = "ftUnsupportedHardware",
  ftUnsupportedProduct = "ftUnsupportedProduct",
  missingVMotionNic = "missingVMotionNic",
  missingFtLoggingNic = "missingFTLoggingNic",
  thinDisk = "thinDisk",
  verifySslCertificateFlagNotSet = "verifySSLCertificateFlagNotSet",
  hasSnapshots = "hasSnapshots",
  noConfig = "noConfig",
  ftSecondaryVm = "ftSecondaryVm",
  hasLocalDisk = "hasLocalDisk",
  esxAgentVm = "esxAgentVm",
  video3DEnabled = "video3dEnabled",
  hasUnsupportedDisk = "hasUnsupportedDisk",
  insufficientBandwidth = "insufficientBandwidth",
  hasNestedHvConfiguration = "hasNestedHVConfiguration",
  hasVFlashConfiguration = "hasVFlashConfiguration",
  unsupportedProduct = "unsupportedProduct",
  cpuHvUnsupported = "cpuHvUnsupported",
  cpuHwmmuUnsupported = "cpuHwmmuUnsupported",
  cpuHvDisabled = "cpuHvDisabled",
  hasEfiFirmware = "hasEFIFirmware",
  tooManyVcpUs = "tooManyVCPUs",
  tooMuchMemory = "tooMuchMemory"
}
export enum VmFaultToleranceInvalidFileBackingDeviceType {
  virtualFloppy = "virtualFloppy",
  virtualCdrom = "virtualCdrom",
  virtualSerialPort = "virtualSerialPort",
  virtualParallelPort = "virtualParallelPort",
  virtualDisk = "virtualDisk"
}
export enum WillLoseHAProtectionResolution {
  svmotion = "svmotion",
  relocate = "relocate"
}
export enum HostActiveDirectoryAuthenticationCertificateDigest {
  sha1 = "SHA1"
}
export enum HostActiveDirectoryInfoDomainMembershipStatus {
  unknown = "unknown",
  ok = "ok",
  noServers = "noServers",
  clientTrustBroken = "clientTrustBroken",
  serverTrustBroken = "serverTrustBroken",
  inconsistentTrust = "inconsistentTrust",
  otherProblem = "otherProblem"
}
export enum HostDateTimeInfoProtocol {
  ntp = "ntp",
  ptp = "ptp"
}
export enum FibreChannelPortType {
  fabric = "fabric",
  loop = "loop",
  pointToPoint = "pointToPoint",
  unknown = "unknown"
}
export enum HostInternetScsiHbaChapAuthenticationType {
  chapProhibited = "chapProhibited",
  chapDiscouraged = "chapDiscouraged",
  chapPreferred = "chapPreferred",
  chapRequired = "chapRequired"
}
export enum HostInternetScsiHbaDigestType {
  digestProhibited = "digestProhibited",
  digestDiscouraged = "digestDiscouraged",
  digestPreferred = "digestPreferred",
  digestRequired = "digestRequired"
}
export enum InternetScsiSnsDiscoveryMethod {
  isnsStatic = "isnsStatic",
  isnsDhcp = "isnsDhcp",
  isnsSlp = "isnsSlp"
}
export enum SlpDiscoveryMethod {
  slpDhcp = "slpDhcp",
  slpAutoUnicast = "slpAutoUnicast",
  slpAutoMulticast = "slpAutoMulticast",
  slpManual = "slpManual"
}
export enum HostInternetScsiHbaIscsiIpv6AddressAddressConfigurationType {
  dhcp = "DHCP",
  autoConfigured = "AutoConfigured",
  static = "Static",
  other = "Other"
}
export enum HostInternetScsiHbaIscsiIpv6AddressIPv6AddressOperation {
  add = "add",
  remove = "remove"
}
export enum HostInternetScsiHbaNetworkBindingSupportType {
  notsupported = "notsupported",
  optional = "optional",
  required = "required"
}
export enum HostInternetScsiHbaStaticTargetTargetDiscoveryMethod {
  staticMethod = "staticMethod",
  sendTargetMethod = "sendTargetMethod",
  slpMethod = "slpMethod",
  isnsMethod = "isnsMethod",
  unknownMethod = "unknownMethod"
}
export enum ScsiDiskType {
  native512 = "native512",
  emulated512 = "emulated512",
  native4K = "native4k",
  softwareEmulated4K = "SoftwareEmulated4k",
  unknown = "unknown"
}
export enum HostUnresolvedVmfsExtentUnresolvedReason {
  diskIdMismatch = "diskIdMismatch",
  uuidConflict = "uuidConflict"
}
export enum HostVmfsVolumeUnmapBandwidthPolicy {
  fixed = "fixed",
  dynamic = "dynamic"
}
export enum HostVmfsVolumeUnmapPriority {
  none = "none",
  low = "low"
}
export enum HostProfileValidationFailureInfoUpdateType {
  hostBased = "HostBased",
  import = "Import",
  edit = "Edit",
  compose = "Compose"
}
export enum HostProfileValidationState {
  ready = "Ready",
  running = "Running",
  failed = "Failed"
}
export enum HostProfileManagerAnswerFileStatus {
  valid = "valid",
  invalid = "invalid",
  unknown = "unknown"
}
export enum ApplyHostProfileConfigurationResultStatus {
  success = "success",
  failed = "failed",
  rebootFailed = "reboot_failed",
  statelessRebootFailed = "stateless_reboot_failed",
  checkComplianceFailed = "check_compliance_failed",
  stateNotSatisfied = "state_not_satisfied",
  exitMaintenancemodeFailed = "exit_maintenancemode_failed",
  canceled = "canceled"
}
export enum HostProfileManagerCompositionResultResultElementStatus {
  success = "success",
  error = "error"
}
export enum HostProfileManagerCompositionValidationResultResultElementStatus {
  success = "success",
  error = "error"
}
export enum HostProfileManagerTaskListRequirement {
  maintenanceModeRequired = "maintenanceModeRequired",
  rebootRequired = "rebootRequired"
}
export enum StoragePlacementSpecPlacementType {
  create = "create",
  reconfigure = "reconfigure",
  relocate = "relocate",
  clone = "clone"
}
export enum VirtualDiskRuleSpecRuleType {
  affinity = "affinity",
  antiAffinity = "antiAffinity",
  disabled = "disabled"
}
export enum VirtualMachineRelocateDiskMoveOptions {
  moveAllDiskBackingsAndAllowSharing = "moveAllDiskBackingsAndAllowSharing",
  moveAllDiskBackingsAndDisallowSharing = "moveAllDiskBackingsAndDisallowSharing",
  moveChildMostDiskBacking = "moveChildMostDiskBacking",
  createNewChildDiskBacking = "createNewChildDiskBacking",
  moveAllDiskBackingsAndConsolidate = "moveAllDiskBackingsAndConsolidate"
}
export enum VirtualMachineRelocateTransformation {
  flat = "flat",
  sparse = "sparse"
}
export enum VirtualMachineScsiPassthroughType {
  disk = "disk",
  tape = "tape",
  printer = "printer",
  processor = "processor",
  worm = "worm",
  cdrom = "cdrom",
  scanner = "scanner",
  optical = "optical",
  media = "media",
  com = "com",
  raid = "raid",
  unknown = "unknown"
}
export enum VirtualSCSISharing {
  noSharing = "noSharing",
  virtualSharing = "virtualSharing",
  physicalSharing = "physicalSharing"
}
export enum VirtualVmxnet3VrdmaOptionDeviceProtocols {
  rocev1 = "rocev1",
  rocev2 = "rocev2"
}
export enum ComputeResourceHostSPBMLicenseInfoHostSPBMLicenseState {
  licensed = "licensed",
  unlicensed = "unlicensed",
  unknown = "unknown"
}
export enum DatastoreAccessible {
  true = "True",
  false = "False"
}
export enum DatastoreSummaryMaintenanceModeState {
  normal = "normal",
  enteringMaintenance = "enteringMaintenance",
  inMaintenance = "inMaintenance"
}
export enum DistributedVirtualSwitchHostInfrastructureTrafficClass {
  management = "management",
  faultTolerance = "faultTolerance",
  vmotion = "vmotion",
  virtualMachine = "virtualMachine",
  iScsi = "iSCSI",
  nfs = "nfs",
  hbr = "hbr",
  vsan = "vsan",
  vdp = "vdp",
  backupNfc = "backupNfc"
}
export enum DistributedVirtualSwitchNetworkResourceControlVersion {
  version2 = "version2",
  version3 = "version3"
}
export enum DistributedVirtualSwitchNicTeamingPolicyMode {
  loadbalanceIp = "loadbalance_ip",
  loadbalanceSrcmac = "loadbalance_srcmac",
  loadbalanceSrcid = "loadbalance_srcid",
  failoverExplicit = "failover_explicit",
  loadbalanceLoadbased = "loadbalance_loadbased"
}
export enum DistributedVirtualSwitchProductSpecOperationType {
  preInstall = "preInstall",
  upgrade = "upgrade",
  notifyAvailableUpgrade = "notifyAvailableUpgrade",
  proceedWithUpgrade = "proceedWithUpgrade",
  updateBundleInfo = "updateBundleInfo"
}
export enum FolderDesiredHostState {
  maintenance = "maintenance",
  nonMaintenance = "non_maintenance"
}
export enum HostSystemConnectionState {
  connected = "connected",
  notResponding = "notResponding",
  disconnected = "disconnected"
}
export enum HostCryptoState {
  incapable = "incapable",
  prepared = "prepared",
  safe = "safe",
  pendingIncapable = "pendingIncapable"
}
export enum HostSystemPowerState {
  poweredOn = "poweredOn",
  poweredOff = "poweredOff",
  standBy = "standBy",
  unknown = "unknown"
}
export enum HostSystemRemediationStateState {
  remediationReady = "remediationReady",
  precheckRemediationRunning = "precheckRemediationRunning",
  precheckRemediationComplete = "precheckRemediationComplete",
  precheckRemediationFailed = "precheckRemediationFailed",
  remediationRunning = "remediationRunning",
  remediationFailed = "remediationFailed"
}
export enum HostStandbyMode {
  entering = "entering",
  exiting = "exiting",
  in = "in",
  none = "none"
}
export enum VMotionCompatibilityType {
  cpu = "cpu",
  software = "software"
}
export enum ValidateMigrationTestType {
  sourceTests = "sourceTests",
  compatibilityTests = "compatibilityTests",
  diskAccessibilityTests = "diskAccessibilityTests",
  resourceTests = "resourceTests"
}
export enum VMwareDvsLacpApiVersion {
  singleLag = "singleLag",
  multipleLag = "multipleLag"
}
export enum VMwareDvsLacpLoadBalanceAlgorithm {
  srcMac = "srcMac",
  destMac = "destMac",
  srcDestMac = "srcDestMac",
  destIpVlan = "destIpVlan",
  srcIpVlan = "srcIpVlan",
  srcDestIpVlan = "srcDestIpVlan",
  destTcpUdpPort = "destTcpUdpPort",
  srcTcpUdpPort = "srcTcpUdpPort",
  srcDestTcpUdpPort = "srcDestTcpUdpPort",
  destIpTcpUdpPort = "destIpTcpUdpPort",
  srcIpTcpUdpPort = "srcIpTcpUdpPort",
  srcDestIpTcpUdpPort = "srcDestIpTcpUdpPort",
  destIpTcpUdpPortVlan = "destIpTcpUdpPortVlan",
  srcIpTcpUdpPortVlan = "srcIpTcpUdpPortVlan",
  srcDestIpTcpUdpPortVlan = "srcDestIpTcpUdpPortVlan",
  destIp = "destIp",
  srcIp = "srcIp",
  srcDestIp = "srcDestIp",
  vlan = "vlan",
  srcPortId = "srcPortId"
}
export enum DVSMacLimitPolicyType {
  allow = "allow",
  drop = "drop"
}
export enum VMwareDvsMulticastFilteringMode {
  legacyFiltering = "legacyFiltering",
  snooping = "snooping"
}
export enum VmwareDistributedVirtualSwitchPvlanPortType {
  promiscuous = "promiscuous",
  isolated = "isolated",
  community = "community"
}
export enum VMwareDVSTeamingMatchStatus {
  iphashMatch = "iphashMatch",
  nonIphashMatch = "nonIphashMatch",
  iphashMismatch = "iphashMismatch",
  nonIphashMismatch = "nonIphashMismatch"
}
export enum VMwareUplinkLacpMode {
  active = "active",
  passive = "passive"
}
export enum VMwareDVSVspanSessionEncapType {
  gre = "gre",
  erspan2 = "erspan2",
  erspan3 = "erspan3"
}
export enum VMwareDVSVspanSessionType {
  mixedDestMirror = "mixedDestMirror",
  dvPortMirror = "dvPortMirror",
  remoteMirrorSource = "remoteMirrorSource",
  remoteMirrorDest = "remoteMirrorDest",
  encapsulatedRemoteMirrorSource = "encapsulatedRemoteMirrorSource"
}
export enum AffinityType {
  memory = "memory",
  cpu = "cpu"
}
export enum AgentInstallFailedReason {
  notEnoughSpaceOnDevice = "NotEnoughSpaceOnDevice",
  prepareToUpgradeFailed = "PrepareToUpgradeFailed",
  agentNotRunning = "AgentNotRunning",
  agentNotReachable = "AgentNotReachable",
  installTimedout = "InstallTimedout",
  signatureVerificationFailed = "SignatureVerificationFailed",
  agentUploadFailed = "AgentUploadFailed",
  agentUploadTimedout = "AgentUploadTimedout",
  unknownInstallerError = "UnknownInstallerError"
}
export enum CannotPowerOffVmInClusterOperation {
  suspend = "suspend",
  powerOff = "powerOff",
  guestShutdown = "guestShutdown",
  guestSuspend = "guestSuspend"
}
export enum DeviceNotSupportedReason {
  host = "host",
  guest = "guest"
}
export enum IncompatibleHostForVmReplicationIncompatibleReason {
  rpo = "rpo",
  netCompression = "netCompression"
}
export enum ReplicationDiskConfigFaultReasonForFault {
  diskNotFound = "diskNotFound",
  diskTypeNotSupported = "diskTypeNotSupported",
  invalidDiskKey = "invalidDiskKey",
  invalidDiskReplicationId = "invalidDiskReplicationId",
  duplicateDiskReplicationId = "duplicateDiskReplicationId",
  invalidPersistentFilePath = "invalidPersistentFilePath",
  reconfigureDiskReplicationIdNotAllowed = "reconfigureDiskReplicationIdNotAllowed"
}
export enum ReplicationVmConfigFaultReasonForFault {
  incompatibleHwVersion = "incompatibleHwVersion",
  invalidVmReplicationId = "invalidVmReplicationId",
  invalidGenerationNumber = "invalidGenerationNumber",
  outOfBoundsRpoValue = "outOfBoundsRpoValue",
  invalidDestinationIpAddress = "invalidDestinationIpAddress",
  invalidDestinationPort = "invalidDestinationPort",
  invalidExtraVmOptions = "invalidExtraVmOptions",
  staleGenerationNumber = "staleGenerationNumber",
  reconfigureVmReplicationIdNotAllowed = "reconfigureVmReplicationIdNotAllowed",
  cannotRetrieveVmReplicationConfiguration = "cannotRetrieveVmReplicationConfiguration",
  replicationAlreadyEnabled = "replicationAlreadyEnabled",
  invalidPriorConfiguration = "invalidPriorConfiguration",
  replicationNotEnabled = "replicationNotEnabled",
  replicationConfigurationFailed = "replicationConfigurationFailed",
  encryptedVm = "encryptedVm",
  invalidThumbprint = "invalidThumbprint",
  incompatibleDevice = "incompatibleDevice"
}
export enum DiagnosticPartitionType {
  singleHost = "singleHost",
  multiHost = "multiHost"
}
export enum DiagnosticPartitionStorageType {
  directAttached = "directAttached",
  networkAttached = "networkAttached"
}
export enum HostRuntimeInfoNetStackInstanceRuntimeInfoState {
  inactive = "inactive",
  active = "active",
  deactivating = "deactivating",
  activating = "activating"
}
export enum ClusterComputeResourceHCIWorkflowState {
  inProgress = "in_progress",
  done = "done",
  invalid = "invalid"
}
export enum DayOfWeek {
  sunday = "sunday",
  monday = "monday",
  tuesday = "tuesday",
  wednesday = "wednesday",
  thursday = "thursday",
  friday = "friday",
  saturday = "saturday"
}
export enum WeekOfMonth {
  first = "first",
  second = "second",
  third = "third",
  fourth = "fourth",
  last = "last"
}
export class PropertyCollector extends ManagedObject {
  filter?: PropertyFilter[];
  constructor(
    public connection: Connection,
    init?: Partial<PropertyCollector>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async createFilter(args: {
    spec: PropertyFilterSpec;
    partialUpdates: boolean
  }): Promise<PropertyFilter> {
    const result = await this.connection.exec<{
      spec: PropertyFilterSpec;
      partialUpdates: boolean
    } & { _this: ObjectReference }, PropertyFilter>(
      "CreateFilter", { _this: { attributes: { type: "PropertyCollector" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "PropertyFilter");
  }
  async retrieveContents(args: {
    specSet: PropertyFilterSpec[]
  }): Promise<ObjectContent[] | undefined> {
    const result = await this.connection.exec<{
      specSet: PropertyFilterSpec[]
    } & { _this: ObjectReference }, ObjectContent[] | undefined>(
      "RetrieveProperties", { _this: { attributes: { type: "PropertyCollector" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "ObjectContent[]");
  }
  async checkForUpdates(args: {
    version?: string
  }): Promise<UpdateSet | undefined> {
    const result = await this.connection.exec<{
      version?: string
    } & { _this: ObjectReference }, UpdateSet | undefined>(
      "CheckForUpdates", { _this: { attributes: { type: "PropertyCollector" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "UpdateSet");
  }
  async waitForUpdates(args: {
    version?: string
  }): Promise<UpdateSet> {
    const result = await this.connection.exec<{
      version?: string
    } & { _this: ObjectReference }, UpdateSet>(
      "WaitForUpdates", { _this: { attributes: { type: "PropertyCollector" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "UpdateSet");
  }
  async cancelWaitForUpdates(): Promise<void> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, void>(
      "CancelWaitForUpdates", { _this: { attributes: { type: "PropertyCollector" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async waitForUpdatesEx(args: {
    version?: string;
    options?: WaitOptions
  }): Promise<UpdateSet | undefined> {
    const result = await this.connection.exec<{
      version?: string;
      options?: WaitOptions
    } & { _this: ObjectReference }, UpdateSet | undefined>(
      "WaitForUpdatesEx", { _this: { attributes: { type: "PropertyCollector" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "UpdateSet");
  }
  async retrievePropertiesEx(args: {
    specSet: PropertyFilterSpec[];
    options: RetrieveOptions
  }): Promise<RetrieveResult | undefined> {
    const result = await this.connection.exec<{
      specSet: PropertyFilterSpec[];
      options: RetrieveOptions
    } & { _this: ObjectReference }, RetrieveResult | undefined>(
      "RetrievePropertiesEx", { _this: { attributes: { type: "PropertyCollector" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "RetrieveResult");
  }
  async continueRetrievePropertiesEx(args: {
    token: string
  }): Promise<RetrieveResult> {
    const result = await this.connection.exec<{
      token: string
    } & { _this: ObjectReference }, RetrieveResult>(
      "ContinueRetrievePropertiesEx", { _this: { attributes: { type: "PropertyCollector" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "RetrieveResult");
  }
  async cancelRetrievePropertiesEx(args: {
    token: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      token: string
    } & { _this: ObjectReference }, void>(
      "CancelRetrievePropertiesEx", { _this: { attributes: { type: "PropertyCollector" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async createPropertyCollector(): Promise<PropertyCollector> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, PropertyCollector>(
      "CreatePropertyCollector", { _this: { attributes: { type: "PropertyCollector" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "PropertyCollector");
  }
  async destroy(): Promise<void> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, void>(
      "DestroyPropertyCollector", { _this: { attributes: { type: "PropertyCollector" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  };
}
export class PropertyFilter extends ManagedObject {
  spec!: PropertyFilterSpec;
  partialUpdates!: boolean;
  constructor(
    public connection: Connection,
    init?: Partial<PropertyFilter>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async destroy(): Promise<void> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, void>(
      "DestroyPropertyFilter", { _this: { attributes: { type: "PropertyFilter" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  };
}
export class CertificateManager extends ManagedObject {
  
  constructor(
    public connection: Connection,
    init?: Partial<CertificateManager>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async refreshCACertificatesAndCRLs(args: {
    host: HostSystem[]
  }): Promise<Task> {
    const result = await this.connection.exec<{
      host: HostSystem[]
    } & { _this: ObjectReference }, Task>(
      "CertMgrRefreshCACertificatesAndCRLs_Task", { _this: { attributes: { type: "CertificateManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async refreshCertificates(args: {
    host: HostSystem[]
  }): Promise<Task> {
    const result = await this.connection.exec<{
      host: HostSystem[]
    } & { _this: ObjectReference }, Task>(
      "CertMgrRefreshCertificates_Task", { _this: { attributes: { type: "CertificateManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async revokeCertificates(args: {
    host: HostSystem[]
  }): Promise<Task> {
    const result = await this.connection.exec<{
      host: HostSystem[]
    } & { _this: ObjectReference }, Task>(
      "CertMgrRevokeCertificates_Task", { _this: { attributes: { type: "CertificateManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  };
}
export class CustomFieldsManager extends ManagedObject {
  field?: CustomFieldDef[];
  constructor(
    public connection: Connection,
    init?: Partial<CustomFieldsManager>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async addFieldDefinition(args: {
    name: string;
    moType?: string;
    fieldDefPolicy?: PrivilegePolicyDef;
    fieldPolicy?: PrivilegePolicyDef
  }): Promise<CustomFieldDef> {
    const result = await this.connection.exec<{
      name: string;
      moType?: string;
      fieldDefPolicy?: PrivilegePolicyDef;
      fieldPolicy?: PrivilegePolicyDef
    } & { _this: ObjectReference }, CustomFieldDef>(
      "AddCustomFieldDef", { _this: { attributes: { type: "CustomFieldsManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "CustomFieldDef");
  }
  async removeFieldDefinition(args: {
    key: number
  }): Promise<void> {
    const result = await this.connection.exec<{
      key: number
    } & { _this: ObjectReference }, void>(
      "RemoveCustomFieldDef", { _this: { attributes: { type: "CustomFieldsManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async renameFieldDefinition(args: {
    key: number;
    name: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      key: number;
      name: string
    } & { _this: ObjectReference }, void>(
      "RenameCustomFieldDef", { _this: { attributes: { type: "CustomFieldsManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async setField(args: {
    entity: ManagedEntity;
    key: number;
    value: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      entity: ManagedEntity;
      key: number;
      value: string
    } & { _this: ObjectReference }, void>(
      "SetField", { _this: { attributes: { type: "CustomFieldsManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  };
}
export class CustomizationSpecManager extends ManagedObject {
  info?: CustomizationSpecInfo[];
  encryptionKey?: number[];
  constructor(
    public connection: Connection,
    init?: Partial<CustomizationSpecManager>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async checkResources(args: {
    guestOs: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      guestOs: string
    } & { _this: ObjectReference }, void>(
      "CheckCustomizationResources", { _this: { attributes: { type: "CustomizationSpecManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async create(args: {
    item: CustomizationSpecItem
  }): Promise<void> {
    const result = await this.connection.exec<{
      item: CustomizationSpecItem
    } & { _this: ObjectReference }, void>(
      "CreateCustomizationSpec", { _this: { attributes: { type: "CustomizationSpecManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async specItemToXml(args: {
    item: CustomizationSpecItem
  }): Promise<string> {
    const result = await this.connection.exec<{
      item: CustomizationSpecItem
    } & { _this: ObjectReference }, string>(
      "CustomizationSpecItemToXml", { _this: { attributes: { type: "CustomizationSpecManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "string");
  }
  async delete(args: {
    name: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      name: string
    } & { _this: ObjectReference }, void>(
      "DeleteCustomizationSpec", { _this: { attributes: { type: "CustomizationSpecManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async exists(args: {
    name: string
  }): Promise<boolean> {
    const result = await this.connection.exec<{
      name: string
    } & { _this: ObjectReference }, boolean>(
      "DoesCustomizationSpecExist", { _this: { attributes: { type: "CustomizationSpecManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "boolean");
  }
  async duplicate(args: {
    name: string;
    newName: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      name: string;
      newName: string
    } & { _this: ObjectReference }, void>(
      "DuplicateCustomizationSpec", { _this: { attributes: { type: "CustomizationSpecManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async get(args: {
    name: string
  }): Promise<CustomizationSpecItem> {
    const result = await this.connection.exec<{
      name: string
    } & { _this: ObjectReference }, CustomizationSpecItem>(
      "GetCustomizationSpec", { _this: { attributes: { type: "CustomizationSpecManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "CustomizationSpecItem");
  }
  async overwrite(args: {
    item: CustomizationSpecItem
  }): Promise<void> {
    const result = await this.connection.exec<{
      item: CustomizationSpecItem
    } & { _this: ObjectReference }, void>(
      "OverwriteCustomizationSpec", { _this: { attributes: { type: "CustomizationSpecManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async rename(args: {
    name: string;
    newName: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      name: string;
      newName: string
    } & { _this: ObjectReference }, void>(
      "RenameCustomizationSpec", { _this: { attributes: { type: "CustomizationSpecManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async xmlToSpecItem(args: {
    specItemXml: string
  }): Promise<CustomizationSpecItem> {
    const result = await this.connection.exec<{
      specItemXml: string
    } & { _this: ObjectReference }, CustomizationSpecItem>(
      "XmlToCustomizationSpecItem", { _this: { attributes: { type: "CustomizationSpecManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "CustomizationSpecItem");
  };
}
export class DatastoreNamespaceManager extends ManagedObject {
  
  constructor(
    public connection: Connection,
    init?: Partial<DatastoreNamespaceManager>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async ConvertNamespacePathToUuidPath(args: {
    datacenter?: Datacenter;
    namespaceUrl: string
  }): Promise<string> {
    const result = await this.connection.exec<{
      datacenter?: Datacenter;
      namespaceUrl: string
    } & { _this: ObjectReference }, string>(
      "ConvertNamespacePathToUuidPath", { _this: { attributes: { type: "DatastoreNamespaceManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "string");
  }
  async CreateDirectory(args: {
    datastore: Datastore;
    displayName?: string;
    policy?: string
  }): Promise<string> {
    const result = await this.connection.exec<{
      datastore: Datastore;
      displayName?: string;
      policy?: string
    } & { _this: ObjectReference }, string>(
      "CreateDirectory", { _this: { attributes: { type: "DatastoreNamespaceManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "string");
  }
  async DeleteDirectory(args: {
    datacenter?: Datacenter;
    datastorePath: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      datacenter?: Datacenter;
      datastorePath: string
    } & { _this: ObjectReference }, void>(
      "DeleteDirectory", { _this: { attributes: { type: "DatastoreNamespaceManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  };
}
export class DiagnosticManager extends ManagedObject {
  
  constructor(
    public connection: Connection,
    init?: Partial<DiagnosticManager>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async browse(args: {
    host?: HostSystem;
    key: string;
    start?: number;
    lines?: number
  }): Promise<DiagnosticManagerLogHeader> {
    const result = await this.connection.exec<{
      host?: HostSystem;
      key: string;
      start?: number;
      lines?: number
    } & { _this: ObjectReference }, DiagnosticManagerLogHeader>(
      "BrowseDiagnosticLog", { _this: { attributes: { type: "DiagnosticManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "DiagnosticManagerLogHeader");
  }
  async generateLogBundles(args: {
    includeDefault: boolean;
    host?: HostSystem[]
  }): Promise<Task | undefined> {
    const result = await this.connection.exec<{
      includeDefault: boolean;
      host?: HostSystem[]
    } & { _this: ObjectReference }, Task | undefined>(
      "GenerateLogBundles_Task", { _this: { attributes: { type: "DiagnosticManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async queryDescriptions(args: {
    host?: HostSystem
  }): Promise<DiagnosticManagerLogDescriptor[] | undefined> {
    const result = await this.connection.exec<{
      host?: HostSystem
    } & { _this: ObjectReference }, DiagnosticManagerLogDescriptor[] | undefined>(
      "QueryDescriptions", { _this: { attributes: { type: "DiagnosticManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "DiagnosticManagerLogDescriptor[]");
  };
}
export class EnvironmentBrowser extends ManagedObject {
  datastoreBrowser?: HostDatastoreBrowser;
  constructor(
    public connection: Connection,
    init?: Partial<EnvironmentBrowser>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async queryConfigOption(args: {
    key?: string;
    host?: HostSystem
  }): Promise<VirtualMachineConfigOption | undefined> {
    const result = await this.connection.exec<{
      key?: string;
      host?: HostSystem
    } & { _this: ObjectReference }, VirtualMachineConfigOption | undefined>(
      "QueryConfigOption", { _this: { attributes: { type: "EnvironmentBrowser" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "VirtualMachineConfigOption");
  }
  async queryConfigOptionDescriptor(): Promise<VirtualMachineConfigOptionDescriptor[] | undefined> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, VirtualMachineConfigOptionDescriptor[] | undefined>(
      "QueryConfigOptionDescriptor", { _this: { attributes: { type: "EnvironmentBrowser" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "VirtualMachineConfigOptionDescriptor[]");
  }
  async queryConfigOptionEx(args: {
    spec?: EnvironmentBrowserConfigOptionQuerySpec
  }): Promise<VirtualMachineConfigOption | undefined> {
    const result = await this.connection.exec<{
      spec?: EnvironmentBrowserConfigOptionQuerySpec
    } & { _this: ObjectReference }, VirtualMachineConfigOption | undefined>(
      "QueryConfigOptionEx", { _this: { attributes: { type: "EnvironmentBrowser" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "VirtualMachineConfigOption");
  }
  async queryConfigTarget(args: {
    host?: HostSystem
  }): Promise<ConfigTarget | undefined> {
    const result = await this.connection.exec<{
      host?: HostSystem
    } & { _this: ObjectReference }, ConfigTarget | undefined>(
      "QueryConfigTarget", { _this: { attributes: { type: "EnvironmentBrowser" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "ConfigTarget");
  }
  async queryTargetCapabilities(args: {
    host?: HostSystem
  }): Promise<HostCapability | undefined> {
    const result = await this.connection.exec<{
      host?: HostSystem
    } & { _this: ObjectReference }, HostCapability | undefined>(
      "QueryTargetCapabilities", { _this: { attributes: { type: "EnvironmentBrowser" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "HostCapability");
  };
}
export class ExtensibleManagedObject extends ManagedObject {
  value?: CustomFieldValue[];
  availableField?: CustomFieldDef[];
  constructor(
    public connection: Connection,
    init?: Partial<ExtensibleManagedObject>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async setCustomValue(args: {
    key: string;
    value: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      key: string;
      value: string
    } & { _this: ObjectReference }, void>(
      "setCustomValue", { _this: { attributes: { type: "ExtensibleManagedObject" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  };
}
export class ExtensionManager extends ManagedObject {
  extensionList?: Extension[];
  constructor(
    public connection: Connection,
    init?: Partial<ExtensionManager>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async findExtension(args: {
    extensionKey: string
  }): Promise<Extension | undefined> {
    const result = await this.connection.exec<{
      extensionKey: string
    } & { _this: ObjectReference }, Extension | undefined>(
      "FindExtension", { _this: { attributes: { type: "ExtensionManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Extension");
  }
  async getPublicKey(): Promise<string> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, string>(
      "GetPublicKey", { _this: { attributes: { type: "ExtensionManager" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "string");
  }
  async queryExtensionIpAllocationUsage(args: {
    extensionKeys?: string[]
  }): Promise<ExtensionManagerIpAllocationUsage[] | undefined> {
    const result = await this.connection.exec<{
      extensionKeys?: string[]
    } & { _this: ObjectReference }, ExtensionManagerIpAllocationUsage[] | undefined>(
      "QueryExtensionIpAllocationUsage", { _this: { attributes: { type: "ExtensionManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "ExtensionManagerIpAllocationUsage[]");
  }
  async queryManagedBy(args: {
    extensionKey: string
  }): Promise<ManagedEntity[] | undefined> {
    const result = await this.connection.exec<{
      extensionKey: string
    } & { _this: ObjectReference }, ManagedEntity[] | undefined>(
      "QueryManagedBy", { _this: { attributes: { type: "ExtensionManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "ManagedEntity[]");
  }
  async registerExtension(args: {
    extension: Extension
  }): Promise<void> {
    const result = await this.connection.exec<{
      extension: Extension
    } & { _this: ObjectReference }, void>(
      "RegisterExtension", { _this: { attributes: { type: "ExtensionManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async setCertificate(args: {
    extensionKey: string;
    certificatePem?: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      extensionKey: string;
      certificatePem?: string
    } & { _this: ObjectReference }, void>(
      "SetExtensionCertificate", { _this: { attributes: { type: "ExtensionManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async setPublicKey(args: {
    extensionKey: string;
    publicKey: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      extensionKey: string;
      publicKey: string
    } & { _this: ObjectReference }, void>(
      "SetPublicKey", { _this: { attributes: { type: "ExtensionManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async unregisterExtension(args: {
    extensionKey: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      extensionKey: string
    } & { _this: ObjectReference }, void>(
      "UnregisterExtension", { _this: { attributes: { type: "ExtensionManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async updateExtension(args: {
    extension: Extension
  }): Promise<void> {
    const result = await this.connection.exec<{
      extension: Extension
    } & { _this: ObjectReference }, void>(
      "UpdateExtension", { _this: { attributes: { type: "ExtensionManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  };
}
export class FileManager extends ManagedObject {
  
  constructor(
    public connection: Connection,
    init?: Partial<FileManager>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async changeOwner(args: {
    name: string;
    datacenter?: Datacenter;
    owner: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      name: string;
      datacenter?: Datacenter;
      owner: string
    } & { _this: ObjectReference }, void>(
      "ChangeOwner", { _this: { attributes: { type: "FileManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async copyFile(args: {
    sourceName: string;
    sourceDatacenter?: Datacenter;
    destinationName: string;
    destinationDatacenter?: Datacenter;
    force?: boolean
  }): Promise<Task> {
    const result = await this.connection.exec<{
      sourceName: string;
      sourceDatacenter?: Datacenter;
      destinationName: string;
      destinationDatacenter?: Datacenter;
      force?: boolean
    } & { _this: ObjectReference }, Task>(
      "CopyDatastoreFile_Task", { _this: { attributes: { type: "FileManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async deleteFile(args: {
    name: string;
    datacenter?: Datacenter
  }): Promise<Task> {
    const result = await this.connection.exec<{
      name: string;
      datacenter?: Datacenter
    } & { _this: ObjectReference }, Task>(
      "DeleteDatastoreFile_Task", { _this: { attributes: { type: "FileManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async makeDirectory(args: {
    name: string;
    datacenter?: Datacenter;
    createParentDirectories?: boolean
  }): Promise<void> {
    const result = await this.connection.exec<{
      name: string;
      datacenter?: Datacenter;
      createParentDirectories?: boolean
    } & { _this: ObjectReference }, void>(
      "MakeDirectory", { _this: { attributes: { type: "FileManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async moveFile(args: {
    sourceName: string;
    sourceDatacenter?: Datacenter;
    destinationName: string;
    destinationDatacenter?: Datacenter;
    force?: boolean
  }): Promise<Task> {
    const result = await this.connection.exec<{
      sourceName: string;
      sourceDatacenter?: Datacenter;
      destinationName: string;
      destinationDatacenter?: Datacenter;
      force?: boolean
    } & { _this: ObjectReference }, Task>(
      "MoveDatastoreFile_Task", { _this: { attributes: { type: "FileManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  };
}
export class HealthUpdateManager extends ManagedObject {
  
  constructor(
    public connection: Connection,
    init?: Partial<HealthUpdateManager>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async addFilter(args: {
    providerId: string;
    filterName: string;
    infoIds?: string[]
  }): Promise<string> {
    const result = await this.connection.exec<{
      providerId: string;
      filterName: string;
      infoIds?: string[]
    } & { _this: ObjectReference }, string>(
      "AddFilter", { _this: { attributes: { type: "HealthUpdateManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "string");
  }
  async addFilterEntities(args: {
    filterId: string;
    entities?: ManagedEntity[]
  }): Promise<void> {
    const result = await this.connection.exec<{
      filterId: string;
      entities?: ManagedEntity[]
    } & { _this: ObjectReference }, void>(
      "AddFilterEntities", { _this: { attributes: { type: "HealthUpdateManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async addMonitoredEntities(args: {
    providerId: string;
    entities?: ManagedEntity[]
  }): Promise<void> {
    const result = await this.connection.exec<{
      providerId: string;
      entities?: ManagedEntity[]
    } & { _this: ObjectReference }, void>(
      "AddMonitoredEntities", { _this: { attributes: { type: "HealthUpdateManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async hasMonitoredEntity(args: {
    providerId: string;
    entity: ManagedEntity
  }): Promise<boolean> {
    const result = await this.connection.exec<{
      providerId: string;
      entity: ManagedEntity
    } & { _this: ObjectReference }, boolean>(
      "HasMonitoredEntity", { _this: { attributes: { type: "HealthUpdateManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "boolean");
  }
  async hasProvider(args: {
    id: string
  }): Promise<boolean> {
    const result = await this.connection.exec<{
      id: string
    } & { _this: ObjectReference }, boolean>(
      "HasProvider", { _this: { attributes: { type: "HealthUpdateManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "boolean");
  }
  async postHealthUpdates(args: {
    providerId: string;
    updates?: HealthUpdate[]
  }): Promise<void> {
    const result = await this.connection.exec<{
      providerId: string;
      updates?: HealthUpdate[]
    } & { _this: ObjectReference }, void>(
      "PostHealthUpdates", { _this: { attributes: { type: "HealthUpdateManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async queryFilterEntities(args: {
    filterId: string
  }): Promise<ManagedEntity[] | undefined> {
    const result = await this.connection.exec<{
      filterId: string
    } & { _this: ObjectReference }, ManagedEntity[] | undefined>(
      "QueryFilterEntities", { _this: { attributes: { type: "HealthUpdateManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "ManagedEntity[]");
  }
  async queryFilterInfoIds(args: {
    filterId: string
  }): Promise<string[] | undefined> {
    const result = await this.connection.exec<{
      filterId: string
    } & { _this: ObjectReference }, string[] | undefined>(
      "QueryFilterInfoIds", { _this: { attributes: { type: "HealthUpdateManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "string[]");
  }
  async queryFilterList(args: {
    providerId: string
  }): Promise<string[] | undefined> {
    const result = await this.connection.exec<{
      providerId: string
    } & { _this: ObjectReference }, string[] | undefined>(
      "QueryFilterList", { _this: { attributes: { type: "HealthUpdateManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "string[]");
  }
  async queryFilterName(args: {
    filterId: string
  }): Promise<string> {
    const result = await this.connection.exec<{
      filterId: string
    } & { _this: ObjectReference }, string>(
      "QueryFilterName", { _this: { attributes: { type: "HealthUpdateManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "string");
  }
  async queryHealthUpdateInfos(args: {
    providerId: string
  }): Promise<HealthUpdateInfo[] | undefined> {
    const result = await this.connection.exec<{
      providerId: string
    } & { _this: ObjectReference }, HealthUpdateInfo[] | undefined>(
      "QueryHealthUpdateInfos", { _this: { attributes: { type: "HealthUpdateManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "HealthUpdateInfo[]");
  }
  async queryHealthUpdates(args: {
    providerId: string
  }): Promise<HealthUpdate[] | undefined> {
    const result = await this.connection.exec<{
      providerId: string
    } & { _this: ObjectReference }, HealthUpdate[] | undefined>(
      "QueryHealthUpdates", { _this: { attributes: { type: "HealthUpdateManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "HealthUpdate[]");
  }
  async queryMonitoredEntities(args: {
    providerId: string
  }): Promise<ManagedEntity[] | undefined> {
    const result = await this.connection.exec<{
      providerId: string
    } & { _this: ObjectReference }, ManagedEntity[] | undefined>(
      "QueryMonitoredEntities", { _this: { attributes: { type: "HealthUpdateManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "ManagedEntity[]");
  }
  async queryProviderList(): Promise<string[] | undefined> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, string[] | undefined>(
      "QueryProviderList", { _this: { attributes: { type: "HealthUpdateManager" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "string[]");
  }
  async queryProviderName(args: {
    id: string
  }): Promise<string> {
    const result = await this.connection.exec<{
      id: string
    } & { _this: ObjectReference }, string>(
      "QueryProviderName", { _this: { attributes: { type: "HealthUpdateManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "string");
  }
  async queryUnmonitoredHosts(args: {
    providerId: string;
    cluster: ClusterComputeResource
  }): Promise<HostSystem[] | undefined> {
    const result = await this.connection.exec<{
      providerId: string;
      cluster: ClusterComputeResource
    } & { _this: ObjectReference }, HostSystem[] | undefined>(
      "QueryUnmonitoredHosts", { _this: { attributes: { type: "HealthUpdateManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "HostSystem[]");
  }
  async registerProvider(args: {
    name: string;
    healthUpdateInfo?: HealthUpdateInfo[]
  }): Promise<string> {
    const result = await this.connection.exec<{
      name: string;
      healthUpdateInfo?: HealthUpdateInfo[]
    } & { _this: ObjectReference }, string>(
      "RegisterHealthUpdateProvider", { _this: { attributes: { type: "HealthUpdateManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "string");
  }
  async removeFilter(args: {
    filterId: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      filterId: string
    } & { _this: ObjectReference }, void>(
      "RemoveFilter", { _this: { attributes: { type: "HealthUpdateManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async removeFilterEntities(args: {
    filterId: string;
    entities?: ManagedEntity[]
  }): Promise<void> {
    const result = await this.connection.exec<{
      filterId: string;
      entities?: ManagedEntity[]
    } & { _this: ObjectReference }, void>(
      "RemoveFilterEntities", { _this: { attributes: { type: "HealthUpdateManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async removeMonitoredEntities(args: {
    providerId: string;
    entities?: ManagedEntity[]
  }): Promise<void> {
    const result = await this.connection.exec<{
      providerId: string;
      entities?: ManagedEntity[]
    } & { _this: ObjectReference }, void>(
      "RemoveMonitoredEntities", { _this: { attributes: { type: "HealthUpdateManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async unregisterProvider(args: {
    providerId: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      providerId: string
    } & { _this: ObjectReference }, void>(
      "UnregisterHealthUpdateProvider", { _this: { attributes: { type: "HealthUpdateManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  };
}
export class HistoryCollector extends ManagedObject {
  filter!: any;
  constructor(
    public connection: Connection,
    init?: Partial<HistoryCollector>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async remove(): Promise<void> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, void>(
      "DestroyCollector", { _this: { attributes: { type: "HistoryCollector" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async reset(): Promise<void> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, void>(
      "ResetCollector", { _this: { attributes: { type: "HistoryCollector" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async rewind(): Promise<void> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, void>(
      "RewindCollector", { _this: { attributes: { type: "HistoryCollector" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async setLatestPageSize(args: {
    maxCount: number
  }): Promise<void> {
    const result = await this.connection.exec<{
      maxCount: number
    } & { _this: ObjectReference }, void>(
      "SetCollectorPageSize", { _this: { attributes: { type: "HistoryCollector" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  };
}
export class HttpNfcLease extends ManagedObject {
  initializeProgress!: number;
  transferProgress!: number;
  mode!: string;
  capabilities!: HttpNfcLeaseCapabilities;
  info?: HttpNfcLeaseInfo;
  state!: HttpNfcLeaseState;
  error?: MethodFault;
  constructor(
    public connection: Connection,
    init?: Partial<HttpNfcLease>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async abort(args: {
    fault?: MethodFault
  }): Promise<void> {
    const result = await this.connection.exec<{
      fault?: MethodFault
    } & { _this: ObjectReference }, void>(
      "HttpNfcLeaseAbort", { _this: { attributes: { type: "HttpNfcLease" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async complete(): Promise<void> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, void>(
      "HttpNfcLeaseComplete", { _this: { attributes: { type: "HttpNfcLease" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async getManifest(): Promise<HttpNfcLeaseManifestEntry[] | undefined> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, HttpNfcLeaseManifestEntry[] | undefined>(
      "HttpNfcLeaseGetManifest", { _this: { attributes: { type: "HttpNfcLease" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "HttpNfcLeaseManifestEntry[]");
  }
  async progress(args: {
    percent: number
  }): Promise<void> {
    const result = await this.connection.exec<{
      percent: number
    } & { _this: ObjectReference }, void>(
      "HttpNfcLeaseProgress", { _this: { attributes: { type: "HttpNfcLease" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async pullFromUrls(args: {
    files?: HttpNfcLeaseSourceFile[]
  }): Promise<Task> {
    const result = await this.connection.exec<{
      files?: HttpNfcLeaseSourceFile[]
    } & { _this: ObjectReference }, Task>(
      "HttpNfcLeasePullFromUrls_Task", { _this: { attributes: { type: "HttpNfcLease" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async setManifestChecksumType(args: {
    deviceUrlsToChecksumTypes?: KeyValue[]
  }): Promise<void> {
    const result = await this.connection.exec<{
      deviceUrlsToChecksumTypes?: KeyValue[]
    } & { _this: ObjectReference }, void>(
      "HttpNfcLeaseSetManifestChecksumType", { _this: { attributes: { type: "HttpNfcLease" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  };
}
export class IoFilterManager extends ManagedObject {
  
  constructor(
    public connection: Connection,
    init?: Partial<IoFilterManager>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async installIoFilter(args: {
    vibUrl: string;
    compRes: ComputeResource
  }): Promise<Task | undefined> {
    const result = await this.connection.exec<{
      vibUrl: string;
      compRes: ComputeResource
    } & { _this: ObjectReference }, Task | undefined>(
      "InstallIoFilter_Task", { _this: { attributes: { type: "IoFilterManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async queryDisksUsingFilter(args: {
    filterId: string;
    compRes: ComputeResource
  }): Promise<VirtualDiskId[]> {
    const result = await this.connection.exec<{
      filterId: string;
      compRes: ComputeResource
    } & { _this: ObjectReference }, VirtualDiskId[]>(
      "QueryDisksUsingFilter", { _this: { attributes: { type: "IoFilterManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "VirtualDiskId[]");
  }
  async queryIoFilterInfo(args: {
    compRes: ComputeResource
  }): Promise<ClusterIoFilterInfo[] | undefined> {
    const result = await this.connection.exec<{
      compRes: ComputeResource
    } & { _this: ObjectReference }, ClusterIoFilterInfo[] | undefined>(
      "QueryIoFilterInfo", { _this: { attributes: { type: "IoFilterManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "ClusterIoFilterInfo[]");
  }
  async queryIssue(args: {
    filterId: string;
    compRes: ComputeResource
  }): Promise<IoFilterQueryIssueResult> {
    const result = await this.connection.exec<{
      filterId: string;
      compRes: ComputeResource
    } & { _this: ObjectReference }, IoFilterQueryIssueResult>(
      "QueryIoFilterIssues", { _this: { attributes: { type: "IoFilterManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "IoFilterQueryIssueResult");
  }
  async resolveInstallationErrorsOnCluster(args: {
    filterId: string;
    cluster: ClusterComputeResource
  }): Promise<Task> {
    const result = await this.connection.exec<{
      filterId: string;
      cluster: ClusterComputeResource
    } & { _this: ObjectReference }, Task>(
      "ResolveInstallationErrorsOnCluster_Task", { _this: { attributes: { type: "IoFilterManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async resolveInstallationErrorsOnHost(args: {
    filterId: string;
    host: HostSystem
  }): Promise<Task> {
    const result = await this.connection.exec<{
      filterId: string;
      host: HostSystem
    } & { _this: ObjectReference }, Task>(
      "ResolveInstallationErrorsOnHost_Task", { _this: { attributes: { type: "IoFilterManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async uninstallIoFilter(args: {
    filterId: string;
    compRes: ComputeResource
  }): Promise<Task> {
    const result = await this.connection.exec<{
      filterId: string;
      compRes: ComputeResource
    } & { _this: ObjectReference }, Task>(
      "UninstallIoFilter_Task", { _this: { attributes: { type: "IoFilterManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async upgradeIoFilter(args: {
    filterId: string;
    compRes: ComputeResource;
    vibUrl: string
  }): Promise<Task | undefined> {
    const result = await this.connection.exec<{
      filterId: string;
      compRes: ComputeResource;
      vibUrl: string
    } & { _this: ObjectReference }, Task | undefined>(
      "UpgradeIoFilter_Task", { _this: { attributes: { type: "IoFilterManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  };
}
export class IpPoolManager extends ManagedObject {
  
  constructor(
    public connection: Connection,
    init?: Partial<IpPoolManager>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async allocateIpv4Address(args: {
    dc: Datacenter;
    poolId: number;
    allocationId: string
  }): Promise<string> {
    const result = await this.connection.exec<{
      dc: Datacenter;
      poolId: number;
      allocationId: string
    } & { _this: ObjectReference }, string>(
      "AllocateIpv4Address", { _this: { attributes: { type: "IpPoolManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "string");
  }
  async allocateIpv6Address(args: {
    dc: Datacenter;
    poolId: number;
    allocationId: string
  }): Promise<string> {
    const result = await this.connection.exec<{
      dc: Datacenter;
      poolId: number;
      allocationId: string
    } & { _this: ObjectReference }, string>(
      "AllocateIpv6Address", { _this: { attributes: { type: "IpPoolManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "string");
  }
  async createIpPool(args: {
    dc: Datacenter;
    pool: IpPool
  }): Promise<number> {
    const result = await this.connection.exec<{
      dc: Datacenter;
      pool: IpPool
    } & { _this: ObjectReference }, number>(
      "CreateIpPool", { _this: { attributes: { type: "IpPoolManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "number");
  }
  async destroyIpPool(args: {
    dc: Datacenter;
    id: number;
    force: boolean
  }): Promise<void> {
    const result = await this.connection.exec<{
      dc: Datacenter;
      id: number;
      force: boolean
    } & { _this: ObjectReference }, void>(
      "DestroyIpPool", { _this: { attributes: { type: "IpPoolManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async queryIPAllocations(args: {
    dc: Datacenter;
    poolId: number;
    extensionKey: string
  }): Promise<IpPoolManagerIpAllocation[]> {
    const result = await this.connection.exec<{
      dc: Datacenter;
      poolId: number;
      extensionKey: string
    } & { _this: ObjectReference }, IpPoolManagerIpAllocation[]>(
      "QueryIPAllocations", { _this: { attributes: { type: "IpPoolManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "IpPoolManagerIpAllocation[]");
  }
  async queryIpPools(args: {
    dc: Datacenter
  }): Promise<IpPool[] | undefined> {
    const result = await this.connection.exec<{
      dc: Datacenter
    } & { _this: ObjectReference }, IpPool[] | undefined>(
      "QueryIpPools", { _this: { attributes: { type: "IpPoolManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "IpPool[]");
  }
  async releaseIpAllocation(args: {
    dc: Datacenter;
    poolId: number;
    allocationId: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      dc: Datacenter;
      poolId: number;
      allocationId: string
    } & { _this: ObjectReference }, void>(
      "ReleaseIpAllocation", { _this: { attributes: { type: "IpPoolManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async updateIpPool(args: {
    dc: Datacenter;
    pool: IpPool
  }): Promise<void> {
    const result = await this.connection.exec<{
      dc: Datacenter;
      pool: IpPool
    } & { _this: ObjectReference }, void>(
      "UpdateIpPool", { _this: { attributes: { type: "IpPoolManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  };
}
export class LicenseManager extends ManagedObject {
  source!: LicenseSource;
  sourceAvailable!: boolean;
  diagnostics?: LicenseDiagnostics;
  featureInfo?: LicenseFeatureInfo[];
  licensedEdition!: string;
  licenses!: LicenseManagerLicenseInfo[];
  licenseAssignmentManager?: LicenseAssignmentManager;
  evaluation!: LicenseManagerEvaluationInfo;
  constructor(
    public connection: Connection,
    init?: Partial<LicenseManager>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async addLicense(args: {
    licenseKey: string;
    labels?: KeyValue[]
  }): Promise<LicenseManagerLicenseInfo> {
    const result = await this.connection.exec<{
      licenseKey: string;
      labels?: KeyValue[]
    } & { _this: ObjectReference }, LicenseManagerLicenseInfo>(
      "AddLicense", { _this: { attributes: { type: "LicenseManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "LicenseManagerLicenseInfo");
  }
  async checkFeature(args: {
    host?: HostSystem;
    featureKey: string
  }): Promise<boolean> {
    const result = await this.connection.exec<{
      host?: HostSystem;
      featureKey: string
    } & { _this: ObjectReference }, boolean>(
      "CheckLicenseFeature", { _this: { attributes: { type: "LicenseManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "boolean");
  }
  async configureSource(args: {
    host?: HostSystem;
    licenseSource: LicenseSource
  }): Promise<void> {
    const result = await this.connection.exec<{
      host?: HostSystem;
      licenseSource: LicenseSource
    } & { _this: ObjectReference }, void>(
      "ConfigureLicenseSource", { _this: { attributes: { type: "LicenseManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async decodeLicense(args: {
    licenseKey: string
  }): Promise<LicenseManagerLicenseInfo> {
    const result = await this.connection.exec<{
      licenseKey: string
    } & { _this: ObjectReference }, LicenseManagerLicenseInfo>(
      "DecodeLicense", { _this: { attributes: { type: "LicenseManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "LicenseManagerLicenseInfo");
  }
  async disable(args: {
    host?: HostSystem;
    featureKey: string
  }): Promise<boolean> {
    const result = await this.connection.exec<{
      host?: HostSystem;
      featureKey: string
    } & { _this: ObjectReference }, boolean>(
      "DisableFeature", { _this: { attributes: { type: "LicenseManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "boolean");
  }
  async enable(args: {
    host?: HostSystem;
    featureKey: string
  }): Promise<boolean> {
    const result = await this.connection.exec<{
      host?: HostSystem;
      featureKey: string
    } & { _this: ObjectReference }, boolean>(
      "EnableFeature", { _this: { attributes: { type: "LicenseManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "boolean");
  }
  async querySourceAvailability(args: {
    host?: HostSystem
  }): Promise<LicenseAvailabilityInfo[] | undefined> {
    const result = await this.connection.exec<{
      host?: HostSystem
    } & { _this: ObjectReference }, LicenseAvailabilityInfo[] | undefined>(
      "QueryLicenseSourceAvailability", { _this: { attributes: { type: "LicenseManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "LicenseAvailabilityInfo[]");
  }
  async queryUsage(args: {
    host?: HostSystem
  }): Promise<LicenseUsageInfo> {
    const result = await this.connection.exec<{
      host?: HostSystem
    } & { _this: ObjectReference }, LicenseUsageInfo>(
      "QueryLicenseUsage", { _this: { attributes: { type: "LicenseManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "LicenseUsageInfo");
  }
  async querySupportedFeatures(args: {
    host?: HostSystem
  }): Promise<LicenseFeatureInfo[] | undefined> {
    const result = await this.connection.exec<{
      host?: HostSystem
    } & { _this: ObjectReference }, LicenseFeatureInfo[] | undefined>(
      "QuerySupportedFeatures", { _this: { attributes: { type: "LicenseManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "LicenseFeatureInfo[]");
  }
  async removeLicense(args: {
    licenseKey: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      licenseKey: string
    } & { _this: ObjectReference }, void>(
      "RemoveLicense", { _this: { attributes: { type: "LicenseManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async removeLabel(args: {
    licenseKey: string;
    labelKey: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      licenseKey: string;
      labelKey: string
    } & { _this: ObjectReference }, void>(
      "RemoveLicenseLabel", { _this: { attributes: { type: "LicenseManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async setEdition(args: {
    host?: HostSystem;
    featureKey?: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      host?: HostSystem;
      featureKey?: string
    } & { _this: ObjectReference }, void>(
      "SetLicenseEdition", { _this: { attributes: { type: "LicenseManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async updateLicense(args: {
    licenseKey: string;
    labels?: KeyValue[]
  }): Promise<LicenseManagerLicenseInfo> {
    const result = await this.connection.exec<{
      licenseKey: string;
      labels?: KeyValue[]
    } & { _this: ObjectReference }, LicenseManagerLicenseInfo>(
      "UpdateLicense", { _this: { attributes: { type: "LicenseManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "LicenseManagerLicenseInfo");
  }
  async updateLabel(args: {
    licenseKey: string;
    labelKey: string;
    labelValue: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      licenseKey: string;
      labelKey: string;
      labelValue: string
    } & { _this: ObjectReference }, void>(
      "UpdateLicenseLabel", { _this: { attributes: { type: "LicenseManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  };
}
export class LocalizationManager extends ManagedObject {
  catalog?: LocalizationManagerMessageCatalog[];
  constructor(
    public connection: Connection,
    init?: Partial<LocalizationManager>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  
}
export class OverheadMemoryManager extends ManagedObject {
  
  constructor(
    public connection: Connection,
    init?: Partial<OverheadMemoryManager>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async lookupVmOverheadMemory(args: {
    vm: VirtualMachine;
    host: HostSystem
  }): Promise<number> {
    const result = await this.connection.exec<{
      vm: VirtualMachine;
      host: HostSystem
    } & { _this: ObjectReference }, number>(
      "LookupVmOverheadMemory", { _this: { attributes: { type: "OverheadMemoryManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "number");
  };
}
export class OvfManager extends ManagedObject {
  ovfImportOption?: OvfOptionInfo[];
  ovfExportOption?: OvfOptionInfo[];
  constructor(
    public connection: Connection,
    init?: Partial<OvfManager>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async createDescriptor(args: {
    obj: ManagedEntity;
    cdp: OvfCreateDescriptorParams
  }): Promise<OvfCreateDescriptorResult> {
    const result = await this.connection.exec<{
      obj: ManagedEntity;
      cdp: OvfCreateDescriptorParams
    } & { _this: ObjectReference }, OvfCreateDescriptorResult>(
      "CreateDescriptor", { _this: { attributes: { type: "OvfManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "OvfCreateDescriptorResult");
  }
  async createImportSpec(args: {
    ovfDescriptor: string;
    resourcePool: ResourcePool;
    datastore: Datastore;
    cisp: OvfCreateImportSpecParams
  }): Promise<OvfCreateImportSpecResult> {
    const result = await this.connection.exec<{
      ovfDescriptor: string;
      resourcePool: ResourcePool;
      datastore: Datastore;
      cisp: OvfCreateImportSpecParams
    } & { _this: ObjectReference }, OvfCreateImportSpecResult>(
      "CreateImportSpec", { _this: { attributes: { type: "OvfManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "OvfCreateImportSpecResult");
  }
  async parseDescriptor(args: {
    ovfDescriptor: string;
    pdp: OvfParseDescriptorParams
  }): Promise<OvfParseDescriptorResult> {
    const result = await this.connection.exec<{
      ovfDescriptor: string;
      pdp: OvfParseDescriptorParams
    } & { _this: ObjectReference }, OvfParseDescriptorResult>(
      "ParseDescriptor", { _this: { attributes: { type: "OvfManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "OvfParseDescriptorResult");
  }
  async validateHost(args: {
    ovfDescriptor: string;
    host: HostSystem;
    vhp: OvfValidateHostParams
  }): Promise<OvfValidateHostResult> {
    const result = await this.connection.exec<{
      ovfDescriptor: string;
      host: HostSystem;
      vhp: OvfValidateHostParams
    } & { _this: ObjectReference }, OvfValidateHostResult>(
      "ValidateHost", { _this: { attributes: { type: "OvfManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "OvfValidateHostResult");
  };
}
export class PerformanceManager extends ManagedObject {
  description!: PerformanceDescription;
  historicalInterval?: PerfInterval[];
  perfCounter?: PerfCounterInfo[];
  constructor(
    public connection: Connection,
    init?: Partial<PerformanceManager>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async createHistoricalInterval(args: {
    intervalId: PerfInterval
  }): Promise<void> {
    const result = await this.connection.exec<{
      intervalId: PerfInterval
    } & { _this: ObjectReference }, void>(
      "CreatePerfInterval", { _this: { attributes: { type: "PerformanceManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async queryAvailableMetric(args: {
    entity: ManagedObject;
    beginTime?: Date;
    endTime?: Date;
    intervalId?: number
  }): Promise<PerfMetricId[] | undefined> {
    const result = await this.connection.exec<{
      entity: ManagedObject;
      beginTime?: Date;
      endTime?: Date;
      intervalId?: number
    } & { _this: ObjectReference }, PerfMetricId[] | undefined>(
      "QueryAvailablePerfMetric", { _this: { attributes: { type: "PerformanceManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "PerfMetricId[]");
  }
  async queryStats(args: {
    querySpec: PerfQuerySpec[]
  }): Promise<PerfEntityMetricBase[] | undefined> {
    const result = await this.connection.exec<{
      querySpec: PerfQuerySpec[]
    } & { _this: ObjectReference }, PerfEntityMetricBase[] | undefined>(
      "QueryPerf", { _this: { attributes: { type: "PerformanceManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "PerfEntityMetricBase[]");
  }
  async queryCompositeStats(args: {
    querySpec: PerfQuerySpec
  }): Promise<PerfCompositeMetric> {
    const result = await this.connection.exec<{
      querySpec: PerfQuerySpec
    } & { _this: ObjectReference }, PerfCompositeMetric>(
      "QueryPerfComposite", { _this: { attributes: { type: "PerformanceManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "PerfCompositeMetric");
  }
  async queryCounter(args: {
    counterId: number[]
  }): Promise<PerfCounterInfo[] | undefined> {
    const result = await this.connection.exec<{
      counterId: number[]
    } & { _this: ObjectReference }, PerfCounterInfo[] | undefined>(
      "QueryPerfCounter", { _this: { attributes: { type: "PerformanceManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "PerfCounterInfo[]");
  }
  async queryCounterByLevel(args: {
    level: number
  }): Promise<PerfCounterInfo[]> {
    const result = await this.connection.exec<{
      level: number
    } & { _this: ObjectReference }, PerfCounterInfo[]>(
      "QueryPerfCounterByLevel", { _this: { attributes: { type: "PerformanceManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "PerfCounterInfo[]");
  }
  async queryProviderSummary(args: {
    entity: ManagedObject
  }): Promise<PerfProviderSummary> {
    const result = await this.connection.exec<{
      entity: ManagedObject
    } & { _this: ObjectReference }, PerfProviderSummary>(
      "QueryPerfProviderSummary", { _this: { attributes: { type: "PerformanceManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "PerfProviderSummary");
  }
  async removeHistoricalInterval(args: {
    samplePeriod: number
  }): Promise<void> {
    const result = await this.connection.exec<{
      samplePeriod: number
    } & { _this: ObjectReference }, void>(
      "RemovePerfInterval", { _this: { attributes: { type: "PerformanceManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async resetCounterLevelMapping(args: {
    counters: number[]
  }): Promise<void> {
    const result = await this.connection.exec<{
      counters: number[]
    } & { _this: ObjectReference }, void>(
      "ResetCounterLevelMapping", { _this: { attributes: { type: "PerformanceManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async updateCounterLevelMapping(args: {
    counterLevelMap: PerformanceManagerCounterLevelMapping[]
  }): Promise<void> {
    const result = await this.connection.exec<{
      counterLevelMap: PerformanceManagerCounterLevelMapping[]
    } & { _this: ObjectReference }, void>(
      "UpdateCounterLevelMapping", { _this: { attributes: { type: "PerformanceManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async updateHistoricalInterval(args: {
    interval: PerfInterval
  }): Promise<void> {
    const result = await this.connection.exec<{
      interval: PerfInterval
    } & { _this: ObjectReference }, void>(
      "UpdatePerfInterval", { _this: { attributes: { type: "PerformanceManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  };
}
export class ResourcePlanningManager extends ManagedObject {
  
  constructor(
    public connection: Connection,
    init?: Partial<ResourcePlanningManager>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async estimateDatabaseSize(args: {
    dbSizeParam: DatabaseSizeParam
  }): Promise<DatabaseSizeEstimate> {
    const result = await this.connection.exec<{
      dbSizeParam: DatabaseSizeParam
    } & { _this: ObjectReference }, DatabaseSizeEstimate>(
      "EstimateDatabaseSize", { _this: { attributes: { type: "ResourcePlanningManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "DatabaseSizeEstimate");
  };
}
export class SearchIndex extends ManagedObject {
  
  constructor(
    public connection: Connection,
    init?: Partial<SearchIndex>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async findAllByDnsName(args: {
    datacenter?: Datacenter;
    dnsName: string;
    vmSearch: boolean
  }): Promise<ManagedEntity[]> {
    const result = await this.connection.exec<{
      datacenter?: Datacenter;
      dnsName: string;
      vmSearch: boolean
    } & { _this: ObjectReference }, ManagedEntity[]>(
      "FindAllByDnsName", { _this: { attributes: { type: "SearchIndex" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "ManagedEntity[]");
  }
  async findAllByIp(args: {
    datacenter?: Datacenter;
    ip: string;
    vmSearch: boolean
  }): Promise<ManagedEntity[]> {
    const result = await this.connection.exec<{
      datacenter?: Datacenter;
      ip: string;
      vmSearch: boolean
    } & { _this: ObjectReference }, ManagedEntity[]>(
      "FindAllByIp", { _this: { attributes: { type: "SearchIndex" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "ManagedEntity[]");
  }
  async findAllByUuid(args: {
    datacenter?: Datacenter;
    uuid: string;
    vmSearch: boolean;
    instanceUuid?: boolean
  }): Promise<ManagedEntity[]> {
    const result = await this.connection.exec<{
      datacenter?: Datacenter;
      uuid: string;
      vmSearch: boolean;
      instanceUuid?: boolean
    } & { _this: ObjectReference }, ManagedEntity[]>(
      "FindAllByUuid", { _this: { attributes: { type: "SearchIndex" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "ManagedEntity[]");
  }
  async findByDatastorePath(args: {
    datacenter: Datacenter;
    path: string
  }): Promise<VirtualMachine | undefined> {
    const result = await this.connection.exec<{
      datacenter: Datacenter;
      path: string
    } & { _this: ObjectReference }, VirtualMachine | undefined>(
      "FindByDatastorePath", { _this: { attributes: { type: "SearchIndex" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "VirtualMachine");
  }
  async findByDnsName(args: {
    datacenter?: Datacenter;
    dnsName: string;
    vmSearch: boolean
  }): Promise<ManagedEntity | undefined> {
    const result = await this.connection.exec<{
      datacenter?: Datacenter;
      dnsName: string;
      vmSearch: boolean
    } & { _this: ObjectReference }, ManagedEntity | undefined>(
      "FindByDnsName", { _this: { attributes: { type: "SearchIndex" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "ManagedEntity");
  }
  async findByInventoryPath(args: {
    inventoryPath: string
  }): Promise<ManagedEntity | undefined> {
    const result = await this.connection.exec<{
      inventoryPath: string
    } & { _this: ObjectReference }, ManagedEntity | undefined>(
      "FindByInventoryPath", { _this: { attributes: { type: "SearchIndex" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "ManagedEntity");
  }
  async findByIp(args: {
    datacenter?: Datacenter;
    ip: string;
    vmSearch: boolean
  }): Promise<ManagedEntity | undefined> {
    const result = await this.connection.exec<{
      datacenter?: Datacenter;
      ip: string;
      vmSearch: boolean
    } & { _this: ObjectReference }, ManagedEntity | undefined>(
      "FindByIp", { _this: { attributes: { type: "SearchIndex" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "ManagedEntity");
  }
  async findByUuid(args: {
    datacenter?: Datacenter;
    uuid: string;
    vmSearch: boolean;
    instanceUuid?: boolean
  }): Promise<ManagedEntity | undefined> {
    const result = await this.connection.exec<{
      datacenter?: Datacenter;
      uuid: string;
      vmSearch: boolean;
      instanceUuid?: boolean
    } & { _this: ObjectReference }, ManagedEntity | undefined>(
      "FindByUuid", { _this: { attributes: { type: "SearchIndex" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "ManagedEntity");
  }
  async findChild(args: {
    entity: ManagedEntity;
    name: string
  }): Promise<ManagedEntity | undefined> {
    const result = await this.connection.exec<{
      entity: ManagedEntity;
      name: string
    } & { _this: ObjectReference }, ManagedEntity | undefined>(
      "FindChild", { _this: { attributes: { type: "SearchIndex" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "ManagedEntity");
  };
}
export class ServiceManager extends ManagedObject {
  service?: ServiceManagerServiceInfo[];
  constructor(
    public connection: Connection,
    init?: Partial<ServiceManager>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async queryServiceList(args: {
    serviceName?: string;
    location?: string[]
  }): Promise<ServiceManagerServiceInfo[] | undefined> {
    const result = await this.connection.exec<{
      serviceName?: string;
      location?: string[]
    } & { _this: ObjectReference }, ServiceManagerServiceInfo[] | undefined>(
      "QueryServiceList", { _this: { attributes: { type: "ServiceManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "ServiceManagerServiceInfo[]");
  };
}
export class SessionManager extends ManagedObject {
  sessionList?: UserSession[];
  currentSession?: UserSession;
  message?: string;
  messageLocaleList?: string[];
  supportedLocaleList?: string[];
  defaultLocale!: string;
  constructor(
    public connection: Connection,
    init?: Partial<SessionManager>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async acquireCloneTicket(): Promise<string> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, string>(
      "AcquireCloneTicket", { _this: { attributes: { type: "SessionManager" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "string");
  }
  async acquireGenericServiceTicket(args: {
    spec: SessionManagerServiceRequestSpec
  }): Promise<SessionManagerGenericServiceTicket> {
    const result = await this.connection.exec<{
      spec: SessionManagerServiceRequestSpec
    } & { _this: ObjectReference }, SessionManagerGenericServiceTicket>(
      "AcquireGenericServiceTicket", { _this: { attributes: { type: "SessionManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "SessionManagerGenericServiceTicket");
  }
  async acquireLocalTicket(args: {
    userName: string
  }): Promise<SessionManagerLocalTicket> {
    const result = await this.connection.exec<{
      userName: string
    } & { _this: ObjectReference }, SessionManagerLocalTicket>(
      "AcquireLocalTicket", { _this: { attributes: { type: "SessionManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "SessionManagerLocalTicket");
  }
  async cloneSession(args: {
    cloneTicket: string
  }): Promise<UserSession> {
    const result = await this.connection.exec<{
      cloneTicket: string
    } & { _this: ObjectReference }, UserSession>(
      "CloneSession", { _this: { attributes: { type: "SessionManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "UserSession");
  }
  async impersonateUser(args: {
    userName: string;
    locale?: string
  }): Promise<UserSession> {
    const result = await this.connection.exec<{
      userName: string;
      locale?: string
    } & { _this: ObjectReference }, UserSession>(
      "ImpersonateUser", { _this: { attributes: { type: "SessionManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "UserSession");
  }
  async login(args: {
    userName: string;
    password: string;
    locale?: string
  }): Promise<UserSession> {
    const result = await this.connection.exec<{
      userName: string;
      password: string;
      locale?: string
    } & { _this: ObjectReference }, UserSession>(
      "Login", { _this: { attributes: { type: "SessionManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "UserSession");
  }
  async loginBySSPI(args: {
    base64Token: string;
    locale?: string
  }): Promise<UserSession> {
    const result = await this.connection.exec<{
      base64Token: string;
      locale?: string
    } & { _this: ObjectReference }, UserSession>(
      "LoginBySSPI", { _this: { attributes: { type: "SessionManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "UserSession");
  }
  async loginByToken(args: {
    locale?: string
  }): Promise<UserSession> {
    const result = await this.connection.exec<{
      locale?: string
    } & { _this: ObjectReference }, UserSession>(
      "LoginByToken", { _this: { attributes: { type: "SessionManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "UserSession");
  }
  async loginExtensionByCertificate(args: {
    extensionKey: string;
    locale?: string
  }): Promise<UserSession> {
    const result = await this.connection.exec<{
      extensionKey: string;
      locale?: string
    } & { _this: ObjectReference }, UserSession>(
      "LoginExtensionByCertificate", { _this: { attributes: { type: "SessionManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "UserSession");
  }
  async loginExtensionBySubjectName(args: {
    extensionKey: string;
    locale?: string
  }): Promise<UserSession> {
    const result = await this.connection.exec<{
      extensionKey: string;
      locale?: string
    } & { _this: ObjectReference }, UserSession>(
      "LoginExtensionBySubjectName", { _this: { attributes: { type: "SessionManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "UserSession");
  }
  async logout(): Promise<void> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, void>(
      "Logout", { _this: { attributes: { type: "SessionManager" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async sessionIsActive(args: {
    sessionID: string;
    userName: string
  }): Promise<boolean> {
    const result = await this.connection.exec<{
      sessionID: string;
      userName: string
    } & { _this: ObjectReference }, boolean>(
      "SessionIsActive", { _this: { attributes: { type: "SessionManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "boolean");
  }
  async setLocale(args: {
    locale: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      locale: string
    } & { _this: ObjectReference }, void>(
      "SetLocale", { _this: { attributes: { type: "SessionManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async terminate(args: {
    sessionId: string[]
  }): Promise<void> {
    const result = await this.connection.exec<{
      sessionId: string[]
    } & { _this: ObjectReference }, void>(
      "TerminateSession", { _this: { attributes: { type: "SessionManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async updateMessage(args: {
    message: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      message: string
    } & { _this: ObjectReference }, void>(
      "UpdateServiceMessage", { _this: { attributes: { type: "SessionManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  };
}
export class SimpleCommand extends ManagedObject {
  encodingType!: SimpleCommandEncoding;
  entity!: ServiceManagerServiceInfo;
  constructor(
    public connection: Connection,
    init?: Partial<SimpleCommand>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async Execute(args: {
    arguments?: string[]
  }): Promise<string> {
    const result = await this.connection.exec<{
      arguments?: string[]
    } & { _this: ObjectReference }, string>(
      "ExecuteSimpleCommand", { _this: { attributes: { type: "SimpleCommand" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "string");
  };
}
export class SiteInfoManager extends ManagedObject {
  
  constructor(
    public connection: Connection,
    init?: Partial<SiteInfoManager>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async GetSiteInfo(): Promise<SiteInfo> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, SiteInfo>(
      "GetSiteInfo", { _this: { attributes: { type: "SiteInfoManager" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "SiteInfo");
  };
}
export class StorageQueryManager extends ManagedObject {
  
  constructor(
    public connection: Connection,
    init?: Partial<StorageQueryManager>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async queryHostsWithAttachedLun(args: {
    lunUuid: string
  }): Promise<HostSystem[] | undefined> {
    const result = await this.connection.exec<{
      lunUuid: string
    } & { _this: ObjectReference }, HostSystem[] | undefined>(
      "QueryHostsWithAttachedLun", { _this: { attributes: { type: "StorageQueryManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "HostSystem[]");
  };
}
export class StorageResourceManager extends ManagedObject {
  
  constructor(
    public connection: Connection,
    init?: Partial<StorageResourceManager>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async applyRecommendationToPod(args: {
    pod: StoragePod;
    key: string
  }): Promise<Task> {
    const result = await this.connection.exec<{
      pod: StoragePod;
      key: string
    } & { _this: ObjectReference }, Task>(
      "ApplyStorageDrsRecommendationToPod_Task", { _this: { attributes: { type: "StorageResourceManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async applyRecommendation(args: {
    key: string[]
  }): Promise<Task> {
    const result = await this.connection.exec<{
      key: string[]
    } & { _this: ObjectReference }, Task>(
      "ApplyStorageDrsRecommendation_Task", { _this: { attributes: { type: "StorageResourceManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async cancelRecommendation(args: {
    key: string[]
  }): Promise<void> {
    const result = await this.connection.exec<{
      key: string[]
    } & { _this: ObjectReference }, void>(
      "CancelStorageDrsRecommendation", { _this: { attributes: { type: "StorageResourceManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async ConfigureDatastoreIORM(args: {
    datastore: Datastore;
    spec: StorageIORMConfigSpec
  }): Promise<Task> {
    const result = await this.connection.exec<{
      datastore: Datastore;
      spec: StorageIORMConfigSpec
    } & { _this: ObjectReference }, Task>(
      "ConfigureDatastoreIORM_Task", { _this: { attributes: { type: "StorageResourceManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async configureStorageDrsForPod(args: {
    pod: StoragePod;
    spec: StorageDrsConfigSpec;
    modify: boolean
  }): Promise<Task> {
    const result = await this.connection.exec<{
      pod: StoragePod;
      spec: StorageDrsConfigSpec;
      modify: boolean
    } & { _this: ObjectReference }, Task>(
      "ConfigureStorageDrsForPod_Task", { _this: { attributes: { type: "StorageResourceManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async queryDatastorePerformanceSummary(args: {
    datastore: Datastore
  }): Promise<StoragePerformanceSummary[] | undefined> {
    const result = await this.connection.exec<{
      datastore: Datastore
    } & { _this: ObjectReference }, StoragePerformanceSummary[] | undefined>(
      "QueryDatastorePerformanceSummary", { _this: { attributes: { type: "StorageResourceManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "StoragePerformanceSummary[]");
  }
  async QueryIORMConfigOption(args: {
    host: HostSystem
  }): Promise<StorageIORMConfigOption> {
    const result = await this.connection.exec<{
      host: HostSystem
    } & { _this: ObjectReference }, StorageIORMConfigOption>(
      "QueryIORMConfigOption", { _this: { attributes: { type: "StorageResourceManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "StorageIORMConfigOption");
  }
  async recommendDatastores(args: {
    storageSpec: StoragePlacementSpec
  }): Promise<StoragePlacementResult> {
    const result = await this.connection.exec<{
      storageSpec: StoragePlacementSpec
    } & { _this: ObjectReference }, StoragePlacementResult>(
      "RecommendDatastores", { _this: { attributes: { type: "StorageResourceManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "StoragePlacementResult");
  }
  async refreshRecommendation(args: {
    pod: StoragePod
  }): Promise<void> {
    const result = await this.connection.exec<{
      pod: StoragePod
    } & { _this: ObjectReference }, void>(
      "RefreshStorageDrsRecommendation", { _this: { attributes: { type: "StorageResourceManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async refreshRecommendationsForPod(args: {
    pod: StoragePod
  }): Promise<Task> {
    const result = await this.connection.exec<{
      pod: StoragePod
    } & { _this: ObjectReference }, Task>(
      "RefreshStorageDrsRecommendationsForPod_Task", { _this: { attributes: { type: "StorageResourceManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async validateStoragePodConfig(args: {
    pod: StoragePod;
    spec: StorageDrsConfigSpec
  }): Promise<MethodFault | undefined> {
    const result = await this.connection.exec<{
      pod: StoragePod;
      spec: StorageDrsConfigSpec
    } & { _this: ObjectReference }, MethodFault | undefined>(
      "ValidateStoragePodConfig", { _this: { attributes: { type: "StorageResourceManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "MethodFault");
  };
}
export class TaskHistoryCollector extends HistoryCollector {
  latestPage?: TaskInfo[];
  constructor(
    public connection: Connection,
    init?: Partial<TaskHistoryCollector>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async readNext(args: {
    maxCount: number
  }): Promise<TaskInfo[] | undefined> {
    const result = await this.connection.exec<{
      maxCount: number
    } & { _this: ObjectReference }, TaskInfo[] | undefined>(
      "ReadNextTasks", { _this: { attributes: { type: "TaskHistoryCollector" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "TaskInfo[]");
  }
  async readPrev(args: {
    maxCount: number
  }): Promise<TaskInfo[] | undefined> {
    const result = await this.connection.exec<{
      maxCount: number
    } & { _this: ObjectReference }, TaskInfo[] | undefined>(
      "ReadPreviousTasks", { _this: { attributes: { type: "TaskHistoryCollector" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "TaskInfo[]");
  };
}
export class TaskManager extends ManagedObject {
  recentTask?: Task[];
  description!: TaskDescription;
  maxCollector!: number;
  constructor(
    public connection: Connection,
    init?: Partial<TaskManager>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async createCollector(args: {
    filter: TaskFilterSpec
  }): Promise<TaskHistoryCollector> {
    const result = await this.connection.exec<{
      filter: TaskFilterSpec
    } & { _this: ObjectReference }, TaskHistoryCollector>(
      "CreateCollectorForTasks", { _this: { attributes: { type: "TaskManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "TaskHistoryCollector");
  }
  async createTask(args: {
    obj: ManagedObject;
    taskTypeId: string;
    initiatedBy?: string;
    cancelable: boolean;
    parentTaskKey?: string;
    activationId?: string
  }): Promise<TaskInfo> {
    const result = await this.connection.exec<{
      obj: ManagedObject;
      taskTypeId: string;
      initiatedBy?: string;
      cancelable: boolean;
      parentTaskKey?: string;
      activationId?: string
    } & { _this: ObjectReference }, TaskInfo>(
      "CreateTask", { _this: { attributes: { type: "TaskManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "TaskInfo");
  };
}
export class UserDirectory extends ManagedObject {
  domainList?: string[];
  constructor(
    public connection: Connection,
    init?: Partial<UserDirectory>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async retrieveUserGroups(args: {
    domain?: string;
    searchStr: string;
    belongsToGroup?: string;
    belongsToUser?: string;
    exactMatch: boolean;
    findUsers: boolean;
    findGroups: boolean
  }): Promise<UserSearchResult[] | undefined> {
    const result = await this.connection.exec<{
      domain?: string;
      searchStr: string;
      belongsToGroup?: string;
      belongsToUser?: string;
      exactMatch: boolean;
      findUsers: boolean;
      findGroups: boolean
    } & { _this: ObjectReference }, UserSearchResult[] | undefined>(
      "RetrieveUserGroups", { _this: { attributes: { type: "UserDirectory" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "UserSearchResult[]");
  };
}
export class VirtualizationManager extends ManagedObject {
  
  constructor(
    public connection: Connection,
    init?: Partial<VirtualizationManager>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  
}
export class VsanUpgradeSystem extends ManagedObject {
  
  constructor(
    public connection: Connection,
    init?: Partial<VsanUpgradeSystem>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async performUpgradePreflightCheck(args: {
    cluster: ClusterComputeResource;
    downgradeFormat?: boolean
  }): Promise<VsanUpgradeSystemPreflightCheckResult> {
    const result = await this.connection.exec<{
      cluster: ClusterComputeResource;
      downgradeFormat?: boolean
    } & { _this: ObjectReference }, VsanUpgradeSystemPreflightCheckResult>(
      "PerformVsanUpgradePreflightCheck", { _this: { attributes: { type: "VsanUpgradeSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "VsanUpgradeSystemPreflightCheckResult");
  }
  async performUpgrade(args: {
    cluster: ClusterComputeResource;
    performObjectUpgrade?: boolean;
    downgradeFormat?: boolean;
    allowReducedRedundancy?: boolean;
    excludeHosts?: HostSystem[]
  }): Promise<Task> {
    const result = await this.connection.exec<{
      cluster: ClusterComputeResource;
      performObjectUpgrade?: boolean;
      downgradeFormat?: boolean;
      allowReducedRedundancy?: boolean;
      excludeHosts?: HostSystem[]
    } & { _this: ObjectReference }, Task>(
      "PerformVsanUpgrade_Task", { _this: { attributes: { type: "VsanUpgradeSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async queryUpgradeStatus(args: {
    cluster: ClusterComputeResource
  }): Promise<VsanUpgradeSystemUpgradeStatus> {
    const result = await this.connection.exec<{
      cluster: ClusterComputeResource
    } & { _this: ObjectReference }, VsanUpgradeSystemUpgradeStatus>(
      "QueryVsanUpgradeStatus", { _this: { attributes: { type: "VsanUpgradeSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "VsanUpgradeSystemUpgradeStatus");
  };
}
export class Alarm extends ExtensibleManagedObject {
  info!: AlarmInfo;
  constructor(
    public connection: Connection,
    init?: Partial<Alarm>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async reconfigure(args: {
    spec: AlarmSpec
  }): Promise<void> {
    const result = await this.connection.exec<{
      spec: AlarmSpec
    } & { _this: ObjectReference }, void>(
      "ReconfigureAlarm", { _this: { attributes: { type: "Alarm" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async remove(): Promise<void> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, void>(
      "RemoveAlarm", { _this: { attributes: { type: "Alarm" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  };
}
export class ClusterEVCManager extends ExtensibleManagedObject {
  managedCluster!: ClusterComputeResource;
  evcState!: ClusterEVCManagerEVCState;
  constructor(
    public connection: Connection,
    init?: Partial<ClusterEVCManager>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async checkAddHostEvc(args: {
    cnxSpec: HostConnectSpec
  }): Promise<Task | undefined> {
    const result = await this.connection.exec<{
      cnxSpec: HostConnectSpec
    } & { _this: ObjectReference }, Task | undefined>(
      "CheckAddHostEvc_Task", { _this: { attributes: { type: "ClusterEVCManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async checkConfigureEvc(args: {
    evcModeKey: string;
    evcGraphicsModeKey?: string
  }): Promise<Task | undefined> {
    const result = await this.connection.exec<{
      evcModeKey: string;
      evcGraphicsModeKey?: string
    } & { _this: ObjectReference }, Task | undefined>(
      "CheckConfigureEvcMode_Task", { _this: { attributes: { type: "ClusterEVCManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async configureEvc(args: {
    evcModeKey: string;
    evcGraphicsModeKey?: string
  }): Promise<Task> {
    const result = await this.connection.exec<{
      evcModeKey: string;
      evcGraphicsModeKey?: string
    } & { _this: ObjectReference }, Task>(
      "ConfigureEvcMode_Task", { _this: { attributes: { type: "ClusterEVCManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async disableEvc(): Promise<Task> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, Task>(
      "DisableEvcMode_Task", { _this: { attributes: { type: "ClusterEVCManager" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  };
}
export class CryptoManager extends ManagedObject {
  enabled!: boolean;
  constructor(
    public connection: Connection,
    init?: Partial<CryptoManager>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async addKey(args: {
    key: CryptoKeyPlain
  }): Promise<void> {
    const result = await this.connection.exec<{
      key: CryptoKeyPlain
    } & { _this: ObjectReference }, void>(
      "AddKey", { _this: { attributes: { type: "CryptoManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async addKeys(args: {
    keys?: CryptoKeyPlain[]
  }): Promise<CryptoKeyResult[] | undefined> {
    const result = await this.connection.exec<{
      keys?: CryptoKeyPlain[]
    } & { _this: ObjectReference }, CryptoKeyResult[] | undefined>(
      "AddKeys", { _this: { attributes: { type: "CryptoManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "CryptoKeyResult[]");
  }
  async listKeys(args: {
    limit?: number
  }): Promise<CryptoKeyId[] | undefined> {
    const result = await this.connection.exec<{
      limit?: number
    } & { _this: ObjectReference }, CryptoKeyId[] | undefined>(
      "ListKeys", { _this: { attributes: { type: "CryptoManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "CryptoKeyId[]");
  }
  async removeKey(args: {
    key: CryptoKeyId;
    force: boolean
  }): Promise<void> {
    const result = await this.connection.exec<{
      key: CryptoKeyId;
      force: boolean
    } & { _this: ObjectReference }, void>(
      "RemoveKey", { _this: { attributes: { type: "CryptoManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async removeKeys(args: {
    keys?: CryptoKeyId[];
    force: boolean
  }): Promise<CryptoKeyResult[] | undefined> {
    const result = await this.connection.exec<{
      keys?: CryptoKeyId[];
      force: boolean
    } & { _this: ObjectReference }, CryptoKeyResult[] | undefined>(
      "RemoveKeys", { _this: { attributes: { type: "CryptoManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "CryptoKeyResult[]");
  };
}
export class CryptoManagerHost extends CryptoManager {
  
  constructor(
    public connection: Connection,
    init?: Partial<CryptoManagerHost>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async changeKey(args: {
    newKey: CryptoKeyPlain
  }): Promise<Task> {
    const result = await this.connection.exec<{
      newKey: CryptoKeyPlain
    } & { _this: ObjectReference }, Task>(
      "ChangeKey_Task", { _this: { attributes: { type: "CryptoManagerHost" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async disable(): Promise<void> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, void>(
      "CryptoManagerHostDisable", { _this: { attributes: { type: "CryptoManagerHost" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async enable(args: {
    initialKey: CryptoKeyPlain
  }): Promise<void> {
    const result = await this.connection.exec<{
      initialKey: CryptoKeyPlain
    } & { _this: ObjectReference }, void>(
      "CryptoManagerHostEnable", { _this: { attributes: { type: "CryptoManagerHost" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async prepare(): Promise<void> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, void>(
      "CryptoManagerHostPrepare", { _this: { attributes: { type: "CryptoManagerHost" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  };
}
export class CryptoManagerHostKMS extends CryptoManagerHost {
  
  constructor(
    public connection: Connection,
    init?: Partial<CryptoManagerHostKMS>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  
}
export class EventHistoryCollector extends HistoryCollector {
  latestPage?: Event[];
  constructor(
    public connection: Connection,
    init?: Partial<EventHistoryCollector>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async readNext(args: {
    maxCount: number
  }): Promise<Event[] | undefined> {
    const result = await this.connection.exec<{
      maxCount: number
    } & { _this: ObjectReference }, Event[] | undefined>(
      "ReadNextEvents", { _this: { attributes: { type: "EventHistoryCollector" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Event[]");
  }
  async readPrev(args: {
    maxCount: number
  }): Promise<Event[] | undefined> {
    const result = await this.connection.exec<{
      maxCount: number
    } & { _this: ObjectReference }, Event[] | undefined>(
      "ReadPreviousEvents", { _this: { attributes: { type: "EventHistoryCollector" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Event[]");
  };
}
export class EventManager extends ManagedObject {
  description!: EventDescription;
  latestEvent?: Event;
  maxCollector!: number;
  constructor(
    public connection: Connection,
    init?: Partial<EventManager>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async createCollector(args: {
    filter: EventFilterSpec
  }): Promise<EventHistoryCollector> {
    const result = await this.connection.exec<{
      filter: EventFilterSpec
    } & { _this: ObjectReference }, EventHistoryCollector>(
      "CreateCollectorForEvents", { _this: { attributes: { type: "EventManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "EventHistoryCollector");
  }
  async logUserEvent(args: {
    entity: ManagedEntity;
    msg: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      entity: ManagedEntity;
      msg: string
    } & { _this: ObjectReference }, void>(
      "LogUserEvent", { _this: { attributes: { type: "EventManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async postEvent(args: {
    eventToPost: Event;
    taskInfo?: TaskInfo
  }): Promise<void> {
    const result = await this.connection.exec<{
      eventToPost: Event;
      taskInfo?: TaskInfo
    } & { _this: ObjectReference }, void>(
      "PostEvent", { _this: { attributes: { type: "EventManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async QueryEvent(args: {
    filter: EventFilterSpec
  }): Promise<Event[] | undefined> {
    const result = await this.connection.exec<{
      filter: EventFilterSpec
    } & { _this: ObjectReference }, Event[] | undefined>(
      "QueryEvents", { _this: { attributes: { type: "EventManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Event[]");
  }
  async retrieveArgumentDescription(args: {
    eventTypeId: string
  }): Promise<EventArgDesc[] | undefined> {
    const result = await this.connection.exec<{
      eventTypeId: string
    } & { _this: ObjectReference }, EventArgDesc[] | undefined>(
      "RetrieveArgumentDescription", { _this: { attributes: { type: "EventManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "EventArgDesc[]");
  };
}
export class HostAssignableHardwareManager extends ManagedObject {
  binding?: HostAssignableHardwareBinding[];
  config!: HostAssignableHardwareConfig;
  constructor(
    public connection: Connection,
    init?: Partial<HostAssignableHardwareManager>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async downloadDescriptionTree(): Promise<Buffer> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, Buffer>(
      "DownloadDescriptionTree", { _this: { attributes: { type: "HostAssignableHardwareManager" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Buffer");
  }
  async retrieveDynamicPassthroughInfo(): Promise<VirtualMachineDynamicPassthroughInfo[] | undefined> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, VirtualMachineDynamicPassthroughInfo[] | undefined>(
      "RetrieveDynamicPassthroughInfo", { _this: { attributes: { type: "HostAssignableHardwareManager" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "VirtualMachineDynamicPassthroughInfo[]");
  }
  async updateConfig(args: {
    config: HostAssignableHardwareConfig
  }): Promise<void> {
    const result = await this.connection.exec<{
      config: HostAssignableHardwareConfig
    } & { _this: ObjectReference }, void>(
      "UpdateAssignableHardwareConfig", { _this: { attributes: { type: "HostAssignableHardwareManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  };
}
export class HostAuthenticationManager extends ManagedObject {
  info!: HostAuthenticationManagerInfo;
  supportedStore!: HostAuthenticationStore[];
  constructor(
    public connection: Connection,
    init?: Partial<HostAuthenticationManager>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  
}
export class HostAuthenticationStore extends ManagedObject {
  info!: HostAuthenticationStoreInfo;
  constructor(
    public connection: Connection,
    init?: Partial<HostAuthenticationStore>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  
}
export class HostAutoStartManager extends ManagedObject {
  config!: HostAutoStartManagerConfig;
  constructor(
    public connection: Connection,
    init?: Partial<HostAutoStartManager>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async autoPowerOff(): Promise<void> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, void>(
      "AutoStartPowerOff", { _this: { attributes: { type: "HostAutoStartManager" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async autoPowerOn(): Promise<void> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, void>(
      "AutoStartPowerOn", { _this: { attributes: { type: "HostAutoStartManager" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async reconfigure(args: {
    spec: HostAutoStartManagerConfig
  }): Promise<void> {
    const result = await this.connection.exec<{
      spec: HostAutoStartManagerConfig
    } & { _this: ObjectReference }, void>(
      "ReconfigureAutostart", { _this: { attributes: { type: "HostAutoStartManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  };
}
export class HostBootDeviceSystem extends ManagedObject {
  
  constructor(
    public connection: Connection,
    init?: Partial<HostBootDeviceSystem>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async queryBootDevices(): Promise<HostBootDeviceInfo | undefined> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, HostBootDeviceInfo | undefined>(
      "QueryBootDevices", { _this: { attributes: { type: "HostBootDeviceSystem" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "HostBootDeviceInfo");
  }
  async updateBootDevice(args: {
    key: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      key: string
    } & { _this: ObjectReference }, void>(
      "UpdateBootDevice", { _this: { attributes: { type: "HostBootDeviceSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  };
}
export class HostCacheConfigurationManager extends ManagedObject {
  cacheConfigurationInfo?: HostCacheConfigurationInfo[];
  constructor(
    public connection: Connection,
    init?: Partial<HostCacheConfigurationManager>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async configureCache(args: {
    spec: HostCacheConfigurationSpec
  }): Promise<Task> {
    const result = await this.connection.exec<{
      spec: HostCacheConfigurationSpec
    } & { _this: ObjectReference }, Task>(
      "ConfigureHostCache_Task", { _this: { attributes: { type: "HostCacheConfigurationManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  };
}
export class HostCertificateManager extends ManagedObject {
  certificateInfo!: HostCertificateManagerCertificateInfo;
  constructor(
    public connection: Connection,
    init?: Partial<HostCertificateManager>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async generateCertificateSigningRequest(args: {
    useIpAddressAsCommonName: boolean
  }): Promise<string> {
    const result = await this.connection.exec<{
      useIpAddressAsCommonName: boolean
    } & { _this: ObjectReference }, string>(
      "GenerateCertificateSigningRequest", { _this: { attributes: { type: "HostCertificateManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "string");
  }
  async generateCertificateSigningRequestByDn(args: {
    distinguishedName: string
  }): Promise<string> {
    const result = await this.connection.exec<{
      distinguishedName: string
    } & { _this: ObjectReference }, string>(
      "GenerateCertificateSigningRequestByDn", { _this: { attributes: { type: "HostCertificateManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "string");
  }
  async installServerCertificate(args: {
    cert: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      cert: string
    } & { _this: ObjectReference }, void>(
      "InstallServerCertificate", { _this: { attributes: { type: "HostCertificateManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async listCACertificateRevocationLists(): Promise<string[] | undefined> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, string[] | undefined>(
      "ListCACertificateRevocationLists", { _this: { attributes: { type: "HostCertificateManager" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "string[]");
  }
  async listCACertificates(): Promise<string[] | undefined> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, string[] | undefined>(
      "ListCACertificates", { _this: { attributes: { type: "HostCertificateManager" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "string[]");
  }
  async replaceCACertificatesAndCRLs(args: {
    caCert: string[];
    caCrl?: string[]
  }): Promise<void> {
    const result = await this.connection.exec<{
      caCert: string[];
      caCrl?: string[]
    } & { _this: ObjectReference }, void>(
      "ReplaceCACertificatesAndCRLs", { _this: { attributes: { type: "HostCertificateManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  };
}
export class HostCpuSchedulerSystem extends ExtensibleManagedObject {
  hyperthreadInfo?: HostHyperThreadScheduleInfo;
  constructor(
    public connection: Connection,
    init?: Partial<HostCpuSchedulerSystem>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async disableHyperThreading(): Promise<void> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, void>(
      "DisableHyperThreading", { _this: { attributes: { type: "HostCpuSchedulerSystem" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async enableHyperThreading(): Promise<void> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, void>(
      "EnableHyperThreading", { _this: { attributes: { type: "HostCpuSchedulerSystem" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  };
}
export class HostDatastoreBrowser extends ManagedObject {
  datastore?: Datastore[];
  supportedType?: FileQuery[];
  constructor(
    public connection: Connection,
    init?: Partial<HostDatastoreBrowser>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async deleteFile(args: {
    datastorePath: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      datastorePath: string
    } & { _this: ObjectReference }, void>(
      "DeleteFile", { _this: { attributes: { type: "HostDatastoreBrowser" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async searchSubFolders(args: {
    datastorePath: string;
    searchSpec?: HostDatastoreBrowserSearchSpec
  }): Promise<Task | undefined> {
    const result = await this.connection.exec<{
      datastorePath: string;
      searchSpec?: HostDatastoreBrowserSearchSpec
    } & { _this: ObjectReference }, Task | undefined>(
      "SearchDatastoreSubFolders_Task", { _this: { attributes: { type: "HostDatastoreBrowser" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async search(args: {
    datastorePath: string;
    searchSpec?: HostDatastoreBrowserSearchSpec
  }): Promise<Task> {
    const result = await this.connection.exec<{
      datastorePath: string;
      searchSpec?: HostDatastoreBrowserSearchSpec
    } & { _this: ObjectReference }, Task>(
      "SearchDatastore_Task", { _this: { attributes: { type: "HostDatastoreBrowser" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  };
}
export class HostDateTimeSystem extends ManagedObject {
  dateTimeInfo!: HostDateTimeInfo;
  constructor(
    public connection: Connection,
    init?: Partial<HostDateTimeSystem>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async queryAvailableTimeZones(): Promise<HostDateTimeSystemTimeZone[] | undefined> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, HostDateTimeSystemTimeZone[] | undefined>(
      "QueryAvailableTimeZones", { _this: { attributes: { type: "HostDateTimeSystem" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "HostDateTimeSystemTimeZone[]");
  }
  async queryDateTime(): Promise<Date> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, Date>(
      "QueryDateTime", { _this: { attributes: { type: "HostDateTimeSystem" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Date");
  }
  async refresh(): Promise<void> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, void>(
      "RefreshDateTimeSystem", { _this: { attributes: { type: "HostDateTimeSystem" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async updateDateTime(args: {
    dateTime: Date
  }): Promise<void> {
    const result = await this.connection.exec<{
      dateTime: Date
    } & { _this: ObjectReference }, void>(
      "UpdateDateTime", { _this: { attributes: { type: "HostDateTimeSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async updateConfig(args: {
    config: HostDateTimeConfig
  }): Promise<void> {
    const result = await this.connection.exec<{
      config: HostDateTimeConfig
    } & { _this: ObjectReference }, void>(
      "UpdateDateTimeConfig", { _this: { attributes: { type: "HostDateTimeSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  };
}
export class HostDirectoryStore extends HostAuthenticationStore {
  
  constructor(
    public connection: Connection,
    init?: Partial<HostDirectoryStore>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  
}
export class HostEsxAgentHostManager extends ManagedObject {
  configInfo!: HostEsxAgentHostManagerConfigInfo;
  constructor(
    public connection: Connection,
    init?: Partial<HostEsxAgentHostManager>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async updateConfig(args: {
    configInfo: HostEsxAgentHostManagerConfigInfo
  }): Promise<void> {
    const result = await this.connection.exec<{
      configInfo: HostEsxAgentHostManagerConfigInfo
    } & { _this: ObjectReference }, void>(
      "EsxAgentHostManagerUpdateConfig", { _this: { attributes: { type: "HostEsxAgentHostManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  };
}
export class HostFirmwareSystem extends ManagedObject {
  
  constructor(
    public connection: Connection,
    init?: Partial<HostFirmwareSystem>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async backupConfiguration(): Promise<string> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, string>(
      "BackupFirmwareConfiguration", { _this: { attributes: { type: "HostFirmwareSystem" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "string");
  }
  async queryConfigUploadURL(): Promise<string> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, string>(
      "QueryFirmwareConfigUploadURL", { _this: { attributes: { type: "HostFirmwareSystem" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "string");
  }
  async resetToFactoryDefaults(): Promise<void> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, void>(
      "ResetFirmwareToFactoryDefaults", { _this: { attributes: { type: "HostFirmwareSystem" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async restoreConfiguration(args: {
    force: boolean
  }): Promise<void> {
    const result = await this.connection.exec<{
      force: boolean
    } & { _this: ObjectReference }, void>(
      "RestoreFirmwareConfiguration", { _this: { attributes: { type: "HostFirmwareSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  };
}
export class HostGraphicsManager extends ExtensibleManagedObject {
  graphicsInfo?: HostGraphicsInfo[];
  graphicsConfig?: HostGraphicsConfig;
  sharedPassthruGpuTypes?: string[];
  sharedGpuCapabilities?: HostSharedGpuCapabilities[];
  constructor(
    public connection: Connection,
    init?: Partial<HostGraphicsManager>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async isSharedGraphicsActive(): Promise<boolean> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, boolean>(
      "IsSharedGraphicsActive", { _this: { attributes: { type: "HostGraphicsManager" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "boolean");
  }
  async refresh(): Promise<void> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, void>(
      "RefreshGraphicsManager", { _this: { attributes: { type: "HostGraphicsManager" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async updateGraphicsConfig(args: {
    config: HostGraphicsConfig
  }): Promise<void> {
    const result = await this.connection.exec<{
      config: HostGraphicsConfig
    } & { _this: ObjectReference }, void>(
      "UpdateGraphicsConfig", { _this: { attributes: { type: "HostGraphicsManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  };
}
export class HostHealthStatusSystem extends ManagedObject {
  runtime!: HealthSystemRuntime;
  constructor(
    public connection: Connection,
    init?: Partial<HostHealthStatusSystem>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async clearSystemEventLog(): Promise<void> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, void>(
      "ClearSystemEventLog", { _this: { attributes: { type: "HostHealthStatusSystem" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async FetchSystemEventLog(): Promise<SystemEventInfo[] | undefined> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, SystemEventInfo[] | undefined>(
      "FetchSystemEventLog", { _this: { attributes: { type: "HostHealthStatusSystem" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "SystemEventInfo[]");
  }
  async refresh(): Promise<void> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, void>(
      "RefreshHealthStatusSystem", { _this: { attributes: { type: "HostHealthStatusSystem" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async resetSystemHealthInfo(): Promise<void> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, void>(
      "ResetSystemHealthInfo", { _this: { attributes: { type: "HostHealthStatusSystem" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  };
}
export class HostAccessManager extends ManagedObject {
  lockdownMode!: HostLockdownMode;
  constructor(
    public connection: Connection,
    init?: Partial<HostAccessManager>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async changeAccessMode(args: {
    principal: string;
    isGroup: boolean;
    accessMode: HostAccessMode
  }): Promise<void> {
    const result = await this.connection.exec<{
      principal: string;
      isGroup: boolean;
      accessMode: HostAccessMode
    } & { _this: ObjectReference }, void>(
      "ChangeAccessMode", { _this: { attributes: { type: "HostAccessManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async changeLockdownMode(args: {
    mode: HostLockdownMode
  }): Promise<void> {
    const result = await this.connection.exec<{
      mode: HostLockdownMode
    } & { _this: ObjectReference }, void>(
      "ChangeLockdownMode", { _this: { attributes: { type: "HostAccessManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async queryLockdownExceptions(): Promise<string[] | undefined> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, string[] | undefined>(
      "QueryLockdownExceptions", { _this: { attributes: { type: "HostAccessManager" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "string[]");
  }
  async querySystemUsers(): Promise<string[] | undefined> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, string[] | undefined>(
      "QuerySystemUsers", { _this: { attributes: { type: "HostAccessManager" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "string[]");
  }
  async retrieveAccessEntries(): Promise<HostAccessControlEntry[] | undefined> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, HostAccessControlEntry[] | undefined>(
      "RetrieveHostAccessControlEntries", { _this: { attributes: { type: "HostAccessManager" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "HostAccessControlEntry[]");
  }
  async updateLockdownExceptions(args: {
    users?: string[]
  }): Promise<void> {
    const result = await this.connection.exec<{
      users?: string[]
    } & { _this: ObjectReference }, void>(
      "UpdateLockdownExceptions", { _this: { attributes: { type: "HostAccessManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async updateSystemUsers(args: {
    users?: string[]
  }): Promise<void> {
    const result = await this.connection.exec<{
      users?: string[]
    } & { _this: ObjectReference }, void>(
      "UpdateSystemUsers", { _this: { attributes: { type: "HostAccessManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  };
}
export class HostImageConfigManager extends ManagedObject {
  
  constructor(
    public connection: Connection,
    init?: Partial<HostImageConfigManager>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async queryHostAcceptanceLevel(): Promise<string> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, string>(
      "HostImageConfigGetAcceptance", { _this: { attributes: { type: "HostImageConfigManager" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "string");
  }
  async queryHostImageProfile(): Promise<HostImageProfileSummary> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, HostImageProfileSummary>(
      "HostImageConfigGetProfile", { _this: { attributes: { type: "HostImageConfigManager" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "HostImageProfileSummary");
  }
  async updateAcceptanceLevel(args: {
    newAcceptanceLevel: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      newAcceptanceLevel: string
    } & { _this: ObjectReference }, void>(
      "UpdateHostImageAcceptanceLevel", { _this: { attributes: { type: "HostImageConfigManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async fetchSoftwarePackages(): Promise<SoftwarePackage[] | undefined> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, SoftwarePackage[] | undefined>(
      "fetchSoftwarePackages", { _this: { attributes: { type: "HostImageConfigManager" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "SoftwarePackage[]");
  }
  async installDate(): Promise<Date> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, Date>(
      "installDate", { _this: { attributes: { type: "HostImageConfigManager" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Date");
  };
}
export class IscsiManager extends ManagedObject {
  
  constructor(
    public connection: Connection,
    init?: Partial<IscsiManager>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async bindVnic(args: {
    iScsiHbaName: string;
    vnicDevice: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      iScsiHbaName: string;
      vnicDevice: string
    } & { _this: ObjectReference }, void>(
      "BindVnic", { _this: { attributes: { type: "IscsiManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async queryBoundVnics(args: {
    iScsiHbaName: string
  }): Promise<IscsiPortInfo[] | undefined> {
    const result = await this.connection.exec<{
      iScsiHbaName: string
    } & { _this: ObjectReference }, IscsiPortInfo[] | undefined>(
      "QueryBoundVnics", { _this: { attributes: { type: "IscsiManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "IscsiPortInfo[]");
  }
  async queryCandidateNics(args: {
    iScsiHbaName: string
  }): Promise<IscsiPortInfo[] | undefined> {
    const result = await this.connection.exec<{
      iScsiHbaName: string
    } & { _this: ObjectReference }, IscsiPortInfo[] | undefined>(
      "QueryCandidateNics", { _this: { attributes: { type: "IscsiManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "IscsiPortInfo[]");
  }
  async queryMigrationDependencies(args: {
    pnicDevice: string[]
  }): Promise<IscsiMigrationDependency> {
    const result = await this.connection.exec<{
      pnicDevice: string[]
    } & { _this: ObjectReference }, IscsiMigrationDependency>(
      "QueryMigrationDependencies", { _this: { attributes: { type: "IscsiManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "IscsiMigrationDependency");
  }
  async queryPnicStatus(args: {
    pnicDevice: string
  }): Promise<IscsiStatus> {
    const result = await this.connection.exec<{
      pnicDevice: string
    } & { _this: ObjectReference }, IscsiStatus>(
      "QueryPnicStatus", { _this: { attributes: { type: "IscsiManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "IscsiStatus");
  }
  async queryVnicStatus(args: {
    vnicDevice: string
  }): Promise<IscsiStatus> {
    const result = await this.connection.exec<{
      vnicDevice: string
    } & { _this: ObjectReference }, IscsiStatus>(
      "QueryVnicStatus", { _this: { attributes: { type: "IscsiManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "IscsiStatus");
  }
  async unbindVnic(args: {
    iScsiHbaName: string;
    vnicDevice: string;
    force: boolean
  }): Promise<void> {
    const result = await this.connection.exec<{
      iScsiHbaName: string;
      vnicDevice: string;
      force: boolean
    } & { _this: ObjectReference }, void>(
      "UnbindVnic", { _this: { attributes: { type: "IscsiManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  };
}
export class HostKernelModuleSystem extends ManagedObject {
  
  constructor(
    public connection: Connection,
    init?: Partial<HostKernelModuleSystem>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async queryConfiguredModuleOptionString(args: {
    name: string
  }): Promise<string> {
    const result = await this.connection.exec<{
      name: string
    } & { _this: ObjectReference }, string>(
      "QueryConfiguredModuleOptionString", { _this: { attributes: { type: "HostKernelModuleSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "string");
  }
  async queryModules(): Promise<KernelModuleInfo[] | undefined> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, KernelModuleInfo[] | undefined>(
      "QueryModules", { _this: { attributes: { type: "HostKernelModuleSystem" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "KernelModuleInfo[]");
  }
  async updateModuleOptionString(args: {
    name: string;
    options: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      name: string;
      options: string
    } & { _this: ObjectReference }, void>(
      "UpdateModuleOptionString", { _this: { attributes: { type: "HostKernelModuleSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  };
}
export class HostLocalAccountManager extends ManagedObject {
  
  constructor(
    public connection: Connection,
    init?: Partial<HostLocalAccountManager>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async assignUserToGroup(args: {
    user: string;
    group: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      user: string;
      group: string
    } & { _this: ObjectReference }, void>(
      "AssignUserToGroup", { _this: { attributes: { type: "HostLocalAccountManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async changePassword(args: {
    user: string;
    oldPassword: string;
    newPassword: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      user: string;
      oldPassword: string;
      newPassword: string
    } & { _this: ObjectReference }, void>(
      "ChangePassword", { _this: { attributes: { type: "HostLocalAccountManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async createGroup(args: {
    group: HostAccountSpec
  }): Promise<void> {
    const result = await this.connection.exec<{
      group: HostAccountSpec
    } & { _this: ObjectReference }, void>(
      "CreateGroup", { _this: { attributes: { type: "HostLocalAccountManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async createUser(args: {
    user: HostAccountSpec
  }): Promise<void> {
    const result = await this.connection.exec<{
      user: HostAccountSpec
    } & { _this: ObjectReference }, void>(
      "CreateUser", { _this: { attributes: { type: "HostLocalAccountManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async removeGroup(args: {
    groupName: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      groupName: string
    } & { _this: ObjectReference }, void>(
      "RemoveGroup", { _this: { attributes: { type: "HostLocalAccountManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async removeUser(args: {
    userName: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      userName: string
    } & { _this: ObjectReference }, void>(
      "RemoveUser", { _this: { attributes: { type: "HostLocalAccountManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async unassignUserFromGroup(args: {
    user: string;
    group: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      user: string;
      group: string
    } & { _this: ObjectReference }, void>(
      "UnassignUserFromGroup", { _this: { attributes: { type: "HostLocalAccountManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async updateUser(args: {
    user: HostAccountSpec
  }): Promise<void> {
    const result = await this.connection.exec<{
      user: HostAccountSpec
    } & { _this: ObjectReference }, void>(
      "UpdateUser", { _this: { attributes: { type: "HostLocalAccountManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  };
}
export class HostLocalAuthentication extends HostAuthenticationStore {
  
  constructor(
    public connection: Connection,
    init?: Partial<HostLocalAuthentication>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  
}
export class HostMemorySystem extends ExtensibleManagedObject {
  consoleReservationInfo?: ServiceConsoleReservationInfo;
  virtualMachineReservationInfo?: VirtualMachineMemoryReservationInfo;
  constructor(
    public connection: Connection,
    init?: Partial<HostMemorySystem>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async reconfigureServiceConsoleReservation(args: {
    cfgBytes: number
  }): Promise<void> {
    const result = await this.connection.exec<{
      cfgBytes: number
    } & { _this: ObjectReference }, void>(
      "ReconfigureServiceConsoleReservation", { _this: { attributes: { type: "HostMemorySystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async reconfigureVirtualMachineReservation(args: {
    spec: VirtualMachineMemoryReservationSpec
  }): Promise<void> {
    const result = await this.connection.exec<{
      spec: VirtualMachineMemoryReservationSpec
    } & { _this: ObjectReference }, void>(
      "ReconfigureVirtualMachineReservation", { _this: { attributes: { type: "HostMemorySystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  };
}
export class MessageBusProxy extends ManagedObject {
  
  constructor(
    public connection: Connection,
    init?: Partial<MessageBusProxy>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  
}
export class HostNvdimmSystem extends ManagedObject {
  nvdimmSystemInfo!: NvdimmSystemInfo;
  constructor(
    public connection: Connection,
    init?: Partial<HostNvdimmSystem>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async createNamespace(args: {
    createSpec: NvdimmNamespaceCreateSpec
  }): Promise<Task> {
    const result = await this.connection.exec<{
      createSpec: NvdimmNamespaceCreateSpec
    } & { _this: ObjectReference }, Task>(
      "CreateNvdimmNamespace_Task", { _this: { attributes: { type: "HostNvdimmSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async createPMemNamespace(args: {
    createSpec: NvdimmPMemNamespaceCreateSpec
  }): Promise<Task> {
    const result = await this.connection.exec<{
      createSpec: NvdimmPMemNamespaceCreateSpec
    } & { _this: ObjectReference }, Task>(
      "CreateNvdimmPMemNamespace_Task", { _this: { attributes: { type: "HostNvdimmSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async deleteBlockNamespaces(): Promise<Task> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, Task>(
      "DeleteNvdimmBlockNamespaces_Task", { _this: { attributes: { type: "HostNvdimmSystem" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async deleteNamespace(args: {
    deleteSpec: NvdimmNamespaceDeleteSpec
  }): Promise<Task> {
    const result = await this.connection.exec<{
      deleteSpec: NvdimmNamespaceDeleteSpec
    } & { _this: ObjectReference }, Task>(
      "DeleteNvdimmNamespace_Task", { _this: { attributes: { type: "HostNvdimmSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  };
}
export class HostPatchManager extends ManagedObject {
  
  constructor(
    public connection: Connection,
    init?: Partial<HostPatchManager>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async Check(args: {
    metaUrls?: string[];
    bundleUrls?: string[];
    spec?: HostPatchManagerPatchManagerOperationSpec
  }): Promise<Task> {
    const result = await this.connection.exec<{
      metaUrls?: string[];
      bundleUrls?: string[];
      spec?: HostPatchManagerPatchManagerOperationSpec
    } & { _this: ObjectReference }, Task>(
      "CheckHostPatch_Task", { _this: { attributes: { type: "HostPatchManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async InstallV2(args: {
    metaUrls?: string[];
    bundleUrls?: string[];
    vibUrls?: string[];
    spec?: HostPatchManagerPatchManagerOperationSpec
  }): Promise<Task> {
    const result = await this.connection.exec<{
      metaUrls?: string[];
      bundleUrls?: string[];
      vibUrls?: string[];
      spec?: HostPatchManagerPatchManagerOperationSpec
    } & { _this: ObjectReference }, Task>(
      "InstallHostPatchV2_Task", { _this: { attributes: { type: "HostPatchManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async Install(args: {
    repository: HostPatchManagerLocator;
    updateID: string;
    force?: boolean
  }): Promise<Task> {
    const result = await this.connection.exec<{
      repository: HostPatchManagerLocator;
      updateID: string;
      force?: boolean
    } & { _this: ObjectReference }, Task>(
      "InstallHostPatch_Task", { _this: { attributes: { type: "HostPatchManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async Query(args: {
    spec?: HostPatchManagerPatchManagerOperationSpec
  }): Promise<Task> {
    const result = await this.connection.exec<{
      spec?: HostPatchManagerPatchManagerOperationSpec
    } & { _this: ObjectReference }, Task>(
      "QueryHostPatch_Task", { _this: { attributes: { type: "HostPatchManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async ScanV2(args: {
    metaUrls?: string[];
    bundleUrls?: string[];
    spec?: HostPatchManagerPatchManagerOperationSpec
  }): Promise<Task | undefined> {
    const result = await this.connection.exec<{
      metaUrls?: string[];
      bundleUrls?: string[];
      spec?: HostPatchManagerPatchManagerOperationSpec
    } & { _this: ObjectReference }, Task | undefined>(
      "ScanHostPatchV2_Task", { _this: { attributes: { type: "HostPatchManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async Scan(args: {
    repository: HostPatchManagerLocator;
    updateID?: string[]
  }): Promise<Task | undefined> {
    const result = await this.connection.exec<{
      repository: HostPatchManagerLocator;
      updateID?: string[]
    } & { _this: ObjectReference }, Task | undefined>(
      "ScanHostPatch_Task", { _this: { attributes: { type: "HostPatchManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async Stage(args: {
    metaUrls?: string[];
    bundleUrls?: string[];
    vibUrls?: string[];
    spec?: HostPatchManagerPatchManagerOperationSpec
  }): Promise<Task> {
    const result = await this.connection.exec<{
      metaUrls?: string[];
      bundleUrls?: string[];
      vibUrls?: string[];
      spec?: HostPatchManagerPatchManagerOperationSpec
    } & { _this: ObjectReference }, Task>(
      "StageHostPatch_Task", { _this: { attributes: { type: "HostPatchManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async Uninstall(args: {
    bulletinIds?: string[];
    spec?: HostPatchManagerPatchManagerOperationSpec
  }): Promise<Task> {
    const result = await this.connection.exec<{
      bulletinIds?: string[];
      spec?: HostPatchManagerPatchManagerOperationSpec
    } & { _this: ObjectReference }, Task>(
      "UninstallHostPatch_Task", { _this: { attributes: { type: "HostPatchManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  };
}
export class HostPciPassthruSystem extends ExtensibleManagedObject {
  pciPassthruInfo!: HostPciPassthruInfo[];
  sriovDevicePoolInfo?: HostSriovDevicePoolInfo[];
  constructor(
    public connection: Connection,
    init?: Partial<HostPciPassthruSystem>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async refresh(): Promise<void> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, void>(
      "Refresh", { _this: { attributes: { type: "HostPciPassthruSystem" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async updatePassthruConfig(args: {
    config: HostPciPassthruConfig[]
  }): Promise<void> {
    const result = await this.connection.exec<{
      config: HostPciPassthruConfig[]
    } & { _this: ObjectReference }, void>(
      "UpdatePassthruConfig", { _this: { attributes: { type: "HostPciPassthruSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  };
}
export class HostPowerSystem extends ManagedObject {
  capability!: PowerSystemCapability;
  info!: PowerSystemInfo;
  constructor(
    public connection: Connection,
    init?: Partial<HostPowerSystem>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async configurePolicy(args: {
    key: number
  }): Promise<void> {
    const result = await this.connection.exec<{
      key: number
    } & { _this: ObjectReference }, void>(
      "ConfigurePowerPolicy", { _this: { attributes: { type: "HostPowerSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  };
}
export class HostServiceSystem extends ExtensibleManagedObject {
  serviceInfo!: HostServiceInfo;
  constructor(
    public connection: Connection,
    init?: Partial<HostServiceSystem>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async refresh(): Promise<void> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, void>(
      "RefreshServices", { _this: { attributes: { type: "HostServiceSystem" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async restart(args: {
    id: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      id: string
    } & { _this: ObjectReference }, void>(
      "RestartService", { _this: { attributes: { type: "HostServiceSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async start(args: {
    id: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      id: string
    } & { _this: ObjectReference }, void>(
      "StartService", { _this: { attributes: { type: "HostServiceSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async stop(args: {
    id: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      id: string
    } & { _this: ObjectReference }, void>(
      "StopService", { _this: { attributes: { type: "HostServiceSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async uninstall(args: {
    id: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      id: string
    } & { _this: ObjectReference }, void>(
      "UninstallService", { _this: { attributes: { type: "HostServiceSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async updatePolicy(args: {
    id: string;
    policy: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      id: string;
      policy: string
    } & { _this: ObjectReference }, void>(
      "UpdateServicePolicy", { _this: { attributes: { type: "HostServiceSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  };
}
export class HostSnmpSystem extends ManagedObject {
  configuration!: HostSnmpConfigSpec;
  limits!: HostSnmpSystemAgentLimits;
  constructor(
    public connection: Connection,
    init?: Partial<HostSnmpSystem>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async reconfigureSnmpAgent(args: {
    spec: HostSnmpConfigSpec
  }): Promise<void> {
    const result = await this.connection.exec<{
      spec: HostSnmpConfigSpec
    } & { _this: ObjectReference }, void>(
      "ReconfigureSnmpAgent", { _this: { attributes: { type: "HostSnmpSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async sendTestNotification(): Promise<void> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, void>(
      "SendTestNotification", { _this: { attributes: { type: "HostSnmpSystem" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  };
}
export class HostVMotionSystem extends ExtensibleManagedObject {
  netConfig?: HostVMotionNetConfig;
  ipConfig?: HostIpConfig;
  constructor(
    public connection: Connection,
    init?: Partial<HostVMotionSystem>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async deselectVnic(): Promise<void> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, void>(
      "DeselectVnic", { _this: { attributes: { type: "HostVMotionSystem" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async selectVnic(args: {
    device: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      device: string
    } & { _this: ObjectReference }, void>(
      "SelectVnic", { _this: { attributes: { type: "HostVMotionSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async updateIpConfig(args: {
    ipConfig: HostIpConfig
  }): Promise<void> {
    const result = await this.connection.exec<{
      ipConfig: HostIpConfig
    } & { _this: ObjectReference }, void>(
      "UpdateIpConfig", { _this: { attributes: { type: "HostVMotionSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  };
}
export class HostVirtualNicManager extends ExtensibleManagedObject {
  info!: HostVirtualNicManagerInfo;
  constructor(
    public connection: Connection,
    init?: Partial<HostVirtualNicManager>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async deselectVnic(args: {
    nicType: string;
    device: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      nicType: string;
      device: string
    } & { _this: ObjectReference }, void>(
      "DeselectVnicForNicType", { _this: { attributes: { type: "HostVirtualNicManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async queryNetConfig(args: {
    nicType: string
  }): Promise<VirtualNicManagerNetConfig | undefined> {
    const result = await this.connection.exec<{
      nicType: string
    } & { _this: ObjectReference }, VirtualNicManagerNetConfig | undefined>(
      "QueryNetConfig", { _this: { attributes: { type: "HostVirtualNicManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "VirtualNicManagerNetConfig");
  }
  async selectVnic(args: {
    nicType: string;
    device: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      nicType: string;
      device: string
    } & { _this: ObjectReference }, void>(
      "SelectVnicForNicType", { _this: { attributes: { type: "HostVirtualNicManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  };
}
export class HostVsanInternalSystem extends ManagedObject {
  
  constructor(
    public connection: Connection,
    init?: Partial<HostVsanInternalSystem>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async abdicateDomOwnership(args: {
    uuids: string[]
  }): Promise<string[] | undefined> {
    const result = await this.connection.exec<{
      uuids: string[]
    } & { _this: ObjectReference }, string[] | undefined>(
      "AbdicateDomOwnership", { _this: { attributes: { type: "HostVsanInternalSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "string[]");
  }
  async canProvisionObjects(args: {
    npbs: VsanNewPolicyBatch[];
    ignoreSatisfiability?: boolean
  }): Promise<VsanPolicySatisfiability[]> {
    const result = await this.connection.exec<{
      npbs: VsanNewPolicyBatch[];
      ignoreSatisfiability?: boolean
    } & { _this: ObjectReference }, VsanPolicySatisfiability[]>(
      "CanProvisionObjects", { _this: { attributes: { type: "HostVsanInternalSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "VsanPolicySatisfiability[]");
  }
  async deleteVsanObjects(args: {
    uuids: string[];
    force?: boolean
  }): Promise<HostVsanInternalSystemDeleteVsanObjectsResult[]> {
    const result = await this.connection.exec<{
      uuids: string[];
      force?: boolean
    } & { _this: ObjectReference }, HostVsanInternalSystemDeleteVsanObjectsResult[]>(
      "DeleteVsanObjects", { _this: { attributes: { type: "HostVsanInternalSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "HostVsanInternalSystemDeleteVsanObjectsResult[]");
  }
  async getVsanObjExtAttrs(args: {
    uuids: string[]
  }): Promise<string> {
    const result = await this.connection.exec<{
      uuids: string[]
    } & { _this: ObjectReference }, string>(
      "GetVsanObjExtAttrs", { _this: { attributes: { type: "HostVsanInternalSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "string");
  }
  async queryCmmds(args: {
    queries: HostVsanInternalSystemCmmdsQuery[]
  }): Promise<string> {
    const result = await this.connection.exec<{
      queries: HostVsanInternalSystemCmmdsQuery[]
    } & { _this: ObjectReference }, string>(
      "QueryCmmds", { _this: { attributes: { type: "HostVsanInternalSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "string");
  }
  async queryObjectsOnPhysicalVsanDisk(args: {
    disks: string[]
  }): Promise<string> {
    const result = await this.connection.exec<{
      disks: string[]
    } & { _this: ObjectReference }, string>(
      "QueryObjectsOnPhysicalVsanDisk", { _this: { attributes: { type: "HostVsanInternalSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "string");
  }
  async queryPhysicalVsanDisks(args: {
    props?: string[]
  }): Promise<string> {
    const result = await this.connection.exec<{
      props?: string[]
    } & { _this: ObjectReference }, string>(
      "QueryPhysicalVsanDisks", { _this: { attributes: { type: "HostVsanInternalSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "string");
  }
  async querySyncingVsanObjects(args: {
    uuids?: string[]
  }): Promise<string> {
    const result = await this.connection.exec<{
      uuids?: string[]
    } & { _this: ObjectReference }, string>(
      "QuerySyncingVsanObjects", { _this: { attributes: { type: "HostVsanInternalSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "string");
  }
  async queryVsanObjectUuidsByFilter(args: {
    uuids?: string[];
    limit?: number;
    version?: number
  }): Promise<string[] | undefined> {
    const result = await this.connection.exec<{
      uuids?: string[];
      limit?: number;
      version?: number
    } & { _this: ObjectReference }, string[] | undefined>(
      "QueryVsanObjectUuidsByFilter", { _this: { attributes: { type: "HostVsanInternalSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "string[]");
  }
  async queryVsanObjects(args: {
    uuids?: string[]
  }): Promise<string> {
    const result = await this.connection.exec<{
      uuids?: string[]
    } & { _this: ObjectReference }, string>(
      "QueryVsanObjects", { _this: { attributes: { type: "HostVsanInternalSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "string");
  }
  async queryVsanStatistics(args: {
    labels: string[]
  }): Promise<string> {
    const result = await this.connection.exec<{
      labels: string[]
    } & { _this: ObjectReference }, string>(
      "QueryVsanStatistics", { _this: { attributes: { type: "HostVsanInternalSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "string");
  }
  async reconfigurationSatisfiable(args: {
    pcbs: VsanPolicyChangeBatch[];
    ignoreSatisfiability?: boolean
  }): Promise<VsanPolicySatisfiability[]> {
    const result = await this.connection.exec<{
      pcbs: VsanPolicyChangeBatch[];
      ignoreSatisfiability?: boolean
    } & { _this: ObjectReference }, VsanPolicySatisfiability[]>(
      "ReconfigurationSatisfiable", { _this: { attributes: { type: "HostVsanInternalSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "VsanPolicySatisfiability[]");
  }
  async reconfigureDomObject(args: {
    uuid: string;
    policy: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      uuid: string;
      policy: string
    } & { _this: ObjectReference }, void>(
      "ReconfigureDomObject", { _this: { attributes: { type: "HostVsanInternalSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async runVsanPhysicalDiskDiagnostics(args: {
    disks?: string[]
  }): Promise<HostVsanInternalSystemVsanPhysicalDiskDiagnosticsResult[]> {
    const result = await this.connection.exec<{
      disks?: string[]
    } & { _this: ObjectReference }, HostVsanInternalSystemVsanPhysicalDiskDiagnosticsResult[]>(
      "RunVsanPhysicalDiskDiagnostics", { _this: { attributes: { type: "HostVsanInternalSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "HostVsanInternalSystemVsanPhysicalDiskDiagnosticsResult[]");
  }
  async upgradeVsanObjects(args: {
    uuids: string[];
    newVersion: number
  }): Promise<HostVsanInternalSystemVsanObjectOperationResult[] | undefined> {
    const result = await this.connection.exec<{
      uuids: string[];
      newVersion: number
    } & { _this: ObjectReference }, HostVsanInternalSystemVsanObjectOperationResult[] | undefined>(
      "UpgradeVsanObjects", { _this: { attributes: { type: "HostVsanInternalSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "HostVsanInternalSystemVsanObjectOperationResult[]");
  };
}
export class HostVsanSystem extends ManagedObject {
  config!: VsanHostConfigInfo;
  constructor(
    public connection: Connection,
    init?: Partial<HostVsanSystem>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async addDisks(args: {
    disk: HostScsiDisk[]
  }): Promise<Task | undefined> {
    const result = await this.connection.exec<{
      disk: HostScsiDisk[]
    } & { _this: ObjectReference }, Task | undefined>(
      "AddDisks_Task", { _this: { attributes: { type: "HostVsanSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async evacuateNode(args: {
    maintenanceSpec: HostMaintenanceSpec;
    timeout: number
  }): Promise<Task> {
    const result = await this.connection.exec<{
      maintenanceSpec: HostMaintenanceSpec;
      timeout: number
    } & { _this: ObjectReference }, Task>(
      "EvacuateVsanNode_Task", { _this: { attributes: { type: "HostVsanSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async initializeDisks(args: {
    mapping: VsanHostDiskMapping[]
  }): Promise<Task | undefined> {
    const result = await this.connection.exec<{
      mapping: VsanHostDiskMapping[]
    } & { _this: ObjectReference }, Task | undefined>(
      "InitializeDisks_Task", { _this: { attributes: { type: "HostVsanSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async queryDisksForVsan(args: {
    canonicalName?: string[]
  }): Promise<VsanHostDiskResult[] | undefined> {
    const result = await this.connection.exec<{
      canonicalName?: string[]
    } & { _this: ObjectReference }, VsanHostDiskResult[] | undefined>(
      "QueryDisksForVsan", { _this: { attributes: { type: "HostVsanSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "VsanHostDiskResult[]");
  }
  async queryHostStatus(): Promise<VsanHostClusterStatus> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, VsanHostClusterStatus>(
      "QueryHostStatus", { _this: { attributes: { type: "HostVsanSystem" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "VsanHostClusterStatus");
  }
  async recommissionNode(): Promise<Task> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, Task>(
      "RecommissionVsanNode_Task", { _this: { attributes: { type: "HostVsanSystem" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async removeDiskMapping(args: {
    mapping: VsanHostDiskMapping[];
    maintenanceSpec?: HostMaintenanceSpec;
    timeout?: number
  }): Promise<Task | undefined> {
    const result = await this.connection.exec<{
      mapping: VsanHostDiskMapping[];
      maintenanceSpec?: HostMaintenanceSpec;
      timeout?: number
    } & { _this: ObjectReference }, Task | undefined>(
      "RemoveDiskMapping_Task", { _this: { attributes: { type: "HostVsanSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async removeDisk(args: {
    disk: HostScsiDisk[];
    maintenanceSpec?: HostMaintenanceSpec;
    timeout?: number
  }): Promise<Task | undefined> {
    const result = await this.connection.exec<{
      disk: HostScsiDisk[];
      maintenanceSpec?: HostMaintenanceSpec;
      timeout?: number
    } & { _this: ObjectReference }, Task | undefined>(
      "RemoveDisk_Task", { _this: { attributes: { type: "HostVsanSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async unmountDiskMapping(args: {
    mapping: VsanHostDiskMapping[]
  }): Promise<Task> {
    const result = await this.connection.exec<{
      mapping: VsanHostDiskMapping[]
    } & { _this: ObjectReference }, Task>(
      "UnmountDiskMapping_Task", { _this: { attributes: { type: "HostVsanSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async update(args: {
    config: VsanHostConfigInfo
  }): Promise<Task> {
    const result = await this.connection.exec<{
      config: VsanHostConfigInfo
    } & { _this: ObjectReference }, Task>(
      "UpdateVsan_Task", { _this: { attributes: { type: "HostVsanSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  };
}
export class OptionManager extends ManagedObject {
  supportedOption?: OptionDef[];
  setting?: OptionValue[];
  constructor(
    public connection: Connection,
    init?: Partial<OptionManager>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async queryView(args: {
    name?: string
  }): Promise<OptionValue[] | undefined> {
    const result = await this.connection.exec<{
      name?: string
    } & { _this: ObjectReference }, OptionValue[] | undefined>(
      "QueryOptions", { _this: { attributes: { type: "OptionManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "OptionValue[]");
  }
  async updateValues(args: {
    changedValue: OptionValue[]
  }): Promise<void> {
    const result = await this.connection.exec<{
      changedValue: OptionValue[]
    } & { _this: ObjectReference }, void>(
      "UpdateOptions", { _this: { attributes: { type: "OptionManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  };
}
export class ProfileComplianceManager extends ManagedObject {
  
  constructor(
    public connection: Connection,
    init?: Partial<ProfileComplianceManager>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async checkCompliance(args: {
    profile?: Profile[];
    entity?: ManagedEntity[]
  }): Promise<Task> {
    const result = await this.connection.exec<{
      profile?: Profile[];
      entity?: ManagedEntity[]
    } & { _this: ObjectReference }, Task>(
      "CheckCompliance_Task", { _this: { attributes: { type: "ProfileComplianceManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async clearComplianceStatus(args: {
    profile?: Profile[];
    entity?: ManagedEntity[]
  }): Promise<void> {
    const result = await this.connection.exec<{
      profile?: Profile[];
      entity?: ManagedEntity[]
    } & { _this: ObjectReference }, void>(
      "ClearComplianceStatus", { _this: { attributes: { type: "ProfileComplianceManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async queryComplianceStatus(args: {
    profile?: Profile[];
    entity?: ManagedEntity[]
  }): Promise<ComplianceResult[] | undefined> {
    const result = await this.connection.exec<{
      profile?: Profile[];
      entity?: ManagedEntity[]
    } & { _this: ObjectReference }, ComplianceResult[] | undefined>(
      "QueryComplianceStatus", { _this: { attributes: { type: "ProfileComplianceManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "ComplianceResult[]");
  }
  async queryExpressionMetadata(args: {
    expressionName?: string[];
    profile?: Profile
  }): Promise<ProfileExpressionMetadata[] | undefined> {
    const result = await this.connection.exec<{
      expressionName?: string[];
      profile?: Profile
    } & { _this: ObjectReference }, ProfileExpressionMetadata[] | undefined>(
      "QueryExpressionMetadata", { _this: { attributes: { type: "ProfileComplianceManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "ProfileExpressionMetadata[]");
  };
}
export class Profile extends ManagedObject {
  config!: ProfileConfigInfo;
  description?: ProfileDescription;
  name!: string;
  createdTime!: Date;
  modifiedTime!: Date;
  entity?: ManagedEntity[];
  complianceStatus!: string;
  constructor(
    public connection: Connection,
    init?: Partial<Profile>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async associateEntities(args: {
    entity: ManagedEntity[]
  }): Promise<void> {
    const result = await this.connection.exec<{
      entity: ManagedEntity[]
    } & { _this: ObjectReference }, void>(
      "AssociateProfile", { _this: { attributes: { type: "Profile" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async checkCompliance(args: {
    entity?: ManagedEntity[]
  }): Promise<Task> {
    const result = await this.connection.exec<{
      entity?: ManagedEntity[]
    } & { _this: ObjectReference }, Task>(
      "CheckProfileCompliance_Task", { _this: { attributes: { type: "Profile" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async destroy(): Promise<void> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, void>(
      "DestroyProfile", { _this: { attributes: { type: "Profile" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async dissociateEntities(args: {
    entity?: ManagedEntity[]
  }): Promise<void> {
    const result = await this.connection.exec<{
      entity?: ManagedEntity[]
    } & { _this: ObjectReference }, void>(
      "DissociateProfile", { _this: { attributes: { type: "Profile" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async exportProfile(): Promise<string> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, string>(
      "ExportProfile", { _this: { attributes: { type: "Profile" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "string");
  }
  async retrieveDescription(): Promise<ProfileDescription | undefined> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, ProfileDescription | undefined>(
      "RetrieveDescription", { _this: { attributes: { type: "Profile" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "ProfileDescription");
  };
}
export class ProfileManager extends ManagedObject {
  profile?: Profile[];
  constructor(
    public connection: Connection,
    init?: Partial<ProfileManager>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async createProfile(args: {
    createSpec: ProfileCreateSpec
  }): Promise<Profile> {
    const result = await this.connection.exec<{
      createSpec: ProfileCreateSpec
    } & { _this: ObjectReference }, Profile>(
      "CreateProfile", { _this: { attributes: { type: "ProfileManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Profile");
  }
  async findAssociatedProfile(args: {
    entity: ManagedEntity
  }): Promise<Profile[] | undefined> {
    const result = await this.connection.exec<{
      entity: ManagedEntity
    } & { _this: ObjectReference }, Profile[] | undefined>(
      "FindAssociatedProfile", { _this: { attributes: { type: "ProfileManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Profile[]");
  }
  async queryPolicyMetadata(args: {
    policyName?: string[];
    profile?: Profile
  }): Promise<ProfilePolicyMetadata[] | undefined> {
    const result = await this.connection.exec<{
      policyName?: string[];
      profile?: Profile
    } & { _this: ObjectReference }, ProfilePolicyMetadata[] | undefined>(
      "QueryPolicyMetadata", { _this: { attributes: { type: "ProfileManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "ProfilePolicyMetadata[]");
  };
}
export class ClusterProfile extends Profile {
  
  constructor(
    public connection: Connection,
    init?: Partial<ClusterProfile>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async update(args: {
    config: ClusterProfileConfigSpec
  }): Promise<void> {
    const result = await this.connection.exec<{
      config: ClusterProfileConfigSpec
    } & { _this: ObjectReference }, void>(
      "UpdateClusterProfile", { _this: { attributes: { type: "ClusterProfile" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  };
}
export class ClusterProfileManager extends ProfileManager {
  
  constructor(
    public connection: Connection,
    init?: Partial<ClusterProfileManager>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  
}
export class HostSpecificationManager extends ManagedObject {
  
  constructor(
    public connection: Connection,
    init?: Partial<HostSpecificationManager>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async deleteHostSpecification(args: {
    host: HostSystem
  }): Promise<void> {
    const result = await this.connection.exec<{
      host: HostSystem
    } & { _this: ObjectReference }, void>(
      "DeleteHostSpecification", { _this: { attributes: { type: "HostSpecificationManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async deleteHostSubSpecification(args: {
    host: HostSystem;
    subSpecName: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      host: HostSystem;
      subSpecName: string
    } & { _this: ObjectReference }, void>(
      "DeleteHostSubSpecification", { _this: { attributes: { type: "HostSpecificationManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async getUpdatedHosts(args: {
    startChangeID?: string;
    endChangeID?: string
  }): Promise<HostSystem[] | undefined> {
    const result = await this.connection.exec<{
      startChangeID?: string;
      endChangeID?: string
    } & { _this: ObjectReference }, HostSystem[] | undefined>(
      "HostSpecGetUpdatedHosts", { _this: { attributes: { type: "HostSpecificationManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "HostSystem[]");
  }
  async retrieveHostSpecification(args: {
    host: HostSystem;
    fromHost: boolean
  }): Promise<HostSpecification> {
    const result = await this.connection.exec<{
      host: HostSystem;
      fromHost: boolean
    } & { _this: ObjectReference }, HostSpecification>(
      "RetrieveHostSpecification", { _this: { attributes: { type: "HostSpecificationManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "HostSpecification");
  }
  async updateHostSpecification(args: {
    host: HostSystem;
    hostSpec: HostSpecification
  }): Promise<void> {
    const result = await this.connection.exec<{
      host: HostSystem;
      hostSpec: HostSpecification
    } & { _this: ObjectReference }, void>(
      "UpdateHostSpecification", { _this: { attributes: { type: "HostSpecificationManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async updateHostSubSpecification(args: {
    host: HostSystem;
    hostSubSpec: HostSubSpecification
  }): Promise<void> {
    const result = await this.connection.exec<{
      host: HostSystem;
      hostSubSpec: HostSubSpecification
    } & { _this: ObjectReference }, void>(
      "UpdateHostSubSpecification", { _this: { attributes: { type: "HostSpecificationManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  };
}
export class ScheduledTask extends ExtensibleManagedObject {
  info!: ScheduledTaskInfo;
  constructor(
    public connection: Connection,
    init?: Partial<ScheduledTask>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async reconfigure(args: {
    spec: ScheduledTaskSpec
  }): Promise<void> {
    const result = await this.connection.exec<{
      spec: ScheduledTaskSpec
    } & { _this: ObjectReference }, void>(
      "ReconfigureScheduledTask", { _this: { attributes: { type: "ScheduledTask" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async remove(): Promise<void> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, void>(
      "RemoveScheduledTask", { _this: { attributes: { type: "ScheduledTask" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async run(): Promise<void> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, void>(
      "RunScheduledTask", { _this: { attributes: { type: "ScheduledTask" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  };
}
export class ScheduledTaskManager extends ManagedObject {
  scheduledTask?: ScheduledTask[];
  description!: ScheduledTaskDescription;
  constructor(
    public connection: Connection,
    init?: Partial<ScheduledTaskManager>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async createObjectScheduledTask(args: {
    obj: ManagedObject;
    spec: ScheduledTaskSpec
  }): Promise<ScheduledTask> {
    const result = await this.connection.exec<{
      obj: ManagedObject;
      spec: ScheduledTaskSpec
    } & { _this: ObjectReference }, ScheduledTask>(
      "CreateObjectScheduledTask", { _this: { attributes: { type: "ScheduledTaskManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "ScheduledTask");
  }
  async create(args: {
    entity: ManagedEntity;
    spec: ScheduledTaskSpec
  }): Promise<ScheduledTask> {
    const result = await this.connection.exec<{
      entity: ManagedEntity;
      spec: ScheduledTaskSpec
    } & { _this: ObjectReference }, ScheduledTask>(
      "CreateScheduledTask", { _this: { attributes: { type: "ScheduledTaskManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "ScheduledTask");
  }
  async retrieveEntityScheduledTask(args: {
    entity?: ManagedEntity
  }): Promise<ScheduledTask[] | undefined> {
    const result = await this.connection.exec<{
      entity?: ManagedEntity
    } & { _this: ObjectReference }, ScheduledTask[] | undefined>(
      "RetrieveEntityScheduledTask", { _this: { attributes: { type: "ScheduledTaskManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "ScheduledTask[]");
  }
  async retrieveObjectScheduledTask(args: {
    obj?: ManagedObject
  }): Promise<ScheduledTask[] | undefined> {
    const result = await this.connection.exec<{
      obj?: ManagedObject
    } & { _this: ObjectReference }, ScheduledTask[] | undefined>(
      "RetrieveObjectScheduledTask", { _this: { attributes: { type: "ScheduledTaskManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "ScheduledTask[]");
  };
}
export class TenantTenantManager extends ManagedObject {
  
  constructor(
    public connection: Connection,
    init?: Partial<TenantTenantManager>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async markServiceProviderEntities(args: {
    entity?: ManagedEntity[]
  }): Promise<void> {
    const result = await this.connection.exec<{
      entity?: ManagedEntity[]
    } & { _this: ObjectReference }, void>(
      "MarkServiceProviderEntities", { _this: { attributes: { type: "TenantTenantManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async retrieveServiceProviderEntities(): Promise<ManagedEntity[] | undefined> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, ManagedEntity[] | undefined>(
      "RetrieveServiceProviderEntities", { _this: { attributes: { type: "TenantTenantManager" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "ManagedEntity[]");
  }
  async unmarkServiceProviderEntities(args: {
    entity?: ManagedEntity[]
  }): Promise<void> {
    const result = await this.connection.exec<{
      entity?: ManagedEntity[]
    } & { _this: ObjectReference }, void>(
      "UnmarkServiceProviderEntities", { _this: { attributes: { type: "TenantTenantManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  };
}
export class FailoverClusterConfigurator extends ManagedObject {
  disabledConfigureMethod?: string[];
  constructor(
    public connection: Connection,
    init?: Partial<FailoverClusterConfigurator>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async configure(args: {
    configSpec: VchaClusterConfigSpec
  }): Promise<Task> {
    const result = await this.connection.exec<{
      configSpec: VchaClusterConfigSpec
    } & { _this: ObjectReference }, Task>(
      "configureVcha_Task", { _this: { attributes: { type: "FailoverClusterConfigurator" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async createPassiveNode(args: {
    passiveDeploymentSpec: PassiveNodeDeploymentSpec;
    sourceVcSpec: SourceNodeSpec
  }): Promise<Task> {
    const result = await this.connection.exec<{
      passiveDeploymentSpec: PassiveNodeDeploymentSpec;
      sourceVcSpec: SourceNodeSpec
    } & { _this: ObjectReference }, Task>(
      "createPassiveNode_Task", { _this: { attributes: { type: "FailoverClusterConfigurator" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async createWitnessNode(args: {
    witnessDeploymentSpec: NodeDeploymentSpec;
    sourceVcSpec: SourceNodeSpec
  }): Promise<Task> {
    const result = await this.connection.exec<{
      witnessDeploymentSpec: NodeDeploymentSpec;
      sourceVcSpec: SourceNodeSpec
    } & { _this: ObjectReference }, Task>(
      "createWitnessNode_Task", { _this: { attributes: { type: "FailoverClusterConfigurator" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async deploy(args: {
    deploymentSpec: VchaClusterDeploymentSpec
  }): Promise<Task> {
    const result = await this.connection.exec<{
      deploymentSpec: VchaClusterDeploymentSpec
    } & { _this: ObjectReference }, Task>(
      "deployVcha_Task", { _this: { attributes: { type: "FailoverClusterConfigurator" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async destroy(): Promise<Task> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, Task>(
      "destroyVcha_Task", { _this: { attributes: { type: "FailoverClusterConfigurator" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async getConfig(): Promise<VchaClusterConfigInfo> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, VchaClusterConfigInfo>(
      "getVchaConfig", { _this: { attributes: { type: "FailoverClusterConfigurator" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "VchaClusterConfigInfo");
  }
  async prepare(args: {
    networkSpec: VchaClusterNetworkSpec
  }): Promise<Task> {
    const result = await this.connection.exec<{
      networkSpec: VchaClusterNetworkSpec
    } & { _this: ObjectReference }, Task>(
      "prepareVcha_Task", { _this: { attributes: { type: "FailoverClusterConfigurator" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  };
}
export class FailoverClusterManager extends ManagedObject {
  disabledClusterMethod?: string[];
  constructor(
    public connection: Connection,
    init?: Partial<FailoverClusterManager>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async getClusterHealth(): Promise<VchaClusterHealth> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, VchaClusterHealth>(
      "GetVchaClusterHealth", { _this: { attributes: { type: "FailoverClusterManager" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "VchaClusterHealth");
  }
  async getClusterMode(): Promise<string> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, string>(
      "getClusterMode", { _this: { attributes: { type: "FailoverClusterManager" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "string");
  }
  async initiateFailover(args: {
    planned: boolean
  }): Promise<Task> {
    const result = await this.connection.exec<{
      planned: boolean
    } & { _this: ObjectReference }, Task>(
      "initiateFailover_Task", { _this: { attributes: { type: "FailoverClusterManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async setClusterMode(args: {
    mode: string
  }): Promise<Task> {
    const result = await this.connection.exec<{
      mode: string
    } & { _this: ObjectReference }, Task>(
      "setClusterMode_Task", { _this: { attributes: { type: "FailoverClusterManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  };
}
export class View extends ManagedObject {
  
  constructor(
    public connection: Connection,
    init?: Partial<View>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async destroy(): Promise<void> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, void>(
      "DestroyView", { _this: { attributes: { type: "View" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  };
}
export class ViewManager extends ManagedObject {
  viewList?: View[];
  constructor(
    public connection: Connection,
    init?: Partial<ViewManager>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async createContainerView(args: {
    container: ManagedEntity;
    type?: string[];
    recursive: boolean
  }): Promise<ContainerView> {
    const result = await this.connection.exec<{
      container: ManagedEntity;
      type?: string[];
      recursive: boolean
    } & { _this: ObjectReference }, ContainerView>(
      "CreateContainerView", { _this: { attributes: { type: "ViewManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "ContainerView");
  }
  async createInventoryView(): Promise<InventoryView> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, InventoryView>(
      "CreateInventoryView", { _this: { attributes: { type: "ViewManager" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "InventoryView");
  }
  async createListView(args: {
    obj?: ManagedObject[]
  }): Promise<ListView> {
    const result = await this.connection.exec<{
      obj?: ManagedObject[]
    } & { _this: ObjectReference }, ListView>(
      "CreateListView", { _this: { attributes: { type: "ViewManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "ListView");
  }
  async createListViewFromView(args: {
    view: View
  }): Promise<ListView> {
    const result = await this.connection.exec<{
      view: View
    } & { _this: ObjectReference }, ListView>(
      "CreateListViewFromView", { _this: { attributes: { type: "ViewManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "ListView");
  };
}
export class VirtualMachineGuestCustomizationManager extends ManagedObject {
  
  constructor(
    public connection: Connection,
    init?: Partial<VirtualMachineGuestCustomizationManager>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async abortCustomization(args: {
    vm: VirtualMachine;
    auth: GuestAuthentication
  }): Promise<Task> {
    const result = await this.connection.exec<{
      vm: VirtualMachine;
      auth: GuestAuthentication
    } & { _this: ObjectReference }, Task>(
      "AbortCustomization_Task", { _this: { attributes: { type: "VirtualMachineGuestCustomizationManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async customize(args: {
    vm: VirtualMachine;
    auth: GuestAuthentication;
    spec: CustomizationSpec;
    configParams?: OptionValue[]
  }): Promise<Task> {
    const result = await this.connection.exec<{
      vm: VirtualMachine;
      auth: GuestAuthentication;
      spec: CustomizationSpec;
      configParams?: OptionValue[]
    } & { _this: ObjectReference }, Task>(
      "CustomizeGuest_Task", { _this: { attributes: { type: "VirtualMachineGuestCustomizationManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async startNetwork(args: {
    vm: VirtualMachine;
    auth: GuestAuthentication
  }): Promise<Task> {
    const result = await this.connection.exec<{
      vm: VirtualMachine;
      auth: GuestAuthentication
    } & { _this: ObjectReference }, Task>(
      "StartGuestNetwork_Task", { _this: { attributes: { type: "VirtualMachineGuestCustomizationManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  };
}
export class VirtualMachineSnapshot extends ExtensibleManagedObject {
  config!: VirtualMachineConfigInfo;
  childSnapshot?: VirtualMachineSnapshot[];
  vm!: VirtualMachine;
  constructor(
    public connection: Connection,
    init?: Partial<VirtualMachineSnapshot>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async exportSnapshot(): Promise<HttpNfcLease> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, HttpNfcLease>(
      "ExportSnapshot", { _this: { attributes: { type: "VirtualMachineSnapshot" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "HttpNfcLease");
  }
  async remove(args: {
    removeChildren: boolean;
    consolidate?: boolean
  }): Promise<Task> {
    const result = await this.connection.exec<{
      removeChildren: boolean;
      consolidate?: boolean
    } & { _this: ObjectReference }, Task>(
      "RemoveSnapshot_Task", { _this: { attributes: { type: "VirtualMachineSnapshot" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async rename(args: {
    name?: string;
    description?: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      name?: string;
      description?: string
    } & { _this: ObjectReference }, void>(
      "RenameSnapshot", { _this: { attributes: { type: "VirtualMachineSnapshot" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async revert(args: {
    host?: HostSystem;
    suppressPowerOn?: boolean
  }): Promise<Task> {
    const result = await this.connection.exec<{
      host?: HostSystem;
      suppressPowerOn?: boolean
    } & { _this: ObjectReference }, Task>(
      "RevertToSnapshot_Task", { _this: { attributes: { type: "VirtualMachineSnapshot" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  };
}
export class VirtualMachineCompatibilityChecker extends ManagedObject {
  
  constructor(
    public connection: Connection,
    init?: Partial<VirtualMachineCompatibilityChecker>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async checkCompatibility(args: {
    vm: VirtualMachine;
    host?: HostSystem;
    pool?: ResourcePool;
    testType?: string[]
  }): Promise<Task> {
    const result = await this.connection.exec<{
      vm: VirtualMachine;
      host?: HostSystem;
      pool?: ResourcePool;
      testType?: string[]
    } & { _this: ObjectReference }, Task>(
      "CheckCompatibility_Task", { _this: { attributes: { type: "VirtualMachineCompatibilityChecker" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async checkPowerOn(args: {
    vm: VirtualMachine;
    host?: HostSystem;
    pool?: ResourcePool;
    testType?: string[]
  }): Promise<Task | undefined> {
    const result = await this.connection.exec<{
      vm: VirtualMachine;
      host?: HostSystem;
      pool?: ResourcePool;
      testType?: string[]
    } & { _this: ObjectReference }, Task | undefined>(
      "CheckPowerOn_Task", { _this: { attributes: { type: "VirtualMachineCompatibilityChecker" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async checkVmConfig(args: {
    spec: VirtualMachineConfigSpec;
    vm?: VirtualMachine;
    host?: HostSystem;
    pool?: ResourcePool;
    testType?: string[]
  }): Promise<Task | undefined> {
    const result = await this.connection.exec<{
      spec: VirtualMachineConfigSpec;
      vm?: VirtualMachine;
      host?: HostSystem;
      pool?: ResourcePool;
      testType?: string[]
    } & { _this: ObjectReference }, Task | undefined>(
      "CheckVmConfig_Task", { _this: { attributes: { type: "VirtualMachineCompatibilityChecker" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  };
}
export class GuestAliasManager extends ManagedObject {
  
  constructor(
    public connection: Connection,
    init?: Partial<GuestAliasManager>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async addAlias(args: {
    vm: VirtualMachine;
    auth: GuestAuthentication;
    username: string;
    mapCert: boolean;
    base64Cert: string;
    aliasInfo: GuestAuthAliasInfo
  }): Promise<void> {
    const result = await this.connection.exec<{
      vm: VirtualMachine;
      auth: GuestAuthentication;
      username: string;
      mapCert: boolean;
      base64Cert: string;
      aliasInfo: GuestAuthAliasInfo
    } & { _this: ObjectReference }, void>(
      "AddGuestAlias", { _this: { attributes: { type: "GuestAliasManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async listAliases(args: {
    vm: VirtualMachine;
    auth: GuestAuthentication;
    username: string
  }): Promise<GuestAliases[] | undefined> {
    const result = await this.connection.exec<{
      vm: VirtualMachine;
      auth: GuestAuthentication;
      username: string
    } & { _this: ObjectReference }, GuestAliases[] | undefined>(
      "ListGuestAliases", { _this: { attributes: { type: "GuestAliasManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "GuestAliases[]");
  }
  async listMappedAliases(args: {
    vm: VirtualMachine;
    auth: GuestAuthentication
  }): Promise<GuestMappedAliases[] | undefined> {
    const result = await this.connection.exec<{
      vm: VirtualMachine;
      auth: GuestAuthentication
    } & { _this: ObjectReference }, GuestMappedAliases[] | undefined>(
      "ListGuestMappedAliases", { _this: { attributes: { type: "GuestAliasManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "GuestMappedAliases[]");
  }
  async removeAlias(args: {
    vm: VirtualMachine;
    auth: GuestAuthentication;
    username: string;
    base64Cert: string;
    subject: GuestAuthSubject
  }): Promise<void> {
    const result = await this.connection.exec<{
      vm: VirtualMachine;
      auth: GuestAuthentication;
      username: string;
      base64Cert: string;
      subject: GuestAuthSubject
    } & { _this: ObjectReference }, void>(
      "RemoveGuestAlias", { _this: { attributes: { type: "GuestAliasManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async removeAliasByCert(args: {
    vm: VirtualMachine;
    auth: GuestAuthentication;
    username: string;
    base64Cert: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      vm: VirtualMachine;
      auth: GuestAuthentication;
      username: string;
      base64Cert: string
    } & { _this: ObjectReference }, void>(
      "RemoveGuestAliasByCert", { _this: { attributes: { type: "GuestAliasManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  };
}
export class GuestAuthManager extends ManagedObject {
  
  constructor(
    public connection: Connection,
    init?: Partial<GuestAuthManager>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async acquireCredentials(args: {
    vm: VirtualMachine;
    requestedAuth: GuestAuthentication;
    sessionID?: number
  }): Promise<GuestAuthentication> {
    const result = await this.connection.exec<{
      vm: VirtualMachine;
      requestedAuth: GuestAuthentication;
      sessionID?: number
    } & { _this: ObjectReference }, GuestAuthentication>(
      "AcquireCredentialsInGuest", { _this: { attributes: { type: "GuestAuthManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "GuestAuthentication");
  }
  async releaseCredentials(args: {
    vm: VirtualMachine;
    auth: GuestAuthentication
  }): Promise<void> {
    const result = await this.connection.exec<{
      vm: VirtualMachine;
      auth: GuestAuthentication
    } & { _this: ObjectReference }, void>(
      "ReleaseCredentialsInGuest", { _this: { attributes: { type: "GuestAuthManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async validateCredentials(args: {
    vm: VirtualMachine;
    auth: GuestAuthentication
  }): Promise<void> {
    const result = await this.connection.exec<{
      vm: VirtualMachine;
      auth: GuestAuthentication
    } & { _this: ObjectReference }, void>(
      "ValidateCredentialsInGuest", { _this: { attributes: { type: "GuestAuthManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  };
}
export class GuestFileManager extends ManagedObject {
  
  constructor(
    public connection: Connection,
    init?: Partial<GuestFileManager>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async changeFileAttributes(args: {
    vm: VirtualMachine;
    auth: GuestAuthentication;
    guestFilePath: string;
    fileAttributes: GuestFileAttributes
  }): Promise<void> {
    const result = await this.connection.exec<{
      vm: VirtualMachine;
      auth: GuestAuthentication;
      guestFilePath: string;
      fileAttributes: GuestFileAttributes
    } & { _this: ObjectReference }, void>(
      "ChangeFileAttributesInGuest", { _this: { attributes: { type: "GuestFileManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async createTemporaryDirectory(args: {
    vm: VirtualMachine;
    auth: GuestAuthentication;
    prefix: string;
    suffix: string;
    directoryPath?: string
  }): Promise<string> {
    const result = await this.connection.exec<{
      vm: VirtualMachine;
      auth: GuestAuthentication;
      prefix: string;
      suffix: string;
      directoryPath?: string
    } & { _this: ObjectReference }, string>(
      "CreateTemporaryDirectoryInGuest", { _this: { attributes: { type: "GuestFileManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "string");
  }
  async createTemporaryFile(args: {
    vm: VirtualMachine;
    auth: GuestAuthentication;
    prefix: string;
    suffix: string;
    directoryPath?: string
  }): Promise<string> {
    const result = await this.connection.exec<{
      vm: VirtualMachine;
      auth: GuestAuthentication;
      prefix: string;
      suffix: string;
      directoryPath?: string
    } & { _this: ObjectReference }, string>(
      "CreateTemporaryFileInGuest", { _this: { attributes: { type: "GuestFileManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "string");
  }
  async deleteDirectory(args: {
    vm: VirtualMachine;
    auth: GuestAuthentication;
    directoryPath: string;
    recursive: boolean
  }): Promise<void> {
    const result = await this.connection.exec<{
      vm: VirtualMachine;
      auth: GuestAuthentication;
      directoryPath: string;
      recursive: boolean
    } & { _this: ObjectReference }, void>(
      "DeleteDirectoryInGuest", { _this: { attributes: { type: "GuestFileManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async deleteFile(args: {
    vm: VirtualMachine;
    auth: GuestAuthentication;
    filePath: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      vm: VirtualMachine;
      auth: GuestAuthentication;
      filePath: string
    } & { _this: ObjectReference }, void>(
      "DeleteFileInGuest", { _this: { attributes: { type: "GuestFileManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async initiateFileTransferFromGuest(args: {
    vm: VirtualMachine;
    auth: GuestAuthentication;
    guestFilePath: string
  }): Promise<FileTransferInformation> {
    const result = await this.connection.exec<{
      vm: VirtualMachine;
      auth: GuestAuthentication;
      guestFilePath: string
    } & { _this: ObjectReference }, FileTransferInformation>(
      "InitiateFileTransferFromGuest", { _this: { attributes: { type: "GuestFileManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "FileTransferInformation");
  }
  async initiateFileTransferToGuest(args: {
    vm: VirtualMachine;
    auth: GuestAuthentication;
    guestFilePath: string;
    fileAttributes: GuestFileAttributes;
    fileSize: number;
    overwrite: boolean
  }): Promise<string> {
    const result = await this.connection.exec<{
      vm: VirtualMachine;
      auth: GuestAuthentication;
      guestFilePath: string;
      fileAttributes: GuestFileAttributes;
      fileSize: number;
      overwrite: boolean
    } & { _this: ObjectReference }, string>(
      "InitiateFileTransferToGuest", { _this: { attributes: { type: "GuestFileManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "string");
  }
  async listFiles(args: {
    vm: VirtualMachine;
    auth: GuestAuthentication;
    filePath: string;
    index?: number;
    maxResults?: number;
    matchPattern?: string
  }): Promise<GuestListFileInfo> {
    const result = await this.connection.exec<{
      vm: VirtualMachine;
      auth: GuestAuthentication;
      filePath: string;
      index?: number;
      maxResults?: number;
      matchPattern?: string
    } & { _this: ObjectReference }, GuestListFileInfo>(
      "ListFilesInGuest", { _this: { attributes: { type: "GuestFileManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "GuestListFileInfo");
  }
  async makeDirectory(args: {
    vm: VirtualMachine;
    auth: GuestAuthentication;
    directoryPath: string;
    createParentDirectories: boolean
  }): Promise<void> {
    const result = await this.connection.exec<{
      vm: VirtualMachine;
      auth: GuestAuthentication;
      directoryPath: string;
      createParentDirectories: boolean
    } & { _this: ObjectReference }, void>(
      "MakeDirectoryInGuest", { _this: { attributes: { type: "GuestFileManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async moveDirectory(args: {
    vm: VirtualMachine;
    auth: GuestAuthentication;
    srcDirectoryPath: string;
    dstDirectoryPath: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      vm: VirtualMachine;
      auth: GuestAuthentication;
      srcDirectoryPath: string;
      dstDirectoryPath: string
    } & { _this: ObjectReference }, void>(
      "MoveDirectoryInGuest", { _this: { attributes: { type: "GuestFileManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async moveFile(args: {
    vm: VirtualMachine;
    auth: GuestAuthentication;
    srcFilePath: string;
    dstFilePath: string;
    overwrite: boolean
  }): Promise<void> {
    const result = await this.connection.exec<{
      vm: VirtualMachine;
      auth: GuestAuthentication;
      srcFilePath: string;
      dstFilePath: string;
      overwrite: boolean
    } & { _this: ObjectReference }, void>(
      "MoveFileInGuest", { _this: { attributes: { type: "GuestFileManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  };
}
export class GuestOperationsManager extends ManagedObject {
  authManager?: GuestAuthManager;
  fileManager?: GuestFileManager;
  processManager?: GuestProcessManager;
  guestWindowsRegistryManager?: GuestWindowsRegistryManager;
  aliasManager?: GuestAliasManager;
  constructor(
    public connection: Connection,
    init?: Partial<GuestOperationsManager>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  
}
export class GuestProcessManager extends ManagedObject {
  
  constructor(
    public connection: Connection,
    init?: Partial<GuestProcessManager>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async listProcesses(args: {
    vm: VirtualMachine;
    auth: GuestAuthentication;
    pids?: number[]
  }): Promise<GuestProcessInfo[] | undefined> {
    const result = await this.connection.exec<{
      vm: VirtualMachine;
      auth: GuestAuthentication;
      pids?: number[]
    } & { _this: ObjectReference }, GuestProcessInfo[] | undefined>(
      "ListProcessesInGuest", { _this: { attributes: { type: "GuestProcessManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "GuestProcessInfo[]");
  }
  async readEnvironmentVariable(args: {
    vm: VirtualMachine;
    auth: GuestAuthentication;
    names?: string[]
  }): Promise<string[] | undefined> {
    const result = await this.connection.exec<{
      vm: VirtualMachine;
      auth: GuestAuthentication;
      names?: string[]
    } & { _this: ObjectReference }, string[] | undefined>(
      "ReadEnvironmentVariableInGuest", { _this: { attributes: { type: "GuestProcessManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "string[]");
  }
  async startProgram(args: {
    vm: VirtualMachine;
    auth: GuestAuthentication;
    spec: GuestProgramSpec
  }): Promise<number> {
    const result = await this.connection.exec<{
      vm: VirtualMachine;
      auth: GuestAuthentication;
      spec: GuestProgramSpec
    } & { _this: ObjectReference }, number>(
      "StartProgramInGuest", { _this: { attributes: { type: "GuestProcessManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "number");
  }
  async terminateProcess(args: {
    vm: VirtualMachine;
    auth: GuestAuthentication;
    pid: number
  }): Promise<void> {
    const result = await this.connection.exec<{
      vm: VirtualMachine;
      auth: GuestAuthentication;
      pid: number
    } & { _this: ObjectReference }, void>(
      "TerminateProcessInGuest", { _this: { attributes: { type: "GuestProcessManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  };
}
export class GuestWindowsRegistryManager extends ManagedObject {
  
  constructor(
    public connection: Connection,
    init?: Partial<GuestWindowsRegistryManager>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async createRegistryKey(args: {
    vm: VirtualMachine;
    auth: GuestAuthentication;
    keyName: GuestRegKeyNameSpec;
    isVolatile: boolean;
    classType?: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      vm: VirtualMachine;
      auth: GuestAuthentication;
      keyName: GuestRegKeyNameSpec;
      isVolatile: boolean;
      classType?: string
    } & { _this: ObjectReference }, void>(
      "CreateRegistryKeyInGuest", { _this: { attributes: { type: "GuestWindowsRegistryManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async deleteRegistryKey(args: {
    vm: VirtualMachine;
    auth: GuestAuthentication;
    keyName: GuestRegKeyNameSpec;
    recursive: boolean
  }): Promise<void> {
    const result = await this.connection.exec<{
      vm: VirtualMachine;
      auth: GuestAuthentication;
      keyName: GuestRegKeyNameSpec;
      recursive: boolean
    } & { _this: ObjectReference }, void>(
      "DeleteRegistryKeyInGuest", { _this: { attributes: { type: "GuestWindowsRegistryManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async deleteRegistryValue(args: {
    vm: VirtualMachine;
    auth: GuestAuthentication;
    valueName: GuestRegValueNameSpec
  }): Promise<void> {
    const result = await this.connection.exec<{
      vm: VirtualMachine;
      auth: GuestAuthentication;
      valueName: GuestRegValueNameSpec
    } & { _this: ObjectReference }, void>(
      "DeleteRegistryValueInGuest", { _this: { attributes: { type: "GuestWindowsRegistryManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async listRegistryKeys(args: {
    vm: VirtualMachine;
    auth: GuestAuthentication;
    keyName: GuestRegKeyNameSpec;
    recursive: boolean;
    matchPattern?: string
  }): Promise<GuestRegKeyRecordSpec[] | undefined> {
    const result = await this.connection.exec<{
      vm: VirtualMachine;
      auth: GuestAuthentication;
      keyName: GuestRegKeyNameSpec;
      recursive: boolean;
      matchPattern?: string
    } & { _this: ObjectReference }, GuestRegKeyRecordSpec[] | undefined>(
      "ListRegistryKeysInGuest", { _this: { attributes: { type: "GuestWindowsRegistryManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "GuestRegKeyRecordSpec[]");
  }
  async listRegistryValues(args: {
    vm: VirtualMachine;
    auth: GuestAuthentication;
    keyName: GuestRegKeyNameSpec;
    expandStrings: boolean;
    matchPattern?: string
  }): Promise<GuestRegValueSpec[] | undefined> {
    const result = await this.connection.exec<{
      vm: VirtualMachine;
      auth: GuestAuthentication;
      keyName: GuestRegKeyNameSpec;
      expandStrings: boolean;
      matchPattern?: string
    } & { _this: ObjectReference }, GuestRegValueSpec[] | undefined>(
      "ListRegistryValuesInGuest", { _this: { attributes: { type: "GuestWindowsRegistryManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "GuestRegValueSpec[]");
  }
  async setRegistryValue(args: {
    vm: VirtualMachine;
    auth: GuestAuthentication;
    value: GuestRegValueSpec
  }): Promise<void> {
    const result = await this.connection.exec<{
      vm: VirtualMachine;
      auth: GuestAuthentication;
      value: GuestRegValueSpec
    } & { _this: ObjectReference }, void>(
      "SetRegistryValueInGuest", { _this: { attributes: { type: "GuestWindowsRegistryManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  };
}
export class VStorageObjectManagerBase extends ManagedObject {
  
  constructor(
    public connection: Connection,
    init?: Partial<VStorageObjectManagerBase>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  
}
export class AuthorizationManager extends ManagedObject {
  privilegeList?: AuthorizationPrivilege[];
  roleList?: AuthorizationRole[];
  description!: AuthorizationDescription;
  constructor(
    public connection: Connection,
    init?: Partial<AuthorizationManager>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async addRole(args: {
    name: string;
    privIds?: string[]
  }): Promise<number> {
    const result = await this.connection.exec<{
      name: string;
      privIds?: string[]
    } & { _this: ObjectReference }, number>(
      "AddAuthorizationRole", { _this: { attributes: { type: "AuthorizationManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "number");
  }
  async fetchUserPrivilegeOnEntities(args: {
    entities: ManagedEntity[];
    userName: string
  }): Promise<UserPrivilegeResult[] | undefined> {
    const result = await this.connection.exec<{
      entities: ManagedEntity[];
      userName: string
    } & { _this: ObjectReference }, UserPrivilegeResult[] | undefined>(
      "FetchUserPrivilegeOnEntities", { _this: { attributes: { type: "AuthorizationManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "UserPrivilegeResult[]");
  }
  async hasPrivilegeOnEntities(args: {
    entity: ManagedEntity[];
    sessionId: string;
    privId?: string[]
  }): Promise<EntityPrivilege[] | undefined> {
    const result = await this.connection.exec<{
      entity: ManagedEntity[];
      sessionId: string;
      privId?: string[]
    } & { _this: ObjectReference }, EntityPrivilege[] | undefined>(
      "HasPrivilegeOnEntities", { _this: { attributes: { type: "AuthorizationManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "EntityPrivilege[]");
  }
  async hasPrivilegeOnEntity(args: {
    entity: ManagedEntity;
    sessionId: string;
    privId?: string[]
  }): Promise<boolean[] | undefined> {
    const result = await this.connection.exec<{
      entity: ManagedEntity;
      sessionId: string;
      privId?: string[]
    } & { _this: ObjectReference }, boolean[] | undefined>(
      "HasPrivilegeOnEntity", { _this: { attributes: { type: "AuthorizationManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "boolean[]");
  }
  async hasUserPrivilegeOnEntities(args: {
    entities: ManagedObject[];
    userName: string;
    privId?: string[]
  }): Promise<EntityPrivilege[] | undefined> {
    const result = await this.connection.exec<{
      entities: ManagedObject[];
      userName: string;
      privId?: string[]
    } & { _this: ObjectReference }, EntityPrivilege[] | undefined>(
      "HasUserPrivilegeOnEntities", { _this: { attributes: { type: "AuthorizationManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "EntityPrivilege[]");
  }
  async mergePermissions(args: {
    srcRoleId: number;
    dstRoleId: number
  }): Promise<void> {
    const result = await this.connection.exec<{
      srcRoleId: number;
      dstRoleId: number
    } & { _this: ObjectReference }, void>(
      "MergePermissions", { _this: { attributes: { type: "AuthorizationManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async removeRole(args: {
    roleId: number;
    failIfUsed: boolean
  }): Promise<void> {
    const result = await this.connection.exec<{
      roleId: number;
      failIfUsed: boolean
    } & { _this: ObjectReference }, void>(
      "RemoveAuthorizationRole", { _this: { attributes: { type: "AuthorizationManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async removeEntityPermission(args: {
    entity: ManagedEntity;
    user: string;
    isGroup: boolean
  }): Promise<void> {
    const result = await this.connection.exec<{
      entity: ManagedEntity;
      user: string;
      isGroup: boolean
    } & { _this: ObjectReference }, void>(
      "RemoveEntityPermission", { _this: { attributes: { type: "AuthorizationManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async resetEntityPermissions(args: {
    entity: ManagedEntity;
    permission?: Permission[]
  }): Promise<void> {
    const result = await this.connection.exec<{
      entity: ManagedEntity;
      permission?: Permission[]
    } & { _this: ObjectReference }, void>(
      "ResetEntityPermissions", { _this: { attributes: { type: "AuthorizationManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async retrieveAllPermissions(): Promise<Permission[] | undefined> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, Permission[] | undefined>(
      "RetrieveAllPermissions", { _this: { attributes: { type: "AuthorizationManager" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Permission[]");
  }
  async retrieveEntityPermissions(args: {
    entity: ManagedEntity;
    inherited: boolean
  }): Promise<Permission[] | undefined> {
    const result = await this.connection.exec<{
      entity: ManagedEntity;
      inherited: boolean
    } & { _this: ObjectReference }, Permission[] | undefined>(
      "RetrieveEntityPermissions", { _this: { attributes: { type: "AuthorizationManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Permission[]");
  }
  async retrieveRolePermissions(args: {
    roleId: number
  }): Promise<Permission[] | undefined> {
    const result = await this.connection.exec<{
      roleId: number
    } & { _this: ObjectReference }, Permission[] | undefined>(
      "RetrieveRolePermissions", { _this: { attributes: { type: "AuthorizationManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Permission[]");
  }
  async setEntityPermissions(args: {
    entity: ManagedEntity;
    permission?: Permission[]
  }): Promise<void> {
    const result = await this.connection.exec<{
      entity: ManagedEntity;
      permission?: Permission[]
    } & { _this: ObjectReference }, void>(
      "SetEntityPermissions", { _this: { attributes: { type: "AuthorizationManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async updateRole(args: {
    roleId: number;
    newName: string;
    privIds?: string[]
  }): Promise<void> {
    const result = await this.connection.exec<{
      roleId: number;
      newName: string;
      privIds?: string[]
    } & { _this: ObjectReference }, void>(
      "UpdateAuthorizationRole", { _this: { attributes: { type: "AuthorizationManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  };
}
export class LicenseAssignmentManager extends ManagedObject {
  
  constructor(
    public connection: Connection,
    init?: Partial<LicenseAssignmentManager>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async queryAssignedLicenses(args: {
    entityId?: string
  }): Promise<LicenseAssignmentManagerLicenseAssignment[] | undefined> {
    const result = await this.connection.exec<{
      entityId?: string
    } & { _this: ObjectReference }, LicenseAssignmentManagerLicenseAssignment[] | undefined>(
      "QueryAssignedLicenses", { _this: { attributes: { type: "LicenseAssignmentManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "LicenseAssignmentManagerLicenseAssignment[]");
  }
  async removeAssignedLicense(args: {
    entityId: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      entityId: string
    } & { _this: ObjectReference }, void>(
      "RemoveAssignedLicense", { _this: { attributes: { type: "LicenseAssignmentManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async updateAssignedLicense(args: {
    entity: string;
    licenseKey: string;
    entityDisplayName?: string
  }): Promise<LicenseManagerLicenseInfo> {
    const result = await this.connection.exec<{
      entity: string;
      licenseKey: string;
      entityDisplayName?: string
    } & { _this: ObjectReference }, LicenseManagerLicenseInfo>(
      "UpdateAssignedLicense", { _this: { attributes: { type: "LicenseAssignmentManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "LicenseManagerLicenseInfo");
  };
}
export class ManagedEntity extends ExtensibleManagedObject {
  parent?: ManagedEntity;
  customValue?: CustomFieldValue[];
  overallStatus!: ManagedEntityStatus;
  configStatus!: ManagedEntityStatus;
  configIssue?: Event[];
  effectiveRole?: number[];
  permission?: Permission[];
  name!: string;
  disabledMethod?: string[];
  recentTask?: Task[];
  declaredAlarmState?: AlarmState[];
  triggeredAlarmState?: AlarmState[];
  alarmActionsEnabled?: boolean;
  tag?: Tag[];
  constructor(
    public connection: Connection,
    init?: Partial<ManagedEntity>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async destroy(): Promise<Task> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, Task>(
      "Destroy_Task", { _this: { attributes: { type: "ManagedEntity" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async reload(): Promise<void> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, void>(
      "Reload", { _this: { attributes: { type: "ManagedEntity" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async rename(args: {
    newName: string
  }): Promise<Task> {
    const result = await this.connection.exec<{
      newName: string
    } & { _this: ObjectReference }, Task>(
      "Rename_Task", { _this: { attributes: { type: "ManagedEntity" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  };
}
export class Network extends ManagedEntity {
  summary!: NetworkSummary;
  host?: HostSystem[];
  vm?: VirtualMachine[];
  constructor(
    public connection: Connection,
    init?: Partial<Network>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async destroyNetwork(): Promise<void> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, void>(
      "DestroyNetwork", { _this: { attributes: { type: "Network" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  };
}
export class OpaqueNetwork extends Network {
  capability?: OpaqueNetworkCapability;
  extraConfig?: OptionValue[];
  constructor(
    public connection: Connection,
    init?: Partial<OpaqueNetwork>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  
}
export class ResourcePool extends ManagedEntity {
  summary!: ResourcePoolSummary;
  runtime!: ResourcePoolRuntimeInfo;
  owner!: ComputeResource;
  resourcePool?: ResourcePool[];
  vm?: VirtualMachine[];
  config!: ResourceConfigSpec;
  namespace?: string;
  childConfiguration?: ResourceConfigSpec[];
  constructor(
    public connection: Connection,
    init?: Partial<ResourcePool>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async createVm(args: {
    config: VirtualMachineConfigSpec;
    host?: HostSystem
  }): Promise<Task> {
    const result = await this.connection.exec<{
      config: VirtualMachineConfigSpec;
      host?: HostSystem
    } & { _this: ObjectReference }, Task>(
      "CreateChildVM_Task", { _this: { attributes: { type: "ResourcePool" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async createResourcePool(args: {
    name: string;
    spec: ResourceConfigSpec
  }): Promise<ResourcePool> {
    const result = await this.connection.exec<{
      name: string;
      spec: ResourceConfigSpec
    } & { _this: ObjectReference }, ResourcePool>(
      "CreateResourcePool", { _this: { attributes: { type: "ResourcePool" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "ResourcePool");
  }
  async createVApp(args: {
    name: string;
    resSpec: ResourceConfigSpec;
    configSpec: VAppConfigSpec;
    vmFolder?: Folder
  }): Promise<VirtualApp> {
    const result = await this.connection.exec<{
      name: string;
      resSpec: ResourceConfigSpec;
      configSpec: VAppConfigSpec;
      vmFolder?: Folder
    } & { _this: ObjectReference }, VirtualApp>(
      "CreateVApp", { _this: { attributes: { type: "ResourcePool" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "VirtualApp");
  }
  async destroyChildren(): Promise<void> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, void>(
      "DestroyChildren", { _this: { attributes: { type: "ResourcePool" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async importVApp(args: {
    spec: ImportSpec;
    folder?: Folder;
    host?: HostSystem
  }): Promise<HttpNfcLease> {
    const result = await this.connection.exec<{
      spec: ImportSpec;
      folder?: Folder;
      host?: HostSystem
    } & { _this: ObjectReference }, HttpNfcLease>(
      "ImportVApp", { _this: { attributes: { type: "ResourcePool" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "HttpNfcLease");
  }
  async moveInto(args: {
    list: ManagedEntity[]
  }): Promise<void> {
    const result = await this.connection.exec<{
      list: ManagedEntity[]
    } & { _this: ObjectReference }, void>(
      "MoveIntoResourcePool", { _this: { attributes: { type: "ResourcePool" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async queryResourceConfigOption(): Promise<ResourceConfigOption> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, ResourceConfigOption>(
      "QueryResourceConfigOption", { _this: { attributes: { type: "ResourcePool" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "ResourceConfigOption");
  }
  async refreshRuntime(): Promise<void> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, void>(
      "RefreshRuntime", { _this: { attributes: { type: "ResourcePool" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async registerVm(args: {
    path: string;
    name?: string;
    host?: HostSystem
  }): Promise<Task> {
    const result = await this.connection.exec<{
      path: string;
      name?: string;
      host?: HostSystem
    } & { _this: ObjectReference }, Task>(
      "RegisterChildVM_Task", { _this: { attributes: { type: "ResourcePool" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async updateChildResourceConfiguration(args: {
    spec: ResourceConfigSpec[]
  }): Promise<void> {
    const result = await this.connection.exec<{
      spec: ResourceConfigSpec[]
    } & { _this: ObjectReference }, void>(
      "UpdateChildResourceConfiguration", { _this: { attributes: { type: "ResourcePool" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async updateConfig(args: {
    name?: string;
    config?: ResourceConfigSpec
  }): Promise<void> {
    const result = await this.connection.exec<{
      name?: string;
      config?: ResourceConfigSpec
    } & { _this: ObjectReference }, void>(
      "UpdateConfig", { _this: { attributes: { type: "ResourcePool" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  };
}
export class Task extends ExtensibleManagedObject {
  info!: TaskInfo;
  constructor(
    public connection: Connection,
    init?: Partial<Task>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async cancel(): Promise<void> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, void>(
      "CancelTask", { _this: { attributes: { type: "Task" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async UpdateDescription(args: {
    description: LocalizableMessage
  }): Promise<void> {
    const result = await this.connection.exec<{
      description: LocalizableMessage
    } & { _this: ObjectReference }, void>(
      "SetTaskDescription", { _this: { attributes: { type: "Task" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async setState(args: {
    state: TaskInfoState;
    result?: any;
    fault?: MethodFault
  }): Promise<void> {
    const result = await this.connection.exec<{
      state: TaskInfoState;
      result?: any;
      fault?: MethodFault
    } & { _this: ObjectReference }, void>(
      "SetTaskState", { _this: { attributes: { type: "Task" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async UpdateProgress(args: {
    percentDone: number
  }): Promise<void> {
    const result = await this.connection.exec<{
      percentDone: number
    } & { _this: ObjectReference }, void>(
      "UpdateProgress", { _this: { attributes: { type: "Task" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  };
}
export class VirtualApp extends ResourcePool {
  parentFolder?: Folder;
  datastore?: Datastore[];
  network?: Network[];
  vAppConfig?: VAppConfigInfo;
  parentVApp?: ManagedEntity;
  childLink?: VirtualAppLinkInfo[];
  constructor(
    public connection: Connection,
    init?: Partial<VirtualApp>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async clone(args: {
    name: string;
    target: ResourcePool;
    spec: VAppCloneSpec
  }): Promise<Task> {
    const result = await this.connection.exec<{
      name: string;
      target: ResourcePool;
      spec: VAppCloneSpec
    } & { _this: ObjectReference }, Task>(
      "CloneVApp_Task", { _this: { attributes: { type: "VirtualApp" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async exportVApp(): Promise<HttpNfcLease> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, HttpNfcLease>(
      "ExportVApp", { _this: { attributes: { type: "VirtualApp" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "HttpNfcLease");
  }
  async powerOff(args: {
    force: boolean
  }): Promise<Task> {
    const result = await this.connection.exec<{
      force: boolean
    } & { _this: ObjectReference }, Task>(
      "PowerOffVApp_Task", { _this: { attributes: { type: "VirtualApp" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async powerOn(): Promise<Task> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, Task>(
      "PowerOnVApp_Task", { _this: { attributes: { type: "VirtualApp" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async suspend(): Promise<Task> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, Task>(
      "SuspendVApp_Task", { _this: { attributes: { type: "VirtualApp" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async updateLinkedChildren(args: {
    addChangeSet?: VirtualAppLinkInfo[];
    removeSet?: ManagedEntity[]
  }): Promise<void> {
    const result = await this.connection.exec<{
      addChangeSet?: VirtualAppLinkInfo[];
      removeSet?: ManagedEntity[]
    } & { _this: ObjectReference }, void>(
      "UpdateLinkedChildren", { _this: { attributes: { type: "VirtualApp" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async updateVAppConfig(args: {
    spec: VAppConfigSpec
  }): Promise<void> {
    const result = await this.connection.exec<{
      spec: VAppConfigSpec
    } & { _this: ObjectReference }, void>(
      "UpdateVAppConfig", { _this: { attributes: { type: "VirtualApp" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async unregister(): Promise<Task> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, Task>(
      "unregisterVApp_Task", { _this: { attributes: { type: "VirtualApp" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  };
}
export class VirtualDiskManager extends ManagedObject {
  
  constructor(
    public connection: Connection,
    init?: Partial<VirtualDiskManager>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async copyVirtualDisk(args: {
    sourceName: string;
    sourceDatacenter?: Datacenter;
    destName: string;
    destDatacenter?: Datacenter;
    destSpec?: VirtualDiskSpec;
    force?: boolean
  }): Promise<Task> {
    const result = await this.connection.exec<{
      sourceName: string;
      sourceDatacenter?: Datacenter;
      destName: string;
      destDatacenter?: Datacenter;
      destSpec?: VirtualDiskSpec;
      force?: boolean
    } & { _this: ObjectReference }, Task>(
      "CopyVirtualDisk_Task", { _this: { attributes: { type: "VirtualDiskManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async createVirtualDisk(args: {
    name: string;
    datacenter?: Datacenter;
    spec: VirtualDiskSpec
  }): Promise<Task> {
    const result = await this.connection.exec<{
      name: string;
      datacenter?: Datacenter;
      spec: VirtualDiskSpec
    } & { _this: ObjectReference }, Task>(
      "CreateVirtualDisk_Task", { _this: { attributes: { type: "VirtualDiskManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async defragmentVirtualDisk(args: {
    name: string;
    datacenter?: Datacenter
  }): Promise<Task> {
    const result = await this.connection.exec<{
      name: string;
      datacenter?: Datacenter
    } & { _this: ObjectReference }, Task>(
      "DefragmentVirtualDisk_Task", { _this: { attributes: { type: "VirtualDiskManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async deleteVirtualDisk(args: {
    name: string;
    datacenter?: Datacenter
  }): Promise<Task> {
    const result = await this.connection.exec<{
      name: string;
      datacenter?: Datacenter
    } & { _this: ObjectReference }, Task>(
      "DeleteVirtualDisk_Task", { _this: { attributes: { type: "VirtualDiskManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async eagerZeroVirtualDisk(args: {
    name: string;
    datacenter?: Datacenter
  }): Promise<Task> {
    const result = await this.connection.exec<{
      name: string;
      datacenter?: Datacenter
    } & { _this: ObjectReference }, Task>(
      "EagerZeroVirtualDisk_Task", { _this: { attributes: { type: "VirtualDiskManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async extendVirtualDisk(args: {
    name: string;
    datacenter?: Datacenter;
    newCapacityKb: number;
    eagerZero?: boolean
  }): Promise<Task> {
    const result = await this.connection.exec<{
      name: string;
      datacenter?: Datacenter;
      newCapacityKb: number;
      eagerZero?: boolean
    } & { _this: ObjectReference }, Task>(
      "ExtendVirtualDisk_Task", { _this: { attributes: { type: "VirtualDiskManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async importUnmanagedSnapshot(args: {
    vdisk: string;
    datacenter?: Datacenter;
    vvolId: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      vdisk: string;
      datacenter?: Datacenter;
      vvolId: string
    } & { _this: ObjectReference }, void>(
      "ImportUnmanagedSnapshot", { _this: { attributes: { type: "VirtualDiskManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async inflateVirtualDisk(args: {
    name: string;
    datacenter?: Datacenter
  }): Promise<Task> {
    const result = await this.connection.exec<{
      name: string;
      datacenter?: Datacenter
    } & { _this: ObjectReference }, Task>(
      "InflateVirtualDisk_Task", { _this: { attributes: { type: "VirtualDiskManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async moveVirtualDisk(args: {
    sourceName: string;
    sourceDatacenter?: Datacenter;
    destName: string;
    destDatacenter?: Datacenter;
    force?: boolean;
    profile?: VirtualMachineProfileSpec[]
  }): Promise<Task> {
    const result = await this.connection.exec<{
      sourceName: string;
      sourceDatacenter?: Datacenter;
      destName: string;
      destDatacenter?: Datacenter;
      force?: boolean;
      profile?: VirtualMachineProfileSpec[]
    } & { _this: ObjectReference }, Task>(
      "MoveVirtualDisk_Task", { _this: { attributes: { type: "VirtualDiskManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async queryVirtualDiskFragmentation(args: {
    name: string;
    datacenter?: Datacenter
  }): Promise<number> {
    const result = await this.connection.exec<{
      name: string;
      datacenter?: Datacenter
    } & { _this: ObjectReference }, number>(
      "QueryVirtualDiskFragmentation", { _this: { attributes: { type: "VirtualDiskManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "number");
  }
  async queryVirtualDiskGeometry(args: {
    name: string;
    datacenter?: Datacenter
  }): Promise<HostDiskDimensionsChs> {
    const result = await this.connection.exec<{
      name: string;
      datacenter?: Datacenter
    } & { _this: ObjectReference }, HostDiskDimensionsChs>(
      "QueryVirtualDiskGeometry", { _this: { attributes: { type: "VirtualDiskManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "HostDiskDimensionsChs");
  }
  async queryVirtualDiskUuid(args: {
    name: string;
    datacenter?: Datacenter
  }): Promise<string> {
    const result = await this.connection.exec<{
      name: string;
      datacenter?: Datacenter
    } & { _this: ObjectReference }, string>(
      "QueryVirtualDiskUuid", { _this: { attributes: { type: "VirtualDiskManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "string");
  }
  async releaseManagedSnapshot(args: {
    vdisk: string;
    datacenter?: Datacenter
  }): Promise<void> {
    const result = await this.connection.exec<{
      vdisk: string;
      datacenter?: Datacenter
    } & { _this: ObjectReference }, void>(
      "ReleaseManagedSnapshot", { _this: { attributes: { type: "VirtualDiskManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async setVirtualDiskUuid(args: {
    name: string;
    datacenter?: Datacenter;
    uuid: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      name: string;
      datacenter?: Datacenter;
      uuid: string
    } & { _this: ObjectReference }, void>(
      "SetVirtualDiskUuid", { _this: { attributes: { type: "VirtualDiskManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async shrinkVirtualDisk(args: {
    name: string;
    datacenter?: Datacenter;
    copy?: boolean
  }): Promise<Task> {
    const result = await this.connection.exec<{
      name: string;
      datacenter?: Datacenter;
      copy?: boolean
    } & { _this: ObjectReference }, Task>(
      "ShrinkVirtualDisk_Task", { _this: { attributes: { type: "VirtualDiskManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async zeroFillVirtualDisk(args: {
    name: string;
    datacenter?: Datacenter
  }): Promise<Task> {
    const result = await this.connection.exec<{
      name: string;
      datacenter?: Datacenter
    } & { _this: ObjectReference }, Task>(
      "ZeroFillVirtualDisk_Task", { _this: { attributes: { type: "VirtualDiskManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  };
}
export class VirtualMachine extends ManagedEntity {
  capability!: VirtualMachineCapability;
  config?: VirtualMachineConfigInfo;
  layout?: VirtualMachineFileLayout;
  layoutEx?: VirtualMachineFileLayoutEx;
  storage?: VirtualMachineStorageInfo;
  environmentBrowser!: EnvironmentBrowser;
  resourcePool?: ResourcePool;
  parentVApp?: ManagedEntity;
  resourceConfig?: ResourceConfigSpec;
  runtime!: VirtualMachineRuntimeInfo;
  guest?: GuestInfo;
  summary!: VirtualMachineSummary;
  datastore?: Datastore[];
  network?: Network[];
  snapshot?: VirtualMachineSnapshotInfo;
  rootSnapshot?: VirtualMachineSnapshot[];
  guestHeartbeatStatus!: ManagedEntityStatus;
  constructor(
    public connection: Connection,
    init?: Partial<VirtualMachine>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async acquireMksTicket(): Promise<VirtualMachineMksTicket> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, VirtualMachineMksTicket>(
      "AcquireMksTicket", { _this: { attributes: { type: "VirtualMachine" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "VirtualMachineMksTicket");
  }
  async acquireTicket(args: {
    ticketType: string
  }): Promise<VirtualMachineTicket> {
    const result = await this.connection.exec<{
      ticketType: string
    } & { _this: ObjectReference }, VirtualMachineTicket>(
      "AcquireTicket", { _this: { attributes: { type: "VirtualMachine" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "VirtualMachineTicket");
  }
  async answer(args: {
    questionId: string;
    answerChoice: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      questionId: string;
      answerChoice: string
    } & { _this: ObjectReference }, void>(
      "AnswerVM", { _this: { attributes: { type: "VirtualMachine" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async applyEvcMode(args: {
    mask?: HostFeatureMask[];
    completeMasks?: boolean
  }): Promise<Task> {
    const result = await this.connection.exec<{
      mask?: HostFeatureMask[];
      completeMasks?: boolean
    } & { _this: ObjectReference }, Task>(
      "ApplyEvcModeVM_Task", { _this: { attributes: { type: "VirtualMachine" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async attachDisk(args: {
    diskId: ID;
    datastore: Datastore;
    controllerKey?: number;
    unitNumber?: number
  }): Promise<Task> {
    const result = await this.connection.exec<{
      diskId: ID;
      datastore: Datastore;
      controllerKey?: number;
      unitNumber?: number
    } & { _this: ObjectReference }, Task>(
      "AttachDisk_Task", { _this: { attributes: { type: "VirtualMachine" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async checkCustomizationSpec(args: {
    spec: CustomizationSpec
  }): Promise<void> {
    const result = await this.connection.exec<{
      spec: CustomizationSpec
    } & { _this: ObjectReference }, void>(
      "CheckCustomizationSpec", { _this: { attributes: { type: "VirtualMachine" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async clone(args: {
    folder: Folder;
    name: string;
    spec: VirtualMachineCloneSpec
  }): Promise<Task> {
    const result = await this.connection.exec<{
      folder: Folder;
      name: string;
      spec: VirtualMachineCloneSpec
    } & { _this: ObjectReference }, Task>(
      "CloneVM_Task", { _this: { attributes: { type: "VirtualMachine" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async consolidateDisks(): Promise<Task> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, Task>(
      "ConsolidateVMDisks_Task", { _this: { attributes: { type: "VirtualMachine" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async createScreenshot(): Promise<Task> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, Task>(
      "CreateScreenshot_Task", { _this: { attributes: { type: "VirtualMachine" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async createSecondaryEx(args: {
    host?: HostSystem;
    spec?: FaultToleranceConfigSpec
  }): Promise<Task> {
    const result = await this.connection.exec<{
      host?: HostSystem;
      spec?: FaultToleranceConfigSpec
    } & { _this: ObjectReference }, Task>(
      "CreateSecondaryVMEx_Task", { _this: { attributes: { type: "VirtualMachine" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async createSecondary(args: {
    host?: HostSystem
  }): Promise<Task> {
    const result = await this.connection.exec<{
      host?: HostSystem
    } & { _this: ObjectReference }, Task>(
      "CreateSecondaryVM_Task", { _this: { attributes: { type: "VirtualMachine" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async createSnapshotEx(args: {
    name: string;
    description?: string;
    memory: boolean;
    quiesceSpec?: VirtualMachineGuestQuiesceSpec
  }): Promise<Task> {
    const result = await this.connection.exec<{
      name: string;
      description?: string;
      memory: boolean;
      quiesceSpec?: VirtualMachineGuestQuiesceSpec
    } & { _this: ObjectReference }, Task>(
      "CreateSnapshotEx_Task", { _this: { attributes: { type: "VirtualMachine" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async createSnapshot(args: {
    name: string;
    description?: string;
    memory: boolean;
    quiesce: boolean
  }): Promise<Task> {
    const result = await this.connection.exec<{
      name: string;
      description?: string;
      memory: boolean;
      quiesce: boolean
    } & { _this: ObjectReference }, Task>(
      "CreateSnapshot_Task", { _this: { attributes: { type: "VirtualMachine" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async cryptoUnlock(): Promise<Task> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, Task>(
      "CryptoUnlock_Task", { _this: { attributes: { type: "VirtualMachine" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async customize(args: {
    spec: CustomizationSpec
  }): Promise<Task> {
    const result = await this.connection.exec<{
      spec: CustomizationSpec
    } & { _this: ObjectReference }, Task>(
      "CustomizeVM_Task", { _this: { attributes: { type: "VirtualMachine" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async defragmentAllDisks(): Promise<void> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, void>(
      "DefragmentAllDisks", { _this: { attributes: { type: "VirtualMachine" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async detachDisk(args: {
    diskId: ID
  }): Promise<Task> {
    const result = await this.connection.exec<{
      diskId: ID
    } & { _this: ObjectReference }, Task>(
      "DetachDisk_Task", { _this: { attributes: { type: "VirtualMachine" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async disableSecondary(args: {
    vm: VirtualMachine
  }): Promise<Task> {
    const result = await this.connection.exec<{
      vm: VirtualMachine
    } & { _this: ObjectReference }, Task>(
      "DisableSecondaryVM_Task", { _this: { attributes: { type: "VirtualMachine" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async dropConnections(args: {
    listOfConnections?: VirtualMachineConnection[]
  }): Promise<boolean> {
    const result = await this.connection.exec<{
      listOfConnections?: VirtualMachineConnection[]
    } & { _this: ObjectReference }, boolean>(
      "DropConnections", { _this: { attributes: { type: "VirtualMachine" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "boolean");
  }
  async enableSecondary(args: {
    vm: VirtualMachine;
    host?: HostSystem
  }): Promise<Task> {
    const result = await this.connection.exec<{
      vm: VirtualMachine;
      host?: HostSystem
    } & { _this: ObjectReference }, Task>(
      "EnableSecondaryVM_Task", { _this: { attributes: { type: "VirtualMachine" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async estimateStorageRequirementForConsolidate(): Promise<Task | undefined> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, Task | undefined>(
      "EstimateStorageForConsolidateSnapshots_Task", { _this: { attributes: { type: "VirtualMachine" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async exportVm(): Promise<HttpNfcLease> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, HttpNfcLease>(
      "ExportVm", { _this: { attributes: { type: "VirtualMachine" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "HttpNfcLease");
  }
  async extractOvfEnvironment(): Promise<string> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, string>(
      "ExtractOvfEnvironment", { _this: { attributes: { type: "VirtualMachine" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "string");
  }
  async instantClone(args: {
    spec: VirtualMachineInstantCloneSpec
  }): Promise<Task> {
    const result = await this.connection.exec<{
      spec: VirtualMachineInstantCloneSpec
    } & { _this: ObjectReference }, Task>(
      "InstantClone_Task", { _this: { attributes: { type: "VirtualMachine" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async makePrimary(args: {
    vm: VirtualMachine
  }): Promise<Task> {
    const result = await this.connection.exec<{
      vm: VirtualMachine
    } & { _this: ObjectReference }, Task>(
      "MakePrimaryVM_Task", { _this: { attributes: { type: "VirtualMachine" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async markAsTemplate(): Promise<void> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, void>(
      "MarkAsTemplate", { _this: { attributes: { type: "VirtualMachine" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async markAsVirtualMachine(args: {
    pool: ResourcePool;
    host?: HostSystem
  }): Promise<void> {
    const result = await this.connection.exec<{
      pool: ResourcePool;
      host?: HostSystem
    } & { _this: ObjectReference }, void>(
      "MarkAsVirtualMachine", { _this: { attributes: { type: "VirtualMachine" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async migrate(args: {
    pool?: ResourcePool;
    host?: HostSystem;
    priority: VirtualMachineMovePriority;
    state?: VirtualMachinePowerState
  }): Promise<Task> {
    const result = await this.connection.exec<{
      pool?: ResourcePool;
      host?: HostSystem;
      priority: VirtualMachineMovePriority;
      state?: VirtualMachinePowerState
    } & { _this: ObjectReference }, Task>(
      "MigrateVM_Task", { _this: { attributes: { type: "VirtualMachine" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async mountToolsInstaller(): Promise<void> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, void>(
      "MountToolsInstaller", { _this: { attributes: { type: "VirtualMachine" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async powerOff(): Promise<Task> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, Task>(
      "PowerOffVM_Task", { _this: { attributes: { type: "VirtualMachine" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async powerOn(args: {
    host?: HostSystem
  }): Promise<Task> {
    const result = await this.connection.exec<{
      host?: HostSystem
    } & { _this: ObjectReference }, Task>(
      "PowerOnVM_Task", { _this: { attributes: { type: "VirtualMachine" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async promoteDisks(args: {
    unlink: boolean;
    disks?: VirtualDisk[]
  }): Promise<Task> {
    const result = await this.connection.exec<{
      unlink: boolean;
      disks?: VirtualDisk[]
    } & { _this: ObjectReference }, Task>(
      "PromoteDisks_Task", { _this: { attributes: { type: "VirtualMachine" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async putUsbScanCodes(args: {
    spec: UsbScanCodeSpec
  }): Promise<number> {
    const result = await this.connection.exec<{
      spec: UsbScanCodeSpec
    } & { _this: ObjectReference }, number>(
      "PutUsbScanCodes", { _this: { attributes: { type: "VirtualMachine" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "number");
  }
  async queryChangedDiskAreas(args: {
    snapshot?: VirtualMachineSnapshot;
    deviceKey: number;
    startOffset: number;
    changeId: string
  }): Promise<DiskChangeInfo> {
    const result = await this.connection.exec<{
      snapshot?: VirtualMachineSnapshot;
      deviceKey: number;
      startOffset: number;
      changeId: string
    } & { _this: ObjectReference }, DiskChangeInfo>(
      "QueryChangedDiskAreas", { _this: { attributes: { type: "VirtualMachine" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "DiskChangeInfo");
  }
  async queryConnections(): Promise<VirtualMachineConnection[] | undefined> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, VirtualMachineConnection[] | undefined>(
      "QueryConnections", { _this: { attributes: { type: "VirtualMachine" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "VirtualMachineConnection[]");
  }
  async queryFaultToleranceCompatibility(): Promise<MethodFault[] | undefined> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, MethodFault[] | undefined>(
      "QueryFaultToleranceCompatibility", { _this: { attributes: { type: "VirtualMachine" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "MethodFault[]");
  }
  async queryFaultToleranceCompatibilityEx(args: {
    forLegacyFt?: boolean
  }): Promise<MethodFault[] | undefined> {
    const result = await this.connection.exec<{
      forLegacyFt?: boolean
    } & { _this: ObjectReference }, MethodFault[] | undefined>(
      "QueryFaultToleranceCompatibilityEx", { _this: { attributes: { type: "VirtualMachine" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "MethodFault[]");
  }
  async queryUnownedFiles(): Promise<string[] | undefined> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, string[] | undefined>(
      "QueryUnownedFiles", { _this: { attributes: { type: "VirtualMachine" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "string[]");
  }
  async rebootGuest(): Promise<void> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, void>(
      "RebootGuest", { _this: { attributes: { type: "VirtualMachine" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async reconfigure(args: {
    spec: VirtualMachineConfigSpec
  }): Promise<Task> {
    const result = await this.connection.exec<{
      spec: VirtualMachineConfigSpec
    } & { _this: ObjectReference }, Task>(
      "ReconfigVM_Task", { _this: { attributes: { type: "VirtualMachine" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async refreshStorageInfo(): Promise<void> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, void>(
      "RefreshStorageInfo", { _this: { attributes: { type: "VirtualMachine" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async relocate(args: {
    spec: VirtualMachineRelocateSpec;
    priority?: VirtualMachineMovePriority
  }): Promise<Task> {
    const result = await this.connection.exec<{
      spec: VirtualMachineRelocateSpec;
      priority?: VirtualMachineMovePriority
    } & { _this: ObjectReference }, Task>(
      "RelocateVM_Task", { _this: { attributes: { type: "VirtualMachine" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async removeAllSnapshots(args: {
    consolidate?: boolean
  }): Promise<Task> {
    const result = await this.connection.exec<{
      consolidate?: boolean
    } & { _this: ObjectReference }, Task>(
      "RemoveAllSnapshots_Task", { _this: { attributes: { type: "VirtualMachine" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async resetGuestInformation(): Promise<void> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, void>(
      "ResetGuestInformation", { _this: { attributes: { type: "VirtualMachine" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async reset(): Promise<Task> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, Task>(
      "ResetVM_Task", { _this: { attributes: { type: "VirtualMachine" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async revertToCurrentSnapshot(args: {
    host?: HostSystem;
    suppressPowerOn?: boolean
  }): Promise<Task> {
    const result = await this.connection.exec<{
      host?: HostSystem;
      suppressPowerOn?: boolean
    } & { _this: ObjectReference }, Task>(
      "RevertToCurrentSnapshot_Task", { _this: { attributes: { type: "VirtualMachine" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async sendNMI(): Promise<void> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, void>(
      "SendNMI", { _this: { attributes: { type: "VirtualMachine" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async setDisplayTopology(args: {
    displays: VirtualMachineDisplayTopology[]
  }): Promise<void> {
    const result = await this.connection.exec<{
      displays: VirtualMachineDisplayTopology[]
    } & { _this: ObjectReference }, void>(
      "SetDisplayTopology", { _this: { attributes: { type: "VirtualMachine" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async setScreenResolution(args: {
    width: number;
    height: number
  }): Promise<void> {
    const result = await this.connection.exec<{
      width: number;
      height: number
    } & { _this: ObjectReference }, void>(
      "SetScreenResolution", { _this: { attributes: { type: "VirtualMachine" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async shutdownGuest(): Promise<void> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, void>(
      "ShutdownGuest", { _this: { attributes: { type: "VirtualMachine" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async standbyGuest(): Promise<void> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, void>(
      "StandbyGuest", { _this: { attributes: { type: "VirtualMachine" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async startRecording(args: {
    name: string;
    description?: string
  }): Promise<Task> {
    const result = await this.connection.exec<{
      name: string;
      description?: string
    } & { _this: ObjectReference }, Task>(
      "StartRecording_Task", { _this: { attributes: { type: "VirtualMachine" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async startReplaying(args: {
    replaySnapshot: VirtualMachineSnapshot
  }): Promise<Task> {
    const result = await this.connection.exec<{
      replaySnapshot: VirtualMachineSnapshot
    } & { _this: ObjectReference }, Task>(
      "StartReplaying_Task", { _this: { attributes: { type: "VirtualMachine" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async stopRecording(): Promise<Task> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, Task>(
      "StopRecording_Task", { _this: { attributes: { type: "VirtualMachine" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async stopReplaying(): Promise<Task> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, Task>(
      "StopReplaying_Task", { _this: { attributes: { type: "VirtualMachine" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async suspend(): Promise<Task> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, Task>(
      "SuspendVM_Task", { _this: { attributes: { type: "VirtualMachine" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async terminateFaultTolerantVM(args: {
    vm?: VirtualMachine
  }): Promise<Task> {
    const result = await this.connection.exec<{
      vm?: VirtualMachine
    } & { _this: ObjectReference }, Task>(
      "TerminateFaultTolerantVM_Task", { _this: { attributes: { type: "VirtualMachine" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async terminate(): Promise<void> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, void>(
      "TerminateVM", { _this: { attributes: { type: "VirtualMachine" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async turnOffFaultTolerance(): Promise<Task> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, Task>(
      "TurnOffFaultToleranceForVM_Task", { _this: { attributes: { type: "VirtualMachine" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async unmountToolsInstaller(): Promise<void> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, void>(
      "UnmountToolsInstaller", { _this: { attributes: { type: "VirtualMachine" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async unregister(): Promise<void> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, void>(
      "UnregisterVM", { _this: { attributes: { type: "VirtualMachine" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async upgradeTools(args: {
    installerOptions?: string
  }): Promise<Task> {
    const result = await this.connection.exec<{
      installerOptions?: string
    } & { _this: ObjectReference }, Task>(
      "UpgradeTools_Task", { _this: { attributes: { type: "VirtualMachine" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async upgradeVirtualHardware(args: {
    version?: string
  }): Promise<Task> {
    const result = await this.connection.exec<{
      version?: string
    } & { _this: ObjectReference }, Task>(
      "UpgradeVM_Task", { _this: { attributes: { type: "VirtualMachine" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async reloadFromPath(args: {
    configurationPath: string
  }): Promise<Task> {
    const result = await this.connection.exec<{
      configurationPath: string
    } & { _this: ObjectReference }, Task>(
      "reloadVirtualMachineFromPath_Task", { _this: { attributes: { type: "VirtualMachine" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  };
}
export class AlarmManager extends ManagedObject {
  defaultExpression?: AlarmExpression[];
  description!: AlarmDescription;
  constructor(
    public connection: Connection,
    init?: Partial<AlarmManager>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async acknowledgeAlarm(args: {
    alarm: Alarm;
    entity: ManagedEntity
  }): Promise<void> {
    const result = await this.connection.exec<{
      alarm: Alarm;
      entity: ManagedEntity
    } & { _this: ObjectReference }, void>(
      "AcknowledgeAlarm", { _this: { attributes: { type: "AlarmManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async getAlarmActionsEnabled(args: {
    entity: ManagedEntity
  }): Promise<boolean> {
    const result = await this.connection.exec<{
      entity: ManagedEntity
    } & { _this: ObjectReference }, boolean>(
      "AreAlarmActionsEnabled", { _this: { attributes: { type: "AlarmManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "boolean");
  }
  async clearTriggeredAlarms(args: {
    filter: AlarmFilterSpec
  }): Promise<void> {
    const result = await this.connection.exec<{
      filter: AlarmFilterSpec
    } & { _this: ObjectReference }, void>(
      "ClearTriggeredAlarms", { _this: { attributes: { type: "AlarmManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async create(args: {
    entity: ManagedEntity;
    spec: AlarmSpec
  }): Promise<Alarm> {
    const result = await this.connection.exec<{
      entity: ManagedEntity;
      spec: AlarmSpec
    } & { _this: ObjectReference }, Alarm>(
      "CreateAlarm", { _this: { attributes: { type: "AlarmManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Alarm");
  }
  async disableAlarm(args: {
    alarm: Alarm;
    entity: ManagedEntity
  }): Promise<void> {
    const result = await this.connection.exec<{
      alarm: Alarm;
      entity: ManagedEntity
    } & { _this: ObjectReference }, void>(
      "DisableAlarm", { _this: { attributes: { type: "AlarmManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async enableAlarm(args: {
    alarm: Alarm;
    entity: ManagedEntity
  }): Promise<void> {
    const result = await this.connection.exec<{
      alarm: Alarm;
      entity: ManagedEntity
    } & { _this: ObjectReference }, void>(
      "EnableAlarm", { _this: { attributes: { type: "AlarmManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async setAlarmActionsEnabled(args: {
    entity: ManagedEntity;
    enabled: boolean
  }): Promise<void> {
    const result = await this.connection.exec<{
      entity: ManagedEntity;
      enabled: boolean
    } & { _this: ObjectReference }, void>(
      "EnableAlarmActions", { _this: { attributes: { type: "AlarmManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async getAlarm(args: {
    entity?: ManagedEntity
  }): Promise<Alarm[] | undefined> {
    const result = await this.connection.exec<{
      entity?: ManagedEntity
    } & { _this: ObjectReference }, Alarm[] | undefined>(
      "GetAlarm", { _this: { attributes: { type: "AlarmManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Alarm[]");
  }
  async getAlarmState(args: {
    entity: ManagedEntity
  }): Promise<AlarmState[] | undefined> {
    const result = await this.connection.exec<{
      entity: ManagedEntity
    } & { _this: ObjectReference }, AlarmState[] | undefined>(
      "GetAlarmState", { _this: { attributes: { type: "AlarmManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "AlarmState[]");
  };
}
export class DistributedVirtualPortgroup extends Network {
  key!: string;
  config!: DVPortgroupConfigInfo;
  portKeys?: string[];
  constructor(
    public connection: Connection,
    init?: Partial<DistributedVirtualPortgroup>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async rollback(args: {
    entityBackup?: EntityBackupConfig
  }): Promise<Task | undefined> {
    const result = await this.connection.exec<{
      entityBackup?: EntityBackupConfig
    } & { _this: ObjectReference }, Task | undefined>(
      "DVPortgroupRollback_Task", { _this: { attributes: { type: "DistributedVirtualPortgroup" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async reconfigure(args: {
    spec: DVPortgroupConfigSpec
  }): Promise<Task> {
    const result = await this.connection.exec<{
      spec: DVPortgroupConfigSpec
    } & { _this: ObjectReference }, Task>(
      "ReconfigureDVPortgroup_Task", { _this: { attributes: { type: "DistributedVirtualPortgroup" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  };
}
export class CryptoManagerKmip extends CryptoManager {
  kmipServers?: KmipClusterInfo[];
  constructor(
    public connection: Connection,
    init?: Partial<CryptoManagerKmip>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async generateClientCsr(args: {
    cluster: KeyProviderId
  }): Promise<string> {
    const result = await this.connection.exec<{
      cluster: KeyProviderId
    } & { _this: ObjectReference }, string>(
      "GenerateClientCsr", { _this: { attributes: { type: "CryptoManagerKmip" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "string");
  }
  async generateKey(args: {
    keyProvider?: KeyProviderId
  }): Promise<CryptoKeyResult> {
    const result = await this.connection.exec<{
      keyProvider?: KeyProviderId
    } & { _this: ObjectReference }, CryptoKeyResult>(
      "GenerateKey", { _this: { attributes: { type: "CryptoManagerKmip" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "CryptoKeyResult");
  }
  async generateSelfSignedClientCert(args: {
    cluster: KeyProviderId
  }): Promise<string> {
    const result = await this.connection.exec<{
      cluster: KeyProviderId
    } & { _this: ObjectReference }, string>(
      "GenerateSelfSignedClientCert", { _this: { attributes: { type: "CryptoManagerKmip" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "string");
  }
  async getDefaultKmsCluster(args: {
    entity?: ManagedEntity;
    defaultsToParent?: boolean
  }): Promise<KeyProviderId | undefined> {
    const result = await this.connection.exec<{
      entity?: ManagedEntity;
      defaultsToParent?: boolean
    } & { _this: ObjectReference }, KeyProviderId | undefined>(
      "GetDefaultKmsCluster", { _this: { attributes: { type: "CryptoManagerKmip" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "KeyProviderId");
  }
  async IsKmsClusterActive(args: {
    cluster?: KeyProviderId
  }): Promise<boolean> {
    const result = await this.connection.exec<{
      cluster?: KeyProviderId
    } & { _this: ObjectReference }, boolean>(
      "IsKmsClusterActive", { _this: { attributes: { type: "CryptoManagerKmip" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "boolean");
  }
  async listKmipServers(args: {
    limit?: number
  }): Promise<KmipClusterInfo[] | undefined> {
    const result = await this.connection.exec<{
      limit?: number
    } & { _this: ObjectReference }, KmipClusterInfo[] | undefined>(
      "ListKmipServers", { _this: { attributes: { type: "CryptoManagerKmip" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "KmipClusterInfo[]");
  }
  async listKmsClusters(args: {
    includeKmsServers?: boolean;
    managementTypeFilter?: number;
    statusFilter?: number
  }): Promise<KmipClusterInfo[] | undefined> {
    const result = await this.connection.exec<{
      includeKmsServers?: boolean;
      managementTypeFilter?: number;
      statusFilter?: number
    } & { _this: ObjectReference }, KmipClusterInfo[] | undefined>(
      "ListKmsClusters", { _this: { attributes: { type: "CryptoManagerKmip" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "KmipClusterInfo[]");
  }
  async markDefault(args: {
    clusterId: KeyProviderId
  }): Promise<void> {
    const result = await this.connection.exec<{
      clusterId: KeyProviderId
    } & { _this: ObjectReference }, void>(
      "MarkDefault", { _this: { attributes: { type: "CryptoManagerKmip" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async queryCryptoKeyStatus(args: {
    keyIds?: CryptoKeyId[];
    checkKeyBitMap: number
  }): Promise<CryptoManagerKmipCryptoKeyStatus[] | undefined> {
    const result = await this.connection.exec<{
      keyIds?: CryptoKeyId[];
      checkKeyBitMap: number
    } & { _this: ObjectReference }, CryptoManagerKmipCryptoKeyStatus[] | undefined>(
      "QueryCryptoKeyStatus", { _this: { attributes: { type: "CryptoManagerKmip" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "CryptoManagerKmipCryptoKeyStatus[]");
  }
  async registerKmipServer(args: {
    server: KmipServerSpec
  }): Promise<void> {
    const result = await this.connection.exec<{
      server: KmipServerSpec
    } & { _this: ObjectReference }, void>(
      "RegisterKmipServer", { _this: { attributes: { type: "CryptoManagerKmip" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async registerKmsCluster(args: {
    clusterId: KeyProviderId;
    managementType?: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      clusterId: KeyProviderId;
      managementType?: string
    } & { _this: ObjectReference }, void>(
      "RegisterKmsCluster", { _this: { attributes: { type: "CryptoManagerKmip" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async removeKmipServer(args: {
    clusterId: KeyProviderId;
    serverName: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      clusterId: KeyProviderId;
      serverName: string
    } & { _this: ObjectReference }, void>(
      "RemoveKmipServer", { _this: { attributes: { type: "CryptoManagerKmip" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async retrieveClientCert(args: {
    cluster: KeyProviderId
  }): Promise<string> {
    const result = await this.connection.exec<{
      cluster: KeyProviderId
    } & { _this: ObjectReference }, string>(
      "RetrieveClientCert", { _this: { attributes: { type: "CryptoManagerKmip" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "string");
  }
  async retrieveClientCsr(args: {
    cluster: KeyProviderId
  }): Promise<string> {
    const result = await this.connection.exec<{
      cluster: KeyProviderId
    } & { _this: ObjectReference }, string>(
      "RetrieveClientCsr", { _this: { attributes: { type: "CryptoManagerKmip" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "string");
  }
  async retrieveKmipServerCert(args: {
    keyProvider: KeyProviderId;
    server: KmipServerInfo
  }): Promise<CryptoManagerKmipServerCertInfo> {
    const result = await this.connection.exec<{
      keyProvider: KeyProviderId;
      server: KmipServerInfo
    } & { _this: ObjectReference }, CryptoManagerKmipServerCertInfo>(
      "RetrieveKmipServerCert", { _this: { attributes: { type: "CryptoManagerKmip" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "CryptoManagerKmipServerCertInfo");
  }
  async retrieveKmipServersStatus(args: {
    clusters?: KmipClusterInfo[]
  }): Promise<Task | undefined> {
    const result = await this.connection.exec<{
      clusters?: KmipClusterInfo[]
    } & { _this: ObjectReference }, Task | undefined>(
      "RetrieveKmipServersStatus_Task", { _this: { attributes: { type: "CryptoManagerKmip" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async retrieveSelfSignedClientCert(args: {
    cluster: KeyProviderId
  }): Promise<string> {
    const result = await this.connection.exec<{
      cluster: KeyProviderId
    } & { _this: ObjectReference }, string>(
      "RetrieveSelfSignedClientCert", { _this: { attributes: { type: "CryptoManagerKmip" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "string");
  }
  async setDefaultKmsCluster(args: {
    entity?: ManagedEntity;
    clusterId?: KeyProviderId
  }): Promise<void> {
    const result = await this.connection.exec<{
      entity?: ManagedEntity;
      clusterId?: KeyProviderId
    } & { _this: ObjectReference }, void>(
      "SetDefaultKmsCluster", { _this: { attributes: { type: "CryptoManagerKmip" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async unregisterKmsCluster(args: {
    clusterId: KeyProviderId
  }): Promise<void> {
    const result = await this.connection.exec<{
      clusterId: KeyProviderId
    } & { _this: ObjectReference }, void>(
      "UnregisterKmsCluster", { _this: { attributes: { type: "CryptoManagerKmip" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async updateKmipServer(args: {
    server: KmipServerSpec
  }): Promise<void> {
    const result = await this.connection.exec<{
      server: KmipServerSpec
    } & { _this: ObjectReference }, void>(
      "UpdateKmipServer", { _this: { attributes: { type: "CryptoManagerKmip" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async updateKmsSignedCsrClientCert(args: {
    cluster: KeyProviderId;
    certificate: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      cluster: KeyProviderId;
      certificate: string
    } & { _this: ObjectReference }, void>(
      "UpdateKmsSignedCsrClientCert", { _this: { attributes: { type: "CryptoManagerKmip" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async updateSelfSignedClientCert(args: {
    cluster: KeyProviderId;
    certificate: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      cluster: KeyProviderId;
      certificate: string
    } & { _this: ObjectReference }, void>(
      "UpdateSelfSignedClientCert", { _this: { attributes: { type: "CryptoManagerKmip" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async uploadClientCert(args: {
    cluster: KeyProviderId;
    certificate: string;
    privateKey: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      cluster: KeyProviderId;
      certificate: string;
      privateKey: string
    } & { _this: ObjectReference }, void>(
      "UploadClientCert", { _this: { attributes: { type: "CryptoManagerKmip" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async uploadKmipServerCert(args: {
    cluster: KeyProviderId;
    certificate: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      cluster: KeyProviderId;
      certificate: string
    } & { _this: ObjectReference }, void>(
      "UploadKmipServerCert", { _this: { attributes: { type: "CryptoManagerKmip" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  };
}
export class HostActiveDirectoryAuthentication extends HostDirectoryStore {
  
  constructor(
    public connection: Connection,
    init?: Partial<HostActiveDirectoryAuthentication>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async disableSmartCardAuthentication(): Promise<void> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, void>(
      "DisableSmartCardAuthentication", { _this: { attributes: { type: "HostActiveDirectoryAuthentication" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async enableSmartCardAuthentication(): Promise<void> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, void>(
      "EnableSmartCardAuthentication", { _this: { attributes: { type: "HostActiveDirectoryAuthentication" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async importCertificateForCAM(args: {
    certPath: string;
    camServer: string
  }): Promise<Task> {
    const result = await this.connection.exec<{
      certPath: string;
      camServer: string
    } & { _this: ObjectReference }, Task>(
      "ImportCertificateForCAM_Task", { _this: { attributes: { type: "HostActiveDirectoryAuthentication" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async installSmartCardTrustAnchor(args: {
    cert: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      cert: string
    } & { _this: ObjectReference }, void>(
      "InstallSmartCardTrustAnchor", { _this: { attributes: { type: "HostActiveDirectoryAuthentication" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async joinDomainWithCAM(args: {
    domainName: string;
    camServer: string
  }): Promise<Task> {
    const result = await this.connection.exec<{
      domainName: string;
      camServer: string
    } & { _this: ObjectReference }, Task>(
      "JoinDomainWithCAM_Task", { _this: { attributes: { type: "HostActiveDirectoryAuthentication" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async joinDomain(args: {
    domainName: string;
    userName: string;
    password: string
  }): Promise<Task> {
    const result = await this.connection.exec<{
      domainName: string;
      userName: string;
      password: string
    } & { _this: ObjectReference }, Task>(
      "JoinDomain_Task", { _this: { attributes: { type: "HostActiveDirectoryAuthentication" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async leaveCurrentDomain(args: {
    force: boolean
  }): Promise<Task> {
    const result = await this.connection.exec<{
      force: boolean
    } & { _this: ObjectReference }, Task>(
      "LeaveCurrentDomain_Task", { _this: { attributes: { type: "HostActiveDirectoryAuthentication" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async listSmartCardTrustAnchors(): Promise<string[] | undefined> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, string[] | undefined>(
      "ListSmartCardTrustAnchors", { _this: { attributes: { type: "HostActiveDirectoryAuthentication" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "string[]");
  }
  async removeSmartCardTrustAnchor(args: {
    issuer: string;
    serial: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      issuer: string;
      serial: string
    } & { _this: ObjectReference }, void>(
      "RemoveSmartCardTrustAnchor", { _this: { attributes: { type: "HostActiveDirectoryAuthentication" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async removeSmartCardTrustAnchorByFingerprint(args: {
    fingerprint: string;
    digest: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      fingerprint: string;
      digest: string
    } & { _this: ObjectReference }, void>(
      "RemoveSmartCardTrustAnchorByFingerprint", { _this: { attributes: { type: "HostActiveDirectoryAuthentication" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async replaceSmartCardTrustAnchors(args: {
    certs?: string[]
  }): Promise<void> {
    const result = await this.connection.exec<{
      certs?: string[]
    } & { _this: ObjectReference }, void>(
      "ReplaceSmartCardTrustAnchors", { _this: { attributes: { type: "HostActiveDirectoryAuthentication" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  };
}
export class HostDatastoreSystem extends ManagedObject {
  datastore?: Datastore[];
  capabilities!: HostDatastoreSystemCapabilities;
  constructor(
    public connection: Connection,
    init?: Partial<HostDatastoreSystem>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async configureDatastorePrincipal(args: {
    userName: string;
    password?: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      userName: string;
      password?: string
    } & { _this: ObjectReference }, void>(
      "ConfigureDatastorePrincipal", { _this: { attributes: { type: "HostDatastoreSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async createLocalDatastore(args: {
    name: string;
    path: string
  }): Promise<Datastore> {
    const result = await this.connection.exec<{
      name: string;
      path: string
    } & { _this: ObjectReference }, Datastore>(
      "CreateLocalDatastore", { _this: { attributes: { type: "HostDatastoreSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Datastore");
  }
  async createNasDatastore(args: {
    spec: HostNasVolumeSpec
  }): Promise<Datastore> {
    const result = await this.connection.exec<{
      spec: HostNasVolumeSpec
    } & { _this: ObjectReference }, Datastore>(
      "CreateNasDatastore", { _this: { attributes: { type: "HostDatastoreSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Datastore");
  }
  async createVmfsDatastore(args: {
    spec: VmfsDatastoreCreateSpec
  }): Promise<Datastore> {
    const result = await this.connection.exec<{
      spec: VmfsDatastoreCreateSpec
    } & { _this: ObjectReference }, Datastore>(
      "CreateVmfsDatastore", { _this: { attributes: { type: "HostDatastoreSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Datastore");
  }
  async createVvolDatastore(args: {
    spec: HostDatastoreSystemVvolDatastoreSpec
  }): Promise<Datastore> {
    const result = await this.connection.exec<{
      spec: HostDatastoreSystemVvolDatastoreSpec
    } & { _this: ObjectReference }, Datastore>(
      "CreateVvolDatastore", { _this: { attributes: { type: "HostDatastoreSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Datastore");
  }
  async disableClusteredVmdkSupport(args: {
    datastore: Datastore
  }): Promise<void> {
    const result = await this.connection.exec<{
      datastore: Datastore
    } & { _this: ObjectReference }, void>(
      "DisableClusteredVmdkSupport", { _this: { attributes: { type: "HostDatastoreSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async enableClusteredVmdkSupport(args: {
    datastore: Datastore
  }): Promise<void> {
    const result = await this.connection.exec<{
      datastore: Datastore
    } & { _this: ObjectReference }, void>(
      "EnableClusteredVmdkSupport", { _this: { attributes: { type: "HostDatastoreSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async expandVmfsDatastore(args: {
    datastore: Datastore;
    spec: VmfsDatastoreExpandSpec
  }): Promise<Datastore> {
    const result = await this.connection.exec<{
      datastore: Datastore;
      spec: VmfsDatastoreExpandSpec
    } & { _this: ObjectReference }, Datastore>(
      "ExpandVmfsDatastore", { _this: { attributes: { type: "HostDatastoreSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Datastore");
  }
  async extendVmfsDatastore(args: {
    datastore: Datastore;
    spec: VmfsDatastoreExtendSpec
  }): Promise<Datastore> {
    const result = await this.connection.exec<{
      datastore: Datastore;
      spec: VmfsDatastoreExtendSpec
    } & { _this: ObjectReference }, Datastore>(
      "ExtendVmfsDatastore", { _this: { attributes: { type: "HostDatastoreSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Datastore");
  }
  async queryAvailableDisksForVmfs(args: {
    datastore?: Datastore
  }): Promise<HostScsiDisk[] | undefined> {
    const result = await this.connection.exec<{
      datastore?: Datastore
    } & { _this: ObjectReference }, HostScsiDisk[] | undefined>(
      "QueryAvailableDisksForVmfs", { _this: { attributes: { type: "HostDatastoreSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "HostScsiDisk[]");
  }
  async queryUnresolvedVmfsVolumes(): Promise<HostUnresolvedVmfsVolume[] | undefined> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, HostUnresolvedVmfsVolume[] | undefined>(
      "QueryUnresolvedVmfsVolumes", { _this: { attributes: { type: "HostDatastoreSystem" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "HostUnresolvedVmfsVolume[]");
  }
  async queryVmfsDatastoreCreateOptions(args: {
    devicePath: string;
    vmfsMajorVersion?: number
  }): Promise<VmfsDatastoreOption[] | undefined> {
    const result = await this.connection.exec<{
      devicePath: string;
      vmfsMajorVersion?: number
    } & { _this: ObjectReference }, VmfsDatastoreOption[] | undefined>(
      "QueryVmfsDatastoreCreateOptions", { _this: { attributes: { type: "HostDatastoreSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "VmfsDatastoreOption[]");
  }
  async queryVmfsDatastoreExpandOptions(args: {
    datastore: Datastore
  }): Promise<VmfsDatastoreOption[] | undefined> {
    const result = await this.connection.exec<{
      datastore: Datastore
    } & { _this: ObjectReference }, VmfsDatastoreOption[] | undefined>(
      "QueryVmfsDatastoreExpandOptions", { _this: { attributes: { type: "HostDatastoreSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "VmfsDatastoreOption[]");
  }
  async queryVmfsDatastoreExtendOptions(args: {
    datastore: Datastore;
    devicePath: string;
    suppressExpandCandidates?: boolean
  }): Promise<VmfsDatastoreOption[] | undefined> {
    const result = await this.connection.exec<{
      datastore: Datastore;
      devicePath: string;
      suppressExpandCandidates?: boolean
    } & { _this: ObjectReference }, VmfsDatastoreOption[] | undefined>(
      "QueryVmfsDatastoreExtendOptions", { _this: { attributes: { type: "HostDatastoreSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "VmfsDatastoreOption[]");
  }
  async removeDatastore(args: {
    datastore: Datastore
  }): Promise<void> {
    const result = await this.connection.exec<{
      datastore: Datastore
    } & { _this: ObjectReference }, void>(
      "RemoveDatastore", { _this: { attributes: { type: "HostDatastoreSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async removeDatastoreEx(args: {
    datastore: Datastore[]
  }): Promise<Task> {
    const result = await this.connection.exec<{
      datastore: Datastore[]
    } & { _this: ObjectReference }, Task>(
      "RemoveDatastoreEx_Task", { _this: { attributes: { type: "HostDatastoreSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async resignatureUnresolvedVmfsVolume(args: {
    resolutionSpec: HostUnresolvedVmfsResignatureSpec
  }): Promise<Task | undefined> {
    const result = await this.connection.exec<{
      resolutionSpec: HostUnresolvedVmfsResignatureSpec
    } & { _this: ObjectReference }, Task | undefined>(
      "ResignatureUnresolvedVmfsVolume_Task", { _this: { attributes: { type: "HostDatastoreSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async updateLocalSwapDatastore(args: {
    datastore?: Datastore
  }): Promise<void> {
    const result = await this.connection.exec<{
      datastore?: Datastore
    } & { _this: ObjectReference }, void>(
      "UpdateLocalSwapDatastore", { _this: { attributes: { type: "HostDatastoreSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  };
}
export class HostFirewallSystem extends ExtensibleManagedObject {
  firewallInfo?: HostFirewallInfo;
  constructor(
    public connection: Connection,
    init?: Partial<HostFirewallSystem>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async disableRuleset(args: {
    id: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      id: string
    } & { _this: ObjectReference }, void>(
      "DisableRuleset", { _this: { attributes: { type: "HostFirewallSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async enableRuleset(args: {
    id: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      id: string
    } & { _this: ObjectReference }, void>(
      "EnableRuleset", { _this: { attributes: { type: "HostFirewallSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async refresh(): Promise<void> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, void>(
      "RefreshFirewall", { _this: { attributes: { type: "HostFirewallSystem" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async updateDefaultPolicy(args: {
    defaultPolicy: HostFirewallDefaultPolicy
  }): Promise<void> {
    const result = await this.connection.exec<{
      defaultPolicy: HostFirewallDefaultPolicy
    } & { _this: ObjectReference }, void>(
      "UpdateDefaultPolicy", { _this: { attributes: { type: "HostFirewallSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async updateRuleset(args: {
    id: string;
    spec: HostFirewallRulesetRulesetSpec
  }): Promise<void> {
    const result = await this.connection.exec<{
      id: string;
      spec: HostFirewallRulesetRulesetSpec
    } & { _this: ObjectReference }, void>(
      "UpdateRuleset", { _this: { attributes: { type: "HostFirewallSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  };
}
export class HostNetworkSystem extends ExtensibleManagedObject {
  capabilities?: HostNetCapabilities;
  networkInfo?: HostNetworkInfo;
  offloadCapabilities?: HostNetOffloadCapabilities;
  networkConfig?: HostNetworkConfig;
  dnsConfig?: HostDnsConfig;
  ipRouteConfig?: HostIpRouteConfig;
  consoleIpRouteConfig?: HostIpRouteConfig;
  constructor(
    public connection: Connection,
    init?: Partial<HostNetworkSystem>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async addPortGroup(args: {
    portgrp: HostPortGroupSpec
  }): Promise<void> {
    const result = await this.connection.exec<{
      portgrp: HostPortGroupSpec
    } & { _this: ObjectReference }, void>(
      "AddPortGroup", { _this: { attributes: { type: "HostNetworkSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async addServiceConsoleVirtualNic(args: {
    portgroup: string;
    nic: HostVirtualNicSpec
  }): Promise<string> {
    const result = await this.connection.exec<{
      portgroup: string;
      nic: HostVirtualNicSpec
    } & { _this: ObjectReference }, string>(
      "AddServiceConsoleVirtualNic", { _this: { attributes: { type: "HostNetworkSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "string");
  }
  async addVirtualNic(args: {
    portgroup: string;
    nic: HostVirtualNicSpec
  }): Promise<string> {
    const result = await this.connection.exec<{
      portgroup: string;
      nic: HostVirtualNicSpec
    } & { _this: ObjectReference }, string>(
      "AddVirtualNic", { _this: { attributes: { type: "HostNetworkSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "string");
  }
  async addVirtualSwitch(args: {
    vswitchName: string;
    spec?: HostVirtualSwitchSpec
  }): Promise<void> {
    const result = await this.connection.exec<{
      vswitchName: string;
      spec?: HostVirtualSwitchSpec
    } & { _this: ObjectReference }, void>(
      "AddVirtualSwitch", { _this: { attributes: { type: "HostNetworkSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async queryNetworkHint(args: {
    device?: string[]
  }): Promise<PhysicalNicHintInfo[] | undefined> {
    const result = await this.connection.exec<{
      device?: string[]
    } & { _this: ObjectReference }, PhysicalNicHintInfo[] | undefined>(
      "QueryNetworkHint", { _this: { attributes: { type: "HostNetworkSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "PhysicalNicHintInfo[]");
  }
  async refresh(): Promise<void> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, void>(
      "RefreshNetworkSystem", { _this: { attributes: { type: "HostNetworkSystem" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async removePortGroup(args: {
    pgName: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      pgName: string
    } & { _this: ObjectReference }, void>(
      "RemovePortGroup", { _this: { attributes: { type: "HostNetworkSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async removeServiceConsoleVirtualNic(args: {
    device: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      device: string
    } & { _this: ObjectReference }, void>(
      "RemoveServiceConsoleVirtualNic", { _this: { attributes: { type: "HostNetworkSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async removeVirtualNic(args: {
    device: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      device: string
    } & { _this: ObjectReference }, void>(
      "RemoveVirtualNic", { _this: { attributes: { type: "HostNetworkSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async removeVirtualSwitch(args: {
    vswitchName: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      vswitchName: string
    } & { _this: ObjectReference }, void>(
      "RemoveVirtualSwitch", { _this: { attributes: { type: "HostNetworkSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async restartServiceConsoleVirtualNic(args: {
    device: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      device: string
    } & { _this: ObjectReference }, void>(
      "RestartServiceConsoleVirtualNic", { _this: { attributes: { type: "HostNetworkSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async updateConsoleIpRouteConfig(args: {
    config: HostIpRouteConfig
  }): Promise<void> {
    const result = await this.connection.exec<{
      config: HostIpRouteConfig
    } & { _this: ObjectReference }, void>(
      "UpdateConsoleIpRouteConfig", { _this: { attributes: { type: "HostNetworkSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async updateDnsConfig(args: {
    config: HostDnsConfig
  }): Promise<void> {
    const result = await this.connection.exec<{
      config: HostDnsConfig
    } & { _this: ObjectReference }, void>(
      "UpdateDnsConfig", { _this: { attributes: { type: "HostNetworkSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async updateIpRouteConfig(args: {
    config: HostIpRouteConfig
  }): Promise<void> {
    const result = await this.connection.exec<{
      config: HostIpRouteConfig
    } & { _this: ObjectReference }, void>(
      "UpdateIpRouteConfig", { _this: { attributes: { type: "HostNetworkSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async updateIpRouteTableConfig(args: {
    config: HostIpRouteTableConfig
  }): Promise<void> {
    const result = await this.connection.exec<{
      config: HostIpRouteTableConfig
    } & { _this: ObjectReference }, void>(
      "UpdateIpRouteTableConfig", { _this: { attributes: { type: "HostNetworkSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async updateNetworkConfig(args: {
    config: HostNetworkConfig;
    changeMode: string
  }): Promise<HostNetworkConfigResult> {
    const result = await this.connection.exec<{
      config: HostNetworkConfig;
      changeMode: string
    } & { _this: ObjectReference }, HostNetworkConfigResult>(
      "UpdateNetworkConfig", { _this: { attributes: { type: "HostNetworkSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "HostNetworkConfigResult");
  }
  async updatePhysicalNicLinkSpeed(args: {
    device: string;
    linkSpeed?: PhysicalNicLinkInfo
  }): Promise<void> {
    const result = await this.connection.exec<{
      device: string;
      linkSpeed?: PhysicalNicLinkInfo
    } & { _this: ObjectReference }, void>(
      "UpdatePhysicalNicLinkSpeed", { _this: { attributes: { type: "HostNetworkSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async updatePortGroup(args: {
    pgName: string;
    portgrp: HostPortGroupSpec
  }): Promise<void> {
    const result = await this.connection.exec<{
      pgName: string;
      portgrp: HostPortGroupSpec
    } & { _this: ObjectReference }, void>(
      "UpdatePortGroup", { _this: { attributes: { type: "HostNetworkSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async updateServiceConsoleVirtualNic(args: {
    device: string;
    nic: HostVirtualNicSpec
  }): Promise<void> {
    const result = await this.connection.exec<{
      device: string;
      nic: HostVirtualNicSpec
    } & { _this: ObjectReference }, void>(
      "UpdateServiceConsoleVirtualNic", { _this: { attributes: { type: "HostNetworkSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async updateVirtualNic(args: {
    device: string;
    nic: HostVirtualNicSpec
  }): Promise<void> {
    const result = await this.connection.exec<{
      device: string;
      nic: HostVirtualNicSpec
    } & { _this: ObjectReference }, void>(
      "UpdateVirtualNic", { _this: { attributes: { type: "HostNetworkSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async updateVirtualSwitch(args: {
    vswitchName: string;
    spec: HostVirtualSwitchSpec
  }): Promise<void> {
    const result = await this.connection.exec<{
      vswitchName: string;
      spec: HostVirtualSwitchSpec
    } & { _this: ObjectReference }, void>(
      "UpdateVirtualSwitch", { _this: { attributes: { type: "HostNetworkSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  };
}
export class HostVFlashManager extends ManagedObject {
  vFlashConfigInfo?: HostVFlashManagerVFlashConfigInfo;
  constructor(
    public connection: Connection,
    init?: Partial<HostVFlashManager>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async configureVFlashResourceEx(args: {
    devicePath?: string[]
  }): Promise<Task | undefined> {
    const result = await this.connection.exec<{
      devicePath?: string[]
    } & { _this: ObjectReference }, Task | undefined>(
      "ConfigureVFlashResourceEx_Task", { _this: { attributes: { type: "HostVFlashManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async configureHostVFlashCache(args: {
    spec: HostVFlashManagerVFlashCacheConfigSpec
  }): Promise<void> {
    const result = await this.connection.exec<{
      spec: HostVFlashManagerVFlashCacheConfigSpec
    } & { _this: ObjectReference }, void>(
      "HostConfigVFlashCache", { _this: { attributes: { type: "HostVFlashManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async configureVFlashResource(args: {
    spec: HostVFlashManagerVFlashResourceConfigSpec
  }): Promise<void> {
    const result = await this.connection.exec<{
      spec: HostVFlashManagerVFlashResourceConfigSpec
    } & { _this: ObjectReference }, void>(
      "HostConfigureVFlashResource", { _this: { attributes: { type: "HostVFlashManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async getVFlashModuleDefaultConfig(args: {
    vFlashModule: string
  }): Promise<VirtualDiskVFlashCacheConfigInfo> {
    const result = await this.connection.exec<{
      vFlashModule: string
    } & { _this: ObjectReference }, VirtualDiskVFlashCacheConfigInfo>(
      "HostGetVFlashModuleDefaultConfig", { _this: { attributes: { type: "HostVFlashManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "VirtualDiskVFlashCacheConfigInfo");
  }
  async removeVFlashResource(): Promise<void> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, void>(
      "HostRemoveVFlashResource", { _this: { attributes: { type: "HostVFlashManager" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  };
}
export class HostProfile extends Profile {
  validationState?: string;
  validationStateUpdateTime?: Date;
  validationFailureInfo?: HostProfileValidationFailureInfo;
  referenceHost?: HostSystem;
  constructor(
    public connection: Connection,
    init?: Partial<HostProfile>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async execute(args: {
    host: HostSystem;
    deferredParam?: ProfileDeferredPolicyOptionParameter[]
  }): Promise<ProfileExecuteResult> {
    const result = await this.connection.exec<{
      host: HostSystem;
      deferredParam?: ProfileDeferredPolicyOptionParameter[]
    } & { _this: ObjectReference }, ProfileExecuteResult>(
      "ExecuteHostProfile", { _this: { attributes: { type: "HostProfile" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "ProfileExecuteResult");
  }
  async ResetValidationState(): Promise<void> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, void>(
      "HostProfileResetValidationState", { _this: { attributes: { type: "HostProfile" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async update(args: {
    config: HostProfileConfigSpec
  }): Promise<void> {
    const result = await this.connection.exec<{
      config: HostProfileConfigSpec
    } & { _this: ObjectReference }, void>(
      "UpdateHostProfile", { _this: { attributes: { type: "HostProfile" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async updateReferenceHost(args: {
    host?: HostSystem
  }): Promise<void> {
    const result = await this.connection.exec<{
      host?: HostSystem
    } & { _this: ObjectReference }, void>(
      "UpdateReferenceHost", { _this: { attributes: { type: "HostProfile" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  };
}
export class HostProfileManager extends ProfileManager {
  
  constructor(
    public connection: Connection,
    init?: Partial<HostProfileManager>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async applyEntitiesConfiguration(args: {
    applyConfigSpecs?: ApplyHostProfileConfigurationSpec[]
  }): Promise<Task | undefined> {
    const result = await this.connection.exec<{
      applyConfigSpecs?: ApplyHostProfileConfigurationSpec[]
    } & { _this: ObjectReference }, Task | undefined>(
      "ApplyEntitiesConfig_Task", { _this: { attributes: { type: "HostProfileManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async applyHostConfiguration(args: {
    host: HostSystem;
    configSpec: HostConfigSpec;
    userInput?: ProfileDeferredPolicyOptionParameter[]
  }): Promise<Task> {
    const result = await this.connection.exec<{
      host: HostSystem;
      configSpec: HostConfigSpec;
      userInput?: ProfileDeferredPolicyOptionParameter[]
    } & { _this: ObjectReference }, Task>(
      "ApplyHostConfig_Task", { _this: { attributes: { type: "HostProfileManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async checkAnswerFileStatus(args: {
    host: HostSystem[]
  }): Promise<Task | undefined> {
    const result = await this.connection.exec<{
      host: HostSystem[]
    } & { _this: ObjectReference }, Task | undefined>(
      "CheckAnswerFileStatus_Task", { _this: { attributes: { type: "HostProfileManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async compositeProfile(args: {
    source: Profile;
    targets?: Profile[];
    toBeMerged?: HostApplyProfile;
    toBeReplacedWith?: HostApplyProfile;
    toBeDeleted?: HostApplyProfile;
    enableStatusToBeCopied?: HostApplyProfile
  }): Promise<Task | undefined> {
    const result = await this.connection.exec<{
      source: Profile;
      targets?: Profile[];
      toBeMerged?: HostApplyProfile;
      toBeReplacedWith?: HostApplyProfile;
      toBeDeleted?: HostApplyProfile;
      enableStatusToBeCopied?: HostApplyProfile
    } & { _this: ObjectReference }, Task | undefined>(
      "CompositeHostProfile_Task", { _this: { attributes: { type: "HostProfileManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async createDefaultProfile(args: {
    profileType: string;
    profileTypeName?: string;
    profile?: Profile
  }): Promise<ApplyProfile> {
    const result = await this.connection.exec<{
      profileType: string;
      profileTypeName?: string;
      profile?: Profile
    } & { _this: ObjectReference }, ApplyProfile>(
      "CreateDefaultProfile", { _this: { attributes: { type: "HostProfileManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "ApplyProfile");
  }
  async exportAnswerFile(args: {
    host: HostSystem
  }): Promise<Task> {
    const result = await this.connection.exec<{
      host: HostSystem
    } & { _this: ObjectReference }, Task>(
      "ExportAnswerFile_Task", { _this: { attributes: { type: "HostProfileManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async generateConfigTaskList(args: {
    configSpec: HostConfigSpec;
    host: HostSystem
  }): Promise<HostProfileManagerConfigTaskList> {
    const result = await this.connection.exec<{
      configSpec: HostConfigSpec;
      host: HostSystem
    } & { _this: ObjectReference }, HostProfileManagerConfigTaskList>(
      "GenerateConfigTaskList", { _this: { attributes: { type: "HostProfileManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "HostProfileManagerConfigTaskList");
  }
  async generateHostConfigTaskSpec(args: {
    hostsInfo?: StructuredCustomizations[]
  }): Promise<Task | undefined> {
    const result = await this.connection.exec<{
      hostsInfo?: StructuredCustomizations[]
    } & { _this: ObjectReference }, Task | undefined>(
      "GenerateHostConfigTaskSpec_Task", { _this: { attributes: { type: "HostProfileManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async generateTaskList(args: {
    configSpec: HostConfigSpec;
    host: HostSystem
  }): Promise<Task | undefined> {
    const result = await this.connection.exec<{
      configSpec: HostConfigSpec;
      host: HostSystem
    } & { _this: ObjectReference }, Task | undefined>(
      "GenerateHostProfileTaskList_Task", { _this: { attributes: { type: "HostProfileManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async queryAnswerFileStatus(args: {
    host: HostSystem[]
  }): Promise<AnswerFileStatusResult[] | undefined> {
    const result = await this.connection.exec<{
      host: HostSystem[]
    } & { _this: ObjectReference }, AnswerFileStatusResult[] | undefined>(
      "QueryAnswerFileStatus", { _this: { attributes: { type: "HostProfileManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "AnswerFileStatusResult[]");
  }
  async queryProfileMetadata(args: {
    profileName?: string[];
    profile?: Profile
  }): Promise<ProfileMetadata[] | undefined> {
    const result = await this.connection.exec<{
      profileName?: string[];
      profile?: Profile
    } & { _this: ObjectReference }, ProfileMetadata[] | undefined>(
      "QueryHostProfileMetadata", { _this: { attributes: { type: "HostProfileManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "ProfileMetadata[]");
  }
  async queryProfileStructure(args: {
    profile?: Profile
  }): Promise<ProfileProfileStructure> {
    const result = await this.connection.exec<{
      profile?: Profile
    } & { _this: ObjectReference }, ProfileProfileStructure>(
      "QueryProfileStructure", { _this: { attributes: { type: "HostProfileManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "ProfileProfileStructure");
  }
  async retrieveAnswerFile(args: {
    host: HostSystem
  }): Promise<AnswerFile | undefined> {
    const result = await this.connection.exec<{
      host: HostSystem
    } & { _this: ObjectReference }, AnswerFile | undefined>(
      "RetrieveAnswerFile", { _this: { attributes: { type: "HostProfileManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "AnswerFile");
  }
  async retrieveAnswerFileForProfile(args: {
    host: HostSystem;
    applyProfile: HostApplyProfile
  }): Promise<AnswerFile | undefined> {
    const result = await this.connection.exec<{
      host: HostSystem;
      applyProfile: HostApplyProfile
    } & { _this: ObjectReference }, AnswerFile | undefined>(
      "RetrieveAnswerFileForProfile", { _this: { attributes: { type: "HostProfileManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "AnswerFile");
  }
  async retrieveHostCustomizations(args: {
    hosts?: HostSystem[]
  }): Promise<StructuredCustomizations[] | undefined> {
    const result = await this.connection.exec<{
      hosts?: HostSystem[]
    } & { _this: ObjectReference }, StructuredCustomizations[] | undefined>(
      "RetrieveHostCustomizations", { _this: { attributes: { type: "HostProfileManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "StructuredCustomizations[]");
  }
  async retrieveHostCustomizationsForProfile(args: {
    hosts?: HostSystem[];
    applyProfile: HostApplyProfile
  }): Promise<StructuredCustomizations[] | undefined> {
    const result = await this.connection.exec<{
      hosts?: HostSystem[];
      applyProfile: HostApplyProfile
    } & { _this: ObjectReference }, StructuredCustomizations[] | undefined>(
      "RetrieveHostCustomizationsForProfile", { _this: { attributes: { type: "HostProfileManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "StructuredCustomizations[]");
  }
  async updateAnswerFile(args: {
    host: HostSystem;
    configSpec: AnswerFileCreateSpec
  }): Promise<Task> {
    const result = await this.connection.exec<{
      host: HostSystem;
      configSpec: AnswerFileCreateSpec
    } & { _this: ObjectReference }, Task>(
      "UpdateAnswerFile_Task", { _this: { attributes: { type: "HostProfileManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async updateHostCustomizations(args: {
    hostToConfigSpecMap?: HostProfileManagerHostToConfigSpecMap[]
  }): Promise<Task | undefined> {
    const result = await this.connection.exec<{
      hostToConfigSpecMap?: HostProfileManagerHostToConfigSpecMap[]
    } & { _this: ObjectReference }, Task | undefined>(
      "UpdateHostCustomizations_Task", { _this: { attributes: { type: "HostProfileManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async validateComposition(args: {
    source: Profile;
    targets?: Profile[];
    toBeMerged?: HostApplyProfile;
    toReplaceWith?: HostApplyProfile;
    toBeDeleted?: HostApplyProfile;
    enableStatusToBeCopied?: HostApplyProfile;
    errorOnly?: boolean
  }): Promise<Task | undefined> {
    const result = await this.connection.exec<{
      source: Profile;
      targets?: Profile[];
      toBeMerged?: HostApplyProfile;
      toReplaceWith?: HostApplyProfile;
      toBeDeleted?: HostApplyProfile;
      enableStatusToBeCopied?: HostApplyProfile;
      errorOnly?: boolean
    } & { _this: ObjectReference }, Task | undefined>(
      "ValidateHostProfileComposition_Task", { _this: { attributes: { type: "HostProfileManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  };
}
export class ManagedObjectView extends View {
  view?: ManagedObject[];
  constructor(
    public connection: Connection,
    init?: Partial<ManagedObjectView>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  
}
export class VirtualMachineProvisioningChecker extends ManagedObject {
  
  constructor(
    public connection: Connection,
    init?: Partial<VirtualMachineProvisioningChecker>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async checkClone(args: {
    vm: VirtualMachine;
    folder: Folder;
    name: string;
    spec: VirtualMachineCloneSpec;
    testType?: string[]
  }): Promise<Task> {
    const result = await this.connection.exec<{
      vm: VirtualMachine;
      folder: Folder;
      name: string;
      spec: VirtualMachineCloneSpec;
      testType?: string[]
    } & { _this: ObjectReference }, Task>(
      "CheckClone_Task", { _this: { attributes: { type: "VirtualMachineProvisioningChecker" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async checkInstantClone(args: {
    vm: VirtualMachine;
    spec: VirtualMachineInstantCloneSpec;
    testType?: string[]
  }): Promise<Task | undefined> {
    const result = await this.connection.exec<{
      vm: VirtualMachine;
      spec: VirtualMachineInstantCloneSpec;
      testType?: string[]
    } & { _this: ObjectReference }, Task | undefined>(
      "CheckInstantClone_Task", { _this: { attributes: { type: "VirtualMachineProvisioningChecker" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async checkMigrate(args: {
    vm: VirtualMachine;
    host?: HostSystem;
    pool?: ResourcePool;
    state?: VirtualMachinePowerState;
    testType?: string[]
  }): Promise<Task> {
    const result = await this.connection.exec<{
      vm: VirtualMachine;
      host?: HostSystem;
      pool?: ResourcePool;
      state?: VirtualMachinePowerState;
      testType?: string[]
    } & { _this: ObjectReference }, Task>(
      "CheckMigrate_Task", { _this: { attributes: { type: "VirtualMachineProvisioningChecker" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async checkRelocate(args: {
    vm: VirtualMachine;
    spec: VirtualMachineRelocateSpec;
    testType?: string[]
  }): Promise<Task> {
    const result = await this.connection.exec<{
      vm: VirtualMachine;
      spec: VirtualMachineRelocateSpec;
      testType?: string[]
    } & { _this: ObjectReference }, Task>(
      "CheckRelocate_Task", { _this: { attributes: { type: "VirtualMachineProvisioningChecker" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async queryVMotionCompatibilityEx(args: {
    vm: VirtualMachine[];
    host: HostSystem[]
  }): Promise<Task> {
    const result = await this.connection.exec<{
      vm: VirtualMachine[];
      host: HostSystem[]
    } & { _this: ObjectReference }, Task>(
      "QueryVMotionCompatibilityEx_Task", { _this: { attributes: { type: "VirtualMachineProvisioningChecker" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  };
}
export class HostVStorageObjectManager extends VStorageObjectManagerBase {
  
  constructor(
    public connection: Connection,
    init?: Partial<HostVStorageObjectManager>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async clearVStorageObjectControlFlags(args: {
    id: ID;
    datastore: Datastore;
    controlFlags?: string[]
  }): Promise<void> {
    const result = await this.connection.exec<{
      id: ID;
      datastore: Datastore;
      controlFlags?: string[]
    } & { _this: ObjectReference }, void>(
      "HostClearVStorageObjectControlFlags", { _this: { attributes: { type: "HostVStorageObjectManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async cloneVStorageObject(args: {
    id: ID;
    datastore: Datastore;
    spec: VslmCloneSpec
  }): Promise<Task> {
    const result = await this.connection.exec<{
      id: ID;
      datastore: Datastore;
      spec: VslmCloneSpec
    } & { _this: ObjectReference }, Task>(
      "HostCloneVStorageObject_Task", { _this: { attributes: { type: "HostVStorageObjectManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async createDisk(args: {
    spec: VslmCreateSpec
  }): Promise<Task> {
    const result = await this.connection.exec<{
      spec: VslmCreateSpec
    } & { _this: ObjectReference }, Task>(
      "HostCreateDisk_Task", { _this: { attributes: { type: "HostVStorageObjectManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async deleteVStorageObject(args: {
    id: ID;
    datastore: Datastore
  }): Promise<Task> {
    const result = await this.connection.exec<{
      id: ID;
      datastore: Datastore
    } & { _this: ObjectReference }, Task>(
      "HostDeleteVStorageObject_Task", { _this: { attributes: { type: "HostVStorageObjectManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async extendDisk(args: {
    id: ID;
    datastore: Datastore;
    newCapacityInMB: number
  }): Promise<Task> {
    const result = await this.connection.exec<{
      id: ID;
      datastore: Datastore;
      newCapacityInMB: number
    } & { _this: ObjectReference }, Task>(
      "HostExtendDisk_Task", { _this: { attributes: { type: "HostVStorageObjectManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async inflateDisk(args: {
    id: ID;
    datastore: Datastore
  }): Promise<Task> {
    const result = await this.connection.exec<{
      id: ID;
      datastore: Datastore
    } & { _this: ObjectReference }, Task>(
      "HostInflateDisk_Task", { _this: { attributes: { type: "HostVStorageObjectManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async listVStorageObject(args: {
    datastore: Datastore
  }): Promise<ID[] | undefined> {
    const result = await this.connection.exec<{
      datastore: Datastore
    } & { _this: ObjectReference }, ID[] | undefined>(
      "HostListVStorageObject", { _this: { attributes: { type: "HostVStorageObjectManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "ID[]");
  }
  async reconcileDatastoreInventory(args: {
    datastore: Datastore
  }): Promise<Task> {
    const result = await this.connection.exec<{
      datastore: Datastore
    } & { _this: ObjectReference }, Task>(
      "HostReconcileDatastoreInventory_Task", { _this: { attributes: { type: "HostVStorageObjectManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async registerDisk(args: {
    path: string;
    name?: string
  }): Promise<VStorageObject> {
    const result = await this.connection.exec<{
      path: string;
      name?: string
    } & { _this: ObjectReference }, VStorageObject>(
      "HostRegisterDisk", { _this: { attributes: { type: "HostVStorageObjectManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "VStorageObject");
  }
  async relocateVStorageObject(args: {
    id: ID;
    datastore: Datastore;
    spec: VslmRelocateSpec
  }): Promise<Task> {
    const result = await this.connection.exec<{
      id: ID;
      datastore: Datastore;
      spec: VslmRelocateSpec
    } & { _this: ObjectReference }, Task>(
      "HostRelocateVStorageObject_Task", { _this: { attributes: { type: "HostVStorageObjectManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async renameVStorageObject(args: {
    id: ID;
    datastore: Datastore;
    name: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      id: ID;
      datastore: Datastore;
      name: string
    } & { _this: ObjectReference }, void>(
      "HostRenameVStorageObject", { _this: { attributes: { type: "HostVStorageObjectManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async retrieveVStorageInfrastructureObjectPolicy(args: {
    datastore: Datastore
  }): Promise<vslmInfrastructureObjectPolicy[] | undefined> {
    const result = await this.connection.exec<{
      datastore: Datastore
    } & { _this: ObjectReference }, vslmInfrastructureObjectPolicy[] | undefined>(
      "HostRetrieveVStorageInfrastructureObjectPolicy", { _this: { attributes: { type: "HostVStorageObjectManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "vslmInfrastructureObjectPolicy[]");
  }
  async retrieveVStorageObject(args: {
    id: ID;
    datastore: Datastore
  }): Promise<VStorageObject> {
    const result = await this.connection.exec<{
      id: ID;
      datastore: Datastore
    } & { _this: ObjectReference }, VStorageObject>(
      "HostRetrieveVStorageObject", { _this: { attributes: { type: "HostVStorageObjectManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "VStorageObject");
  }
  async retrieveVStorageObjectMetadata(args: {
    id: ID;
    datastore: Datastore;
    snapshotId?: ID;
    prefix?: string
  }): Promise<KeyValue[] | undefined> {
    const result = await this.connection.exec<{
      id: ID;
      datastore: Datastore;
      snapshotId?: ID;
      prefix?: string
    } & { _this: ObjectReference }, KeyValue[] | undefined>(
      "HostRetrieveVStorageObjectMetadata", { _this: { attributes: { type: "HostVStorageObjectManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "KeyValue[]");
  }
  async retrieveVStorageObjectMetadataValue(args: {
    id: ID;
    datastore: Datastore;
    snapshotId?: ID;
    key: string
  }): Promise<string> {
    const result = await this.connection.exec<{
      id: ID;
      datastore: Datastore;
      snapshotId?: ID;
      key: string
    } & { _this: ObjectReference }, string>(
      "HostRetrieveVStorageObjectMetadataValue", { _this: { attributes: { type: "HostVStorageObjectManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "string");
  }
  async retrieveVStorageObjectState(args: {
    id: ID;
    datastore: Datastore
  }): Promise<VStorageObjectStateInfo> {
    const result = await this.connection.exec<{
      id: ID;
      datastore: Datastore
    } & { _this: ObjectReference }, VStorageObjectStateInfo>(
      "HostRetrieveVStorageObjectState", { _this: { attributes: { type: "HostVStorageObjectManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "VStorageObjectStateInfo");
  }
  async scheduleReconcileDatastoreInventory(args: {
    datastore: Datastore
  }): Promise<void> {
    const result = await this.connection.exec<{
      datastore: Datastore
    } & { _this: ObjectReference }, void>(
      "HostScheduleReconcileDatastoreInventory", { _this: { attributes: { type: "HostVStorageObjectManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async setVStorageObjectControlFlags(args: {
    id: ID;
    datastore: Datastore;
    controlFlags?: string[]
  }): Promise<void> {
    const result = await this.connection.exec<{
      id: ID;
      datastore: Datastore;
      controlFlags?: string[]
    } & { _this: ObjectReference }, void>(
      "HostSetVStorageObjectControlFlags", { _this: { attributes: { type: "HostVStorageObjectManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async updateVStorageObjectMetadata(args: {
    id: ID;
    datastore: Datastore;
    metadata?: KeyValue[];
    deleteKeys?: string[]
  }): Promise<Task> {
    const result = await this.connection.exec<{
      id: ID;
      datastore: Datastore;
      metadata?: KeyValue[];
      deleteKeys?: string[]
    } & { _this: ObjectReference }, Task>(
      "HostUpdateVStorageObjectMetadata_Task", { _this: { attributes: { type: "HostVStorageObjectManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async createDiskFromSnapshot(args: {
    id: ID;
    datastore: Datastore;
    snapshotId: ID;
    name: string;
    profile?: VirtualMachineProfileSpec[];
    crypto?: CryptoSpec;
    path?: string
  }): Promise<Task> {
    const result = await this.connection.exec<{
      id: ID;
      datastore: Datastore;
      snapshotId: ID;
      name: string;
      profile?: VirtualMachineProfileSpec[];
      crypto?: CryptoSpec;
      path?: string
    } & { _this: ObjectReference }, Task>(
      "HostVStorageObjectCreateDiskFromSnapshot_Task", { _this: { attributes: { type: "HostVStorageObjectManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async createSnapshot(args: {
    id: ID;
    datastore: Datastore;
    description: string
  }): Promise<Task> {
    const result = await this.connection.exec<{
      id: ID;
      datastore: Datastore;
      description: string
    } & { _this: ObjectReference }, Task>(
      "HostVStorageObjectCreateSnapshot_Task", { _this: { attributes: { type: "HostVStorageObjectManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async deleteSnapshot(args: {
    id: ID;
    datastore: Datastore;
    snapshotId: ID
  }): Promise<Task> {
    const result = await this.connection.exec<{
      id: ID;
      datastore: Datastore;
      snapshotId: ID
    } & { _this: ObjectReference }, Task>(
      "HostVStorageObjectDeleteSnapshot_Task", { _this: { attributes: { type: "HostVStorageObjectManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async retrieveSnapshotInfo(args: {
    id: ID;
    datastore: Datastore
  }): Promise<VStorageObjectSnapshotInfo> {
    const result = await this.connection.exec<{
      id: ID;
      datastore: Datastore
    } & { _this: ObjectReference }, VStorageObjectSnapshotInfo>(
      "HostVStorageObjectRetrieveSnapshotInfo", { _this: { attributes: { type: "HostVStorageObjectManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "VStorageObjectSnapshotInfo");
  }
  async RevertVStorageObject(args: {
    id: ID;
    datastore: Datastore;
    snapshotId: ID
  }): Promise<Task> {
    const result = await this.connection.exec<{
      id: ID;
      datastore: Datastore;
      snapshotId: ID
    } & { _this: ObjectReference }, Task>(
      "HostVStorageObjectRevert_Task", { _this: { attributes: { type: "HostVStorageObjectManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  };
}
export class VcenterVStorageObjectManager extends VStorageObjectManagerBase {
  
  constructor(
    public connection: Connection,
    init?: Partial<VcenterVStorageObjectManager>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async attachTagToVStorageObject(args: {
    id: ID;
    category: string;
    tag: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      id: ID;
      category: string;
      tag: string
    } & { _this: ObjectReference }, void>(
      "AttachTagToVStorageObject", { _this: { attributes: { type: "VcenterVStorageObjectManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async clearVStorageObjectControlFlags(args: {
    id: ID;
    datastore: Datastore;
    controlFlags?: string[]
  }): Promise<void> {
    const result = await this.connection.exec<{
      id: ID;
      datastore: Datastore;
      controlFlags?: string[]
    } & { _this: ObjectReference }, void>(
      "ClearVStorageObjectControlFlags", { _this: { attributes: { type: "VcenterVStorageObjectManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async cloneVStorageObject(args: {
    id: ID;
    datastore: Datastore;
    spec: VslmCloneSpec
  }): Promise<Task> {
    const result = await this.connection.exec<{
      id: ID;
      datastore: Datastore;
      spec: VslmCloneSpec
    } & { _this: ObjectReference }, Task>(
      "CloneVStorageObject_Task", { _this: { attributes: { type: "VcenterVStorageObjectManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async createDiskFromSnapshot(args: {
    id: ID;
    datastore: Datastore;
    snapshotId: ID;
    name: string;
    profile?: VirtualMachineProfileSpec[];
    crypto?: CryptoSpec;
    path?: string
  }): Promise<Task> {
    const result = await this.connection.exec<{
      id: ID;
      datastore: Datastore;
      snapshotId: ID;
      name: string;
      profile?: VirtualMachineProfileSpec[];
      crypto?: CryptoSpec;
      path?: string
    } & { _this: ObjectReference }, Task>(
      "CreateDiskFromSnapshot_Task", { _this: { attributes: { type: "VcenterVStorageObjectManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async createDisk(args: {
    spec: VslmCreateSpec
  }): Promise<Task> {
    const result = await this.connection.exec<{
      spec: VslmCreateSpec
    } & { _this: ObjectReference }, Task>(
      "CreateDisk_Task", { _this: { attributes: { type: "VcenterVStorageObjectManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async deleteSnapshot(args: {
    id: ID;
    datastore: Datastore;
    snapshotId: ID
  }): Promise<Task> {
    const result = await this.connection.exec<{
      id: ID;
      datastore: Datastore;
      snapshotId: ID
    } & { _this: ObjectReference }, Task>(
      "DeleteSnapshot_Task", { _this: { attributes: { type: "VcenterVStorageObjectManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async deleteVStorageObject(args: {
    id: ID;
    datastore: Datastore
  }): Promise<Task> {
    const result = await this.connection.exec<{
      id: ID;
      datastore: Datastore
    } & { _this: ObjectReference }, Task>(
      "DeleteVStorageObject_Task", { _this: { attributes: { type: "VcenterVStorageObjectManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async detachTagFromVStorageObject(args: {
    id: ID;
    category: string;
    tag: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      id: ID;
      category: string;
      tag: string
    } & { _this: ObjectReference }, void>(
      "DetachTagFromVStorageObject", { _this: { attributes: { type: "VcenterVStorageObjectManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async extendDisk(args: {
    id: ID;
    datastore: Datastore;
    newCapacityInMB: number
  }): Promise<Task> {
    const result = await this.connection.exec<{
      id: ID;
      datastore: Datastore;
      newCapacityInMB: number
    } & { _this: ObjectReference }, Task>(
      "ExtendDisk_Task", { _this: { attributes: { type: "VcenterVStorageObjectManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async inflateDisk(args: {
    id: ID;
    datastore: Datastore
  }): Promise<Task> {
    const result = await this.connection.exec<{
      id: ID;
      datastore: Datastore
    } & { _this: ObjectReference }, Task>(
      "InflateDisk_Task", { _this: { attributes: { type: "VcenterVStorageObjectManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async listTagsAttachedToVStorageObject(args: {
    id: ID
  }): Promise<VslmTagEntry[] | undefined> {
    const result = await this.connection.exec<{
      id: ID
    } & { _this: ObjectReference }, VslmTagEntry[] | undefined>(
      "ListTagsAttachedToVStorageObject", { _this: { attributes: { type: "VcenterVStorageObjectManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "VslmTagEntry[]");
  }
  async listVStorageObject(args: {
    datastore: Datastore
  }): Promise<ID[] | undefined> {
    const result = await this.connection.exec<{
      datastore: Datastore
    } & { _this: ObjectReference }, ID[] | undefined>(
      "ListVStorageObject", { _this: { attributes: { type: "VcenterVStorageObjectManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "ID[]");
  }
  async listVStorageObjectsAttachedToTag(args: {
    category: string;
    tag: string
  }): Promise<ID[] | undefined> {
    const result = await this.connection.exec<{
      category: string;
      tag: string
    } & { _this: ObjectReference }, ID[] | undefined>(
      "ListVStorageObjectsAttachedToTag", { _this: { attributes: { type: "VcenterVStorageObjectManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "ID[]");
  }
  async reconcileDatastoreInventory(args: {
    datastore: Datastore
  }): Promise<Task> {
    const result = await this.connection.exec<{
      datastore: Datastore
    } & { _this: ObjectReference }, Task>(
      "ReconcileDatastoreInventory_Task", { _this: { attributes: { type: "VcenterVStorageObjectManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async registerDisk(args: {
    path: string;
    name?: string
  }): Promise<VStorageObject> {
    const result = await this.connection.exec<{
      path: string;
      name?: string
    } & { _this: ObjectReference }, VStorageObject>(
      "RegisterDisk", { _this: { attributes: { type: "VcenterVStorageObjectManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "VStorageObject");
  }
  async relocateVStorageObject(args: {
    id: ID;
    datastore: Datastore;
    spec: VslmRelocateSpec
  }): Promise<Task> {
    const result = await this.connection.exec<{
      id: ID;
      datastore: Datastore;
      spec: VslmRelocateSpec
    } & { _this: ObjectReference }, Task>(
      "RelocateVStorageObject_Task", { _this: { attributes: { type: "VcenterVStorageObjectManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async renameVStorageObject(args: {
    id: ID;
    datastore: Datastore;
    name: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      id: ID;
      datastore: Datastore;
      name: string
    } & { _this: ObjectReference }, void>(
      "RenameVStorageObject", { _this: { attributes: { type: "VcenterVStorageObjectManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async retrieveSnapshotDetails(args: {
    id: ID;
    datastore: Datastore;
    snapshotId: ID
  }): Promise<VStorageObjectSnapshotDetails> {
    const result = await this.connection.exec<{
      id: ID;
      datastore: Datastore;
      snapshotId: ID
    } & { _this: ObjectReference }, VStorageObjectSnapshotDetails>(
      "RetrieveSnapshotDetails", { _this: { attributes: { type: "VcenterVStorageObjectManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "VStorageObjectSnapshotDetails");
  }
  async retrieveSnapshotInfo(args: {
    id: ID;
    datastore: Datastore
  }): Promise<VStorageObjectSnapshotInfo> {
    const result = await this.connection.exec<{
      id: ID;
      datastore: Datastore
    } & { _this: ObjectReference }, VStorageObjectSnapshotInfo>(
      "RetrieveSnapshotInfo", { _this: { attributes: { type: "VcenterVStorageObjectManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "VStorageObjectSnapshotInfo");
  }
  async retrieveVStorageInfrastructureObjectPolicy(args: {
    datastore: Datastore
  }): Promise<vslmInfrastructureObjectPolicy[] | undefined> {
    const result = await this.connection.exec<{
      datastore: Datastore
    } & { _this: ObjectReference }, vslmInfrastructureObjectPolicy[] | undefined>(
      "RetrieveVStorageInfrastructureObjectPolicy", { _this: { attributes: { type: "VcenterVStorageObjectManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "vslmInfrastructureObjectPolicy[]");
  }
  async retrieveVStorageObject(args: {
    id: ID;
    datastore: Datastore
  }): Promise<VStorageObject> {
    const result = await this.connection.exec<{
      id: ID;
      datastore: Datastore
    } & { _this: ObjectReference }, VStorageObject>(
      "RetrieveVStorageObject", { _this: { attributes: { type: "VcenterVStorageObjectManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "VStorageObject");
  }
  async retrieveVStorageObjectAssociations(args: {
    ids?: RetrieveVStorageObjSpec[]
  }): Promise<VStorageObjectAssociations[] | undefined> {
    const result = await this.connection.exec<{
      ids?: RetrieveVStorageObjSpec[]
    } & { _this: ObjectReference }, VStorageObjectAssociations[] | undefined>(
      "RetrieveVStorageObjectAssociations", { _this: { attributes: { type: "VcenterVStorageObjectManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "VStorageObjectAssociations[]");
  }
  async retrieveVStorageObjectState(args: {
    id: ID;
    datastore: Datastore
  }): Promise<VStorageObjectStateInfo> {
    const result = await this.connection.exec<{
      id: ID;
      datastore: Datastore
    } & { _this: ObjectReference }, VStorageObjectStateInfo>(
      "RetrieveVStorageObjectState", { _this: { attributes: { type: "VcenterVStorageObjectManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "VStorageObjectStateInfo");
  }
  async RevertVStorageObject(args: {
    id: ID;
    datastore: Datastore;
    snapshotId: ID
  }): Promise<Task> {
    const result = await this.connection.exec<{
      id: ID;
      datastore: Datastore;
      snapshotId: ID
    } & { _this: ObjectReference }, Task>(
      "RevertVStorageObject_Task", { _this: { attributes: { type: "VcenterVStorageObjectManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async scheduleReconcileDatastoreInventory(args: {
    datastore: Datastore
  }): Promise<void> {
    const result = await this.connection.exec<{
      datastore: Datastore
    } & { _this: ObjectReference }, void>(
      "ScheduleReconcileDatastoreInventory", { _this: { attributes: { type: "VcenterVStorageObjectManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async setVStorageObjectControlFlags(args: {
    id: ID;
    datastore: Datastore;
    controlFlags?: string[]
  }): Promise<void> {
    const result = await this.connection.exec<{
      id: ID;
      datastore: Datastore;
      controlFlags?: string[]
    } & { _this: ObjectReference }, void>(
      "SetVStorageObjectControlFlags", { _this: { attributes: { type: "VcenterVStorageObjectManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async updateVStorageInfrastructureObjectPolicy(args: {
    spec: vslmInfrastructureObjectPolicySpec
  }): Promise<Task> {
    const result = await this.connection.exec<{
      spec: vslmInfrastructureObjectPolicySpec
    } & { _this: ObjectReference }, Task>(
      "UpdateVStorageInfrastructureObjectPolicy_Task", { _this: { attributes: { type: "VcenterVStorageObjectManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async updateVStorageObjectCrypto(args: {
    id: ID;
    datastore: Datastore;
    profile?: VirtualMachineProfileSpec[];
    disksCrypto?: DiskCryptoSpec
  }): Promise<Task> {
    const result = await this.connection.exec<{
      id: ID;
      datastore: Datastore;
      profile?: VirtualMachineProfileSpec[];
      disksCrypto?: DiskCryptoSpec
    } & { _this: ObjectReference }, Task>(
      "UpdateVStorageObjectCrypto_Task", { _this: { attributes: { type: "VcenterVStorageObjectManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async updateVStorageObjectPolicy(args: {
    id: ID;
    datastore: Datastore;
    profile?: VirtualMachineProfileSpec[]
  }): Promise<Task> {
    const result = await this.connection.exec<{
      id: ID;
      datastore: Datastore;
      profile?: VirtualMachineProfileSpec[]
    } & { _this: ObjectReference }, Task>(
      "UpdateVStorageObjectPolicy_Task", { _this: { attributes: { type: "VcenterVStorageObjectManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async createSnapshot(args: {
    id: ID;
    datastore: Datastore;
    description: string
  }): Promise<Task> {
    const result = await this.connection.exec<{
      id: ID;
      datastore: Datastore;
      description: string
    } & { _this: ObjectReference }, Task>(
      "VStorageObjectCreateSnapshot_Task", { _this: { attributes: { type: "VcenterVStorageObjectManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async queryChangedDiskAreas(args: {
    id: ID;
    datastore: Datastore;
    snapshotId: ID;
    startOffset: number;
    changeId: string
  }): Promise<DiskChangeInfo> {
    const result = await this.connection.exec<{
      id: ID;
      datastore: Datastore;
      snapshotId: ID;
      startOffset: number;
      changeId: string
    } & { _this: ObjectReference }, DiskChangeInfo>(
      "VstorageObjectVCenterQueryChangedDiskAreas", { _this: { attributes: { type: "VcenterVStorageObjectManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "DiskChangeInfo");
  };
}
export class ComputeResource extends ManagedEntity {
  resourcePool?: ResourcePool;
  host?: HostSystem[];
  datastore?: Datastore[];
  network?: Network[];
  summary!: ComputeResourceSummary;
  environmentBrowser?: EnvironmentBrowser;
  configurationEx!: ComputeResourceConfigInfo;
  lifecycleManaged?: boolean;
  constructor(
    public connection: Connection,
    init?: Partial<ComputeResource>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async reconfigureEx(args: {
    spec: ComputeResourceConfigSpec;
    modify: boolean
  }): Promise<Task> {
    const result = await this.connection.exec<{
      spec: ComputeResourceConfigSpec;
      modify: boolean
    } & { _this: ObjectReference }, Task>(
      "ReconfigureComputeResource_Task", { _this: { attributes: { type: "ComputeResource" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  };
}
export class Datacenter extends ManagedEntity {
  vmFolder!: Folder;
  hostFolder!: Folder;
  datastoreFolder!: Folder;
  networkFolder!: Folder;
  datastore?: Datastore[];
  network?: Network[];
  configuration!: DatacenterConfigInfo;
  constructor(
    public connection: Connection,
    init?: Partial<Datacenter>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async batchQueryConnectInfo(args: {
    hostSpecs?: HostConnectSpec[]
  }): Promise<DatacenterBasicConnectInfo[] | undefined> {
    const result = await this.connection.exec<{
      hostSpecs?: HostConnectSpec[]
    } & { _this: ObjectReference }, DatacenterBasicConnectInfo[] | undefined>(
      "BatchQueryConnectInfo", { _this: { attributes: { type: "Datacenter" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "DatacenterBasicConnectInfo[]");
  }
  async powerOnVm(args: {
    vm: VirtualMachine[];
    option?: OptionValue[]
  }): Promise<Task> {
    const result = await this.connection.exec<{
      vm: VirtualMachine[];
      option?: OptionValue[]
    } & { _this: ObjectReference }, Task>(
      "PowerOnMultiVM_Task", { _this: { attributes: { type: "Datacenter" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async queryConnectionInfo(args: {
    hostname: string;
    port: number;
    username: string;
    password: string;
    sslThumbprint?: string
  }): Promise<HostConnectInfo> {
    const result = await this.connection.exec<{
      hostname: string;
      port: number;
      username: string;
      password: string;
      sslThumbprint?: string
    } & { _this: ObjectReference }, HostConnectInfo>(
      "QueryConnectionInfo", { _this: { attributes: { type: "Datacenter" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "HostConnectInfo");
  }
  async queryConnectionInfoViaSpec(args: {
    spec: HostConnectSpec
  }): Promise<HostConnectInfo> {
    const result = await this.connection.exec<{
      spec: HostConnectSpec
    } & { _this: ObjectReference }, HostConnectInfo>(
      "QueryConnectionInfoViaSpec", { _this: { attributes: { type: "Datacenter" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "HostConnectInfo");
  }
  async reconfigure(args: {
    spec: DatacenterConfigSpec;
    modify: boolean
  }): Promise<Task> {
    const result = await this.connection.exec<{
      spec: DatacenterConfigSpec;
      modify: boolean
    } & { _this: ObjectReference }, Task>(
      "ReconfigureDatacenter_Task", { _this: { attributes: { type: "Datacenter" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async queryConfigOptionDescriptor(): Promise<VirtualMachineConfigOptionDescriptor[] | undefined> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, VirtualMachineConfigOptionDescriptor[] | undefined>(
      "queryDatacenterConfigOptionDescriptor", { _this: { attributes: { type: "Datacenter" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "VirtualMachineConfigOptionDescriptor[]");
  };
}
export class Datastore extends ManagedEntity {
  info!: DatastoreInfo;
  summary!: DatastoreSummary;
  host?: DatastoreHostMount[];
  vm?: VirtualMachine[];
  browser!: HostDatastoreBrowser;
  capability!: DatastoreCapability;
  iormConfiguration?: StorageIORMInfo;
  constructor(
    public connection: Connection,
    init?: Partial<Datastore>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async enterMaintenanceMode(): Promise<StoragePlacementResult> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, StoragePlacementResult>(
      "DatastoreEnterMaintenanceMode", { _this: { attributes: { type: "Datastore" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "StoragePlacementResult");
  }
  async exitMaintenanceMode(): Promise<Task> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, Task>(
      "DatastoreExitMaintenanceMode_Task", { _this: { attributes: { type: "Datastore" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async destroyDatastore(): Promise<void> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, void>(
      "DestroyDatastore", { _this: { attributes: { type: "Datastore" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async refresh(): Promise<void> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, void>(
      "RefreshDatastore", { _this: { attributes: { type: "Datastore" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async refreshStorageInfo(): Promise<void> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, void>(
      "RefreshDatastoreStorageInfo", { _this: { attributes: { type: "Datastore" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async renameDatastore(args: {
    newName: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      newName: string
    } & { _this: ObjectReference }, void>(
      "RenameDatastore", { _this: { attributes: { type: "Datastore" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async updateVVolVirtualMachineFiles(args: {
    failoverPair?: DatastoreVVolContainerFailoverPair[]
  }): Promise<Task> {
    const result = await this.connection.exec<{
      failoverPair?: DatastoreVVolContainerFailoverPair[]
    } & { _this: ObjectReference }, Task>(
      "UpdateVVolVirtualMachineFiles_Task", { _this: { attributes: { type: "Datastore" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async updateVirtualMachineFiles(args: {
    mountPathDatastoreMapping: DatastoreMountPathDatastorePair[]
  }): Promise<Task> {
    const result = await this.connection.exec<{
      mountPathDatastoreMapping: DatastoreMountPathDatastorePair[]
    } & { _this: ObjectReference }, Task>(
      "UpdateVirtualMachineFiles_Task", { _this: { attributes: { type: "Datastore" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  };
}
export class DistributedVirtualSwitch extends ManagedEntity {
  uuid!: string;
  capability!: DVSCapability;
  summary!: DVSSummary;
  config!: DVSConfigInfo;
  networkResourcePool?: DVSNetworkResourcePool[];
  portgroup?: DistributedVirtualPortgroup[];
  runtime?: DVSRuntimeInfo;
  constructor(
    public connection: Connection,
    init?: Partial<DistributedVirtualSwitch>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async addPortgroups(args: {
    spec: DVPortgroupConfigSpec[]
  }): Promise<Task> {
    const result = await this.connection.exec<{
      spec: DVPortgroupConfigSpec[]
    } & { _this: ObjectReference }, Task>(
      "AddDVPortgroup_Task", { _this: { attributes: { type: "DistributedVirtualSwitch" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async addNetworkResourcePool(args: {
    configSpec: DVSNetworkResourcePoolConfigSpec[]
  }): Promise<void> {
    const result = await this.connection.exec<{
      configSpec: DVSNetworkResourcePoolConfigSpec[]
    } & { _this: ObjectReference }, void>(
      "AddNetworkResourcePool", { _this: { attributes: { type: "DistributedVirtualSwitch" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async addPortgroup(args: {
    spec: DVPortgroupConfigSpec
  }): Promise<Task> {
    const result = await this.connection.exec<{
      spec: DVPortgroupConfigSpec
    } & { _this: ObjectReference }, Task>(
      "CreateDVPortgroup_Task", { _this: { attributes: { type: "DistributedVirtualSwitch" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async rollback(args: {
    entityBackup?: EntityBackupConfig
  }): Promise<Task | undefined> {
    const result = await this.connection.exec<{
      entityBackup?: EntityBackupConfig
    } & { _this: ObjectReference }, Task | undefined>(
      "DVSRollback_Task", { _this: { attributes: { type: "DistributedVirtualSwitch" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async reconfigureVmVnicNetworkResourcePool(args: {
    configSpec: DvsVmVnicResourcePoolConfigSpec[]
  }): Promise<Task> {
    const result = await this.connection.exec<{
      configSpec: DvsVmVnicResourcePoolConfigSpec[]
    } & { _this: ObjectReference }, Task>(
      "DvsReconfigureVmVnicNetworkResourcePool_Task", { _this: { attributes: { type: "DistributedVirtualSwitch" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async enableNetworkResourceManagement(args: {
    enable: boolean
  }): Promise<void> {
    const result = await this.connection.exec<{
      enable: boolean
    } & { _this: ObjectReference }, void>(
      "EnableNetworkResourceManagement", { _this: { attributes: { type: "DistributedVirtualSwitch" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async fetchPortKeys(args: {
    criteria?: DistributedVirtualSwitchPortCriteria
  }): Promise<string[] | undefined> {
    const result = await this.connection.exec<{
      criteria?: DistributedVirtualSwitchPortCriteria
    } & { _this: ObjectReference }, string[] | undefined>(
      "FetchDVPortKeys", { _this: { attributes: { type: "DistributedVirtualSwitch" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "string[]");
  }
  async fetchPorts(args: {
    criteria?: DistributedVirtualSwitchPortCriteria
  }): Promise<DistributedVirtualPort[] | undefined> {
    const result = await this.connection.exec<{
      criteria?: DistributedVirtualSwitchPortCriteria
    } & { _this: ObjectReference }, DistributedVirtualPort[] | undefined>(
      "FetchDVPorts", { _this: { attributes: { type: "DistributedVirtualSwitch" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "DistributedVirtualPort[]");
  }
  async lookupPortgroup(args: {
    portgroupKey: string
  }): Promise<DistributedVirtualPortgroup | undefined> {
    const result = await this.connection.exec<{
      portgroupKey: string
    } & { _this: ObjectReference }, DistributedVirtualPortgroup | undefined>(
      "LookupDvPortGroup", { _this: { attributes: { type: "DistributedVirtualSwitch" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "DistributedVirtualPortgroup");
  }
  async merge(args: {
    dvs: DistributedVirtualSwitch
  }): Promise<Task> {
    const result = await this.connection.exec<{
      dvs: DistributedVirtualSwitch
    } & { _this: ObjectReference }, Task>(
      "MergeDvs_Task", { _this: { attributes: { type: "DistributedVirtualSwitch" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async movePort(args: {
    portKey: string[];
    destinationPortgroupKey?: string
  }): Promise<Task> {
    const result = await this.connection.exec<{
      portKey: string[];
      destinationPortgroupKey?: string
    } & { _this: ObjectReference }, Task>(
      "MoveDVPort_Task", { _this: { attributes: { type: "DistributedVirtualSwitch" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async performProductSpecOperation(args: {
    operation: string;
    productSpec?: DistributedVirtualSwitchProductSpec
  }): Promise<Task> {
    const result = await this.connection.exec<{
      operation: string;
      productSpec?: DistributedVirtualSwitchProductSpec
    } & { _this: ObjectReference }, Task>(
      "PerformDvsProductSpecOperation_Task", { _this: { attributes: { type: "DistributedVirtualSwitch" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async queryUsedVlanId(): Promise<number[] | undefined> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, number[] | undefined>(
      "QueryUsedVlanIdInDvs", { _this: { attributes: { type: "DistributedVirtualSwitch" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "number[]");
  }
  async reconfigurePort(args: {
    port: DVPortConfigSpec[]
  }): Promise<Task> {
    const result = await this.connection.exec<{
      port: DVPortConfigSpec[]
    } & { _this: ObjectReference }, Task>(
      "ReconfigureDVPort_Task", { _this: { attributes: { type: "DistributedVirtualSwitch" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async reconfigure(args: {
    spec: DVSConfigSpec
  }): Promise<Task> {
    const result = await this.connection.exec<{
      spec: DVSConfigSpec
    } & { _this: ObjectReference }, Task>(
      "ReconfigureDvs_Task", { _this: { attributes: { type: "DistributedVirtualSwitch" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async rectifyHost(args: {
    hosts?: HostSystem[]
  }): Promise<Task> {
    const result = await this.connection.exec<{
      hosts?: HostSystem[]
    } & { _this: ObjectReference }, Task>(
      "RectifyDvsHost_Task", { _this: { attributes: { type: "DistributedVirtualSwitch" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async refreshPortState(args: {
    portKeys?: string[]
  }): Promise<void> {
    const result = await this.connection.exec<{
      portKeys?: string[]
    } & { _this: ObjectReference }, void>(
      "RefreshDVPortState", { _this: { attributes: { type: "DistributedVirtualSwitch" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async removeNetworkResourcePool(args: {
    key: string[]
  }): Promise<void> {
    const result = await this.connection.exec<{
      key: string[]
    } & { _this: ObjectReference }, void>(
      "RemoveNetworkResourcePool", { _this: { attributes: { type: "DistributedVirtualSwitch" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async updateHealthCheckConfig(args: {
    healthCheckConfig: DVSHealthCheckConfig[]
  }): Promise<Task> {
    const result = await this.connection.exec<{
      healthCheckConfig: DVSHealthCheckConfig[]
    } & { _this: ObjectReference }, Task>(
      "UpdateDVSHealthCheckConfig_Task", { _this: { attributes: { type: "DistributedVirtualSwitch" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async updateCapability(args: {
    capability: DVSCapability
  }): Promise<void> {
    const result = await this.connection.exec<{
      capability: DVSCapability
    } & { _this: ObjectReference }, void>(
      "UpdateDvsCapability", { _this: { attributes: { type: "DistributedVirtualSwitch" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async updateNetworkResourcePool(args: {
    configSpec: DVSNetworkResourcePoolConfigSpec[]
  }): Promise<void> {
    const result = await this.connection.exec<{
      configSpec: DVSNetworkResourcePoolConfigSpec[]
    } & { _this: ObjectReference }, void>(
      "UpdateNetworkResourcePool", { _this: { attributes: { type: "DistributedVirtualSwitch" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  };
}
export class Folder extends ManagedEntity {
  childType?: string[];
  childEntity?: ManagedEntity[];
  namespace?: string;
  constructor(
    public connection: Connection,
    init?: Partial<Folder>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async addStandaloneHost(args: {
    spec: HostConnectSpec;
    compResSpec?: ComputeResourceConfigSpec;
    addConnected: boolean;
    license?: string
  }): Promise<Task> {
    const result = await this.connection.exec<{
      spec: HostConnectSpec;
      compResSpec?: ComputeResourceConfigSpec;
      addConnected: boolean;
      license?: string
    } & { _this: ObjectReference }, Task>(
      "AddStandaloneHost_Task", { _this: { attributes: { type: "Folder" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async batchAddHostsToCluster(args: {
    cluster: ClusterComputeResource;
    newHosts?: FolderNewHostSpec[];
    existingHosts?: HostSystem[];
    compResSpec?: ComputeResourceConfigSpec;
    desiredState?: string
  }): Promise<Task> {
    const result = await this.connection.exec<{
      cluster: ClusterComputeResource;
      newHosts?: FolderNewHostSpec[];
      existingHosts?: HostSystem[];
      compResSpec?: ComputeResourceConfigSpec;
      desiredState?: string
    } & { _this: ObjectReference }, Task>(
      "BatchAddHostsToCluster_Task", { _this: { attributes: { type: "Folder" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async batchAddStandaloneHosts(args: {
    newHosts?: FolderNewHostSpec[];
    compResSpec?: ComputeResourceConfigSpec;
    addConnected: boolean
  }): Promise<Task> {
    const result = await this.connection.exec<{
      newHosts?: FolderNewHostSpec[];
      compResSpec?: ComputeResourceConfigSpec;
      addConnected: boolean
    } & { _this: ObjectReference }, Task>(
      "BatchAddStandaloneHosts_Task", { _this: { attributes: { type: "Folder" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async createCluster(args: {
    name: string;
    spec: ClusterConfigSpec
  }): Promise<ClusterComputeResource> {
    const result = await this.connection.exec<{
      name: string;
      spec: ClusterConfigSpec
    } & { _this: ObjectReference }, ClusterComputeResource>(
      "CreateCluster", { _this: { attributes: { type: "Folder" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "ClusterComputeResource");
  }
  async createClusterEx(args: {
    name: string;
    spec: ClusterConfigSpecEx
  }): Promise<ClusterComputeResource> {
    const result = await this.connection.exec<{
      name: string;
      spec: ClusterConfigSpecEx
    } & { _this: ObjectReference }, ClusterComputeResource>(
      "CreateClusterEx", { _this: { attributes: { type: "Folder" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "ClusterComputeResource");
  }
  async createDistributedVirtualSwitch(args: {
    spec: DVSCreateSpec
  }): Promise<Task> {
    const result = await this.connection.exec<{
      spec: DVSCreateSpec
    } & { _this: ObjectReference }, Task>(
      "CreateDVS_Task", { _this: { attributes: { type: "Folder" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async createDatacenter(args: {
    name: string
  }): Promise<Datacenter> {
    const result = await this.connection.exec<{
      name: string
    } & { _this: ObjectReference }, Datacenter>(
      "CreateDatacenter", { _this: { attributes: { type: "Folder" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Datacenter");
  }
  async createFolder(args: {
    name: string
  }): Promise<Folder> {
    const result = await this.connection.exec<{
      name: string
    } & { _this: ObjectReference }, Folder>(
      "CreateFolder", { _this: { attributes: { type: "Folder" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Folder");
  }
  async createStoragePod(args: {
    name: string
  }): Promise<StoragePod> {
    const result = await this.connection.exec<{
      name: string
    } & { _this: ObjectReference }, StoragePod>(
      "CreateStoragePod", { _this: { attributes: { type: "Folder" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "StoragePod");
  }
  async createVm(args: {
    config: VirtualMachineConfigSpec;
    pool: ResourcePool;
    host?: HostSystem
  }): Promise<Task> {
    const result = await this.connection.exec<{
      config: VirtualMachineConfigSpec;
      pool: ResourcePool;
      host?: HostSystem
    } & { _this: ObjectReference }, Task>(
      "CreateVM_Task", { _this: { attributes: { type: "Folder" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async moveInto(args: {
    list: ManagedEntity[]
  }): Promise<Task> {
    const result = await this.connection.exec<{
      list: ManagedEntity[]
    } & { _this: ObjectReference }, Task>(
      "MoveIntoFolder_Task", { _this: { attributes: { type: "Folder" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async registerVm(args: {
    path: string;
    name?: string;
    asTemplate: boolean;
    pool?: ResourcePool;
    host?: HostSystem
  }): Promise<Task> {
    const result = await this.connection.exec<{
      path: string;
      name?: string;
      asTemplate: boolean;
      pool?: ResourcePool;
      host?: HostSystem
    } & { _this: ObjectReference }, Task>(
      "RegisterVM_Task", { _this: { attributes: { type: "Folder" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async unregisterAndDestroy(): Promise<Task> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, Task>(
      "UnregisterAndDestroy_Task", { _this: { attributes: { type: "Folder" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  };
}
export class HostSystem extends ManagedEntity {
  runtime!: HostRuntimeInfo;
  summary!: HostListSummary;
  hardware?: HostHardwareInfo;
  capability?: HostCapability;
  licensableResource!: HostLicensableResourceInfo;
  remediationState?: HostSystemRemediationState;
  precheckRemediationResult?: ApplyHostProfileConfigurationSpec;
  remediationResult?: ApplyHostProfileConfigurationResult;
  complianceCheckState?: HostSystemComplianceCheckState;
  complianceCheckResult?: ComplianceResult;
  configManager!: HostConfigManager;
  config?: HostConfigInfo;
  vm?: VirtualMachine[];
  datastore?: Datastore[];
  network?: Network[];
  datastoreBrowser!: HostDatastoreBrowser;
  systemResources?: HostSystemResourceInfo;
  answerFileValidationState?: AnswerFileStatusResult;
  answerFileValidationResult?: AnswerFileStatusResult;
  constructor(
    public connection: Connection,
    init?: Partial<HostSystem>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async acquireCimServicesTicket(): Promise<HostServiceTicket> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, HostServiceTicket>(
      "AcquireCimServicesTicket", { _this: { attributes: { type: "HostSystem" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "HostServiceTicket");
  }
  async configureCryptoKey(args: {
    keyId?: CryptoKeyId
  }): Promise<void> {
    const result = await this.connection.exec<{
      keyId?: CryptoKeyId
    } & { _this: ObjectReference }, void>(
      "ConfigureCryptoKey", { _this: { attributes: { type: "HostSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async disconnect(): Promise<Task> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, Task>(
      "DisconnectHost_Task", { _this: { attributes: { type: "HostSystem" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async enableCrypto(args: {
    keyPlain: CryptoKeyPlain
  }): Promise<void> {
    const result = await this.connection.exec<{
      keyPlain: CryptoKeyPlain
    } & { _this: ObjectReference }, void>(
      "EnableCrypto", { _this: { attributes: { type: "HostSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async enterLockdownMode(): Promise<void> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, void>(
      "EnterLockdownMode", { _this: { attributes: { type: "HostSystem" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async enterMaintenanceMode(args: {
    timeout: number;
    evacuatePoweredOffVms?: boolean;
    maintenanceSpec?: HostMaintenanceSpec
  }): Promise<Task> {
    const result = await this.connection.exec<{
      timeout: number;
      evacuatePoweredOffVms?: boolean;
      maintenanceSpec?: HostMaintenanceSpec
    } & { _this: ObjectReference }, Task>(
      "EnterMaintenanceMode_Task", { _this: { attributes: { type: "HostSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async exitLockdownMode(): Promise<void> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, void>(
      "ExitLockdownMode", { _this: { attributes: { type: "HostSystem" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async exitMaintenanceMode(args: {
    timeout: number
  }): Promise<Task> {
    const result = await this.connection.exec<{
      timeout: number
    } & { _this: ObjectReference }, Task>(
      "ExitMaintenanceMode_Task", { _this: { attributes: { type: "HostSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async enterStandbyMode(args: {
    timeoutSec: number;
    evacuatePoweredOffVms?: boolean
  }): Promise<Task> {
    const result = await this.connection.exec<{
      timeoutSec: number;
      evacuatePoweredOffVms?: boolean
    } & { _this: ObjectReference }, Task>(
      "PowerDownHostToStandBy_Task", { _this: { attributes: { type: "HostSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async exitStandbyMode(args: {
    timeoutSec: number
  }): Promise<Task> {
    const result = await this.connection.exec<{
      timeoutSec: number
    } & { _this: ObjectReference }, Task>(
      "PowerUpHostFromStandBy_Task", { _this: { attributes: { type: "HostSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async prepareCrypto(): Promise<void> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, void>(
      "PrepareCrypto", { _this: { attributes: { type: "HostSystem" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async queryConnectionInfo(): Promise<HostConnectInfo> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, HostConnectInfo>(
      "QueryHostConnectionInfo", { _this: { attributes: { type: "HostSystem" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "HostConnectInfo");
  }
  async queryOverhead(args: {
    memorySize: number;
    videoRamSize?: number;
    numVcpus: number
  }): Promise<number> {
    const result = await this.connection.exec<{
      memorySize: number;
      videoRamSize?: number;
      numVcpus: number
    } & { _this: ObjectReference }, number>(
      "QueryMemoryOverhead", { _this: { attributes: { type: "HostSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "number");
  }
  async queryOverheadEx(args: {
    vmConfigInfo: VirtualMachineConfigInfo
  }): Promise<number> {
    const result = await this.connection.exec<{
      vmConfigInfo: VirtualMachineConfigInfo
    } & { _this: ObjectReference }, number>(
      "QueryMemoryOverheadEx", { _this: { attributes: { type: "HostSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "number");
  }
  async queryProductLockerLocation(): Promise<string> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, string>(
      "QueryProductLockerLocation", { _this: { attributes: { type: "HostSystem" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "string");
  }
  async queryTpmAttestationReport(): Promise<HostTpmAttestationReport | undefined> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, HostTpmAttestationReport | undefined>(
      "QueryTpmAttestationReport", { _this: { attributes: { type: "HostSystem" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "HostTpmAttestationReport");
  }
  async reboot(args: {
    force: boolean
  }): Promise<Task> {
    const result = await this.connection.exec<{
      force: boolean
    } & { _this: ObjectReference }, Task>(
      "RebootHost_Task", { _this: { attributes: { type: "HostSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async reconfigureDAS(): Promise<Task> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, Task>(
      "ReconfigureHostForDAS_Task", { _this: { attributes: { type: "HostSystem" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async reconnect(args: {
    cnxSpec?: HostConnectSpec;
    reconnectSpec?: HostSystemReconnectSpec
  }): Promise<Task> {
    const result = await this.connection.exec<{
      cnxSpec?: HostConnectSpec;
      reconnectSpec?: HostSystemReconnectSpec
    } & { _this: ObjectReference }, Task>(
      "ReconnectHost_Task", { _this: { attributes: { type: "HostSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async retrieveFreeEpcMemory(): Promise<number> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, number>(
      "RetrieveFreeEpcMemory", { _this: { attributes: { type: "HostSystem" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "number");
  }
  async retrieveHardwareUptime(): Promise<number> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, number>(
      "RetrieveHardwareUptime", { _this: { attributes: { type: "HostSystem" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "number");
  }
  async shutdown(args: {
    force: boolean
  }): Promise<Task> {
    const result = await this.connection.exec<{
      force: boolean
    } & { _this: ObjectReference }, Task>(
      "ShutdownHost_Task", { _this: { attributes: { type: "HostSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async updateFlags(args: {
    flagInfo: HostFlagInfo
  }): Promise<void> {
    const result = await this.connection.exec<{
      flagInfo: HostFlagInfo
    } & { _this: ObjectReference }, void>(
      "UpdateFlags", { _this: { attributes: { type: "HostSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async updateIpmi(args: {
    ipmiInfo: HostIpmiInfo
  }): Promise<void> {
    const result = await this.connection.exec<{
      ipmiInfo: HostIpmiInfo
    } & { _this: ObjectReference }, void>(
      "UpdateIpmi", { _this: { attributes: { type: "HostSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async updateProductLockerLocation(args: {
    path: string
  }): Promise<Task> {
    const result = await this.connection.exec<{
      path: string
    } & { _this: ObjectReference }, Task>(
      "UpdateProductLockerLocation_Task", { _this: { attributes: { type: "HostSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async updateSystemResources(args: {
    resourceInfo: HostSystemResourceInfo
  }): Promise<void> {
    const result = await this.connection.exec<{
      resourceInfo: HostSystemResourceInfo
    } & { _this: ObjectReference }, void>(
      "UpdateSystemResources", { _this: { attributes: { type: "HostSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async updateSystemSwapConfiguration(args: {
    sysSwapConfig: HostSystemSwapConfiguration
  }): Promise<void> {
    const result = await this.connection.exec<{
      sysSwapConfig: HostSystemSwapConfiguration
    } & { _this: ObjectReference }, void>(
      "UpdateSystemSwapConfiguration", { _this: { attributes: { type: "HostSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  };
}
export class ServiceInstance extends ManagedObject {
  serverClock!: Date;
  capability!: Capability;
  content!: ServiceContent;
  constructor(
    public connection: Connection,
    init?: Partial<ServiceInstance>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async currentTime(): Promise<Date> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, Date>(
      "CurrentTime", { _this: "ServiceInstance",  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Date");
  }
  async queryVMotionCompatibility(args: {
    vm: VirtualMachine;
    host: HostSystem[];
    compatibility?: string[]
  }): Promise<HostVMotionCompatibility[] | undefined> {
    const result = await this.connection.exec<{
      vm: VirtualMachine;
      host: HostSystem[];
      compatibility?: string[]
    } & { _this: ObjectReference }, HostVMotionCompatibility[] | undefined>(
      "QueryVMotionCompatibility", { _this: "ServiceInstance", ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "HostVMotionCompatibility[]");
  }
  async retrieveProductComponents(): Promise<ProductComponentInfo[] | undefined> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, ProductComponentInfo[] | undefined>(
      "RetrieveProductComponents", { _this: "ServiceInstance",  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "ProductComponentInfo[]");
  }
  async retrieveContent(): Promise<ServiceContent> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, ServiceContent>(
      "RetrieveServiceContent", { _this: "ServiceInstance",  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "ServiceContent");
  }
  async validateMigration(args: {
    vm: VirtualMachine[];
    state?: VirtualMachinePowerState;
    testType?: string[];
    pool?: ResourcePool;
    host?: HostSystem
  }): Promise<Event[] | undefined> {
    const result = await this.connection.exec<{
      vm: VirtualMachine[];
      state?: VirtualMachinePowerState;
      testType?: string[];
      pool?: ResourcePool;
      host?: HostSystem
    } & { _this: ObjectReference }, Event[] | undefined>(
      "ValidateMigration", { _this: "ServiceInstance", ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Event[]");
  };
}
export class StoragePod extends Folder {
  summary?: StoragePodSummary;
  podStorageDrsEntry?: PodStorageDrsEntry;
  constructor(
    public connection: Connection,
    init?: Partial<StoragePod>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  
}
export class DistributedVirtualSwitchManager extends ManagedObject {
  
  constructor(
    public connection: Connection,
    init?: Partial<DistributedVirtualSwitchManager>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async exportEntity(args: {
    selectionSet: SelectionSet[]
  }): Promise<Task | undefined> {
    const result = await this.connection.exec<{
      selectionSet: SelectionSet[]
    } & { _this: ObjectReference }, Task | undefined>(
      "DVSManagerExportEntity_Task", { _this: { attributes: { type: "DistributedVirtualSwitchManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async importEntity(args: {
    entityBackup: EntityBackupConfig[];
    importType: string
  }): Promise<Task> {
    const result = await this.connection.exec<{
      entityBackup: EntityBackupConfig[];
      importType: string
    } & { _this: ObjectReference }, Task>(
      "DVSManagerImportEntity_Task", { _this: { attributes: { type: "DistributedVirtualSwitchManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async lookupPortgroup(args: {
    switchUuid: string;
    portgroupKey: string
  }): Promise<DistributedVirtualPortgroup | undefined> {
    const result = await this.connection.exec<{
      switchUuid: string;
      portgroupKey: string
    } & { _this: ObjectReference }, DistributedVirtualPortgroup | undefined>(
      "DVSManagerLookupDvPortGroup", { _this: { attributes: { type: "DistributedVirtualSwitchManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "DistributedVirtualPortgroup");
  }
  async querySupportedSwitchSpec(args: {
    recommended?: boolean
  }): Promise<DistributedVirtualSwitchProductSpec[] | undefined> {
    const result = await this.connection.exec<{
      recommended?: boolean
    } & { _this: ObjectReference }, DistributedVirtualSwitchProductSpec[] | undefined>(
      "QueryAvailableDvsSpec", { _this: { attributes: { type: "DistributedVirtualSwitchManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "DistributedVirtualSwitchProductSpec[]");
  }
  async queryCompatibleHostForExistingDvs(args: {
    container: ManagedEntity;
    recursive: boolean;
    dvs: DistributedVirtualSwitch
  }): Promise<HostSystem[] | undefined> {
    const result = await this.connection.exec<{
      container: ManagedEntity;
      recursive: boolean;
      dvs: DistributedVirtualSwitch
    } & { _this: ObjectReference }, HostSystem[] | undefined>(
      "QueryCompatibleHostForExistingDvs", { _this: { attributes: { type: "DistributedVirtualSwitchManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "HostSystem[]");
  }
  async queryCompatibleHostForNewDvs(args: {
    container: ManagedEntity;
    recursive: boolean;
    switchProductSpec?: DistributedVirtualSwitchProductSpec
  }): Promise<HostSystem[] | undefined> {
    const result = await this.connection.exec<{
      container: ManagedEntity;
      recursive: boolean;
      switchProductSpec?: DistributedVirtualSwitchProductSpec
    } & { _this: ObjectReference }, HostSystem[] | undefined>(
      "QueryCompatibleHostForNewDvs", { _this: { attributes: { type: "DistributedVirtualSwitchManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "HostSystem[]");
  }
  async querySwitchByUuid(args: {
    uuid: string
  }): Promise<DistributedVirtualSwitch | undefined> {
    const result = await this.connection.exec<{
      uuid: string
    } & { _this: ObjectReference }, DistributedVirtualSwitch | undefined>(
      "QueryDvsByUuid", { _this: { attributes: { type: "DistributedVirtualSwitchManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "DistributedVirtualSwitch");
  }
  async checkCompatibility(args: {
    hostContainer: DistributedVirtualSwitchManagerHostContainer;
    dvsProductSpec?: DistributedVirtualSwitchManagerDvsProductSpec;
    hostFilterSpec?: DistributedVirtualSwitchManagerHostDvsFilterSpec[]
  }): Promise<DistributedVirtualSwitchManagerCompatibilityResult[] | undefined> {
    const result = await this.connection.exec<{
      hostContainer: DistributedVirtualSwitchManagerHostContainer;
      dvsProductSpec?: DistributedVirtualSwitchManagerDvsProductSpec;
      hostFilterSpec?: DistributedVirtualSwitchManagerHostDvsFilterSpec[]
    } & { _this: ObjectReference }, DistributedVirtualSwitchManagerCompatibilityResult[] | undefined>(
      "QueryDvsCheckCompatibility", { _this: { attributes: { type: "DistributedVirtualSwitchManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "DistributedVirtualSwitchManagerCompatibilityResult[]");
  }
  async queryCompatibleHostSpec(args: {
    switchProductSpec?: DistributedVirtualSwitchProductSpec
  }): Promise<DistributedVirtualSwitchHostProductSpec[] | undefined> {
    const result = await this.connection.exec<{
      switchProductSpec?: DistributedVirtualSwitchProductSpec
    } & { _this: ObjectReference }, DistributedVirtualSwitchHostProductSpec[] | undefined>(
      "QueryDvsCompatibleHostSpec", { _this: { attributes: { type: "DistributedVirtualSwitchManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "DistributedVirtualSwitchHostProductSpec[]");
  }
  async queryDvsConfigTarget(args: {
    host?: HostSystem;
    dvs?: DistributedVirtualSwitch
  }): Promise<DVSManagerDvsConfigTarget> {
    const result = await this.connection.exec<{
      host?: HostSystem;
      dvs?: DistributedVirtualSwitch
    } & { _this: ObjectReference }, DVSManagerDvsConfigTarget>(
      "QueryDvsConfigTarget", { _this: { attributes: { type: "DistributedVirtualSwitchManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "DVSManagerDvsConfigTarget");
  }
  async queryFeatureCapability(args: {
    switchProductSpec?: DistributedVirtualSwitchProductSpec
  }): Promise<DVSFeatureCapability | undefined> {
    const result = await this.connection.exec<{
      switchProductSpec?: DistributedVirtualSwitchProductSpec
    } & { _this: ObjectReference }, DVSFeatureCapability | undefined>(
      "QueryDvsFeatureCapability", { _this: { attributes: { type: "DistributedVirtualSwitchManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "DVSFeatureCapability");
  }
  async rectifyHost(args: {
    hosts: HostSystem[]
  }): Promise<Task> {
    const result = await this.connection.exec<{
      hosts: HostSystem[]
    } & { _this: ObjectReference }, Task>(
      "RectifyDvsOnHost_Task", { _this: { attributes: { type: "DistributedVirtualSwitchManager" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  };
}
export class VmwareDistributedVirtualSwitch extends DistributedVirtualSwitch {
  
  constructor(
    public connection: Connection,
    init?: Partial<VmwareDistributedVirtualSwitch>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async updateLacpGroupConfig(args: {
    lacpGroupSpec: VMwareDvsLacpGroupSpec[]
  }): Promise<Task> {
    const result = await this.connection.exec<{
      lacpGroupSpec: VMwareDvsLacpGroupSpec[]
    } & { _this: ObjectReference }, Task>(
      "UpdateDVSLacpGroupConfig_Task", { _this: { attributes: { type: "VmwareDistributedVirtualSwitch" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  };
}
export class HostDiagnosticSystem extends ManagedObject {
  activePartition?: HostDiagnosticPartition;
  constructor(
    public connection: Connection,
    init?: Partial<HostDiagnosticSystem>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async createDiagnosticPartition(args: {
    spec: HostDiagnosticPartitionCreateSpec
  }): Promise<void> {
    const result = await this.connection.exec<{
      spec: HostDiagnosticPartitionCreateSpec
    } & { _this: ObjectReference }, void>(
      "CreateDiagnosticPartition", { _this: { attributes: { type: "HostDiagnosticSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async queryAvailablePartition(): Promise<HostDiagnosticPartition[] | undefined> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, HostDiagnosticPartition[] | undefined>(
      "QueryAvailablePartition", { _this: { attributes: { type: "HostDiagnosticSystem" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "HostDiagnosticPartition[]");
  }
  async queryPartitionCreateDesc(args: {
    diskUuid: string;
    diagnosticType: string
  }): Promise<HostDiagnosticPartitionCreateDescription> {
    const result = await this.connection.exec<{
      diskUuid: string;
      diagnosticType: string
    } & { _this: ObjectReference }, HostDiagnosticPartitionCreateDescription>(
      "QueryPartitionCreateDesc", { _this: { attributes: { type: "HostDiagnosticSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "HostDiagnosticPartitionCreateDescription");
  }
  async queryPartitionCreateOptions(args: {
    storageType: string;
    diagnosticType: string
  }): Promise<HostDiagnosticPartitionCreateOption[] | undefined> {
    const result = await this.connection.exec<{
      storageType: string;
      diagnosticType: string
    } & { _this: ObjectReference }, HostDiagnosticPartitionCreateOption[] | undefined>(
      "QueryPartitionCreateOptions", { _this: { attributes: { type: "HostDiagnosticSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "HostDiagnosticPartitionCreateOption[]");
  }
  async selectActivePartition(args: {
    partition?: HostScsiDiskPartition
  }): Promise<void> {
    const result = await this.connection.exec<{
      partition?: HostScsiDiskPartition
    } & { _this: ObjectReference }, void>(
      "SelectActivePartition", { _this: { attributes: { type: "HostDiagnosticSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  };
}
export class HostStorageSystem extends ExtensibleManagedObject {
  storageDeviceInfo?: HostStorageDeviceInfo;
  fileSystemVolumeInfo!: HostFileSystemVolumeInfo;
  systemFile?: string[];
  multipathStateInfo?: HostMultipathStateInfo;
  constructor(
    public connection: Connection,
    init?: Partial<HostStorageSystem>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async addInternetScsiSendTargets(args: {
    iScsiHbaDevice: string;
    targets: HostInternetScsiHbaSendTarget[]
  }): Promise<void> {
    const result = await this.connection.exec<{
      iScsiHbaDevice: string;
      targets: HostInternetScsiHbaSendTarget[]
    } & { _this: ObjectReference }, void>(
      "AddInternetScsiSendTargets", { _this: { attributes: { type: "HostStorageSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async addInternetScsiStaticTargets(args: {
    iScsiHbaDevice: string;
    targets: HostInternetScsiHbaStaticTarget[]
  }): Promise<void> {
    const result = await this.connection.exec<{
      iScsiHbaDevice: string;
      targets: HostInternetScsiHbaStaticTarget[]
    } & { _this: ObjectReference }, void>(
      "AddInternetScsiStaticTargets", { _this: { attributes: { type: "HostStorageSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async attachScsiLun(args: {
    lunUuid: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      lunUuid: string
    } & { _this: ObjectReference }, void>(
      "AttachScsiLun", { _this: { attributes: { type: "HostStorageSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async attachScsiLunEx(args: {
    lunUuid: string[]
  }): Promise<Task> {
    const result = await this.connection.exec<{
      lunUuid: string[]
    } & { _this: ObjectReference }, Task>(
      "AttachScsiLunEx_Task", { _this: { attributes: { type: "HostStorageSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async attachVmfsExtent(args: {
    vmfsPath: string;
    extent: HostScsiDiskPartition
  }): Promise<void> {
    const result = await this.connection.exec<{
      vmfsPath: string;
      extent: HostScsiDiskPartition
    } & { _this: ObjectReference }, void>(
      "AttachVmfsExtent", { _this: { attributes: { type: "HostStorageSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async changeNFSUserPassword(args: {
    password: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      password: string
    } & { _this: ObjectReference }, void>(
      "ChangeNFSUserPassword", { _this: { attributes: { type: "HostStorageSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async clearNFSUser(): Promise<void> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, void>(
      "ClearNFSUser", { _this: { attributes: { type: "HostStorageSystem" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async computeDiskPartitionInfo(args: {
    devicePath: string;
    layout: HostDiskPartitionLayout;
    partitionFormat?: string
  }): Promise<HostDiskPartitionInfo> {
    const result = await this.connection.exec<{
      devicePath: string;
      layout: HostDiskPartitionLayout;
      partitionFormat?: string
    } & { _this: ObjectReference }, HostDiskPartitionInfo>(
      "ComputeDiskPartitionInfo", { _this: { attributes: { type: "HostStorageSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "HostDiskPartitionInfo");
  }
  async computeDiskPartitionInfoForResize(args: {
    partition: HostScsiDiskPartition;
    blockRange: HostDiskPartitionBlockRange;
    partitionFormat?: string
  }): Promise<HostDiskPartitionInfo> {
    const result = await this.connection.exec<{
      partition: HostScsiDiskPartition;
      blockRange: HostDiskPartitionBlockRange;
      partitionFormat?: string
    } & { _this: ObjectReference }, HostDiskPartitionInfo>(
      "ComputeDiskPartitionInfoForResize", { _this: { attributes: { type: "HostStorageSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "HostDiskPartitionInfo");
  }
  async connectNvmeController(args: {
    connectSpec: HostNvmeConnectSpec
  }): Promise<void> {
    const result = await this.connection.exec<{
      connectSpec: HostNvmeConnectSpec
    } & { _this: ObjectReference }, void>(
      "ConnectNvmeController", { _this: { attributes: { type: "HostStorageSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async createNvmeOverRdmaAdapter(args: {
    rdmaDeviceName: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      rdmaDeviceName: string
    } & { _this: ObjectReference }, void>(
      "CreateNvmeOverRdmaAdapter", { _this: { attributes: { type: "HostStorageSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async deleteScsiLunState(args: {
    lunCanonicalName: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      lunCanonicalName: string
    } & { _this: ObjectReference }, void>(
      "DeleteScsiLunState", { _this: { attributes: { type: "HostStorageSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async deleteVffsVolumeState(args: {
    vffsUuid: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      vffsUuid: string
    } & { _this: ObjectReference }, void>(
      "DeleteVffsVolumeState", { _this: { attributes: { type: "HostStorageSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async deleteVmfsVolumeState(args: {
    vmfsUuid: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      vmfsUuid: string
    } & { _this: ObjectReference }, void>(
      "DeleteVmfsVolumeState", { _this: { attributes: { type: "HostStorageSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async destroyVffs(args: {
    vffsPath: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      vffsPath: string
    } & { _this: ObjectReference }, void>(
      "DestroyVffs", { _this: { attributes: { type: "HostStorageSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async detachScsiLun(args: {
    lunUuid: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      lunUuid: string
    } & { _this: ObjectReference }, void>(
      "DetachScsiLun", { _this: { attributes: { type: "HostStorageSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async detachScsiLunEx(args: {
    lunUuid: string[]
  }): Promise<Task> {
    const result = await this.connection.exec<{
      lunUuid: string[]
    } & { _this: ObjectReference }, Task>(
      "DetachScsiLunEx_Task", { _this: { attributes: { type: "HostStorageSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async disableMultipathPath(args: {
    pathName: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      pathName: string
    } & { _this: ObjectReference }, void>(
      "DisableMultipathPath", { _this: { attributes: { type: "HostStorageSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async disconnectNvmeController(args: {
    disconnectSpec: HostNvmeDisconnectSpec
  }): Promise<void> {
    const result = await this.connection.exec<{
      disconnectSpec: HostNvmeDisconnectSpec
    } & { _this: ObjectReference }, void>(
      "DisconnectNvmeController", { _this: { attributes: { type: "HostStorageSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async discoverFcoeHbas(args: {
    fcoeSpec: FcoeConfigFcoeSpecification
  }): Promise<void> {
    const result = await this.connection.exec<{
      fcoeSpec: FcoeConfigFcoeSpecification
    } & { _this: ObjectReference }, void>(
      "DiscoverFcoeHbas", { _this: { attributes: { type: "HostStorageSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async discoverNvmeControllers(args: {
    discoverSpec: HostNvmeDiscoverSpec
  }): Promise<HostNvmeDiscoveryLog> {
    const result = await this.connection.exec<{
      discoverSpec: HostNvmeDiscoverSpec
    } & { _this: ObjectReference }, HostNvmeDiscoveryLog>(
      "DiscoverNvmeControllers", { _this: { attributes: { type: "HostStorageSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "HostNvmeDiscoveryLog");
  }
  async enableMultipathPath(args: {
    pathName: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      pathName: string
    } & { _this: ObjectReference }, void>(
      "EnableMultipathPath", { _this: { attributes: { type: "HostStorageSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async expandVmfsExtent(args: {
    vmfsPath: string;
    extent: HostScsiDiskPartition
  }): Promise<void> {
    const result = await this.connection.exec<{
      vmfsPath: string;
      extent: HostScsiDiskPartition
    } & { _this: ObjectReference }, void>(
      "ExpandVmfsExtent", { _this: { attributes: { type: "HostStorageSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async extendVffs(args: {
    vffsPath: string;
    devicePath: string;
    spec?: HostDiskPartitionSpec
  }): Promise<void> {
    const result = await this.connection.exec<{
      vffsPath: string;
      devicePath: string;
      spec?: HostDiskPartitionSpec
    } & { _this: ObjectReference }, void>(
      "ExtendVffs", { _this: { attributes: { type: "HostStorageSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async formatVffs(args: {
    createSpec: HostVffsSpec
  }): Promise<HostVffsVolume> {
    const result = await this.connection.exec<{
      createSpec: HostVffsSpec
    } & { _this: ObjectReference }, HostVffsVolume>(
      "FormatVffs", { _this: { attributes: { type: "HostStorageSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "HostVffsVolume");
  }
  async formatVmfs(args: {
    createSpec: HostVmfsSpec
  }): Promise<HostVmfsVolume> {
    const result = await this.connection.exec<{
      createSpec: HostVmfsSpec
    } & { _this: ObjectReference }, HostVmfsVolume>(
      "FormatVmfs", { _this: { attributes: { type: "HostStorageSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "HostVmfsVolume");
  }
  async markAsLocal(args: {
    scsiDiskUuid: string
  }): Promise<Task> {
    const result = await this.connection.exec<{
      scsiDiskUuid: string
    } & { _this: ObjectReference }, Task>(
      "MarkAsLocal_Task", { _this: { attributes: { type: "HostStorageSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async markAsNonLocal(args: {
    scsiDiskUuid: string
  }): Promise<Task> {
    const result = await this.connection.exec<{
      scsiDiskUuid: string
    } & { _this: ObjectReference }, Task>(
      "MarkAsNonLocal_Task", { _this: { attributes: { type: "HostStorageSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async markAsNonSsd(args: {
    scsiDiskUuid: string
  }): Promise<Task> {
    const result = await this.connection.exec<{
      scsiDiskUuid: string
    } & { _this: ObjectReference }, Task>(
      "MarkAsNonSsd_Task", { _this: { attributes: { type: "HostStorageSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async markAsSsd(args: {
    scsiDiskUuid: string
  }): Promise<Task> {
    const result = await this.connection.exec<{
      scsiDiskUuid: string
    } & { _this: ObjectReference }, Task>(
      "MarkAsSsd_Task", { _this: { attributes: { type: "HostStorageSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async markForRemoval(args: {
    hbaName: string;
    remove: boolean
  }): Promise<void> {
    const result = await this.connection.exec<{
      hbaName: string;
      remove: boolean
    } & { _this: ObjectReference }, void>(
      "MarkForRemoval", { _this: { attributes: { type: "HostStorageSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async markPerenniallyReserved(args: {
    lunUuid: string;
    state: boolean
  }): Promise<void> {
    const result = await this.connection.exec<{
      lunUuid: string;
      state: boolean
    } & { _this: ObjectReference }, void>(
      "MarkPerenniallyReserved", { _this: { attributes: { type: "HostStorageSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async markPerenniallyReservedEx(args: {
    lunUuid?: string[];
    state: boolean
  }): Promise<Task | undefined> {
    const result = await this.connection.exec<{
      lunUuid?: string[];
      state: boolean
    } & { _this: ObjectReference }, Task | undefined>(
      "MarkPerenniallyReservedEx_Task", { _this: { attributes: { type: "HostStorageSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async mountVffsVolume(args: {
    vffsUuid: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      vffsUuid: string
    } & { _this: ObjectReference }, void>(
      "MountVffsVolume", { _this: { attributes: { type: "HostStorageSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async mountVmfsVolume(args: {
    vmfsUuid: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      vmfsUuid: string
    } & { _this: ObjectReference }, void>(
      "MountVmfsVolume", { _this: { attributes: { type: "HostStorageSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async mountVmfsVolumeEx(args: {
    vmfsUuid: string[]
  }): Promise<Task> {
    const result = await this.connection.exec<{
      vmfsUuid: string[]
    } & { _this: ObjectReference }, Task>(
      "MountVmfsVolumeEx_Task", { _this: { attributes: { type: "HostStorageSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async queryAvailableSsds(args: {
    vffsPath?: string
  }): Promise<HostScsiDisk[] | undefined> {
    const result = await this.connection.exec<{
      vffsPath?: string
    } & { _this: ObjectReference }, HostScsiDisk[] | undefined>(
      "QueryAvailableSsds", { _this: { attributes: { type: "HostStorageSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "HostScsiDisk[]");
  }
  async queryNFSUser(): Promise<HostNasVolumeUserInfo | undefined> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, HostNasVolumeUserInfo | undefined>(
      "QueryNFSUser", { _this: { attributes: { type: "HostStorageSystem" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "HostNasVolumeUserInfo");
  }
  async queryPathSelectionPolicyOptions(): Promise<HostPathSelectionPolicyOption[] | undefined> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, HostPathSelectionPolicyOption[] | undefined>(
      "QueryPathSelectionPolicyOptions", { _this: { attributes: { type: "HostStorageSystem" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "HostPathSelectionPolicyOption[]");
  }
  async queryStorageArrayTypePolicyOptions(): Promise<HostStorageArrayTypePolicyOption[] | undefined> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, HostStorageArrayTypePolicyOption[] | undefined>(
      "QueryStorageArrayTypePolicyOptions", { _this: { attributes: { type: "HostStorageSystem" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "HostStorageArrayTypePolicyOption[]");
  }
  async queryUnresolvedVmfsVolume(): Promise<HostUnresolvedVmfsVolume[] | undefined> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, HostUnresolvedVmfsVolume[] | undefined>(
      "QueryUnresolvedVmfsVolume", { _this: { attributes: { type: "HostStorageSystem" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "HostUnresolvedVmfsVolume[]");
  }
  async queryVmfsConfigOption(): Promise<VmfsConfigOption[] | undefined> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, VmfsConfigOption[] | undefined>(
      "QueryVmfsConfigOption", { _this: { attributes: { type: "HostStorageSystem" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "VmfsConfigOption[]");
  }
  async refresh(): Promise<void> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, void>(
      "RefreshStorageSystem", { _this: { attributes: { type: "HostStorageSystem" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async removeInternetScsiSendTargets(args: {
    iScsiHbaDevice: string;
    targets: HostInternetScsiHbaSendTarget[];
    force?: boolean
  }): Promise<void> {
    const result = await this.connection.exec<{
      iScsiHbaDevice: string;
      targets: HostInternetScsiHbaSendTarget[];
      force?: boolean
    } & { _this: ObjectReference }, void>(
      "RemoveInternetScsiSendTargets", { _this: { attributes: { type: "HostStorageSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async removeInternetScsiStaticTargets(args: {
    iScsiHbaDevice: string;
    targets: HostInternetScsiHbaStaticTarget[]
  }): Promise<void> {
    const result = await this.connection.exec<{
      iScsiHbaDevice: string;
      targets: HostInternetScsiHbaStaticTarget[]
    } & { _this: ObjectReference }, void>(
      "RemoveInternetScsiStaticTargets", { _this: { attributes: { type: "HostStorageSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async removeNvmeOverRdmaAdapter(args: {
    hbaDeviceName: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      hbaDeviceName: string
    } & { _this: ObjectReference }, void>(
      "RemoveNvmeOverRdmaAdapter", { _this: { attributes: { type: "HostStorageSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async rescanAllHba(): Promise<void> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, void>(
      "RescanAllHba", { _this: { attributes: { type: "HostStorageSystem" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async rescanHba(args: {
    hbaDevice: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      hbaDevice: string
    } & { _this: ObjectReference }, void>(
      "RescanHba", { _this: { attributes: { type: "HostStorageSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async rescanVffs(): Promise<void> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, void>(
      "RescanVffs", { _this: { attributes: { type: "HostStorageSystem" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async rescanVmfs(): Promise<void> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, void>(
      "RescanVmfs", { _this: { attributes: { type: "HostStorageSystem" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async resolveMultipleUnresolvedVmfsVolumes(args: {
    resolutionSpec: HostUnresolvedVmfsResolutionSpec[]
  }): Promise<HostUnresolvedVmfsResolutionResult[] | undefined> {
    const result = await this.connection.exec<{
      resolutionSpec: HostUnresolvedVmfsResolutionSpec[]
    } & { _this: ObjectReference }, HostUnresolvedVmfsResolutionResult[] | undefined>(
      "ResolveMultipleUnresolvedVmfsVolumes", { _this: { attributes: { type: "HostStorageSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "HostUnresolvedVmfsResolutionResult[]");
  }
  async resolveMultipleUnresolvedVmfsVolumesEx(args: {
    resolutionSpec: HostUnresolvedVmfsResolutionSpec[]
  }): Promise<Task | undefined> {
    const result = await this.connection.exec<{
      resolutionSpec: HostUnresolvedVmfsResolutionSpec[]
    } & { _this: ObjectReference }, Task | undefined>(
      "ResolveMultipleUnresolvedVmfsVolumesEx_Task", { _this: { attributes: { type: "HostStorageSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async retrieveDiskPartitionInfo(args: {
    devicePath: string[]
  }): Promise<HostDiskPartitionInfo[] | undefined> {
    const result = await this.connection.exec<{
      devicePath: string[]
    } & { _this: ObjectReference }, HostDiskPartitionInfo[] | undefined>(
      "RetrieveDiskPartitionInfo", { _this: { attributes: { type: "HostStorageSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "HostDiskPartitionInfo[]");
  }
  async setMultipathLunPolicy(args: {
    lunId: string;
    policy: HostMultipathInfoLogicalUnitPolicy
  }): Promise<void> {
    const result = await this.connection.exec<{
      lunId: string;
      policy: HostMultipathInfoLogicalUnitPolicy
    } & { _this: ObjectReference }, void>(
      "SetMultipathLunPolicy", { _this: { attributes: { type: "HostStorageSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async setNFSUser(args: {
    user: string;
    password: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      user: string;
      password: string
    } & { _this: ObjectReference }, void>(
      "SetNFSUser", { _this: { attributes: { type: "HostStorageSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async turnDiskLocatorLedOff(args: {
    scsiDiskUuids: string[]
  }): Promise<Task | undefined> {
    const result = await this.connection.exec<{
      scsiDiskUuids: string[]
    } & { _this: ObjectReference }, Task | undefined>(
      "TurnDiskLocatorLedOff_Task", { _this: { attributes: { type: "HostStorageSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async turnDiskLocatorLedOn(args: {
    scsiDiskUuids: string[]
  }): Promise<Task | undefined> {
    const result = await this.connection.exec<{
      scsiDiskUuids: string[]
    } & { _this: ObjectReference }, Task | undefined>(
      "TurnDiskLocatorLedOn_Task", { _this: { attributes: { type: "HostStorageSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async unmapVmfsVolumeEx(args: {
    vmfsUuid: string[]
  }): Promise<Task> {
    const result = await this.connection.exec<{
      vmfsUuid: string[]
    } & { _this: ObjectReference }, Task>(
      "UnmapVmfsVolumeEx_Task", { _this: { attributes: { type: "HostStorageSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async unmountForceMountedVmfsVolume(args: {
    vmfsUuid: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      vmfsUuid: string
    } & { _this: ObjectReference }, void>(
      "UnmountForceMountedVmfsVolume", { _this: { attributes: { type: "HostStorageSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async unmountVffsVolume(args: {
    vffsUuid: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      vffsUuid: string
    } & { _this: ObjectReference }, void>(
      "UnmountVffsVolume", { _this: { attributes: { type: "HostStorageSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async unmountVmfsVolume(args: {
    vmfsUuid: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      vmfsUuid: string
    } & { _this: ObjectReference }, void>(
      "UnmountVmfsVolume", { _this: { attributes: { type: "HostStorageSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async unmountVmfsVolumeEx(args: {
    vmfsUuid: string[]
  }): Promise<Task> {
    const result = await this.connection.exec<{
      vmfsUuid: string[]
    } & { _this: ObjectReference }, Task>(
      "UnmountVmfsVolumeEx_Task", { _this: { attributes: { type: "HostStorageSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async updateDiskPartitions(args: {
    devicePath: string;
    spec: HostDiskPartitionSpec
  }): Promise<void> {
    const result = await this.connection.exec<{
      devicePath: string;
      spec: HostDiskPartitionSpec
    } & { _this: ObjectReference }, void>(
      "UpdateDiskPartitions", { _this: { attributes: { type: "HostStorageSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async updateHppMultipathLunPolicy(args: {
    lunId: string;
    policy: HostMultipathInfoHppLogicalUnitPolicy
  }): Promise<void> {
    const result = await this.connection.exec<{
      lunId: string;
      policy: HostMultipathInfoHppLogicalUnitPolicy
    } & { _this: ObjectReference }, void>(
      "UpdateHppMultipathLunPolicy", { _this: { attributes: { type: "HostStorageSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async updateInternetScsiAdvancedOptions(args: {
    iScsiHbaDevice: string;
    targetSet?: HostInternetScsiHbaTargetSet;
    options: HostInternetScsiHbaParamValue[]
  }): Promise<void> {
    const result = await this.connection.exec<{
      iScsiHbaDevice: string;
      targetSet?: HostInternetScsiHbaTargetSet;
      options: HostInternetScsiHbaParamValue[]
    } & { _this: ObjectReference }, void>(
      "UpdateInternetScsiAdvancedOptions", { _this: { attributes: { type: "HostStorageSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async updateInternetScsiAlias(args: {
    iScsiHbaDevice: string;
    iScsiAlias: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      iScsiHbaDevice: string;
      iScsiAlias: string
    } & { _this: ObjectReference }, void>(
      "UpdateInternetScsiAlias", { _this: { attributes: { type: "HostStorageSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async updateInternetScsiAuthenticationProperties(args: {
    iScsiHbaDevice: string;
    authenticationProperties: HostInternetScsiHbaAuthenticationProperties;
    targetSet?: HostInternetScsiHbaTargetSet
  }): Promise<void> {
    const result = await this.connection.exec<{
      iScsiHbaDevice: string;
      authenticationProperties: HostInternetScsiHbaAuthenticationProperties;
      targetSet?: HostInternetScsiHbaTargetSet
    } & { _this: ObjectReference }, void>(
      "UpdateInternetScsiAuthenticationProperties", { _this: { attributes: { type: "HostStorageSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async updateInternetScsiDigestProperties(args: {
    iScsiHbaDevice: string;
    targetSet?: HostInternetScsiHbaTargetSet;
    digestProperties: HostInternetScsiHbaDigestProperties
  }): Promise<void> {
    const result = await this.connection.exec<{
      iScsiHbaDevice: string;
      targetSet?: HostInternetScsiHbaTargetSet;
      digestProperties: HostInternetScsiHbaDigestProperties
    } & { _this: ObjectReference }, void>(
      "UpdateInternetScsiDigestProperties", { _this: { attributes: { type: "HostStorageSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async updateInternetScsiDiscoveryProperties(args: {
    iScsiHbaDevice: string;
    discoveryProperties: HostInternetScsiHbaDiscoveryProperties
  }): Promise<void> {
    const result = await this.connection.exec<{
      iScsiHbaDevice: string;
      discoveryProperties: HostInternetScsiHbaDiscoveryProperties
    } & { _this: ObjectReference }, void>(
      "UpdateInternetScsiDiscoveryProperties", { _this: { attributes: { type: "HostStorageSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async updateInternetScsiIPProperties(args: {
    iScsiHbaDevice: string;
    ipProperties: HostInternetScsiHbaIPProperties
  }): Promise<void> {
    const result = await this.connection.exec<{
      iScsiHbaDevice: string;
      ipProperties: HostInternetScsiHbaIPProperties
    } & { _this: ObjectReference }, void>(
      "UpdateInternetScsiIPProperties", { _this: { attributes: { type: "HostStorageSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async updateInternetScsiName(args: {
    iScsiHbaDevice: string;
    iScsiName: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      iScsiHbaDevice: string;
      iScsiName: string
    } & { _this: ObjectReference }, void>(
      "UpdateInternetScsiName", { _this: { attributes: { type: "HostStorageSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async updateScsiLunDisplayName(args: {
    lunUuid: string;
    displayName: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      lunUuid: string;
      displayName: string
    } & { _this: ObjectReference }, void>(
      "UpdateScsiLunDisplayName", { _this: { attributes: { type: "HostStorageSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async updateSoftwareInternetScsiEnabled(args: {
    enabled: boolean
  }): Promise<void> {
    const result = await this.connection.exec<{
      enabled: boolean
    } & { _this: ObjectReference }, void>(
      "UpdateSoftwareInternetScsiEnabled", { _this: { attributes: { type: "HostStorageSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async updateVmfsUnmapBandwidth(args: {
    vmfsUuid: string;
    unmapBandwidthSpec: VmfsUnmapBandwidthSpec
  }): Promise<void> {
    const result = await this.connection.exec<{
      vmfsUuid: string;
      unmapBandwidthSpec: VmfsUnmapBandwidthSpec
    } & { _this: ObjectReference }, void>(
      "UpdateVmfsUnmapBandwidth", { _this: { attributes: { type: "HostStorageSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async updateVmfsUnmapPriority(args: {
    vmfsUuid: string;
    unmapPriority: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      vmfsUuid: string;
      unmapPriority: string
    } & { _this: ObjectReference }, void>(
      "UpdateVmfsUnmapPriority", { _this: { attributes: { type: "HostStorageSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async upgradeVmLayout(): Promise<void> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, void>(
      "UpgradeVmLayout", { _this: { attributes: { type: "HostStorageSystem" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async upgradeVmfs(args: {
    vmfsPath: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      vmfsPath: string
    } & { _this: ObjectReference }, void>(
      "UpgradeVmfs", { _this: { attributes: { type: "HostStorageSystem" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  };
}
export class ContainerView extends ManagedObjectView {
  container!: ManagedEntity;
  type?: string[];
  recursive!: boolean;
  constructor(
    public connection: Connection,
    init?: Partial<ContainerView>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  
}
export class InventoryView extends ManagedObjectView {
  
  constructor(
    public connection: Connection,
    init?: Partial<InventoryView>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async closeFolder(args: {
    entity: ManagedEntity[]
  }): Promise<ManagedEntity[] | undefined> {
    const result = await this.connection.exec<{
      entity: ManagedEntity[]
    } & { _this: ObjectReference }, ManagedEntity[] | undefined>(
      "CloseInventoryViewFolder", { _this: { attributes: { type: "InventoryView" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "ManagedEntity[]");
  }
  async openFolder(args: {
    entity: ManagedEntity[]
  }): Promise<ManagedEntity[] | undefined> {
    const result = await this.connection.exec<{
      entity: ManagedEntity[]
    } & { _this: ObjectReference }, ManagedEntity[] | undefined>(
      "OpenInventoryViewFolder", { _this: { attributes: { type: "InventoryView" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "ManagedEntity[]");
  };
}
export class ListView extends ManagedObjectView {
  
  constructor(
    public connection: Connection,
    init?: Partial<ListView>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async modify(args: {
    add?: ManagedObject[];
    remove?: ManagedObject[]
  }): Promise<ManagedObject[] | undefined> {
    const result = await this.connection.exec<{
      add?: ManagedObject[];
      remove?: ManagedObject[]
    } & { _this: ObjectReference }, ManagedObject[] | undefined>(
      "ModifyListView", { _this: { attributes: { type: "ListView" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "ManagedObject[]");
  }
  async reset(args: {
    obj?: ManagedObject[]
  }): Promise<ManagedObject[] | undefined> {
    const result = await this.connection.exec<{
      obj?: ManagedObject[]
    } & { _this: ObjectReference }, ManagedObject[] | undefined>(
      "ResetListView", { _this: { attributes: { type: "ListView" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "ManagedObject[]");
  }
  async resetFromView(args: {
    view: View
  }): Promise<void> {
    const result = await this.connection.exec<{
      view: View
    } & { _this: ObjectReference }, void>(
      "ResetListViewFromView", { _this: { attributes: { type: "ListView" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  };
}
export class ClusterComputeResource extends ComputeResource {
  configuration!: ClusterConfigInfo;
  recommendation?: ClusterRecommendation[];
  drsRecommendation?: ClusterDrsRecommendation[];
  hciConfig?: ClusterComputeResourceHCIConfigInfo;
  migrationHistory?: ClusterDrsMigration[];
  actionHistory?: ClusterActionHistory[];
  drsFault?: ClusterDrsFaults[];
  constructor(
    public connection: Connection,
    init?: Partial<ClusterComputeResource>
  ) {
    super(connection, init);
    if (init) {
      Object.assign(this, constructHelperObjects(connection, init, this.constructor.name, { fromConstructor: true }));
    }
  }
  async AbandonHciWorkflow(): Promise<void> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, void>(
      "AbandonHciWorkflow", { _this: { attributes: { type: "ClusterComputeResource" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async addHost(args: {
    spec: HostConnectSpec;
    asConnected: boolean;
    resourcePool?: ResourcePool;
    license?: string
  }): Promise<Task> {
    const result = await this.connection.exec<{
      spec: HostConnectSpec;
      asConnected: boolean;
      resourcePool?: ResourcePool;
      license?: string
    } & { _this: ObjectReference }, Task>(
      "AddHost_Task", { _this: { attributes: { type: "ClusterComputeResource" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async applyRecommendation(args: {
    key: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      key: string
    } & { _this: ObjectReference }, void>(
      "ApplyRecommendation", { _this: { attributes: { type: "ClusterComputeResource" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async cancelRecommendation(args: {
    key: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      key: string
    } & { _this: ObjectReference }, void>(
      "CancelRecommendation", { _this: { attributes: { type: "ClusterComputeResource" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async enterMaintenanceMode(args: {
    host: HostSystem[];
    option?: OptionValue[]
  }): Promise<ClusterEnterMaintenanceResult> {
    const result = await this.connection.exec<{
      host: HostSystem[];
      option?: OptionValue[]
    } & { _this: ObjectReference }, ClusterEnterMaintenanceResult>(
      "ClusterEnterMaintenanceMode", { _this: { attributes: { type: "ClusterComputeResource" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "ClusterEnterMaintenanceResult");
  }
  async configureHCI(args: {
    clusterSpec: ClusterComputeResourceHCIConfigSpec;
    hostInputs?: ClusterComputeResourceHostConfigurationInput[]
  }): Promise<Task> {
    const result = await this.connection.exec<{
      clusterSpec: ClusterComputeResourceHCIConfigSpec;
      hostInputs?: ClusterComputeResourceHostConfigurationInput[]
    } & { _this: ObjectReference }, Task>(
      "ConfigureHCI_Task", { _this: { attributes: { type: "ClusterComputeResource" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async evcManager(): Promise<ClusterEVCManager | undefined> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, ClusterEVCManager | undefined>(
      "EvcManager", { _this: { attributes: { type: "ClusterComputeResource" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "ClusterEVCManager");
  }
  async extendHCI(args: {
    hostInputs?: ClusterComputeResourceHostConfigurationInput[];
    vSanConfigSpec?: SDDCBase
  }): Promise<Task> {
    const result = await this.connection.exec<{
      hostInputs?: ClusterComputeResourceHostConfigurationInput[];
      vSanConfigSpec?: SDDCBase
    } & { _this: ObjectReference }, Task>(
      "ExtendHCI_Task", { _this: { attributes: { type: "ClusterComputeResource" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async findRulesForVm(args: {
    vm: VirtualMachine
  }): Promise<ClusterRuleInfo[] | undefined> {
    const result = await this.connection.exec<{
      vm: VirtualMachine
    } & { _this: ObjectReference }, ClusterRuleInfo[] | undefined>(
      "FindRulesForVm", { _this: { attributes: { type: "ClusterComputeResource" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "ClusterRuleInfo[]");
  }
  async getResourceUsage(): Promise<ClusterResourceUsageSummary> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, ClusterResourceUsageSummary>(
      "GetResourceUsage", { _this: { attributes: { type: "ClusterComputeResource" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "ClusterResourceUsageSummary");
  }
  async moveHostInto(args: {
    host: HostSystem;
    resourcePool?: ResourcePool
  }): Promise<Task> {
    const result = await this.connection.exec<{
      host: HostSystem;
      resourcePool?: ResourcePool
    } & { _this: ObjectReference }, Task>(
      "MoveHostInto_Task", { _this: { attributes: { type: "ClusterComputeResource" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async moveInto(args: {
    host: HostSystem[]
  }): Promise<Task> {
    const result = await this.connection.exec<{
      host: HostSystem[]
    } & { _this: ObjectReference }, Task>(
      "MoveInto_Task", { _this: { attributes: { type: "ClusterComputeResource" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async placeVm(args: {
    placementSpec: PlacementSpec
  }): Promise<PlacementResult> {
    const result = await this.connection.exec<{
      placementSpec: PlacementSpec
    } & { _this: ObjectReference }, PlacementResult>(
      "PlaceVm", { _this: { attributes: { type: "ClusterComputeResource" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "PlacementResult");
  }
  async recommendHostsForVm(args: {
    vm: VirtualMachine;
    pool?: ResourcePool
  }): Promise<ClusterHostRecommendation[] | undefined> {
    const result = await this.connection.exec<{
      vm: VirtualMachine;
      pool?: ResourcePool
    } & { _this: ObjectReference }, ClusterHostRecommendation[] | undefined>(
      "RecommendHostsForVm", { _this: { attributes: { type: "ClusterComputeResource" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "ClusterHostRecommendation[]");
  }
  async reconfigure(args: {
    spec: ClusterConfigSpec;
    modify: boolean
  }): Promise<Task> {
    const result = await this.connection.exec<{
      spec: ClusterConfigSpec;
      modify: boolean
    } & { _this: ObjectReference }, Task>(
      "ReconfigureCluster_Task", { _this: { attributes: { type: "ClusterComputeResource" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async refreshRecommendation(): Promise<void> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, void>(
      "RefreshRecommendation", { _this: { attributes: { type: "ClusterComputeResource" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async retrieveDasAdvancedRuntimeInfo(): Promise<ClusterDasAdvancedRuntimeInfo | undefined> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, ClusterDasAdvancedRuntimeInfo | undefined>(
      "RetrieveDasAdvancedRuntimeInfo", { _this: { attributes: { type: "ClusterComputeResource" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "ClusterDasAdvancedRuntimeInfo");
  }
  async setCryptoMode(args: {
    cryptoMode: string
  }): Promise<void> {
    const result = await this.connection.exec<{
      cryptoMode: string
    } & { _this: ObjectReference }, void>(
      "SetCryptoMode", { _this: { attributes: { type: "ClusterComputeResource" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "void");
  }
  async stampAllRulesWithUuid(): Promise<Task> {
    const result = await this.connection.exec<unknown & { _this: ObjectReference }, Task>(
      "StampAllRulesWithUuid_Task", { _this: { attributes: { type: "ClusterComputeResource" }, $value: this.$value },  }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "Task");
  }
  async validateHCIConfiguration(args: {
    hciConfigSpec?: ClusterComputeResourceHCIConfigSpec;
    hosts?: HostSystem[]
  }): Promise<ClusterComputeResourceValidationResultBase[] | undefined> {
    const result = await this.connection.exec<{
      hciConfigSpec?: ClusterComputeResourceHCIConfigSpec;
      hosts?: HostSystem[]
    } & { _this: ObjectReference }, ClusterComputeResourceValidationResultBase[] | undefined>(
      "ValidateHCIConfiguration", { _this: { attributes: { type: "ClusterComputeResource" }, $value: this.$value }, ...args }
    ).then(r => r.result);
    return constructHelperObjects(this.connection, result, "ClusterComputeResourceValidationResultBase[]");
  };
}
typeNames.enums["ObjectUpdateKind"] = {};
typeNames.enums["PropertyChangeOp"] = {};
typeNames.enums["BatchResultResult"] = {};
typeNames.enums["ConfigSpecOperation"] = {};
typeNames.enums["DiagnosticManagerLogCreator"] = {};
typeNames.enums["DiagnosticManagerLogFormat"] = {};
typeNames.enums["DrsInjectorWorkloadCorrelationState"] = {};
typeNames.enums["ReplicationVmState"] = {};
typeNames.enums["QuiesceMode"] = {};
typeNames.enums["HealthUpdateInfoComponentType"] = {};
typeNames.enums["HttpNfcLeaseManifestEntryChecksumType"] = {};
typeNames.enums["HttpNfcLeaseMode"] = {};
typeNames.enums["HttpNfcLeaseState"] = {};
typeNames.enums["IoFilterType"] = {};
typeNames.enums["IoFilterOperation"] = {};
typeNames.enums["LatencySensitivitySensitivityLevel"] = {};
typeNames.enums["LicenseFeatureInfoUnit"] = {};
typeNames.enums["LicenseFeatureInfoSourceRestriction"] = {};
typeNames.enums["LicenseFeatureInfoState"] = {};
typeNames.enums["HostLicensableResourceKey"] = {};
typeNames.enums["LicenseManagerLicenseKey"] = {};
typeNames.enums["LicenseManagerState"] = {};
typeNames.enums["LicenseReservationInfoState"] = {};
typeNames.enums["OvfConsumerOstNodeType"] = {};
typeNames.enums["OvfCreateImportSpecParamsDiskProvisioningType"] = {};
typeNames.enums["PerfSummaryType"] = {};
typeNames.enums["PerfStatsType"] = {};
typeNames.enums["PerformanceManagerUnit"] = {};
typeNames.enums["PerfFormat"] = {};
typeNames.enums["ResourceConfigSpecScaleSharesBehavior"] = {};
typeNames.enums["SessionManagerHttpServiceRequestSpecMethod"] = {};
typeNames.enums["SharesLevel"] = {};
typeNames.enums["SimpleCommandEncoding"] = {};
typeNames.enums["StorageIORMThresholdMode"] = {};
typeNames.enums["TaskInfoState"] = {};
typeNames.enums["VsanUpgradeSystemUpgradeHistoryDiskGroupOpType"] = {};
typeNames.enums["ActionParameter"] = {};
typeNames.enums["MetricAlarmOperator"] = {};
typeNames.enums["StateAlarmOperator"] = {};
typeNames.enums["ActionType"] = {};
typeNames.enums["ClusterCryptoConfigInfoCryptoMode"] = {};
typeNames.enums["ClusterDasAamNodeStateDasState"] = {};
typeNames.enums["ClusterDasConfigInfoHBDatastoreCandidate"] = {};
typeNames.enums["ClusterDasConfigInfoServiceState"] = {};
typeNames.enums["ClusterDasConfigInfoVmMonitoringState"] = {};
typeNames.enums["ClusterDasFdmAvailabilityState"] = {};
typeNames.enums["DasVmPriority"] = {};
typeNames.enums["ClusterDasVmSettingsIsolationResponse"] = {};
typeNames.enums["ClusterDasVmSettingsRestartPriority"] = {};
typeNames.enums["DpmBehavior"] = {};
typeNames.enums["DrsBehavior"] = {};
typeNames.enums["DrsRecommendationReasonCode"] = {};
typeNames.enums["ClusterHostInfraUpdateHaModeActionOperationType"] = {};
typeNames.enums["HostPowerOperationType"] = {};
typeNames.enums["ClusterInfraUpdateHaConfigInfoBehaviorType"] = {};
typeNames.enums["ClusterInfraUpdateHaConfigInfoRemediationType"] = {};
typeNames.enums["ClusterPowerOnVmOption"] = {};
typeNames.enums["RecommendationReasonCode"] = {};
typeNames.enums["RecommendationType"] = {};
typeNames.enums["ClusterVmComponentProtectionSettingsStorageVmReaction"] = {};
typeNames.enums["ClusterVmComponentProtectionSettingsVmReactionOnAPDCleared"] = {};
typeNames.enums["ClusterVmReadinessReadyCondition"] = {};
typeNames.enums["DvsFilterOnFailure"] = {};
typeNames.enums["DVPortStatusVmDirectPathGen2InactiveReasonNetwork"] = {};
typeNames.enums["DVPortStatusVmDirectPathGen2InactiveReasonOther"] = {};
typeNames.enums["EntityType"] = {};
typeNames.enums["EntityImportType"] = {};
typeNames.enums["DistributedVirtualSwitchHostMemberHostComponentState"] = {};
typeNames.enums["DistributedVirtualSwitchHostMemberTransportZoneType"] = {};
typeNames.enums["DistributedVirtualSwitchPortConnecteeConnecteeType"] = {};
typeNames.enums["DvsNetworkRuleDirectionType"] = {};
typeNames.enums["KmipClusterInfoKmsManagementType"] = {};
typeNames.enums["EventEventSeverity"] = {};
typeNames.enums["EventCategory"] = {};
typeNames.enums["EventFilterSpecRecursionOption"] = {};
typeNames.enums["VmFailedStartingSecondaryEventFailureReason"] = {};
typeNames.enums["VmShutdownOnIsolationEventOperation"] = {};
typeNames.enums["DisallowedChangeByServiceDisallowedChange"] = {};
typeNames.enums["InvalidDasConfigArgumentEntryForInvalidArgument"] = {};
typeNames.enums["InvalidProfileReferenceHostReason"] = {};
typeNames.enums["LicenseAssignmentFailedReason"] = {};
typeNames.enums["ThirdPartyLicenseAssignmentFailedReason"] = {};
typeNames.enums["AutoStartAction"] = {};
typeNames.enums["AutoStartWaitHeartbeatSetting"] = {};
typeNames.enums["HostCapabilityFtUnsupportedReason"] = {};
typeNames.enums["HostReplayUnsupportedReason"] = {};
typeNames.enums["HostCapabilityUnmapMethodSupported"] = {};
typeNames.enums["HostCapabilityVmDirectPathGen2UnsupportedReason"] = {};
typeNames.enums["HostCertificateManagerCertificateInfoCertificateStatus"] = {};
typeNames.enums["HostConfigChangeMode"] = {};
typeNames.enums["HostConfigChangeOperation"] = {};
typeNames.enums["HostCpuPackageVendor"] = {};
typeNames.enums["HostCpuPowerManagementInfoPolicyType"] = {};
typeNames.enums["HostDigestInfoDigestMethodType"] = {};
typeNames.enums["HostDiskPartitionInfoPartitionFormat"] = {};
typeNames.enums["HostDiskPartitionInfoType"] = {};
typeNames.enums["HostFeatureVersionKey"] = {};
typeNames.enums["FileSystemMountInfoVStorageSupportStatus"] = {};
typeNames.enums["HostFileSystemVolumeFileSystemType"] = {};
typeNames.enums["HostGraphicsConfigGraphicsType"] = {};
typeNames.enums["HostGraphicsConfigSharedPassthruAssignmentPolicy"] = {};
typeNames.enums["HostGraphicsInfoGraphicsType"] = {};
typeNames.enums["HostHardwareElementStatus"] = {};
typeNames.enums["HostAccessMode"] = {};
typeNames.enums["HostLockdownMode"] = {};
typeNames.enums["HostImageAcceptanceLevel"] = {};
typeNames.enums["HostIpConfigIpV6AddressConfigType"] = {};
typeNames.enums["HostIpConfigIpV6AddressStatus"] = {};
typeNames.enums["IscsiPortInfoPathStatus"] = {};
typeNames.enums["LinkDiscoveryProtocolConfigOperationType"] = {};
typeNames.enums["LinkDiscoveryProtocolConfigProtocolType"] = {};
typeNames.enums["HostLowLevelProvisioningManagerFileType"] = {};
typeNames.enums["HostLowLevelProvisioningManagerReloadTarget"] = {};
typeNames.enums["HostMaintenanceSpecPurpose"] = {};
typeNames.enums["VirtualMachineMemoryAllocationPolicy"] = {};
typeNames.enums["HostMountMode"] = {};
typeNames.enums["HostMountInfoInaccessibleReason"] = {};
typeNames.enums["MultipathState"] = {};
typeNames.enums["HostNasVolumeSecurityType"] = {};
typeNames.enums["HostNetStackInstanceCongestionControlAlgorithmType"] = {};
typeNames.enums["HostNetStackInstanceSystemStackKey"] = {};
typeNames.enums["HostNumericSensorHealthState"] = {};
typeNames.enums["HostNumericSensorType"] = {};
typeNames.enums["NvdimmNvdimmHealthInfoState"] = {};
typeNames.enums["NvdimmInterleaveSetState"] = {};
typeNames.enums["NvdimmNamespaceDetailsHealthStatus"] = {};
typeNames.enums["NvdimmNamespaceDetailsState"] = {};
typeNames.enums["NvdimmNamespaceHealthStatus"] = {};
typeNames.enums["NvdimmNamespaceState"] = {};
typeNames.enums["NvdimmNamespaceType"] = {};
typeNames.enums["NvdimmRangeType"] = {};
typeNames.enums["HostNvmeDiscoveryLogSubsystemType"] = {};
typeNames.enums["HostNvmeDiscoveryLogTransportRequirements"] = {};
typeNames.enums["HostNvmeTransportParametersNvmeAddressFamily"] = {};
typeNames.enums["HostNvmeTransportType"] = {};
typeNames.enums["HostOpaqueSwitchOpaqueSwitchState"] = {};
typeNames.enums["HostPatchManagerInstallState"] = {};
typeNames.enums["HostPatchManagerIntegrityStatus"] = {};
typeNames.enums["HostPatchManagerReason"] = {};
typeNames.enums["PhysicalNicResourcePoolSchedulerDisallowedReason"] = {};
typeNames.enums["PhysicalNicVmDirectPathGen2SupportedMode"] = {};
typeNames.enums["PortGroupConnecteeType"] = {};
typeNames.enums["HostProtocolEndpointPEType"] = {};
typeNames.enums["HostProtocolEndpointProtocolEndpointType"] = {};
typeNames.enums["HostRdmaDeviceConnectionState"] = {};
typeNames.enums["HostFirewallRuleDirection"] = {};
typeNames.enums["HostFirewallRulePortType"] = {};
typeNames.enums["HostFirewallRuleProtocol"] = {};
typeNames.enums["ScsiLunDescriptorQuality"] = {};
typeNames.enums["ScsiLunType"] = {};
typeNames.enums["ScsiLunState"] = {};
typeNames.enums["ScsiLunVStorageSupportStatus"] = {};
typeNames.enums["HostServicePolicy"] = {};
typeNames.enums["HostSevInfoSevState"] = {};
typeNames.enums["HostSgxInfoFlcModes"] = {};
typeNames.enums["HostSgxInfoSgxStates"] = {};
typeNames.enums["HostSnmpAgentCapability"] = {};
typeNames.enums["SoftwarePackageConstraint"] = {};
typeNames.enums["SoftwarePackageVibType"] = {};
typeNames.enums["HostStorageProtocol"] = {};
typeNames.enums["HostSystemIdentificationInfoIdentifier"] = {};
typeNames.enums["HostTpmAttestationInfoAcceptanceStatus"] = {};
typeNames.enums["HostTrustAuthorityAttestationInfoAttestationStatus"] = {};
typeNames.enums["HostUnresolvedVmfsResolutionSpecVmfsUuidResolution"] = {};
typeNames.enums["HostVirtualNicManagerNicType"] = {};
typeNames.enums["HostVmciAccessManagerMode"] = {};
typeNames.enums["NetIpConfigInfoIpAddressOrigin"] = {};
typeNames.enums["NetIpConfigInfoIpAddressStatus"] = {};
typeNames.enums["NetIpStackInfoEntryType"] = {};
typeNames.enums["NetIpStackInfoPreference"] = {};
typeNames.enums["NetBIOSConfigInfoMode"] = {};
typeNames.enums["ArrayUpdateOperation"] = {};
typeNames.enums["ComplianceResultStatus"] = {};
typeNames.enums["ProfileNumericComparator"] = {};
typeNames.enums["ProfileParameterMetadataRelationType"] = {};
typeNames.enums["ClusterProfileServiceType"] = {};
typeNames.enums["ProfileExecuteResultStatus"] = {};
typeNames.enums["AnswerFileValidationInfoStatus"] = {};
typeNames.enums["PlacementAffinityRuleRuleScope"] = {};
typeNames.enums["PlacementAffinityRuleRuleType"] = {};
typeNames.enums["StorageDrsPodConfigInfoBehavior"] = {};
typeNames.enums["StorageDrsSpaceLoadBalanceConfigSpaceThresholdMode"] = {};
typeNames.enums["VAppCloneSpecProvisioningType"] = {};
typeNames.enums["VAppAutoStartAction"] = {};
typeNames.enums["VAppIPAssignmentInfoAllocationSchemes"] = {};
typeNames.enums["VAppIPAssignmentInfoIpAllocationPolicy"] = {};
typeNames.enums["VAppIPAssignmentInfoProtocols"] = {};
typeNames.enums["VchaState"] = {};
typeNames.enums["VchaClusterMode"] = {};
typeNames.enums["VchaClusterState"] = {};
typeNames.enums["VchaNodeRole"] = {};
typeNames.enums["VchaNodeState"] = {};
typeNames.enums["VirtualMachineBootOptionsNetworkBootProtocolType"] = {};
typeNames.enums["VirtualMachineConfigInfoNpivWwnType"] = {};
typeNames.enums["VirtualMachineConfigInfoSwapPlacementType"] = {};
typeNames.enums["VirtualMachineConfigSpecEncryptedVMotionModes"] = {};
typeNames.enums["VirtualMachineConfigSpecNpivWwnOp"] = {};
typeNames.enums["VirtualMachinePowerOpType"] = {};
typeNames.enums["VirtualMachineStandbyActionType"] = {};
typeNames.enums["VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonOther"] = {};
typeNames.enums["VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm"] = {};
typeNames.enums["VirtualMachineFileLayoutExFileType"] = {};
typeNames.enums["VirtualMachineHtSharing"] = {};
typeNames.enums["VirtualMachineFlagInfoMonitorType"] = {};
typeNames.enums["VirtualMachinePowerOffBehavior"] = {};
typeNames.enums["VirtualMachineFlagInfoVirtualExecUsage"] = {};
typeNames.enums["VirtualMachineFlagInfoVirtualMmuUsage"] = {};
typeNames.enums["VirtualMachineForkConfigInfoChildType"] = {};
typeNames.enums["GuestInfoAppStateType"] = {};
typeNames.enums["VirtualMachineGuestState"] = {};
typeNames.enums["VirtualMachineToolsInstallType"] = {};
typeNames.enums["VirtualMachineToolsRunningStatus"] = {};
typeNames.enums["VirtualMachineToolsStatus"] = {};
typeNames.enums["VirtualMachineToolsVersionStatus"] = {};
typeNames.enums["GuestOsDescriptorFirmwareType"] = {};
typeNames.enums["VirtualMachineGuestOsFamily"] = {};
typeNames.enums["VirtualMachineGuestOsIdentifier"] = {};
typeNames.enums["GuestOsDescriptorSupportLevel"] = {};
typeNames.enums["VirtualMachineMetadataManagerVmMetadataOp"] = {};
typeNames.enums["VirtualMachineMetadataManagerVmMetadataOwnerOwner"] = {};
typeNames.enums["ScheduledHardwareUpgradeInfoHardwareUpgradePolicy"] = {};
typeNames.enums["ScheduledHardwareUpgradeInfoHardwareUpgradeStatus"] = {};
typeNames.enums["VirtualMachineSgxInfoFlcModes"] = {};
typeNames.enums["VirtualMachineTargetInfoConfigurationTag"] = {};
typeNames.enums["UpgradePolicy"] = {};
typeNames.enums["VirtualMachineUsbInfoFamily"] = {};
typeNames.enums["VirtualMachineUsbInfoSpeed"] = {};
typeNames.enums["VirtualMachineWindowsQuiesceSpecVssBackupContext"] = {};
typeNames.enums["CheckTestType"] = {};
typeNames.enums["CustomizationNetBIOSMode"] = {};
typeNames.enums["CustomizationLicenseDataMode"] = {};
typeNames.enums["CustomizationSysprepRebootOption"] = {};
typeNames.enums["VirtualDeviceConnectInfoMigrateConnectOp"] = {};
typeNames.enums["VirtualDeviceConnectInfoStatus"] = {};
typeNames.enums["VirtualDeviceFileExtension"] = {};
typeNames.enums["VirtualDeviceURIBackingOptionDirection"] = {};
typeNames.enums["VirtualDeviceConfigSpecFileOperation"] = {};
typeNames.enums["VirtualDeviceConfigSpecOperation"] = {};
typeNames.enums["VirtualDiskDeltaDiskFormat"] = {};
typeNames.enums["VirtualDiskDeltaDiskFormatVariant"] = {};
typeNames.enums["VirtualDiskSharing"] = {};
typeNames.enums["VirtualDiskVFlashCacheConfigInfoCacheConsistencyType"] = {};
typeNames.enums["VirtualDiskVFlashCacheConfigInfoCacheMode"] = {};
typeNames.enums["VirtualDiskCompatibilityMode"] = {};
typeNames.enums["VirtualDiskMode"] = {};
typeNames.enums["VirtualEthernetCardLegacyNetworkDeviceName"] = {};
typeNames.enums["VirtualEthernetCardMacType"] = {};
typeNames.enums["VirtualPointingDeviceHostChoice"] = {};
typeNames.enums["VirtualSerialPortEndPoint"] = {};
typeNames.enums["VirtualMachineVMCIDeviceAction"] = {};
typeNames.enums["VirtualMachineVMCIDeviceDirection"] = {};
typeNames.enums["VirtualMachineVMCIDeviceProtocol"] = {};
typeNames.enums["VirtualMachineVideoCardUse3dRenderer"] = {};
typeNames.enums["GuestFileType"] = {};
typeNames.enums["GuestRegKeyWowSpec"] = {};
typeNames.enums["VsanHostDecommissionModeObjectAction"] = {};
typeNames.enums["VsanHostDiskResultState"] = {};
typeNames.enums["VsanHostHealthState"] = {};
typeNames.enums["VsanHostNodeState"] = {};
typeNames.enums["VsanDiskIssueType"] = {};
typeNames.enums["BaseConfigInfoDiskFileBackingInfoProvisioningType"] = {};
typeNames.enums["VStorageObjectConsumptionType"] = {};
typeNames.enums["vslmVStorageObjectControlFlag"] = {};
typeNames.enums["ManagedEntityStatus"] = {};
typeNames.enums["TaskFilterSpecRecursionOption"] = {};
typeNames.enums["TaskFilterSpecTimeOption"] = {};
typeNames.enums["VirtualAppVAppState"] = {};
typeNames.enums["VirtualDiskAdapterType"] = {};
typeNames.enums["VirtualDiskType"] = {};
typeNames.enums["VirtualMachineAppHeartbeatStatusType"] = {};
typeNames.enums["VirtualMachineConnectionState"] = {};
typeNames.enums["VirtualMachineCryptoState"] = {};
typeNames.enums["VirtualMachineFaultToleranceState"] = {};
typeNames.enums["VirtualMachineFaultToleranceType"] = {};
typeNames.enums["VirtualMachineMovePriority"] = {};
typeNames.enums["VirtualMachineNeedSecondaryReason"] = {};
typeNames.enums["VirtualMachinePowerState"] = {};
typeNames.enums["VirtualMachineRecordReplayState"] = {};
typeNames.enums["VirtualMachineTicketType"] = {};
typeNames.enums["AlarmFilterSpecAlarmTypeByEntity"] = {};
typeNames.enums["AlarmFilterSpecAlarmTypeByTrigger"] = {};
typeNames.enums["EventAlarmExpressionComparisonOperator"] = {};
typeNames.enums["PlacementSpecPlacementType"] = {};
typeNames.enums["DistributedVirtualPortgroupBackingType"] = {};
typeNames.enums["DistributedVirtualPortgroupMetaTagName"] = {};
typeNames.enums["DistributedVirtualPortgroupPortgroupType"] = {};
typeNames.enums["CryptoManagerKmipCryptoKeyStatusKeyUnavailableReason"] = {};
typeNames.enums["CustomizationFailedReasonCode"] = {};
typeNames.enums["DvsEventPortBlockState"] = {};
typeNames.enums["HostDasErrorEventHostDasErrorReason"] = {};
typeNames.enums["HostDisconnectedEventReasonCode"] = {};
typeNames.enums["VmDasBeingResetEventReasonCode"] = {};
typeNames.enums["CannotEnableVmcpForClusterReason"] = {};
typeNames.enums["CannotMoveFaultToleranceVmMoveType"] = {};
typeNames.enums["CannotUseNetworkReason"] = {};
typeNames.enums["DasConfigFaultDasConfigFaultReason"] = {};
typeNames.enums["FtIssuesOnHostHostSelectionType"] = {};
typeNames.enums["HostHasComponentFailureHostComponentType"] = {};
typeNames.enums["HostIncompatibleForFaultToleranceReason"] = {};
typeNames.enums["HostIncompatibleForRecordReplayReason"] = {};
typeNames.enums["NotSupportedDeviceForFTDeviceType"] = {};
typeNames.enums["NumVirtualCpusIncompatibleReason"] = {};
typeNames.enums["QuarantineModeFaultFaultType"] = {};
typeNames.enums["ReplicationVmFaultReasonForFault"] = {};
typeNames.enums["ReplicationVmInProgressFaultActivity"] = {};
typeNames.enums["VFlashModuleNotSupportedReason"] = {};
typeNames.enums["VmFaultToleranceConfigIssueReasonForIssue"] = {};
typeNames.enums["VmFaultToleranceInvalidFileBackingDeviceType"] = {};
typeNames.enums["WillLoseHAProtectionResolution"] = {};
typeNames.enums["HostActiveDirectoryAuthenticationCertificateDigest"] = {};
typeNames.enums["HostActiveDirectoryInfoDomainMembershipStatus"] = {};
typeNames.enums["HostDateTimeInfoProtocol"] = {};
typeNames.enums["FibreChannelPortType"] = {};
typeNames.enums["HostInternetScsiHbaChapAuthenticationType"] = {};
typeNames.enums["HostInternetScsiHbaDigestType"] = {};
typeNames.enums["InternetScsiSnsDiscoveryMethod"] = {};
typeNames.enums["SlpDiscoveryMethod"] = {};
typeNames.enums["HostInternetScsiHbaIscsiIpv6AddressAddressConfigurationType"] = {};
typeNames.enums["HostInternetScsiHbaIscsiIpv6AddressIPv6AddressOperation"] = {};
typeNames.enums["HostInternetScsiHbaNetworkBindingSupportType"] = {};
typeNames.enums["HostInternetScsiHbaStaticTargetTargetDiscoveryMethod"] = {};
typeNames.enums["ScsiDiskType"] = {};
typeNames.enums["HostUnresolvedVmfsExtentUnresolvedReason"] = {};
typeNames.enums["HostVmfsVolumeUnmapBandwidthPolicy"] = {};
typeNames.enums["HostVmfsVolumeUnmapPriority"] = {};
typeNames.enums["HostProfileValidationFailureInfoUpdateType"] = {};
typeNames.enums["HostProfileValidationState"] = {};
typeNames.enums["HostProfileManagerAnswerFileStatus"] = {};
typeNames.enums["ApplyHostProfileConfigurationResultStatus"] = {};
typeNames.enums["HostProfileManagerCompositionResultResultElementStatus"] = {};
typeNames.enums["HostProfileManagerCompositionValidationResultResultElementStatus"] = {};
typeNames.enums["HostProfileManagerTaskListRequirement"] = {};
typeNames.enums["StoragePlacementSpecPlacementType"] = {};
typeNames.enums["VirtualDiskRuleSpecRuleType"] = {};
typeNames.enums["VirtualMachineRelocateDiskMoveOptions"] = {};
typeNames.enums["VirtualMachineRelocateTransformation"] = {};
typeNames.enums["VirtualMachineScsiPassthroughType"] = {};
typeNames.enums["VirtualSCSISharing"] = {};
typeNames.enums["VirtualVmxnet3VrdmaOptionDeviceProtocols"] = {};
typeNames.enums["ComputeResourceHostSPBMLicenseInfoHostSPBMLicenseState"] = {};
typeNames.enums["DatastoreAccessible"] = {};
typeNames.enums["DatastoreSummaryMaintenanceModeState"] = {};
typeNames.enums["DistributedVirtualSwitchHostInfrastructureTrafficClass"] = {};
typeNames.enums["DistributedVirtualSwitchNetworkResourceControlVersion"] = {};
typeNames.enums["DistributedVirtualSwitchNicTeamingPolicyMode"] = {};
typeNames.enums["DistributedVirtualSwitchProductSpecOperationType"] = {};
typeNames.enums["FolderDesiredHostState"] = {};
typeNames.enums["HostSystemConnectionState"] = {};
typeNames.enums["HostCryptoState"] = {};
typeNames.enums["HostSystemPowerState"] = {};
typeNames.enums["HostSystemRemediationStateState"] = {};
typeNames.enums["HostStandbyMode"] = {};
typeNames.enums["VMotionCompatibilityType"] = {};
typeNames.enums["ValidateMigrationTestType"] = {};
typeNames.enums["VMwareDvsLacpApiVersion"] = {};
typeNames.enums["VMwareDvsLacpLoadBalanceAlgorithm"] = {};
typeNames.enums["DVSMacLimitPolicyType"] = {};
typeNames.enums["VMwareDvsMulticastFilteringMode"] = {};
typeNames.enums["VmwareDistributedVirtualSwitchPvlanPortType"] = {};
typeNames.enums["VMwareDVSTeamingMatchStatus"] = {};
typeNames.enums["VMwareUplinkLacpMode"] = {};
typeNames.enums["VMwareDVSVspanSessionEncapType"] = {};
typeNames.enums["VMwareDVSVspanSessionType"] = {};
typeNames.enums["AffinityType"] = {};
typeNames.enums["AgentInstallFailedReason"] = {};
typeNames.enums["CannotPowerOffVmInClusterOperation"] = {};
typeNames.enums["DeviceNotSupportedReason"] = {};
typeNames.enums["IncompatibleHostForVmReplicationIncompatibleReason"] = {};
typeNames.enums["ReplicationDiskConfigFaultReasonForFault"] = {};
typeNames.enums["ReplicationVmConfigFaultReasonForFault"] = {};
typeNames.enums["DiagnosticPartitionType"] = {};
typeNames.enums["DiagnosticPartitionStorageType"] = {};
typeNames.enums["HostRuntimeInfoNetStackInstanceRuntimeInfoState"] = {};
typeNames.enums["ClusterComputeResourceHCIWorkflowState"] = {};
typeNames.enums["DayOfWeek"] = {};
typeNames.enums["WeekOfMonth"] = {};
typeNames.interfaces["DynamicArray"] = {
dynamicType: "string",
        val: "any"
};
typeNames.interfaces["DynamicData"] = {
dynamicType: "string",
        dynamicProperty: "DynamicProperty"
};
typeNames.interfaces["DynamicProperty"] = {
name: "string",
        val: "any"
};
typeNames.interfaces["KeyAnyValue"] = {
key: "string",
        value: "any"
};
typeNames.interfaces["LocalizableMessage"] = {
key: "string",
        arg: "KeyAnyValue",
        message: "string"
};
typeNames.interfaces["HostCommunication"] = {

};
typeNames.interfaces["HostNotConnected"] = {

};
typeNames.interfaces["HostNotReachable"] = {

};
typeNames.interfaces["InvalidArgument"] = {
invalidProperty: "string"
};
typeNames.interfaces["InvalidRequest"] = {

};
typeNames.interfaces["InvalidType"] = {
argument: "string"
};
typeNames.interfaces["ManagedObjectNotFound"] = {
obj: "ManagedObject"
};
typeNames.interfaces["MethodNotFound"] = {
receiver: "ManagedObject",
        method: "string"
};
typeNames.interfaces["NotEnoughLicenses"] = {

};
typeNames.interfaces["NotImplemented"] = {

};
typeNames.interfaces["NotSupported"] = {

};
typeNames.interfaces["RequestCanceled"] = {

};
typeNames.interfaces["SecurityError"] = {

};
typeNames.interfaces["SystemError"] = {
reason: "string"
};
typeNames.interfaces["UnexpectedFault"] = {
faultName: "string",
        fault: "MethodFault"
};
typeNames.interfaces["InvalidCollectorVersion"] = {

};
typeNames.interfaces["InvalidProperty"] = {
name: "string"
};
typeNames.interfaces["PropertyFilterSpec"] = {
propSet: "PropertySpec",
        objectSet: "ObjectSpec",
        reportMissingObjectsInResults: "boolean"
};
typeNames.interfaces["PropertySpec"] = {
type: "string",
        all: "boolean",
        pathSet: "string"
};
typeNames.interfaces["ObjectSpec"] = {
obj: "ManagedObject",
        skip: "boolean",
        selectSet: "SelectionSpec"
};
typeNames.interfaces["SelectionSpec"] = {
name: "string"
};
typeNames.interfaces["TraversalSpec"] = {
type: "string",
        path: "string",
        skip: "boolean",
        selectSet: "SelectionSpec"
};
typeNames.interfaces["ObjectContent"] = {
obj: "ManagedObject",
        propSet: "DynamicProperty",
        missingSet: "MissingProperty"
};
typeNames.interfaces["UpdateSet"] = {
version: "string",
        filterSet: "PropertyFilterUpdate",
        truncated: "boolean"
};
typeNames.interfaces["PropertyFilterUpdate"] = {
filter: PropertyFilter,
        objectSet: "ObjectUpdate",
        missingSet: "MissingObject"
};
typeNames.interfaces["ObjectUpdate"] = {
kind: "ObjectUpdateKind",
        obj: "ManagedObject",
        changeSet: "PropertyChange",
        missingSet: "MissingProperty"
};
typeNames.interfaces["PropertyChange"] = {
name: "string",
        op: "PropertyChangeOp",
        val: "any"
};
typeNames.interfaces["MissingProperty"] = {
path: "string",
        fault: "MethodFault"
};
typeNames.interfaces["MissingObject"] = {
obj: "ManagedObject",
        fault: "MethodFault"
};
typeNames.interfaces["WaitOptions"] = {
maxWaitSeconds: "number",
        maxObjectUpdates: "number"
};
typeNames.interfaces["RetrieveOptions"] = {
maxObjects: "number"
};
typeNames.interfaces["RetrieveResult"] = {
token: "string",
        objects: "ObjectContent"
};
typeNames.interfaces["AboutInfo"] = {
name: "string",
        fullName: "string",
        vendor: "string",
        version: "string",
        build: "string",
        localeVersion: "string",
        localeBuild: "string",
        osType: "string",
        productLineId: "string",
        apiType: "string",
        apiVersion: "string",
        instanceUuid: "string",
        licenseProductName: "string",
        licenseProductVersion: "string"
};
typeNames.interfaces["AuthorizationDescription"] = {
privilege: "ElementDescription",
        privilegeGroup: "ElementDescription"
};
typeNames.interfaces["BatchResult"] = {
result: "string",
        hostKey: "string",
        ds: Datastore,
        fault: "MethodFault"
};
typeNames.interfaces["Capability"] = {
provisioningSupported: "boolean",
        multiHostSupported: "boolean",
        userShellAccessSupported: "boolean",
        supportedEVCMode: "EVCMode",
        supportedEVCGraphicsMode: "FeatureEVCMode",
        networkBackupAndRestoreSupported: "boolean",
        ftDrsWithoutEvcSupported: "boolean",
        hciWorkflowSupported: "boolean",
        computePolicyVersion: "number",
        clusterPlacementSupported: "boolean",
        lifecycleManagementSupported: "boolean",
        scalableSharesSupported: "boolean"
};
typeNames.interfaces["CustomFieldDef"] = {
key: "number",
        name: "string",
        type: "string",
        managedObjectType: "string",
        fieldDefPrivileges: "PrivilegePolicyDef",
        fieldInstancePrivileges: "PrivilegePolicyDef"
};
typeNames.interfaces["CustomFieldStringValue"] = {
value: "string"
};
typeNames.interfaces["CustomFieldValue"] = {
key: "number"
};
typeNames.interfaces["CustomizationSpecInfo"] = {
name: "string",
        description: "string",
        type: "string",
        changeVersion: "string",
        lastUpdateTime: "Date"
};
typeNames.interfaces["CustomizationSpecItem"] = {
info: "CustomizationSpecInfo",
        spec: "CustomizationSpec"
};
typeNames.interfaces["Description"] = {
label: "string",
        summary: "string"
};
typeNames.interfaces["DesiredSoftwareSpec"] = {
baseImageSpec: "DesiredSoftwareSpecBaseImageSpec",
        vendorAddOnSpec: "DesiredSoftwareSpecVendorAddOnSpec"
};
typeNames.interfaces["DesiredSoftwareSpecBaseImageSpec"] = {
version: "string"
};
typeNames.interfaces["DesiredSoftwareSpecVendorAddOnSpec"] = {
name: "string",
        version: "string"
};
typeNames.interfaces["DiagnosticManagerBundleInfo"] = {
system: HostSystem,
        url: "string"
};
typeNames.interfaces["DiagnosticManagerLogDescriptor"] = {
key: "string",
        fileName: "string",
        creator: "string",
        format: "string",
        mimeType: "string",
        info: "Description"
};
typeNames.interfaces["DiagnosticManagerLogHeader"] = {
lineStart: "number",
        lineEnd: "number",
        lineText: "string"
};
typeNames.interfaces["ElementDescription"] = {
key: "string"
};
typeNames.interfaces["EnumDescription"] = {
key: "string",
        tags: "ElementDescription"
};
typeNames.interfaces["EnvironmentBrowserConfigOptionQuerySpec"] = {
key: "string",
        host: HostSystem,
        guestId: "string"
};
typeNames.interfaces["ExtendedDescription"] = {
messageCatalogKeyPrefix: "string",
        messageArg: "KeyAnyValue"
};
typeNames.interfaces["ExtendedElementDescription"] = {
messageCatalogKeyPrefix: "string",
        messageArg: "KeyAnyValue"
};
typeNames.interfaces["Extension"] = {
description: "Description",
        key: "string",
        company: "string",
        type: "string",
        version: "string",
        subjectName: "string",
        server: "ExtensionServerInfo",
        client: "ExtensionClientInfo",
        taskList: "ExtensionTaskTypeInfo",
        eventList: "ExtensionEventTypeInfo",
        faultList: "ExtensionFaultTypeInfo",
        privilegeList: "ExtensionPrivilegeInfo",
        resourceList: "ExtensionResourceInfo",
        lastHeartbeatTime: "Date",
        healthInfo: "ExtensionHealthInfo",
        ovfConsumerInfo: "ExtensionOvfConsumerInfo",
        extendedProductInfo: "ExtExtendedProductInfo",
        managedEntityInfo: "ExtManagedEntityInfo",
        shownInSolutionManager: "boolean",
        solutionManagerInfo: "ExtSolutionManagerInfo"
};
typeNames.interfaces["ExtensionClientInfo"] = {
version: "string",
        description: "Description",
        company: "string",
        type: "string",
        url: "string"
};
typeNames.interfaces["ExtensionEventTypeInfo"] = {
eventID: "string",
        eventTypeSchema: "string"
};
typeNames.interfaces["ExtensionFaultTypeInfo"] = {
faultID: "string"
};
typeNames.interfaces["ExtensionHealthInfo"] = {
url: "string"
};
typeNames.interfaces["ExtensionOvfConsumerInfo"] = {
callbackUrl: "string",
        sectionType: "string"
};
typeNames.interfaces["ExtensionPrivilegeInfo"] = {
privID: "string",
        privGroupName: "string"
};
typeNames.interfaces["ExtensionResourceInfo"] = {
locale: "string",
        module: "string",
        data: "KeyValue"
};
typeNames.interfaces["ExtensionServerInfo"] = {
url: "string",
        description: "Description",
        company: "string",
        type: "string",
        adminEmail: "string",
        serverThumbprint: "string"
};
typeNames.interfaces["ExtensionTaskTypeInfo"] = {
taskID: "string"
};
typeNames.interfaces["ExtensionManagerIpAllocationUsage"] = {
extensionKey: "string",
        numAddresses: "number"
};
typeNames.interfaces["FaultsByHost"] = {
host: HostSystem,
        faults: "MethodFault"
};
typeNames.interfaces["FaultsByVM"] = {
vm: VirtualMachine,
        faults: "MethodFault"
};
typeNames.interfaces["FeatureEVCMode"] = {
mask: "HostFeatureMask",
        capability: "HostFeatureCapability",
        requirement: "VirtualMachineFeatureRequirement"
};
typeNames.interfaces["HbrManagerReplicationVmInfo"] = {
state: "string",
        progressInfo: "ReplicationVmProgressInfo",
        imageId: "string",
        lastError: "MethodFault"
};
typeNames.interfaces["ReplicationVmProgressInfo"] = {
progress: "number",
        bytesTransferred: "number",
        bytesToTransfer: "number",
        checksumTotalBytes: "number",
        checksumComparedBytes: "number"
};
typeNames.interfaces["HbrManagerVmReplicationCapability"] = {
vm: VirtualMachine,
        supportedQuiesceMode: "string",
        compressionSupported: "boolean",
        maxSupportedSourceDiskCapacity: "number",
        minRpo: "number",
        fault: "MethodFault"
};
typeNames.interfaces["HealthUpdateInfo"] = {
id: "string",
        componentType: "string",
        description: "string"
};
typeNames.interfaces["PerfInterval"] = {
key: "number",
        samplingPeriod: "number",
        name: "string",
        length: "number",
        level: "number",
        enabled: "boolean"
};
typeNames.interfaces["HostServiceTicket"] = {
host: "string",
        port: "number",
        sslThumbprint: "string",
        service: "string",
        serviceVersion: "string",
        sessionId: "string"
};
typeNames.interfaces["HttpNfcLeaseCapabilities"] = {
pullModeSupported: "boolean",
        corsSupported: "boolean"
};
typeNames.interfaces["HttpNfcLeaseDatastoreLeaseInfo"] = {
datastoreKey: "string",
        hosts: "HttpNfcLeaseHostInfo"
};
typeNames.interfaces["HttpNfcLeaseDeviceUrl"] = {
key: "string",
        importKey: "string",
        url: "string",
        sslThumbprint: "string",
        disk: "boolean",
        targetId: "string",
        datastoreKey: "string",
        fileSize: "number"
};
typeNames.interfaces["HttpNfcLeaseHostInfo"] = {
url: "string",
        sslThumbprint: "string"
};
typeNames.interfaces["HttpNfcLeaseInfo"] = {
lease: HttpNfcLease,
        entity: ManagedEntity,
        deviceUrl: "HttpNfcLeaseDeviceUrl",
        totalDiskCapacityInKB: "number",
        leaseTimeout: "number",
        hostMap: "HttpNfcLeaseDatastoreLeaseInfo"
};
typeNames.interfaces["HttpNfcLeaseManifestEntry"] = {
key: "string",
        sha1: "string",
        checksum: "string",
        checksumType: "string",
        size: "number",
        disk: "boolean",
        capacity: "number",
        populatedSize: "number"
};
typeNames.interfaces["HttpNfcLeaseSourceFile"] = {
targetDeviceId: "string",
        url: "string",
        memberName: "string",
        create: "boolean",
        sslThumbprint: "string",
        httpHeaders: "KeyValue",
        size: "number"
};
typeNames.interfaces["InheritablePolicy"] = {
inherited: "boolean"
};
typeNames.interfaces["IntPolicy"] = {
value: "number"
};
typeNames.interfaces["ClusterIoFilterInfo"] = {
opType: "string",
        vibUrl: "string"
};
typeNames.interfaces["HostIoFilterInfo"] = {
available: "boolean"
};
typeNames.interfaces["IoFilterInfo"] = {
id: "string",
        name: "string",
        vendor: "string",
        version: "string",
        type: "string",
        summary: "string",
        releaseDate: "string"
};
typeNames.interfaces["IoFilterQueryIssueResult"] = {
opType: "string",
        hostIssue: "IoFilterHostIssue"
};
typeNames.interfaces["IoFilterHostIssue"] = {
host: HostSystem,
        issue: "MethodFault"
};
typeNames.interfaces["IpPoolManagerIpAllocation"] = {
ipAddress: "string",
        allocationId: "string"
};
typeNames.interfaces["KeyValue"] = {
key: "string",
        value: "string"
};
typeNames.interfaces["LatencySensitivity"] = {
level: "LatencySensitivitySensitivityLevel",
        sensitivity: "number"
};
typeNames.interfaces["LicenseAvailabilityInfo"] = {
feature: "LicenseFeatureInfo",
        total: "number",
        available: "number"
};
typeNames.interfaces["LicenseDiagnostics"] = {
sourceLastChanged: "Date",
        sourceLost: "string",
        sourceLatency: "number",
        licenseRequests: "string",
        licenseRequestFailures: "string",
        licenseFeatureUnknowns: "string",
        opState: "LicenseManagerState",
        lastStatusUpdate: "Date",
        opFailureMessage: "string"
};
typeNames.interfaces["LicenseManagerEvaluationInfo"] = {
properties: "KeyAnyValue"
};
typeNames.interfaces["EvaluationLicenseSource"] = {
remainingHours: "number"
};
typeNames.interfaces["LicenseFeatureInfo"] = {
key: "string",
        featureName: "string",
        featureDescription: "string",
        state: "LicenseFeatureInfoState",
        costUnit: "string",
        sourceRestriction: "string",
        dependentKey: "string",
        edition: "boolean",
        expiresOn: "Date"
};
typeNames.interfaces["HostLicensableResourceInfo"] = {
resource: "KeyAnyValue"
};
typeNames.interfaces["LicenseManagerLicenseInfo"] = {
licenseKey: "string",
        editionKey: "string",
        name: "string",
        total: "number",
        used: "number",
        costUnit: "string",
        properties: "KeyAnyValue",
        labels: "KeyValue"
};
typeNames.interfaces["LicenseServerSource"] = {
licenseServer: "string"
};
typeNames.interfaces["LicenseSource"] = {

};
typeNames.interfaces["LicenseUsageInfo"] = {
source: "LicenseSource",
        sourceAvailable: "boolean",
        reservationInfo: "LicenseReservationInfo",
        featureInfo: "LicenseFeatureInfo"
};
typeNames.interfaces["LocalLicenseSource"] = {
licenseKeys: "string"
};
typeNames.interfaces["LicenseReservationInfo"] = {
key: "string",
        state: "LicenseReservationInfoState",
        required: "number"
};
typeNames.interfaces["LocalizationManagerMessageCatalog"] = {
moduleName: "string",
        catalogName: "string",
        locale: "string",
        catalogUri: "string",
        lastModified: "Date",
        md5sum: "string",
        version: "string"
};
typeNames.interfaces["LongPolicy"] = {
value: "number"
};
typeNames.interfaces["MethodDescription"] = {
key: "string"
};
typeNames.interfaces["NegatableExpression"] = {
negate: "boolean"
};
typeNames.interfaces["NumericRange"] = {
start: "number",
        end: "number"
};
typeNames.interfaces["OvfConsumerOstNode"] = {
id: "string",
        type: "string",
        section: "OvfConsumerOvfSection",
        child: "OvfConsumerOstNode",
        entity: ManagedEntity
};
typeNames.interfaces["OvfConsumerOvfSection"] = {
lineNumber: "number",
        xml: "string"
};
typeNames.interfaces["OvfManagerCommonParams"] = {
locale: "string",
        deploymentOption: "string",
        msgBundle: "KeyValue",
        importOption: "string"
};
typeNames.interfaces["OvfCreateDescriptorParams"] = {
ovfFiles: "OvfFile",
        name: "string",
        description: "string",
        includeImageFiles: "boolean",
        exportOption: "string",
        snapshot: VirtualMachineSnapshot
};
typeNames.interfaces["OvfCreateDescriptorResult"] = {
ovfDescriptor: "string",
        error: "MethodFault",
        warning: "MethodFault",
        includeImageFiles: "boolean"
};
typeNames.interfaces["OvfCreateImportSpecParams"] = {
entityName: "string",
        hostSystem: HostSystem,
        networkMapping: "OvfNetworkMapping",
        ipAllocationPolicy: "string",
        ipProtocol: "string",
        propertyMapping: "KeyValue",
        resourceMapping: "OvfResourceMap",
        diskProvisioning: "string",
        instantiationOst: "OvfConsumerOstNode"
};
typeNames.interfaces["OvfCreateImportSpecResult"] = {
importSpec: "ImportSpec",
        fileItem: "OvfFileItem",
        warning: "MethodFault",
        error: "MethodFault"
};
typeNames.interfaces["OvfDeploymentOption"] = {
key: "string",
        label: "string",
        description: "string"
};
typeNames.interfaces["OvfFileItem"] = {
deviceId: "string",
        path: "string",
        compressionMethod: "string",
        chunkSize: "number",
        size: "number",
        cimType: "number",
        create: "boolean"
};
typeNames.interfaces["OvfNetworkInfo"] = {
name: "string",
        description: "string"
};
typeNames.interfaces["OvfNetworkMapping"] = {
name: "string",
        network: Network
};
typeNames.interfaces["OvfFile"] = {
deviceId: "string",
        path: "string",
        compressionMethod: "string",
        chunkSize: "number",
        size: "number",
        capacity: "number",
        populatedSize: "number"
};
typeNames.interfaces["OvfOptionInfo"] = {
option: "string",
        description: "LocalizableMessage"
};
typeNames.interfaces["OvfParseDescriptorParams"] = {

};
typeNames.interfaces["OvfParseDescriptorResult"] = {
eula: "string",
        network: "OvfNetworkInfo",
        ipAllocationScheme: "string",
        ipProtocols: "string",
        property: "VAppPropertyInfo",
        productInfo: "VAppProductInfo",
        annotation: "string",
        approximateDownloadSize: "number",
        approximateFlatDeploymentSize: "number",
        approximateSparseDeploymentSize: "number",
        defaultEntityName: "string",
        virtualApp: "boolean",
        deploymentOption: "OvfDeploymentOption",
        defaultDeploymentOption: "string",
        entityName: "KeyValue",
        annotatedOst: "OvfConsumerOstNode",
        error: "MethodFault",
        warning: "MethodFault"
};
typeNames.interfaces["OvfResourceMap"] = {
source: "string",
        parent: ResourcePool,
        resourceSpec: "ResourceConfigSpec",
        datastore: Datastore
};
typeNames.interfaces["OvfValidateHostParams"] = {

};
typeNames.interfaces["OvfValidateHostResult"] = {
downloadSize: "number",
        flatDeploymentSize: "number",
        sparseDeploymentSize: "number",
        error: "MethodFault",
        warning: "MethodFault",
        supportedDiskProvisioning: "string"
};
typeNames.interfaces["PasswordField"] = {
value: "string"
};
typeNames.interfaces["PerformanceDescription"] = {
counterType: "ElementDescription",
        statsType: "ElementDescription"
};
typeNames.interfaces["PerfCompositeMetric"] = {
entity: "PerfEntityMetricBase",
        childEntity: "PerfEntityMetricBase"
};
typeNames.interfaces["PerfCounterInfo"] = {
key: "number",
        nameInfo: "ElementDescription",
        groupInfo: "ElementDescription",
        unitInfo: "ElementDescription",
        rollupType: "PerfSummaryType",
        statsType: "PerfStatsType",
        level: "number",
        perDeviceLevel: "number",
        associatedCounterId: "number"
};
typeNames.interfaces["PerformanceManagerCounterLevelMapping"] = {
counterId: "number",
        aggregateLevel: "number",
        perDeviceLevel: "number"
};
typeNames.interfaces["PerfEntityMetric"] = {
sampleInfo: "PerfSampleInfo",
        value: "PerfMetricSeries"
};
typeNames.interfaces["PerfEntityMetricBase"] = {
entity: "ManagedObject"
};
typeNames.interfaces["PerfEntityMetricCSV"] = {
sampleInfoCSV: "string",
        value: "PerfMetricSeriesCSV"
};
typeNames.interfaces["PerfMetricIntSeries"] = {
value: "number"
};
typeNames.interfaces["PerfMetricId"] = {
counterId: "number",
        instance: "string"
};
typeNames.interfaces["PerfMetricSeries"] = {
id: "PerfMetricId"
};
typeNames.interfaces["PerfMetricSeriesCSV"] = {
value: "string"
};
typeNames.interfaces["PerfProviderSummary"] = {
entity: "ManagedObject",
        currentSupported: "boolean",
        summarySupported: "boolean",
        refreshRate: "number"
};
typeNames.interfaces["PerfQuerySpec"] = {
entity: "ManagedObject",
        startTime: "Date",
        endTime: "Date",
        maxSample: "number",
        metricId: "PerfMetricId",
        intervalId: "number",
        format: "string"
};
typeNames.interfaces["PerfSampleInfo"] = {
timestamp: "Date",
        interval: "number"
};
typeNames.interfaces["PrivilegePolicyDef"] = {
createPrivilege: "string",
        readPrivilege: "string",
        updatePrivilege: "string",
        deletePrivilege: "string"
};
typeNames.interfaces["ResourceAllocationInfo"] = {
reservation: "number",
        expandableReservation: "boolean",
        limit: "number",
        shares: "SharesInfo",
        overheadLimit: "number"
};
typeNames.interfaces["ResourceAllocationOption"] = {
sharesOption: "SharesOption"
};
typeNames.interfaces["ResourceConfigOption"] = {
cpuAllocationOption: "ResourceAllocationOption",
        memoryAllocationOption: "ResourceAllocationOption"
};
typeNames.interfaces["ResourceConfigSpec"] = {
entity: ManagedEntity,
        changeVersion: "string",
        lastModified: "Date",
        cpuAllocation: "ResourceAllocationInfo",
        memoryAllocation: "ResourceAllocationInfo",
        scaleDescendantsShares: "string"
};
typeNames.interfaces["DatabaseSizeEstimate"] = {
size: "number"
};
typeNames.interfaces["DatabaseSizeParam"] = {
inventoryDesc: "InventoryDescription",
        perfStatsDesc: "PerformanceStatisticsDescription"
};
typeNames.interfaces["InventoryDescription"] = {
numHosts: "number",
        numVirtualMachines: "number",
        numResourcePools: "number",
        numClusters: "number",
        numCpuDev: "number",
        numNetDev: "number",
        numDiskDev: "number",
        numvCpuDev: "number",
        numvNetDev: "number",
        numvDiskDev: "number"
};
typeNames.interfaces["PerformanceStatisticsDescription"] = {
intervals: "PerfInterval"
};
typeNames.interfaces["SDDCBase"] = {

};
typeNames.interfaces["SelectionSet"] = {

};
typeNames.interfaces["ServiceContent"] = {
rootFolder: Folder,
        propertyCollector: PropertyCollector,
        viewManager: ViewManager,
        about: "AboutInfo",
        setting: OptionManager,
        userDirectory: UserDirectory,
        sessionManager: SessionManager,
        authorizationManager: AuthorizationManager,
        serviceManager: ServiceManager,
        perfManager: PerformanceManager,
        scheduledTaskManager: ScheduledTaskManager,
        alarmManager: AlarmManager,
        eventManager: EventManager,
        taskManager: TaskManager,
        extensionManager: ExtensionManager,
        customizationSpecManager: CustomizationSpecManager,
        guestCustomizationManager: VirtualMachineGuestCustomizationManager,
        customFieldsManager: CustomFieldsManager,
        accountManager: HostLocalAccountManager,
        diagnosticManager: DiagnosticManager,
        licenseManager: LicenseManager,
        searchIndex: SearchIndex,
        fileManager: FileManager,
        datastoreNamespaceManager: DatastoreNamespaceManager,
        virtualDiskManager: VirtualDiskManager,
        virtualizationManager: VirtualizationManager,
        snmpSystem: HostSnmpSystem,
        vmProvisioningChecker: VirtualMachineProvisioningChecker,
        vmCompatibilityChecker: VirtualMachineCompatibilityChecker,
        ovfManager: OvfManager,
        ipPoolManager: IpPoolManager,
        dvSwitchManager: DistributedVirtualSwitchManager,
        hostProfileManager: HostProfileManager,
        clusterProfileManager: ClusterProfileManager,
        complianceManager: ProfileComplianceManager,
        localizationManager: LocalizationManager,
        storageResourceManager: StorageResourceManager,
        guestOperationsManager: GuestOperationsManager,
        overheadMemoryManager: OverheadMemoryManager,
        certificateManager: CertificateManager,
        ioFilterManager: IoFilterManager,
        vStorageObjectManager: VStorageObjectManagerBase,
        hostSpecManager: HostSpecificationManager,
        cryptoManager: CryptoManager,
        healthUpdateManager: HealthUpdateManager,
        failoverClusterConfigurator: FailoverClusterConfigurator,
        failoverClusterManager: FailoverClusterManager,
        tenantManager: TenantTenantManager,
        siteInfoManager: SiteInfoManager,
        storageQueryManager: StorageQueryManager
};
typeNames.interfaces["ServiceLocator"] = {
instanceUuid: "string",
        url: "string",
        credential: "ServiceLocatorCredential",
        sslThumbprint: "string"
};
typeNames.interfaces["ServiceLocatorCredential"] = {

};
typeNames.interfaces["ServiceLocatorNamePassword"] = {
username: "string",
        password: "string"
};
typeNames.interfaces["ServiceLocatorSAMLCredential"] = {
token: "string"
};
typeNames.interfaces["ServiceManagerServiceInfo"] = {
serviceName: "string",
        location: "string",
        service: "ManagedObject",
        description: "string"
};
typeNames.interfaces["SessionManagerGenericServiceTicket"] = {
id: "string",
        hostName: "string",
        sslThumbprint: "string"
};
typeNames.interfaces["SessionManagerHttpServiceRequestSpec"] = {
method: "string",
        url: "string"
};
typeNames.interfaces["SessionManagerLocalTicket"] = {
userName: "string",
        passwordFilePath: "string"
};
typeNames.interfaces["SessionManagerServiceRequestSpec"] = {

};
typeNames.interfaces["SessionManagerVmomiServiceRequestSpec"] = {
method: "string"
};
typeNames.interfaces["SharesInfo"] = {
shares: "number",
        level: "SharesLevel"
};
typeNames.interfaces["SharesOption"] = {
sharesOption: "IntOption",
        defaultLevel: "SharesLevel"
};
typeNames.interfaces["SiteInfo"] = {

};
typeNames.interfaces["StorageIOAllocationInfo"] = {
limit: "number",
        shares: "SharesInfo",
        reservation: "number"
};
typeNames.interfaces["StorageIOAllocationOption"] = {
limitOption: "LongOption",
        sharesOption: "SharesOption"
};
typeNames.interfaces["StorageIORMInfo"] = {
enabled: "boolean",
        congestionThresholdMode: "string",
        congestionThreshold: "number",
        percentOfPeakThroughput: "number",
        statsCollectionEnabled: "boolean",
        reservationEnabled: "boolean",
        statsAggregationDisabled: "boolean",
        reservableIopsThreshold: "number"
};
typeNames.interfaces["StorageIORMConfigOption"] = {
enabledOption: "BoolOption",
        congestionThresholdOption: "IntOption",
        statsCollectionEnabledOption: "BoolOption",
        reservationEnabledOption: "BoolOption"
};
typeNames.interfaces["StorageIORMConfigSpec"] = {
enabled: "boolean",
        congestionThresholdMode: "string",
        congestionThreshold: "number",
        percentOfPeakThroughput: "number",
        statsCollectionEnabled: "boolean",
        reservationEnabled: "boolean",
        statsAggregationDisabled: "boolean",
        reservableIopsThreshold: "number"
};
typeNames.interfaces["PodStorageDrsEntry"] = {
storageDrsConfig: "StorageDrsConfigInfo",
        recommendation: "ClusterRecommendation",
        drsFault: "ClusterDrsFaults",
        actionHistory: "ClusterActionHistory"
};
typeNames.interfaces["StoragePerformanceSummary"] = {
interval: "number",
        percentile: "number",
        datastoreReadLatency: "number",
        datastoreWriteLatency: "number",
        datastoreVmLatency: "number",
        datastoreReadIops: "number",
        datastoreWriteIops: "number",
        siocActivityDuration: "number"
};
typeNames.interfaces["StorageResourceManagerStorageProfileStatistics"] = {
profileId: "string",
        totalSpaceMB: "number",
        usedSpaceMB: "number"
};
typeNames.interfaces["StringExpression"] = {
value: "string"
};
typeNames.interfaces["StringPolicy"] = {
value: "string"
};
typeNames.interfaces["Tag"] = {
key: "string"
};
typeNames.interfaces["TaskDescription"] = {
methodInfo: "ElementDescription",
        state: "ElementDescription",
        reason: "TypeDescription"
};
typeNames.interfaces["TaskInfo"] = {
key: "string",
        task: Task,
        description: "LocalizableMessage",
        name: "string",
        descriptionId: "string",
        entity: ManagedEntity,
        entityName: "string",
        locked: ManagedEntity,
        state: "TaskInfoState",
        cancelled: "boolean",
        cancelable: "boolean",
        error: "MethodFault",
        result: "any",
        progress: "number",
        reason: "TaskReason",
        queueTime: "Date",
        startTime: "Date",
        completeTime: "Date",
        eventChainId: "number",
        changeTag: "string",
        parentTaskKey: "string",
        rootTaskKey: "string",
        activationId: "string"
};
typeNames.interfaces["TaskReason"] = {

};
typeNames.interfaces["TaskReasonAlarm"] = {
alarmName: "string",
        alarm: Alarm,
        entityName: "string",
        entity: ManagedEntity
};
typeNames.interfaces["TaskReasonSchedule"] = {
name: "string",
        scheduledTask: ScheduledTask
};
typeNames.interfaces["TaskReasonSystem"] = {

};
typeNames.interfaces["TaskReasonUser"] = {
userName: "string"
};
typeNames.interfaces["TypeDescription"] = {
key: "string"
};
typeNames.interfaces["UpdateVirtualMachineFilesResult"] = {
failedVmFile: "UpdateVirtualMachineFilesResultFailedVmFileInfo"
};
typeNames.interfaces["UpdateVirtualMachineFilesResultFailedVmFileInfo"] = {
vmFile: "string",
        fault: "MethodFault"
};
typeNames.interfaces["UserSearchResult"] = {
principal: "string",
        fullName: "string",
        group: "boolean"
};
typeNames.interfaces["UserSession"] = {
key: "string",
        userName: "string",
        fullName: "string",
        loginTime: "Date",
        lastActiveTime: "Date",
        locale: "string",
        messageLocale: "string",
        extensionSession: "boolean",
        ipAddress: "string",
        userAgent: "string",
        callCount: "number"
};
typeNames.interfaces["VVolVmConfigFileUpdateResult"] = {
succeededVmConfigFile: "KeyValue",
        failedVmConfigFile: "VVolVmConfigFileUpdateResultFailedVmConfigFileInfo"
};
typeNames.interfaces["VVolVmConfigFileUpdateResultFailedVmConfigFileInfo"] = {
targetConfigVVolId: "string",
        dsPath: "string",
        fault: "MethodFault"
};
typeNames.interfaces["VASAStorageArray"] = {
name: "string",
        uuid: "string",
        vendorId: "string",
        modelId: "string"
};
typeNames.interfaces["VimVasaProvider"] = {
uid: "string",
        url: "string",
        name: "string",
        selfSignedCertificate: "string"
};
typeNames.interfaces["VimVasaProviderStatePerArray"] = {
priority: "number",
        arrayId: "string",
        active: "boolean"
};
typeNames.interfaces["VimVasaProviderInfo"] = {
provider: "VimVasaProvider",
        arrayState: "VimVasaProviderStatePerArray"
};
typeNames.interfaces["VsanUpgradeSystemAPIBrokenIssue"] = {
hosts: HostSystem
};
typeNames.interfaces["VsanUpgradeSystemAutoClaimEnabledOnHostsIssue"] = {
hosts: HostSystem
};
typeNames.interfaces["VsanUpgradeSystemHostsDisconnectedIssue"] = {
hosts: HostSystem
};
typeNames.interfaces["VsanUpgradeSystemMissingHostsInClusterIssue"] = {
hosts: HostSystem
};
typeNames.interfaces["VsanUpgradeSystemNetworkPartitionInfo"] = {
hosts: HostSystem
};
typeNames.interfaces["VsanUpgradeSystemNetworkPartitionIssue"] = {
partitions: "VsanUpgradeSystemNetworkPartitionInfo"
};
typeNames.interfaces["VsanUpgradeSystemNotEnoughFreeCapacityIssue"] = {
reducedRedundancyUpgradePossible: "boolean"
};
typeNames.interfaces["VsanUpgradeSystemPreflightCheckIssue"] = {
msg: "string"
};
typeNames.interfaces["VsanUpgradeSystemPreflightCheckResult"] = {
issues: "VsanUpgradeSystemPreflightCheckIssue",
        diskMappingToRestore: "VsanHostDiskMapping"
};
typeNames.interfaces["VsanUpgradeSystemRogueHostsInClusterIssue"] = {
uuids: "string"
};
typeNames.interfaces["VsanUpgradeSystemUpgradeHistoryDiskGroupOp"] = {
operation: "string",
        diskMapping: "VsanHostDiskMapping"
};
typeNames.interfaces["VsanUpgradeSystemUpgradeHistoryItem"] = {
timestamp: "Date",
        host: HostSystem,
        message: "string",
        task: Task
};
typeNames.interfaces["VsanUpgradeSystemUpgradeHistoryPreflightFail"] = {
preflightResult: "VsanUpgradeSystemPreflightCheckResult"
};
typeNames.interfaces["VsanUpgradeSystemUpgradeStatus"] = {
inProgress: "boolean",
        history: "VsanUpgradeSystemUpgradeHistoryItem",
        aborted: "boolean",
        completed: "boolean",
        progress: "number"
};
typeNames.interfaces["VsanUpgradeSystemV2ObjectsPresentDuringDowngradeIssue"] = {
uuids: "string"
};
typeNames.interfaces["VsanUpgradeSystemWrongEsxVersionIssue"] = {
hosts: HostSystem
};
typeNames.interfaces["Action"] = {

};
typeNames.interfaces["CreateTaskAction"] = {
taskTypeId: "string",
        cancelable: "boolean"
};
typeNames.interfaces["MethodAction"] = {
name: "string",
        argument: "MethodActionArgument"
};
typeNames.interfaces["MethodActionArgument"] = {
value: "any"
};
typeNames.interfaces["RunScriptAction"] = {
script: "string"
};
typeNames.interfaces["SendEmailAction"] = {
toList: "string",
        ccList: "string",
        subject: "string",
        body: "string"
};
typeNames.interfaces["SendSNMPAction"] = {

};
typeNames.interfaces["AlarmAction"] = {

};
typeNames.interfaces["AlarmDescription"] = {
expr: "TypeDescription",
        stateOperator: "ElementDescription",
        metricOperator: "ElementDescription",
        hostSystemConnectionState: "ElementDescription",
        virtualMachinePowerState: "ElementDescription",
        datastoreConnectionState: "ElementDescription",
        hostSystemPowerState: "ElementDescription",
        virtualMachineGuestHeartbeatStatus: "ElementDescription",
        entityStatus: "ElementDescription",
        action: "TypeDescription"
};
typeNames.interfaces["AlarmExpression"] = {

};
typeNames.interfaces["AlarmSetting"] = {
toleranceRange: "number",
        reportingFrequency: "number"
};
typeNames.interfaces["AlarmSpec"] = {
name: "string",
        systemName: "string",
        description: "string",
        enabled: "boolean",
        expression: "AlarmExpression",
        action: "AlarmAction",
        actionFrequency: "number",
        setting: "AlarmSetting"
};
typeNames.interfaces["AndAlarmExpression"] = {
expression: "AlarmExpression"
};
typeNames.interfaces["GroupAlarmAction"] = {
action: "AlarmAction"
};
typeNames.interfaces["MetricAlarmExpression"] = {
operator: "MetricAlarmOperator",
        type: "string",
        metric: "PerfMetricId",
        yellow: "number",
        yellowInterval: "number",
        red: "number",
        redInterval: "number"
};
typeNames.interfaces["OrAlarmExpression"] = {
expression: "AlarmExpression"
};
typeNames.interfaces["StateAlarmExpression"] = {
operator: "StateAlarmOperator",
        type: "string",
        statePath: "string",
        yellow: "string",
        red: "string"
};
typeNames.interfaces["ClusterAction"] = {
type: "string",
        target: "ManagedObject"
};
typeNames.interfaces["ClusterActionHistory"] = {
action: "ClusterAction",
        time: "Date"
};
typeNames.interfaces["ClusterAttemptedVmInfo"] = {
vm: VirtualMachine,
        task: Task
};
typeNames.interfaces["ClusterConfigInfo"] = {
dasConfig: "ClusterDasConfigInfo",
        dasVmConfig: "ClusterDasVmConfigInfo",
        drsConfig: "ClusterDrsConfigInfo",
        drsVmConfig: "ClusterDrsVmConfigInfo",
        rule: "ClusterRuleInfo"
};
typeNames.interfaces["ClusterConfigSpec"] = {
dasConfig: "ClusterDasConfigInfo",
        dasVmConfigSpec: "ClusterDasVmConfigSpec",
        drsConfig: "ClusterDrsConfigInfo",
        drsVmConfigSpec: "ClusterDrsVmConfigSpec",
        rulesSpec: "ClusterRuleSpec"
};
typeNames.interfaces["ClusterCryptoConfigInfo"] = {
cryptoMode: "string"
};
typeNames.interfaces["ClusterDasAamNodeState"] = {
host: HostSystem,
        name: "string",
        configState: "string",
        runtimeState: "string"
};
typeNames.interfaces["ClusterDasAdmissionControlInfo"] = {

};
typeNames.interfaces["ClusterDasAdmissionControlPolicy"] = {
resourceReductionToToleratePercent: "number"
};
typeNames.interfaces["ClusterDasAdvancedRuntimeInfo"] = {
dasHostInfo: "ClusterDasHostInfo",
        vmcpSupported: "ClusterDasAdvancedRuntimeInfoVmcpCapabilityInfo",
        heartbeatDatastoreInfo: "DasHeartbeatDatastoreInfo"
};
typeNames.interfaces["DasHeartbeatDatastoreInfo"] = {
datastore: Datastore,
        hosts: HostSystem
};
typeNames.interfaces["ClusterDasAdvancedRuntimeInfoVmcpCapabilityInfo"] = {
storageAPDSupported: "boolean",
        storagePDLSupported: "boolean"
};
typeNames.interfaces["ClusterDasConfigInfo"] = {
enabled: "boolean",
        vmMonitoring: "string",
        hostMonitoring: "string",
        vmComponentProtecting: "string",
        failoverLevel: "number",
        admissionControlPolicy: "ClusterDasAdmissionControlPolicy",
        admissionControlEnabled: "boolean",
        defaultVmSettings: "ClusterDasVmSettings",
        option: "OptionValue",
        heartbeatDatastore: Datastore,
        hBDatastoreCandidatePolicy: "string"
};
typeNames.interfaces["ClusterDasData"] = {

};
typeNames.interfaces["ClusterDasDataSummary"] = {
hostListVersion: "number",
        clusterConfigVersion: "number",
        compatListVersion: "number"
};
typeNames.interfaces["ClusterDasFailoverLevelAdvancedRuntimeInfo"] = {
slotInfo: "ClusterDasFailoverLevelAdvancedRuntimeInfoSlotInfo",
        totalSlots: "number",
        usedSlots: "number",
        unreservedSlots: "number",
        totalVms: "number",
        totalHosts: "number",
        totalGoodHosts: "number",
        hostSlots: "ClusterDasFailoverLevelAdvancedRuntimeInfoHostSlots",
        vmsRequiringMultipleSlots: "ClusterDasFailoverLevelAdvancedRuntimeInfoVmSlots"
};
typeNames.interfaces["ClusterDasFailoverLevelAdvancedRuntimeInfoHostSlots"] = {
host: HostSystem,
        slots: "number"
};
typeNames.interfaces["ClusterDasFailoverLevelAdvancedRuntimeInfoSlotInfo"] = {
numVcpus: "number",
        cpuMHz: "number",
        memoryMB: "number"
};
typeNames.interfaces["ClusterDasFailoverLevelAdvancedRuntimeInfoVmSlots"] = {
vm: VirtualMachine,
        slots: "number"
};
typeNames.interfaces["ClusterDasFdmHostState"] = {
state: "string",
        stateReporter: HostSystem
};
typeNames.interfaces["ClusterDasHostInfo"] = {

};
typeNames.interfaces["ClusterDasHostRecommendation"] = {
host: HostSystem,
        drsRating: "number"
};
typeNames.interfaces["ClusterDasVmConfigInfo"] = {
key: VirtualMachine,
        restartPriority: "DasVmPriority",
        powerOffOnIsolation: "boolean",
        dasSettings: "ClusterDasVmSettings"
};
typeNames.interfaces["ClusterDasVmSettings"] = {
restartPriority: "string",
        restartPriorityTimeout: "number",
        isolationResponse: "string",
        vmToolsMonitoringSettings: "ClusterVmToolsMonitoringSettings",
        vmComponentProtectionSettings: "ClusterVmComponentProtectionSettings"
};
typeNames.interfaces["ClusterDpmConfigInfo"] = {
enabled: "boolean",
        defaultDpmBehavior: "DpmBehavior",
        hostPowerActionRate: "number",
        option: "OptionValue"
};
typeNames.interfaces["ClusterDpmHostConfigInfo"] = {
key: HostSystem,
        enabled: "boolean",
        behavior: "DpmBehavior"
};
typeNames.interfaces["ClusterDrsConfigInfo"] = {
enabled: "boolean",
        enableVmBehaviorOverrides: "boolean",
        defaultVmBehavior: "DrsBehavior",
        vmotionRate: "number",
        scaleDescendantsShares: "string",
        option: "OptionValue"
};
typeNames.interfaces["ClusterDrsFaults"] = {
reason: "string",
        faultsByVm: "ClusterDrsFaultsFaultsByVm"
};
typeNames.interfaces["ClusterDrsFaultsFaultsByVirtualDisk"] = {
disk: "VirtualDiskId"
};
typeNames.interfaces["ClusterDrsFaultsFaultsByVm"] = {
vm: VirtualMachine,
        fault: "MethodFault"
};
typeNames.interfaces["ClusterDrsMigration"] = {
key: "string",
        time: "Date",
        vm: VirtualMachine,
        cpuLoad: "number",
        memoryLoad: "number",
        source: HostSystem,
        sourceCpuLoad: "number",
        sourceMemoryLoad: "number",
        destination: HostSystem,
        destinationCpuLoad: "number",
        destinationMemoryLoad: "number"
};
typeNames.interfaces["ClusterDrsRecommendation"] = {
key: "string",
        rating: "number",
        reason: "string",
        reasonText: "string",
        migrationList: "ClusterDrsMigration"
};
typeNames.interfaces["ClusterDrsVmConfigInfo"] = {
key: VirtualMachine,
        enabled: "boolean",
        behavior: "DrsBehavior"
};
typeNames.interfaces["ClusterEVCManagerCheckResult"] = {
evcModeKey: "string",
        error: "MethodFault",
        host: HostSystem
};
typeNames.interfaces["ClusterEVCManagerEVCState"] = {
supportedEVCMode: "EVCMode",
        currentEVCModeKey: "string",
        guaranteedCPUFeatures: "HostCpuIdInfo",
        featureCapability: "HostFeatureCapability",
        featureMask: "HostFeatureMask",
        featureRequirement: "VirtualMachineFeatureRequirement"
};
typeNames.interfaces["ClusterEnterMaintenanceResult"] = {
recommendations: "ClusterRecommendation",
        fault: "ClusterDrsFaults"
};
typeNames.interfaces["ClusterFailoverHostAdmissionControlPolicy"] = {
failoverHosts: HostSystem,
        failoverLevel: "number"
};
typeNames.interfaces["ClusterFailoverLevelAdmissionControlInfo"] = {
currentFailoverLevel: "number"
};
typeNames.interfaces["ClusterFailoverLevelAdmissionControlPolicy"] = {
failoverLevel: "number",
        slotPolicy: "ClusterSlotPolicy"
};
typeNames.interfaces["ClusterFailoverResourcesAdmissionControlInfo"] = {
currentCpuFailoverResourcesPercent: "number",
        currentMemoryFailoverResourcesPercent: "number"
};
typeNames.interfaces["ClusterFailoverResourcesAdmissionControlPolicy"] = {
cpuFailoverResourcesPercent: "number",
        memoryFailoverResourcesPercent: "number",
        failoverLevel: "number",
        autoComputePercentages: "boolean"
};
typeNames.interfaces["ClusterGroupInfo"] = {
name: "string",
        userCreated: "boolean",
        uniqueID: "string"
};
typeNames.interfaces["ClusterHostGroup"] = {
host: HostSystem
};
typeNames.interfaces["ClusterHostInfraUpdateHaModeAction"] = {
operationType: "string"
};
typeNames.interfaces["ClusterHostPowerAction"] = {
operationType: "HostPowerOperationType",
        powerConsumptionWatt: "number",
        cpuCapacityMHz: "number",
        memCapacityMB: "number"
};
typeNames.interfaces["ClusterHostRecommendation"] = {
host: HostSystem,
        rating: "number"
};
typeNames.interfaces["ClusterInfraUpdateHaConfigInfo"] = {
enabled: "boolean",
        behavior: "string",
        moderateRemediation: "string",
        severeRemediation: "string",
        providers: "string"
};
typeNames.interfaces["ClusterInitialPlacementAction"] = {
targetHost: HostSystem,
        pool: ResourcePool
};
typeNames.interfaces["ClusterMigrationAction"] = {
drsMigration: "ClusterDrsMigration"
};
typeNames.interfaces["ClusterNotAttemptedVmInfo"] = {
vm: VirtualMachine,
        fault: "MethodFault"
};
typeNames.interfaces["ClusterOrchestrationInfo"] = {
defaultVmReadiness: "ClusterVmReadiness"
};
typeNames.interfaces["PlacementAction"] = {
vm: VirtualMachine,
        targetHost: HostSystem,
        relocateSpec: "VirtualMachineRelocateSpec"
};
typeNames.interfaces["PlacementResult"] = {
recommendations: "ClusterRecommendation",
        drsFault: "ClusterDrsFaults"
};
typeNames.interfaces["ClusterPowerOnVmResult"] = {
attempted: "ClusterAttemptedVmInfo",
        notAttempted: "ClusterNotAttemptedVmInfo",
        recommendations: "ClusterRecommendation"
};
typeNames.interfaces["ClusterProactiveDrsConfigInfo"] = {
enabled: "boolean"
};
typeNames.interfaces["ClusterRecommendation"] = {
key: "string",
        type: "string",
        time: "Date",
        rating: "number",
        reason: "string",
        reasonText: "string",
        warningText: "string",
        warningDetails: "LocalizableMessage",
        prerequisite: "string",
        action: "ClusterAction",
        target: "ManagedObject"
};
typeNames.interfaces["ClusterResourceUsageSummary"] = {
cpuUsedMHz: "number",
        cpuCapacityMHz: "number",
        memUsedMB: "number",
        memCapacityMB: "number",
        pMemAvailableMB: "number",
        pMemCapacityMB: "number",
        storageUsedMB: "number",
        storageCapacityMB: "number"
};
typeNames.interfaces["ClusterSlotPolicy"] = {

};
typeNames.interfaces["ClusterUsageSummary"] = {
totalCpuCapacityMhz: "number",
        totalMemCapacityMB: "number",
        cpuReservationMhz: "number",
        memReservationMB: "number",
        poweredOffCpuReservationMhz: "number",
        poweredOffMemReservationMB: "number",
        cpuDemandMhz: "number",
        memDemandMB: "number",
        statsGenNumber: "number",
        cpuEntitledMhz: "number",
        memEntitledMB: "number",
        poweredOffVmCount: "number",
        totalVmCount: "number"
};
typeNames.interfaces["ClusterVmComponentProtectionSettings"] = {
vmStorageProtectionForAPD: "string",
        enableAPDTimeoutForHosts: "boolean",
        vmTerminateDelayForAPDSec: "number",
        vmReactionOnAPDCleared: "string",
        vmStorageProtectionForPDL: "string"
};
typeNames.interfaces["ClusterVmGroup"] = {
vm: VirtualMachine
};
typeNames.interfaces["ClusterVmOrchestrationInfo"] = {
vm: VirtualMachine,
        vmReadiness: "ClusterVmReadiness"
};
typeNames.interfaces["ClusterVmReadiness"] = {
readyCondition: "string",
        postReadyDelay: "number"
};
typeNames.interfaces["ClusterVmToolsMonitoringSettings"] = {
enabled: "boolean",
        vmMonitoring: "string",
        clusterSettings: "boolean",
        failureInterval: "number",
        minUpTime: "number",
        maxFailures: "number",
        maxFailureWindow: "number"
};
typeNames.interfaces["DistributedVirtualPort"] = {
key: "string",
        config: "DVPortConfigInfo",
        dvsUuid: "string",
        portgroupKey: "string",
        proxyHost: HostSystem,
        connectee: "DistributedVirtualSwitchPortConnectee",
        conflict: "boolean",
        conflictPortKey: "string",
        state: "DVPortState",
        connectionCookie: "number",
        lastStatusChange: "Date",
        hostLocalPort: "boolean",
        externalId: "string",
        segmentPortId: "string"
};
typeNames.interfaces["DVPortConfigInfo"] = {
name: "string",
        scope: ManagedEntity,
        description: "string",
        setting: "DVPortSetting",
        configVersion: "string"
};
typeNames.interfaces["DVPortConfigSpec"] = {
operation: "string",
        key: "string",
        name: "string",
        scope: ManagedEntity,
        description: "string",
        setting: "DVPortSetting",
        configVersion: "string"
};
typeNames.interfaces["DvsFilterConfig"] = {
key: "string",
        agentName: "string",
        slotNumber: "string",
        parameters: "DvsFilterParameter",
        onFailure: "string"
};
typeNames.interfaces["DvsFilterConfigSpec"] = {
operation: "string"
};
typeNames.interfaces["DvsFilterParameter"] = {
parameters: "string"
};
typeNames.interfaces["DvsFilterPolicy"] = {
filterConfig: "DvsFilterConfig"
};
typeNames.interfaces["DVSHostLocalPortInfo"] = {
switchUuid: "string",
        portKey: "string",
        setting: "DVPortSetting",
        vnic: "string"
};
typeNames.interfaces["DVPortStatus"] = {
linkUp: "boolean",
        blocked: "boolean",
        vlanIds: "NumericRange",
        trunkingMode: "boolean",
        mtu: "number",
        linkPeer: "string",
        macAddress: "string",
        statusDetail: "string",
        vmDirectPathGen2Active: "boolean",
        vmDirectPathGen2InactiveReasonNetwork: "string",
        vmDirectPathGen2InactiveReasonOther: "string",
        vmDirectPathGen2InactiveReasonExtended: "string"
};
typeNames.interfaces["DVPortSetting"] = {
blocked: "BoolPolicy",
        vmDirectPathGen2Allowed: "BoolPolicy",
        inShapingPolicy: "DVSTrafficShapingPolicy",
        outShapingPolicy: "DVSTrafficShapingPolicy",
        vendorSpecificConfig: "DVSVendorSpecificConfig",
        networkResourcePoolKey: "StringPolicy",
        filterPolicy: "DvsFilterPolicy"
};
typeNames.interfaces["DVPortState"] = {
runtimeInfo: "DVPortStatus",
        stats: "DistributedVirtualSwitchPortStatistics",
        vendorSpecificState: "DistributedVirtualSwitchKeyedOpaqueBlob"
};
typeNames.interfaces["DvsTrafficFilterConfig"] = {
trafficRuleset: "DvsTrafficRuleset"
};
typeNames.interfaces["DvsTrafficFilterConfigSpec"] = {
operation: "string"
};
typeNames.interfaces["DVSTrafficShapingPolicy"] = {
enabled: "BoolPolicy",
        averageBandwidth: "LongPolicy",
        peakBandwidth: "LongPolicy",
        burstSize: "LongPolicy"
};
typeNames.interfaces["DVSVendorSpecificConfig"] = {
keyValue: "DistributedVirtualSwitchKeyedOpaqueBlob"
};
typeNames.interfaces["DistributedVirtualPortgroupInfo"] = {
switchName: "string",
        switchUuid: "string",
        portgroupName: "string",
        portgroupKey: "string",
        portgroupType: "string",
        uplinkPortgroup: "boolean",
        portgroup: DistributedVirtualPortgroup,
        networkReservationSupported: "boolean",
        backingType: "string",
        logicalSwitchUuid: "string",
        segmentId: "string"
};
typeNames.interfaces["DVPortgroupSelection"] = {
dvsUuid: "string",
        portgroupKey: "string"
};
typeNames.interfaces["DistributedVirtualSwitchInfo"] = {
switchName: "string",
        switchUuid: "string",
        distributedVirtualSwitch: DistributedVirtualSwitch,
        networkReservationSupported: "boolean"
};
typeNames.interfaces["DVSSelection"] = {
dvsUuid: "string"
};
typeNames.interfaces["EntityBackup"] = {

};
typeNames.interfaces["EntityBackupConfig"] = {
entityType: "string",
        configBlob: "Buffer",
        key: "string",
        name: "string",
        container: ManagedEntity,
        configVersion: "string"
};
typeNames.interfaces["DistributedVirtualSwitchHostMember"] = {
runtimeState: "DistributedVirtualSwitchHostMemberRuntimeState",
        config: "DistributedVirtualSwitchHostMemberConfigInfo",
        productInfo: "DistributedVirtualSwitchProductSpec",
        uplinkPortKey: "string",
        status: "string",
        statusDetail: "string"
};
typeNames.interfaces["DistributedVirtualSwitchHostMemberBacking"] = {

};
typeNames.interfaces["DistributedVirtualSwitchHostMemberConfigInfo"] = {
host: HostSystem,
        maxProxySwitchPorts: "number",
        vendorSpecificConfig: "DistributedVirtualSwitchKeyedOpaqueBlob",
        backing: "DistributedVirtualSwitchHostMemberBacking",
        nsxSwitch: "boolean",
        ensEnabled: "boolean",
        ensInterruptEnabled: "boolean",
        transportZones: "DistributedVirtualSwitchHostMemberTransportZoneInfo",
        nsxtUsedUplinkNames: "string"
};
typeNames.interfaces["DistributedVirtualSwitchHostMemberConfigSpec"] = {
operation: "string",
        host: HostSystem,
        backing: "DistributedVirtualSwitchHostMemberBacking",
        maxProxySwitchPorts: "number",
        vendorSpecificConfig: "DistributedVirtualSwitchKeyedOpaqueBlob"
};
typeNames.interfaces["HostMemberHealthCheckResult"] = {
summary: "string"
};
typeNames.interfaces["DistributedVirtualSwitchHostMemberPnicBacking"] = {
pnicSpec: "DistributedVirtualSwitchHostMemberPnicSpec"
};
typeNames.interfaces["DistributedVirtualSwitchHostMemberPnicSpec"] = {
pnicDevice: "string",
        uplinkPortKey: "string",
        uplinkPortgroupKey: "string",
        connectionCookie: "number"
};
typeNames.interfaces["HostMemberRuntimeInfo"] = {
host: HostSystem,
        status: "string",
        statusDetail: "string",
        nsxtStatus: "string",
        nsxtStatusDetail: "string",
        healthCheckResult: "HostMemberHealthCheckResult"
};
typeNames.interfaces["DistributedVirtualSwitchHostMemberRuntimeState"] = {
currentMaxProxySwitchPorts: "number"
};
typeNames.interfaces["DistributedVirtualSwitchHostMemberTransportZoneInfo"] = {
uuid: "string",
        type: "string"
};
typeNames.interfaces["HostMemberUplinkHealthCheckResult"] = {
uplinkPortKey: "string"
};
typeNames.interfaces["DistributedVirtualSwitchHostProductSpec"] = {
productLineId: "string",
        version: "string"
};
typeNames.interfaces["DistributedVirtualSwitchKeyedOpaqueBlob"] = {
key: "string",
        opaqueData: "string"
};
typeNames.interfaces["DVSNetworkResourcePool"] = {
key: "string",
        name: "string",
        description: "string",
        configVersion: "string",
        allocationInfo: "DVSNetworkResourcePoolAllocationInfo"
};
typeNames.interfaces["DVSNetworkResourcePoolAllocationInfo"] = {
limit: "number",
        shares: "SharesInfo",
        priorityTag: "number"
};
typeNames.interfaces["DVSNetworkResourcePoolConfigSpec"] = {
key: "string",
        configVersion: "string",
        allocationInfo: "DVSNetworkResourcePoolAllocationInfo",
        name: "string",
        description: "string"
};
typeNames.interfaces["DistributedVirtualSwitchPortConnectee"] = {
connectedEntity: ManagedEntity,
        nicKey: "string",
        type: "string",
        addressHint: "string"
};
typeNames.interfaces["DistributedVirtualSwitchPortConnection"] = {
switchUuid: "string",
        portgroupKey: "string",
        portKey: "string",
        connectionCookie: "number"
};
typeNames.interfaces["DistributedVirtualSwitchPortCriteria"] = {
connected: "boolean",
        active: "boolean",
        uplinkPort: "boolean",
        nsxPort: "boolean",
        scope: ManagedEntity,
        portgroupKey: "string",
        inside: "boolean",
        portKey: "string",
        host: HostSystem
};
typeNames.interfaces["DistributedVirtualSwitchPortStatistics"] = {
packetsInMulticast: "number",
        packetsOutMulticast: "number",
        bytesInMulticast: "number",
        bytesOutMulticast: "number",
        packetsInUnicast: "number",
        packetsOutUnicast: "number",
        bytesInUnicast: "number",
        bytesOutUnicast: "number",
        packetsInBroadcast: "number",
        packetsOutBroadcast: "number",
        bytesInBroadcast: "number",
        bytesOutBroadcast: "number",
        packetsInDropped: "number",
        packetsOutDropped: "number",
        packetsInException: "number",
        packetsOutException: "number",
        bytesInFromPnic: "number",
        bytesOutToPnic: "number"
};
typeNames.interfaces["DistributedVirtualSwitchProductSpec"] = {
name: "string",
        vendor: "string",
        version: "string",
        build: "string",
        forwardingClass: "string",
        bundleId: "string",
        bundleUrl: "string"
};
typeNames.interfaces["DvsTrafficRule"] = {
key: "string",
        description: "string",
        sequence: "number",
        qualifier: "DvsNetworkRuleQualifier",
        action: "DvsNetworkRuleAction",
        direction: "string"
};
typeNames.interfaces["DvsAcceptNetworkRuleAction"] = {

};
typeNames.interfaces["DvsNetworkRuleAction"] = {

};
typeNames.interfaces["DvsCopyNetworkRuleAction"] = {

};
typeNames.interfaces["DvsDropNetworkRuleAction"] = {

};
typeNames.interfaces["DvsGreEncapNetworkRuleAction"] = {
encapsulationIp: "SingleIp"
};
typeNames.interfaces["DvsIpPort"] = {

};
typeNames.interfaces["DvsIpPortRange"] = {
startPortNumber: "number",
        endPortNumber: "number"
};
typeNames.interfaces["DvsIpNetworkRuleQualifier"] = {
sourceAddress: "IpAddress",
        destinationAddress: "IpAddress",
        protocol: "IntExpression",
        sourceIpPort: "DvsIpPort",
        destinationIpPort: "DvsIpPort",
        tcpFlags: "IntExpression"
};
typeNames.interfaces["DvsLogNetworkRuleAction"] = {

};
typeNames.interfaces["DvsMacNetworkRuleQualifier"] = {
sourceAddress: "MacAddress",
        destinationAddress: "MacAddress",
        protocol: "IntExpression",
        vlanId: "IntExpression"
};
typeNames.interfaces["DvsMacRewriteNetworkRuleAction"] = {
rewriteMac: "string"
};
typeNames.interfaces["DvsPuntNetworkRuleAction"] = {

};
typeNames.interfaces["DvsNetworkRuleQualifier"] = {
key: "string"
};
typeNames.interfaces["DvsRateLimitNetworkRuleAction"] = {
packetsPerSecond: "number"
};
typeNames.interfaces["DvsSingleIpPort"] = {
portNumber: "number"
};
typeNames.interfaces["DvsSystemTrafficNetworkRuleQualifier"] = {
typeOfSystemTraffic: "StringExpression"
};
typeNames.interfaces["DvsUpdateTagNetworkRuleAction"] = {
qosTag: "number",
        dscpTag: "number"
};
typeNames.interfaces["DvsTrafficRuleset"] = {
key: "string",
        enabled: "boolean",
        precedence: "number",
        rules: "DvsTrafficRule"
};
typeNames.interfaces["DVSVmVnicNetworkResourcePool"] = {
key: "string",
        name: "string",
        description: "string",
        configVersion: "string",
        allocationInfo: "DvsVmVnicResourceAllocation"
};
typeNames.interfaces["DvsVmVnicResourcePoolConfigSpec"] = {
operation: "string",
        key: "string",
        configVersion: "string",
        allocationInfo: "DvsVmVnicResourceAllocation",
        name: "string",
        description: "string"
};
typeNames.interfaces["DvsVmVnicResourceAllocation"] = {
reservationQuota: "number"
};
typeNames.interfaces["DvsVmVnicNetworkResourcePoolRuntimeInfo"] = {
key: "string",
        name: "string",
        capacity: "number",
        usage: "number",
        available: "number",
        status: "string",
        allocatedResource: "DvsVnicAllocatedResource"
};
typeNames.interfaces["DvsVnicAllocatedResource"] = {
vm: VirtualMachine,
        vnicKey: "string",
        reservation: "number"
};
typeNames.interfaces["CryptoKeyId"] = {
keyId: "string",
        providerId: "KeyProviderId"
};
typeNames.interfaces["CryptoKeyPlain"] = {
keyId: "CryptoKeyId",
        algorithm: "string",
        keyData: "string"
};
typeNames.interfaces["CryptoKeyResult"] = {
keyId: "CryptoKeyId",
        success: "boolean",
        reason: "string",
        fault: "MethodFault"
};
typeNames.interfaces["CryptoSpec"] = {

};
typeNames.interfaces["CryptoSpecDecrypt"] = {

};
typeNames.interfaces["CryptoSpecDeepRecrypt"] = {
newKeyId: "CryptoKeyId"
};
typeNames.interfaces["CryptoSpecEncrypt"] = {
cryptoKeyId: "CryptoKeyId"
};
typeNames.interfaces["CryptoSpecNoOp"] = {

};
typeNames.interfaces["CryptoSpecRegister"] = {
cryptoKeyId: "CryptoKeyId"
};
typeNames.interfaces["CryptoSpecShallowRecrypt"] = {
newKeyId: "CryptoKeyId"
};
typeNames.interfaces["KeyProviderId"] = {
id: "string"
};
typeNames.interfaces["KmipClusterInfo"] = {
clusterId: "KeyProviderId",
        servers: "KmipServerInfo",
        useAsDefault: "boolean",
        managementType: "string",
        useAsEntityDefault: ManagedEntity
};
typeNames.interfaces["KmipServerInfo"] = {
name: "string",
        address: "string",
        port: "number",
        proxyAddress: "string",
        proxyPort: "number",
        reconnect: "number",
        protocol: "string",
        nbio: "number",
        timeout: "number",
        userName: "string"
};
typeNames.interfaces["KmipServerSpec"] = {
clusterId: "KeyProviderId",
        info: "KmipServerInfo",
        password: "string"
};
typeNames.interfaces["ChangesInfoEventArgument"] = {
modified: "string",
        added: "string",
        deleted: "string"
};
typeNames.interfaces["DvsOutOfSyncHostArgument"] = {
outOfSyncHost: "HostEventArgument",
        configParamters: "string"
};
typeNames.interfaces["Event"] = {
key: "number",
        chainId: "number",
        createdTime: "Date",
        userName: "string",
        datacenter: "DatacenterEventArgument",
        computeResource: "ComputeResourceEventArgument",
        host: "HostEventArgument",
        vm: "VmEventArgument",
        ds: "DatastoreEventArgument",
        net: "NetworkEventArgument",
        dvs: "DvsEventArgument",
        fullFormattedMessage: "string",
        changeTag: "string"
};
typeNames.interfaces["EventArgument"] = {

};
typeNames.interfaces["EventDescription"] = {
category: "ElementDescription",
        eventInfo: "EventDescriptionEventDetail",
        enumeratedTypes: "EnumDescription"
};
typeNames.interfaces["EventArgDesc"] = {
name: "string",
        type: "string",
        description: "ElementDescription"
};
typeNames.interfaces["EventDescriptionEventDetail"] = {
key: "string",
        description: "string",
        category: "string",
        formatOnDatacenter: "string",
        formatOnComputeResource: "string",
        formatOnHost: "string",
        formatOnVm: "string",
        fullFormat: "string",
        longDescription: "string"
};
typeNames.interfaces["EventEx"] = {
eventTypeId: "string",
        severity: "string",
        message: "string",
        arguments: "KeyAnyValue",
        objectId: "string",
        objectType: "string",
        objectName: "string",
        fault: "MethodFault"
};
typeNames.interfaces["EventFilterSpec"] = {
entity: "EventFilterSpecByEntity",
        time: "EventFilterSpecByTime",
        userName: "EventFilterSpecByUsername",
        eventChainId: "number",
        alarm: Alarm,
        scheduledTask: ScheduledTask,
        disableFullMessage: "boolean",
        category: "string",
        type: "string",
        tag: "string",
        eventTypeId: "string",
        maxCount: "number"
};
typeNames.interfaces["EventFilterSpecByEntity"] = {
entity: ManagedEntity,
        recursion: "EventFilterSpecRecursionOption"
};
typeNames.interfaces["EventFilterSpecByTime"] = {
beginTime: "Date",
        endTime: "Date"
};
typeNames.interfaces["EventFilterSpecByUsername"] = {
systemUser: "boolean",
        userList: "string"
};
typeNames.interfaces["GeneralEvent"] = {
message: "string"
};
typeNames.interfaces["GeneralHostErrorEvent"] = {

};
typeNames.interfaces["GeneralHostInfoEvent"] = {

};
typeNames.interfaces["GeneralHostWarningEvent"] = {

};
typeNames.interfaces["GeneralUserEvent"] = {
entity: "ManagedEntityEventArgument"
};
typeNames.interfaces["GeneralVmErrorEvent"] = {

};
typeNames.interfaces["GeneralVmInfoEvent"] = {

};
typeNames.interfaces["GeneralVmWarningEvent"] = {

};
typeNames.interfaces["HealthStatusChangedEvent"] = {
componentId: "string",
        oldStatus: "string",
        newStatus: "string",
        componentName: "string",
        serviceId: "string"
};
typeNames.interfaces["HostEvent"] = {

};
typeNames.interfaces["HostGetShortNameFailedEvent"] = {

};
typeNames.interfaces["HostInAuditModeEvent"] = {

};
typeNames.interfaces["HostInventoryUnreadableEvent"] = {

};
typeNames.interfaces["HostIpChangedEvent"] = {
oldIP: "string",
        newIP: "string"
};
typeNames.interfaces["HostIpInconsistentEvent"] = {
ipAddress: "string",
        ipAddress2: "string"
};
typeNames.interfaces["HostIpToShortNameFailedEvent"] = {

};
typeNames.interfaces["HostNonCompliantEvent"] = {

};
typeNames.interfaces["HostProfileAppliedEvent"] = {
profile: "ProfileEventArgument"
};
typeNames.interfaces["HostReconnectionFailedEvent"] = {

};
typeNames.interfaces["HostRemovedEvent"] = {

};
typeNames.interfaces["HostShortNameToIpFailedEvent"] = {
shortName: "string"
};
typeNames.interfaces["HostShutdownEvent"] = {
reason: "string"
};
typeNames.interfaces["HostSpecificationChangedEvent"] = {

};
typeNames.interfaces["HostSpecificationRequireEvent"] = {

};
typeNames.interfaces["HostSpecificationUpdateEvent"] = {
hostSpec: "HostSpecification"
};
typeNames.interfaces["HostSubSpecificationDeleteEvent"] = {
subSpecName: "string"
};
typeNames.interfaces["HostSubSpecificationUpdateEvent"] = {
hostSubSpec: "HostSubSpecification"
};
typeNames.interfaces["HostSyncFailedEvent"] = {
reason: "MethodFault"
};
typeNames.interfaces["HostUpgradeFailedEvent"] = {

};
typeNames.interfaces["HostUserWorldSwapNotEnabledEvent"] = {

};
typeNames.interfaces["HostVnicConnectedToCustomizedDVPortEvent"] = {
vnic: "VnicPortArgument",
        prevPortKey: "string"
};
typeNames.interfaces["HostWwnChangedEvent"] = {
oldNodeWwns: "number",
        oldPortWwns: "number",
        newNodeWwns: "number",
        newPortWwns: "number"
};
typeNames.interfaces["HostWwnConflictEvent"] = {
conflictedVms: "VmEventArgument",
        conflictedHosts: "HostEventArgument",
        wwn: "number"
};
typeNames.interfaces["LicenseEvent"] = {

};
typeNames.interfaces["LicenseExpiredEvent"] = {
feature: "LicenseFeatureInfo"
};
typeNames.interfaces["LicenseNonComplianceEvent"] = {
url: "string"
};
typeNames.interfaces["LicenseRestrictedEvent"] = {

};
typeNames.interfaces["LicenseServerAvailableEvent"] = {
licenseServer: "string"
};
typeNames.interfaces["LicenseServerUnavailableEvent"] = {
licenseServer: "string"
};
typeNames.interfaces["LocalDatastoreCreatedEvent"] = {
datastore: "DatastoreEventArgument",
        datastoreUrl: "string"
};
typeNames.interfaces["LocalTSMEnabledEvent"] = {

};
typeNames.interfaces["LockerMisconfiguredEvent"] = {
datastore: "DatastoreEventArgument"
};
typeNames.interfaces["LockerReconfiguredEvent"] = {
oldDatastore: "DatastoreEventArgument",
        newDatastore: "DatastoreEventArgument"
};
typeNames.interfaces["NASDatastoreCreatedEvent"] = {
datastore: "DatastoreEventArgument",
        datastoreUrl: "string"
};
typeNames.interfaces["NetworkRollbackEvent"] = {
methodName: "string",
        transactionId: "string"
};
typeNames.interfaces["NoDatastoresConfiguredEvent"] = {

};
typeNames.interfaces["NoLicenseEvent"] = {
feature: "LicenseFeatureInfo"
};
typeNames.interfaces["ProfileEvent"] = {
profile: "ProfileEventArgument"
};
typeNames.interfaces["ProfileEventArgument"] = {
profile: Profile,
        name: "string"
};
typeNames.interfaces["ProfileReferenceHostChangedEvent"] = {
referenceHost: HostSystem,
        referenceHostName: "string",
        prevReferenceHostName: "string"
};
typeNames.interfaces["ProfileRemovedEvent"] = {

};
typeNames.interfaces["RemoteTSMEnabledEvent"] = {

};
typeNames.interfaces["ResourcePoolEvent"] = {
resourcePool: "ResourcePoolEventArgument"
};
typeNames.interfaces["ResourcePoolMovedEvent"] = {
oldParent: "ResourcePoolEventArgument",
        newParent: "ResourcePoolEventArgument"
};
typeNames.interfaces["ResourcePoolReconfiguredEvent"] = {
configChanges: "ChangesInfoEventArgument"
};
typeNames.interfaces["ResourceViolatedEvent"] = {

};
typeNames.interfaces["RoleEventArgument"] = {
roleId: "number",
        name: "string"
};
typeNames.interfaces["ScheduledTaskEvent"] = {
scheduledTask: "ScheduledTaskEventArgument",
        entity: "ManagedEntityEventArgument"
};
typeNames.interfaces["ScheduledTaskFailedEvent"] = {
reason: "MethodFault"
};
typeNames.interfaces["ScheduledTaskReconfiguredEvent"] = {
configChanges: "ChangesInfoEventArgument"
};
typeNames.interfaces["ScheduledTaskRemovedEvent"] = {

};
typeNames.interfaces["ScheduledTaskStartedEvent"] = {

};
typeNames.interfaces["ServerLicenseExpiredEvent"] = {
product: "string"
};
typeNames.interfaces["SessionEvent"] = {

};
typeNames.interfaces["SessionTerminatedEvent"] = {
sessionId: "string",
        terminatedUsername: "string"
};
typeNames.interfaces["TaskEvent"] = {
info: "TaskInfo"
};
typeNames.interfaces["TaskTimeoutEvent"] = {

};
typeNames.interfaces["TemplateUpgradeEvent"] = {
legacyTemplate: "string"
};
typeNames.interfaces["TemplateUpgradeFailedEvent"] = {
reason: "MethodFault"
};
typeNames.interfaces["TemplateUpgradedEvent"] = {

};
typeNames.interfaces["TimedOutHostOperationEvent"] = {

};
typeNames.interfaces["UnlicensedVirtualMachinesEvent"] = {
unlicensed: "number",
        available: "number"
};
typeNames.interfaces["UnlicensedVirtualMachinesFoundEvent"] = {
available: "number"
};
typeNames.interfaces["UpdatedAgentBeingRestartedEvent"] = {

};
typeNames.interfaces["UpgradeEvent"] = {
message: "string"
};
typeNames.interfaces["UserAssignedToGroup"] = {
userLogin: "string",
        group: "string"
};
typeNames.interfaces["UserLoginSessionEvent"] = {
ipAddress: "string",
        userAgent: "string",
        locale: "string",
        sessionId: "string"
};
typeNames.interfaces["UserLogoutSessionEvent"] = {
ipAddress: "string",
        userAgent: "string",
        callCount: "number",
        sessionId: "string",
        loginTime: "Date"
};
typeNames.interfaces["UserPasswordChanged"] = {
userLogin: "string"
};
typeNames.interfaces["UserUnassignedFromGroup"] = {
userLogin: "string",
        group: "string"
};
typeNames.interfaces["UserUpgradeEvent"] = {

};
typeNames.interfaces["VMFSDatastoreCreatedEvent"] = {
datastore: "DatastoreEventArgument",
        datastoreUrl: "string"
};
typeNames.interfaces["VMFSDatastoreExpandedEvent"] = {
datastore: "DatastoreEventArgument"
};
typeNames.interfaces["VMFSDatastoreExtendedEvent"] = {
datastore: "DatastoreEventArgument"
};
typeNames.interfaces["VMotionLicenseExpiredEvent"] = {

};
typeNames.interfaces["VcAgentUninstallFailedEvent"] = {
reason: "string"
};
typeNames.interfaces["VcAgentUninstalledEvent"] = {

};
typeNames.interfaces["VcAgentUpgradeFailedEvent"] = {
reason: "string"
};
typeNames.interfaces["VcAgentUpgradedEvent"] = {

};
typeNames.interfaces["VimAccountPasswordChangedEvent"] = {

};
typeNames.interfaces["VmEvent"] = {
template: "boolean"
};
typeNames.interfaces["VmFailedMigrateEvent"] = {
destHost: "HostEventArgument",
        reason: "MethodFault",
        destDatacenter: "DatacenterEventArgument",
        destDatastore: "DatastoreEventArgument"
};
typeNames.interfaces["VmFailedRelayoutEvent"] = {
reason: "MethodFault"
};
typeNames.interfaces["VmFailedRelayoutOnVmfs2DatastoreEvent"] = {

};
typeNames.interfaces["VmFailedStartingSecondaryEvent"] = {
reason: "string"
};
typeNames.interfaces["VmFailedToPowerOffEvent"] = {
reason: "MethodFault"
};
typeNames.interfaces["VmFailedToPowerOnEvent"] = {
reason: "MethodFault"
};
typeNames.interfaces["VmFailedToRebootGuestEvent"] = {
reason: "MethodFault"
};
typeNames.interfaces["VmFailedToResetEvent"] = {
reason: "MethodFault"
};
typeNames.interfaces["VmFailedToShutdownGuestEvent"] = {
reason: "MethodFault"
};
typeNames.interfaces["VmFailedToStandbyGuestEvent"] = {
reason: "MethodFault"
};
typeNames.interfaces["VmFailedToSuspendEvent"] = {
reason: "MethodFault"
};
typeNames.interfaces["VmFailedUpdatingSecondaryConfig"] = {

};
typeNames.interfaces["VmFailoverFailed"] = {
reason: "MethodFault"
};
typeNames.interfaces["VmFaultToleranceTurnedOffEvent"] = {

};
typeNames.interfaces["VmFaultToleranceVmTerminatedEvent"] = {
reason: "string"
};
typeNames.interfaces["VmGuestOSCrashedEvent"] = {

};
typeNames.interfaces["VmGuestRebootEvent"] = {

};
typeNames.interfaces["VmGuestShutdownEvent"] = {

};
typeNames.interfaces["VmGuestStandbyEvent"] = {

};
typeNames.interfaces["VmInstanceUuidAssignedEvent"] = {
instanceUuid: "string"
};
typeNames.interfaces["VmInstanceUuidChangedEvent"] = {
oldInstanceUuid: "string",
        newInstanceUuid: "string"
};
typeNames.interfaces["VmInstanceUuidConflictEvent"] = {
conflictedVm: "VmEventArgument",
        instanceUuid: "string"
};
typeNames.interfaces["VmMacAssignedEvent"] = {
adapter: "string",
        mac: "string"
};
typeNames.interfaces["VmMacChangedEvent"] = {
adapter: "string",
        oldMac: "string",
        newMac: "string"
};
typeNames.interfaces["VmMacConflictEvent"] = {
conflictedVm: "VmEventArgument",
        mac: "string"
};
typeNames.interfaces["VmMaxFTRestartCountReached"] = {

};
typeNames.interfaces["VmMaxRestartCountReached"] = {

};
typeNames.interfaces["VmMessageErrorEvent"] = {
message: "string",
        messageInfo: "VirtualMachineMessage"
};
typeNames.interfaces["VmMessageEvent"] = {
message: "string",
        messageInfo: "VirtualMachineMessage"
};
typeNames.interfaces["VmMessageWarningEvent"] = {
message: "string",
        messageInfo: "VirtualMachineMessage"
};
typeNames.interfaces["VmMigratedEvent"] = {
sourceHost: "HostEventArgument",
        sourceDatacenter: "DatacenterEventArgument",
        sourceDatastore: "DatastoreEventArgument"
};
typeNames.interfaces["VmNoCompatibleHostForSecondaryEvent"] = {

};
typeNames.interfaces["VmNoNetworkAccessEvent"] = {
destHost: "HostEventArgument"
};
typeNames.interfaces["VmOrphanedEvent"] = {

};
typeNames.interfaces["VmPoweredOffEvent"] = {

};
typeNames.interfaces["VmPoweredOnEvent"] = {

};
typeNames.interfaces["VmPoweringOnWithCustomizedDVPortEvent"] = {
vnic: "VnicPortArgument"
};
typeNames.interfaces["VmPrimaryFailoverEvent"] = {
reason: "string"
};
typeNames.interfaces["VmReconfiguredEvent"] = {
configSpec: "VirtualMachineConfigSpec",
        configChanges: "ChangesInfoEventArgument"
};
typeNames.interfaces["VmRegisteredEvent"] = {

};
typeNames.interfaces["VmRelayoutSuccessfulEvent"] = {

};
typeNames.interfaces["VmRelayoutUpToDateEvent"] = {

};
typeNames.interfaces["VmReloadFromPathEvent"] = {
configPath: "string"
};
typeNames.interfaces["VmReloadFromPathFailedEvent"] = {
configPath: "string"
};
typeNames.interfaces["VmRelocateSpecEvent"] = {

};
typeNames.interfaces["VmRelocatedEvent"] = {
sourceHost: "HostEventArgument",
        sourceDatacenter: "DatacenterEventArgument",
        sourceDatastore: "DatastoreEventArgument"
};
typeNames.interfaces["VmRemoteConsoleConnectedEvent"] = {

};
typeNames.interfaces["VmRemoteConsoleDisconnectedEvent"] = {

};
typeNames.interfaces["VmRemovedEvent"] = {

};
typeNames.interfaces["VmRenamedEvent"] = {
oldName: "string",
        newName: "string"
};
typeNames.interfaces["VmRequirementsExceedCurrentEVCModeEvent"] = {

};
typeNames.interfaces["VmResettingEvent"] = {

};
typeNames.interfaces["VmResourcePoolMovedEvent"] = {
oldParent: "ResourcePoolEventArgument",
        newParent: "ResourcePoolEventArgument"
};
typeNames.interfaces["VmResourceReallocatedEvent"] = {
configChanges: "ChangesInfoEventArgument"
};
typeNames.interfaces["VmRestartedOnAlternateHostEvent"] = {
sourceHost: "HostEventArgument"
};
typeNames.interfaces["VmResumingEvent"] = {

};
typeNames.interfaces["VmSecondaryAddedEvent"] = {

};
typeNames.interfaces["VmSecondaryDisabledBySystemEvent"] = {
reason: "MethodFault"
};
typeNames.interfaces["VmSecondaryDisabledEvent"] = {

};
typeNames.interfaces["VmSecondaryEnabledEvent"] = {

};
typeNames.interfaces["VmSecondaryStartedEvent"] = {

};
typeNames.interfaces["VmShutdownOnIsolationEvent"] = {
isolatedHost: "HostEventArgument",
        shutdownResult: "string"
};
typeNames.interfaces["VmStartRecordingEvent"] = {

};
typeNames.interfaces["VmStartReplayingEvent"] = {

};
typeNames.interfaces["VmStartingEvent"] = {

};
typeNames.interfaces["VmStartingSecondaryEvent"] = {

};
typeNames.interfaces["VmStaticMacConflictEvent"] = {
conflictedVm: "VmEventArgument",
        mac: "string"
};
typeNames.interfaces["VmStoppingEvent"] = {

};
typeNames.interfaces["VmSuspendedEvent"] = {

};
typeNames.interfaces["VmSuspendingEvent"] = {

};
typeNames.interfaces["VmTimedoutStartingSecondaryEvent"] = {
timeout: "number"
};
typeNames.interfaces["VmUnsupportedStartingEvent"] = {
guestId: "string"
};
typeNames.interfaces["VmUpgradeCompleteEvent"] = {
version: "string"
};
typeNames.interfaces["VmUpgradeFailedEvent"] = {

};
typeNames.interfaces["VmUpgradingEvent"] = {
version: "string"
};
typeNames.interfaces["VmUuidAssignedEvent"] = {
uuid: "string"
};
typeNames.interfaces["VmUuidChangedEvent"] = {
oldUuid: "string",
        newUuid: "string"
};
typeNames.interfaces["VmUuidConflictEvent"] = {
conflictedVm: "VmEventArgument",
        uuid: "string"
};
typeNames.interfaces["VmWwnAssignedEvent"] = {
nodeWwns: "number",
        portWwns: "number"
};
typeNames.interfaces["VmWwnChangedEvent"] = {
oldNodeWwns: "number",
        oldPortWwns: "number",
        newNodeWwns: "number",
        newPortWwns: "number"
};
typeNames.interfaces["VmWwnConflictEvent"] = {
conflictedVms: "VmEventArgument",
        conflictedHosts: "HostEventArgument",
        wwn: "number"
};
typeNames.interfaces["VnicPortArgument"] = {
vnic: "string",
        port: "DistributedVirtualSwitchPortConnection"
};
typeNames.interfaces["WarningUpgradeEvent"] = {

};
typeNames.interfaces["IScsiBootFailureEvent"] = {

};
typeNames.interfaces["ExtExtendedProductInfo"] = {
companyUrl: "string",
        productUrl: "string",
        managementUrl: "string",
        self: ManagedEntity
};
typeNames.interfaces["ManagedByInfo"] = {
extensionKey: "string",
        type: "string"
};
typeNames.interfaces["ExtManagedEntityInfo"] = {
type: "string",
        smallIconUrl: "string",
        iconUrl: "string",
        description: "string"
};
typeNames.interfaces["ExtSolutionManagerInfo"] = {
tab: "ExtSolutionManagerInfoTabInfo",
        smallIconUrl: "string"
};
typeNames.interfaces["ExtSolutionManagerInfoTabInfo"] = {
label: "string",
        url: "string"
};
typeNames.interfaces["CannotDisableDrsOnClustersWithVApps"] = {

};
typeNames.interfaces["ConflictingDatastoreFound"] = {
name: "string",
        url: "string"
};
typeNames.interfaces["DatabaseError"] = {

};
typeNames.interfaces["DisallowedChangeByService"] = {
serviceName: "string",
        disallowedChange: "string"
};
typeNames.interfaces["DisallowedOperationOnFailoverHost"] = {
host: HostSystem,
        hostname: "string"
};
typeNames.interfaces["ExpiredFeatureLicense"] = {
feature: "string",
        count: "number",
        expirationDate: "Date"
};
typeNames.interfaces["FailToLockFaultToleranceVMs"] = {
vmName: "string",
        vm: VirtualMachine,
        alreadyLockedVm: VirtualMachine
};
typeNames.interfaces["HostAccessRestrictedToManagementServer"] = {
managementServer: "string"
};
typeNames.interfaces["HostInventoryFull"] = {
capacity: "number"
};
typeNames.interfaces["InUseFeatureManipulationDisallowed"] = {

};
typeNames.interfaces["IncompatibleSetting"] = {
conflictingProperty: "string"
};
typeNames.interfaces["IncorrectHostInformation"] = {

};
typeNames.interfaces["InvalidDasConfigArgument"] = {
entry: "string",
        clusterName: "string"
};
typeNames.interfaces["InvalidDasRestartPriorityForFtVm"] = {
vm: VirtualMachine,
        vmName: "string"
};
typeNames.interfaces["InvalidDrsBehaviorForFtVm"] = {
vm: VirtualMachine,
        vmName: "string"
};
typeNames.interfaces["InvalidEditionLicense"] = {
feature: "string"
};
typeNames.interfaces["InvalidIndexArgument"] = {
key: "string"
};
typeNames.interfaces["InvalidProfileReferenceHost"] = {
reason: "string",
        host: HostSystem,
        profile: Profile,
        profileName: "string"
};
typeNames.interfaces["InventoryHasStandardAloneHosts"] = {
hosts: "string"
};
typeNames.interfaces["LicenseAssignmentFailed"] = {
reason: "string"
};
typeNames.interfaces["LicenseDowngradeDisallowed"] = {
edition: "string",
        entityId: "string",
        features: "KeyAnyValue"
};
typeNames.interfaces["LicenseExpired"] = {
licenseKey: "string"
};
typeNames.interfaces["LicenseKeyEntityMismatch"] = {

};
typeNames.interfaces["LicenseRestricted"] = {

};
typeNames.interfaces["LicenseSourceUnavailable"] = {
licenseSource: "LicenseSource"
};
typeNames.interfaces["MethodAlreadyDisabledFault"] = {
sourceId: "string"
};
typeNames.interfaces["MethodDisabled"] = {
source: "string"
};
typeNames.interfaces["NoLicenseServerConfigured"] = {

};
typeNames.interfaces["NoPermission"] = {
object: "ManagedObject",
        privilegeId: "string"
};
typeNames.interfaces["NotAuthenticated"] = {

};
typeNames.interfaces["OperationDisallowedOnHost"] = {

};
typeNames.interfaces["RestrictedByAdministrator"] = {
details: "string"
};
typeNames.interfaces["RestrictedVersion"] = {

};
typeNames.interfaces["SolutionUserRequired"] = {

};
typeNames.interfaces["ThirdPartyLicenseAssignmentFailed"] = {
host: HostSystem,
        module: "string",
        reason: "string"
};
typeNames.interfaces["VAppOperationInProgress"] = {

};
typeNames.interfaces["VimFault"] = {

};
typeNames.interfaces["VmConfigFault"] = {

};
typeNames.interfaces["VmConfigIncompatibleForFaultTolerance"] = {
fault: "MethodFault"
};
typeNames.interfaces["VmConfigIncompatibleForRecordReplay"] = {
fault: "MethodFault"
};
typeNames.interfaces["VmFaultToleranceIssue"] = {

};
typeNames.interfaces["VmFaultToleranceOpIssuesList"] = {
errors: "MethodFault",
        warnings: "MethodFault"
};
typeNames.interfaces["VmHostAffinityRuleViolation"] = {
vmName: "string",
        hostName: "string"
};
typeNames.interfaces["VmLimitLicense"] = {
limit: "number"
};
typeNames.interfaces["VmMetadataManagerFault"] = {

};
typeNames.interfaces["VmMonitorIncompatibleForFaultTolerance"] = {

};
typeNames.interfaces["VmToolsUpgradeFault"] = {

};
typeNames.interfaces["VmValidateMaxDevice"] = {
device: "string",
        max: "number",
        count: "number"
};
typeNames.interfaces["VramLimitLicense"] = {
limit: "number"
};
typeNames.interfaces["VsanFault"] = {

};
typeNames.interfaces["WipeDiskFault"] = {

};
typeNames.interfaces["HostActiveDirectory"] = {
changeOperation: "string",
        spec: "HostActiveDirectorySpec"
};
typeNames.interfaces["HostActiveDirectorySpec"] = {
domainName: "string",
        userName: "string",
        password: "string",
        camServer: "string",
        thumbprint: "string",
        smartCardAuthenticationEnabled: "boolean",
        smartCardTrustAnchors: "string"
};
typeNames.interfaces["HostAssignableHardwareBinding"] = {
instanceId: "string",
        vm: VirtualMachine
};
typeNames.interfaces["HostAssignableHardwareConfig"] = {
attributeOverride: "HostAssignableHardwareConfigAttributeOverride"
};
typeNames.interfaces["HostAssignableHardwareConfigAttributeOverride"] = {
instanceId: "string",
        name: "string",
        value: "any"
};
typeNames.interfaces["HostAuthenticationManagerInfo"] = {
authConfig: "HostAuthenticationStoreInfo"
};
typeNames.interfaces["HostAuthenticationStoreInfo"] = {
enabled: "boolean"
};
typeNames.interfaces["AutoStartPowerInfo"] = {
key: VirtualMachine,
        startOrder: "number",
        startDelay: "number",
        waitForHeartbeat: "AutoStartWaitHeartbeatSetting",
        startAction: "string",
        stopDelay: "number",
        stopAction: "string"
};
typeNames.interfaces["HostAutoStartManagerConfig"] = {
defaults: "AutoStartDefaults",
        powerInfo: "AutoStartPowerInfo"
};
typeNames.interfaces["AutoStartDefaults"] = {
enabled: "boolean",
        startDelay: "number",
        stopDelay: "number",
        waitForHeartbeat: "boolean",
        stopAction: "string"
};
typeNames.interfaces["HostBIOSInfo"] = {
biosVersion: "string",
        releaseDate: "Date",
        vendor: "string",
        majorRelease: "number",
        minorRelease: "number",
        firmwareMajorRelease: "number",
        firmwareMinorRelease: "number"
};
typeNames.interfaces["HostBootDevice"] = {
key: "string",
        description: "string"
};
typeNames.interfaces["HostCacheConfigurationInfo"] = {
key: Datastore,
        swapSize: "number"
};
typeNames.interfaces["HostCacheConfigurationSpec"] = {
datastore: Datastore,
        swapSize: "number"
};
typeNames.interfaces["HostCapability"] = {
recursiveResourcePoolsSupported: "boolean",
        cpuMemoryResourceConfigurationSupported: "boolean",
        rebootSupported: "boolean",
        shutdownSupported: "boolean",
        vmotionSupported: "boolean",
        standbySupported: "boolean",
        ipmiSupported: "boolean",
        maxSupportedVMs: "number",
        maxRunningVMs: "number",
        maxSupportedVcpus: "number",
        maxRegisteredVMs: "number",
        datastorePrincipalSupported: "boolean",
        sanSupported: "boolean",
        nfsSupported: "boolean",
        iscsiSupported: "boolean",
        vlanTaggingSupported: "boolean",
        nicTeamingSupported: "boolean",
        highGuestMemSupported: "boolean",
        maintenanceModeSupported: "boolean",
        suspendedRelocateSupported: "boolean",
        restrictedSnapshotRelocateSupported: "boolean",
        perVmSwapFiles: "boolean",
        localSwapDatastoreSupported: "boolean",
        unsharedSwapVMotionSupported: "boolean",
        backgroundSnapshotsSupported: "boolean",
        preAssignedPCIUnitNumbersSupported: "boolean",
        screenshotSupported: "boolean",
        scaledScreenshotSupported: "boolean",
        storageVMotionSupported: "boolean",
        vmotionWithStorageVMotionSupported: "boolean",
        vmotionAcrossNetworkSupported: "boolean",
        maxNumDisksSVMotion: "number",
        hbrNicSelectionSupported: "boolean",
        vrNfcNicSelectionSupported: "boolean",
        recordReplaySupported: "boolean",
        ftSupported: "boolean",
        replayUnsupportedReason: "string",
        replayCompatibilityIssues: "string",
        smpFtSupported: "boolean",
        ftCompatibilityIssues: "string",
        smpFtCompatibilityIssues: "string",
        maxVcpusPerFtVm: "number",
        loginBySSLThumbprintSupported: "boolean",
        cloneFromSnapshotSupported: "boolean",
        deltaDiskBackingsSupported: "boolean",
        perVMNetworkTrafficShapingSupported: "boolean",
        tpmSupported: "boolean",
        tpmVersion: "string",
        txtEnabled: "boolean",
        supportedCpuFeature: "HostCpuIdInfo",
        virtualExecUsageSupported: "boolean",
        storageIORMSupported: "boolean",
        vmDirectPathGen2Supported: "boolean",
        vmDirectPathGen2UnsupportedReason: "string",
        vmDirectPathGen2UnsupportedReasonExtended: "string",
        supportedVmfsMajorVersion: "number",
        vStorageCapable: "boolean",
        snapshotRelayoutSupported: "boolean",
        firewallIpRulesSupported: "boolean",
        servicePackageInfoSupported: "boolean",
        maxHostRunningVms: "number",
        maxHostSupportedVcpus: "number",
        vmfsDatastoreMountCapable: "boolean",
        eightPlusHostVmfsSharedAccessSupported: "boolean",
        nestedHVSupported: "boolean",
        vPMCSupported: "boolean",
        interVMCommunicationThroughVMCISupported: "boolean",
        scheduledHardwareUpgradeSupported: "boolean",
        featureCapabilitiesSupported: "boolean",
        latencySensitivitySupported: "boolean",
        storagePolicySupported: "boolean",
        accel3dSupported: "boolean",
        reliableMemoryAware: "boolean",
        multipleNetworkStackInstanceSupported: "boolean",
        messageBusProxySupported: "boolean",
        vsanSupported: "boolean",
        vFlashSupported: "boolean",
        hostAccessManagerSupported: "boolean",
        provisioningNicSelectionSupported: "boolean",
        nfs41Supported: "boolean",
        nfs41Krb5iSupported: "boolean",
        turnDiskLocatorLedSupported: "boolean",
        virtualVolumeDatastoreSupported: "boolean",
        markAsSsdSupported: "boolean",
        markAsLocalSupported: "boolean",
        smartCardAuthenticationSupported: "boolean",
        pMemSupported: "boolean",
        pMemSnapshotSupported: "boolean",
        cryptoSupported: "boolean",
        oneKVolumeAPIsSupported: "boolean",
        gatewayOnNicSupported: "boolean",
        upitSupported: "boolean",
        cpuHwMmuSupported: "boolean",
        encryptedVMotionSupported: "boolean",
        encryptionChangeOnAddRemoveSupported: "boolean",
        encryptionHotOperationSupported: "boolean",
        encryptionWithSnapshotsSupported: "boolean",
        encryptionFaultToleranceSupported: "boolean",
        encryptionMemorySaveSupported: "boolean",
        encryptionRDMSupported: "boolean",
        encryptionVFlashSupported: "boolean",
        encryptionCBRCSupported: "boolean",
        encryptionHBRSupported: "boolean",
        ftEfiSupported: "boolean",
        unmapMethodSupported: "string",
        maxMemMBPerFtVm: "number",
        virtualMmuUsageIgnored: "boolean",
        virtualExecUsageIgnored: "boolean",
        vmCreateDateSupported: "boolean",
        vmfs3EOLSupported: "boolean",
        ftVmcpSupported: "boolean",
        quickBootSupported: "boolean",
        assignableHardwareSupported: "boolean",
        useFeatureReqsForOldHWv: "boolean",
        markPerenniallyReservedSupported: "boolean",
        hppPspSupported: "boolean",
        deviceRebindWithoutRebootSupported: "boolean",
        storagePolicyChangeSupported: "boolean",
        precisionTimeProtocolSupported: "boolean",
        remoteDeviceVMotionSupported: "boolean",
        maxSupportedVmMemory: "number"
};
typeNames.interfaces["HostCertificateManagerCertificateInfo"] = {
issuer: "string",
        notBefore: "Date",
        notAfter: "Date",
        subject: "string",
        status: "string"
};
typeNames.interfaces["HostConfigChange"] = {

};
typeNames.interfaces["HostConfigManager"] = {
cpuScheduler: HostCpuSchedulerSystem,
        datastoreSystem: HostDatastoreSystem,
        memoryManager: HostMemorySystem,
        storageSystem: HostStorageSystem,
        networkSystem: HostNetworkSystem,
        vmotionSystem: HostVMotionSystem,
        virtualNicManager: HostVirtualNicManager,
        serviceSystem: HostServiceSystem,
        firewallSystem: HostFirewallSystem,
        advancedOption: OptionManager,
        diagnosticSystem: HostDiagnosticSystem,
        autoStartManager: HostAutoStartManager,
        snmpSystem: HostSnmpSystem,
        dateTimeSystem: HostDateTimeSystem,
        patchManager: HostPatchManager,
        imageConfigManager: HostImageConfigManager,
        bootDeviceSystem: HostBootDeviceSystem,
        firmwareSystem: HostFirmwareSystem,
        healthStatusSystem: HostHealthStatusSystem,
        pciPassthruSystem: HostPciPassthruSystem,
        licenseManager: LicenseManager,
        kernelModuleSystem: HostKernelModuleSystem,
        authenticationManager: HostAuthenticationManager,
        powerSystem: HostPowerSystem,
        cacheConfigurationManager: HostCacheConfigurationManager,
        esxAgentHostManager: HostEsxAgentHostManager,
        iscsiManager: IscsiManager,
        vFlashManager: HostVFlashManager,
        vsanSystem: HostVsanSystem,
        messageBusProxy: MessageBusProxy,
        userDirectory: UserDirectory,
        accountManager: HostLocalAccountManager,
        hostAccessManager: HostAccessManager,
        graphicsManager: HostGraphicsManager,
        vsanInternalSystem: HostVsanInternalSystem,
        certificateManager: HostCertificateManager,
        cryptoManager: CryptoManager,
        nvdimmSystem: HostNvdimmSystem,
        assignableHardwareManager: HostAssignableHardwareManager
};
typeNames.interfaces["HostCpuIdInfo"] = {
level: "number",
        vendor: "string",
        eax: "string",
        ebx: "string",
        ecx: "string",
        edx: "string"
};
typeNames.interfaces["HostCpuInfo"] = {
numCpuPackages: "number",
        numCpuCores: "number",
        numCpuThreads: "number",
        hz: "number"
};
typeNames.interfaces["HostCpuPackage"] = {
index: "number",
        vendor: "string",
        hz: "number",
        busHz: "number",
        description: "string",
        threadId: "number",
        cpuFeature: "HostCpuIdInfo"
};
typeNames.interfaces["HostCpuPowerManagementInfo"] = {
currentPolicy: "string",
        hardwareSupport: "string"
};
typeNames.interfaces["HostHyperThreadScheduleInfo"] = {
available: "boolean",
        active: "boolean",
        config: "boolean"
};
typeNames.interfaces["FileInfo"] = {
path: "string",
        friendlyName: "string",
        fileSize: "number",
        modification: "Date",
        owner: "string"
};
typeNames.interfaces["FileQueryFlags"] = {
fileType: "boolean",
        fileSize: "boolean",
        modification: "boolean",
        fileOwner: "boolean"
};
typeNames.interfaces["FloppyImageFileInfo"] = {

};
typeNames.interfaces["FloppyImageFileQuery"] = {

};
typeNames.interfaces["FolderFileInfo"] = {

};
typeNames.interfaces["FolderFileQuery"] = {

};
typeNames.interfaces["IsoImageFileInfo"] = {

};
typeNames.interfaces["IsoImageFileQuery"] = {

};
typeNames.interfaces["FileQuery"] = {

};
typeNames.interfaces["HostDatastoreBrowserSearchResults"] = {
datastore: Datastore,
        folderPath: "string",
        file: "FileInfo"
};
typeNames.interfaces["HostDatastoreBrowserSearchSpec"] = {
query: "FileQuery",
        details: "FileQueryFlags",
        searchCaseInsensitive: "boolean",
        matchPattern: "string",
        sortFoldersFirst: "boolean"
};
typeNames.interfaces["TemplateConfigFileInfo"] = {

};
typeNames.interfaces["TemplateConfigFileQuery"] = {

};
typeNames.interfaces["VmConfigFileInfo"] = {
configVersion: "number",
        encryption: "VmConfigFileEncryptionInfo"
};
typeNames.interfaces["VmConfigFileEncryptionInfo"] = {
keyId: "CryptoKeyId"
};
typeNames.interfaces["VmConfigFileQuery"] = {
filter: "VmConfigFileQueryFilter",
        details: "VmConfigFileQueryFlags"
};
typeNames.interfaces["VmConfigFileQueryFlags"] = {
configVersion: "boolean",
        encryption: "boolean"
};
typeNames.interfaces["VmConfigFileQueryFilter"] = {
matchConfigVersion: "number",
        encrypted: "boolean"
};
typeNames.interfaces["VmDiskFileInfo"] = {
diskType: "string",
        capacityKb: "number",
        hardwareVersion: "number",
        controllerType: "string",
        diskExtents: "string",
        thin: "boolean",
        encryption: "VmDiskFileEncryptionInfo"
};
typeNames.interfaces["VmDiskFileEncryptionInfo"] = {
keyId: "CryptoKeyId"
};
typeNames.interfaces["VmDiskFileQuery"] = {
filter: "VmDiskFileQueryFilter",
        details: "VmDiskFileQueryFlags"
};
typeNames.interfaces["VmDiskFileQueryFlags"] = {
diskType: "boolean",
        capacityKb: "boolean",
        hardwareVersion: "boolean",
        controllerType: "boolean",
        diskExtents: "boolean",
        thin: "boolean",
        encryption: "boolean"
};
typeNames.interfaces["VmDiskFileQueryFilter"] = {
diskType: "string",
        matchHardwareVersion: "number",
        controllerType: "string",
        thin: "boolean",
        encrypted: "boolean"
};
typeNames.interfaces["VmLogFileInfo"] = {

};
typeNames.interfaces["VmLogFileQuery"] = {

};
typeNames.interfaces["VmNvramFileInfo"] = {

};
typeNames.interfaces["VmNvramFileQuery"] = {

};
typeNames.interfaces["VmSnapshotFileInfo"] = {

};
typeNames.interfaces["VmSnapshotFileQuery"] = {

};
typeNames.interfaces["HostDateTimeConfig"] = {
timeZone: "string",
        ntpConfig: "HostNtpConfig"
};
typeNames.interfaces["HostDateTimeSystemTimeZone"] = {
key: "string",
        name: "string",
        description: "string",
        gmtOffset: "number"
};
typeNames.interfaces["HostDeploymentInfo"] = {
bootedFromStatelessCache: "boolean"
};
typeNames.interfaces["HostDevice"] = {
deviceName: "string",
        deviceType: "string"
};
typeNames.interfaces["HostDhcpService"] = {
key: "string",
        spec: "HostDhcpServiceSpec"
};
typeNames.interfaces["HostDhcpServiceConfig"] = {
changeOperation: "string",
        key: "string",
        spec: "HostDhcpServiceSpec"
};
typeNames.interfaces["HostDhcpServiceSpec"] = {
virtualSwitch: "string",
        defaultLeaseDuration: "number",
        leaseBeginIp: "string",
        leaseEndIp: "string",
        maxLeaseDuration: "number",
        unlimitedLease: "boolean",
        ipSubnetAddr: "string",
        ipSubnetMask: "string"
};
typeNames.interfaces["HostDigestInfo"] = {
digestMethod: "string",
        digestValue: "number",
        objectName: "string"
};
typeNames.interfaces["HostDirectoryStoreInfo"] = {

};
typeNames.interfaces["HostDiskConfigurationResult"] = {
devicePath: "string",
        success: "boolean",
        fault: "MethodFault"
};
typeNames.interfaces["HostDiskDimensions"] = {

};
typeNames.interfaces["HostDiskDimensionsChs"] = {
cylinder: "number",
        head: "number",
        sector: "number"
};
typeNames.interfaces["HostDiskDimensionsLba"] = {
blockSize: "number",
        block: "number"
};
typeNames.interfaces["HostDiskPartitionInfo"] = {
deviceName: "string",
        spec: "HostDiskPartitionSpec",
        layout: "HostDiskPartitionLayout"
};
typeNames.interfaces["HostDiskPartitionBlockRange"] = {
partition: "number",
        type: "string",
        start: "HostDiskDimensionsLba",
        end: "HostDiskDimensionsLba"
};
typeNames.interfaces["HostDiskPartitionLayout"] = {
total: "HostDiskDimensionsLba",
        partition: "HostDiskPartitionBlockRange"
};
typeNames.interfaces["HostDiskPartitionAttributes"] = {
partition: "number",
        startSector: "number",
        endSector: "number",
        type: "string",
        guid: "string",
        logical: "boolean",
        attributes: "number",
        partitionAlignment: "number"
};
typeNames.interfaces["HostDiskPartitionSpec"] = {
partitionFormat: "string",
        chs: "HostDiskDimensionsChs",
        totalSectors: "number",
        partition: "HostDiskPartitionAttributes"
};
typeNames.interfaces["HostDnsConfig"] = {
dhcp: "boolean",
        virtualNicDevice: "string",
        ipv6VirtualNicDevice: "string",
        hostName: "string",
        domainName: "string",
        address: "string",
        searchDomain: "string"
};
typeNames.interfaces["HostDnsConfigSpec"] = {
virtualNicConnection: "HostVirtualNicConnection",
        virtualNicConnectionV6: "HostVirtualNicConnection"
};
typeNames.interfaces["HostEnterMaintenanceResult"] = {
vmFaults: "FaultsByVM",
        hostFaults: "FaultsByHost"
};
typeNames.interfaces["HostEsxAgentHostManagerConfigInfo"] = {
agentVmDatastore: Datastore,
        agentVmNetwork: Network
};
typeNames.interfaces["HostFaultToleranceManagerComponentHealthInfo"] = {
isStorageHealthy: "boolean",
        isNetworkHealthy: "boolean"
};
typeNames.interfaces["FcoeConfig"] = {
priorityClass: "number",
        sourceMac: "string",
        vlanRange: "FcoeConfigVlanRange",
        capabilities: "FcoeConfigFcoeCapabilities",
        fcoeActive: "boolean"
};
typeNames.interfaces["FcoeConfigFcoeCapabilities"] = {
priorityClass: "boolean",
        sourceMacAddress: "boolean",
        vlanRange: "boolean"
};
typeNames.interfaces["FcoeConfigFcoeSpecification"] = {
underlyingPnic: "string",
        priorityClass: "number",
        sourceMac: "string",
        vlanRange: "FcoeConfigVlanRange"
};
typeNames.interfaces["FcoeConfigVlanRange"] = {
vlanLow: "number",
        vlanHigh: "number"
};
typeNames.interfaces["HostFeatureCapability"] = {
key: "string",
        featureName: "string",
        value: "string"
};
typeNames.interfaces["HostFeatureMask"] = {
key: "string",
        featureName: "string",
        value: "string"
};
typeNames.interfaces["HostFeatureVersionInfo"] = {
key: "string",
        value: "string"
};
typeNames.interfaces["HostFileAccess"] = {
who: "string",
        what: "string"
};
typeNames.interfaces["ModeInfo"] = {
browse: "string",
        read: "string",
        modify: "string",
        use: "string",
        admin: "string",
        full: "string"
};
typeNames.interfaces["HostFileSystemMountInfo"] = {
mountInfo: "HostMountInfo",
        volume: "HostFileSystemVolume",
        vStorageSupport: "string"
};
typeNames.interfaces["HostFileSystemVolume"] = {
type: "string",
        name: "string",
        capacity: "number"
};
typeNames.interfaces["HostFileSystemVolumeInfo"] = {
volumeTypeList: "string",
        mountInfo: "HostFileSystemMountInfo"
};
typeNames.interfaces["HostFirewallInfo"] = {
defaultPolicy: "HostFirewallDefaultPolicy",
        ruleset: "HostFirewallRuleset"
};
typeNames.interfaces["HostFirewallDefaultPolicy"] = {
incomingBlocked: "boolean",
        outgoingBlocked: "boolean"
};
typeNames.interfaces["HostFlagInfo"] = {
backgroundSnapshotsEnabled: "boolean"
};
typeNames.interfaces["HostForceMountedInfo"] = {
persist: "boolean",
        mounted: "boolean"
};
typeNames.interfaces["HostGatewaySpec"] = {
gatewayType: "string",
        gatewayId: "string",
        trustVerificationToken: "string",
        hostAuthParams: "KeyValue"
};
typeNames.interfaces["HostGraphicsConfig"] = {
hostDefaultGraphicsType: "string",
        sharedPassthruAssignmentPolicy: "string",
        deviceType: "HostGraphicsConfigDeviceType"
};
typeNames.interfaces["HostGraphicsConfigDeviceType"] = {
deviceId: "string",
        graphicsType: "string"
};
typeNames.interfaces["HostGraphicsInfo"] = {
deviceName: "string",
        vendorName: "string",
        pciId: "string",
        graphicsType: "string",
        memorySizeInKB: "number",
        vm: VirtualMachine
};
typeNames.interfaces["HostHardwareInfo"] = {
systemInfo: "HostSystemInfo",
        cpuPowerManagementInfo: "HostCpuPowerManagementInfo",
        cpuInfo: "HostCpuInfo",
        cpuPkg: "HostCpuPackage",
        memorySize: "number",
        numaInfo: "HostNumaInfo",
        smcPresent: "boolean",
        pciDevice: "HostPciDevice",
        cpuFeature: "HostCpuIdInfo",
        biosInfo: "HostBIOSInfo",
        reliableMemoryInfo: "HostReliableMemoryInfo",
        persistentMemoryInfo: "HostPersistentMemoryInfo",
        sgxInfo: "HostSgxInfo",
        sevInfo: "HostSevInfo"
};
typeNames.interfaces["HostHardwareStatusInfo"] = {
memoryStatusInfo: "HostHardwareElementInfo",
        cpuStatusInfo: "HostHardwareElementInfo",
        storageStatusInfo: "HostStorageElementInfo"
};
typeNames.interfaces["HostHardwareElementInfo"] = {
name: "string",
        status: "ElementDescription"
};
typeNames.interfaces["HostStorageElementInfo"] = {
operationalInfo: "HostStorageOperationalInfo"
};
typeNames.interfaces["HostStorageOperationalInfo"] = {
property: "string",
        value: "string"
};
typeNames.interfaces["HealthSystemRuntime"] = {
systemHealthInfo: "HostSystemHealthInfo",
        hardwareStatusInfo: "HostHardwareStatusInfo"
};
typeNames.interfaces["HostAccessControlEntry"] = {
principal: "string",
        group: "boolean",
        accessMode: "HostAccessMode"
};
typeNames.interfaces["HostHostBusAdapter"] = {
key: "string",
        device: "string",
        bus: "number",
        status: "string",
        model: "string",
        driver: "string",
        pci: "string",
        storageProtocol: "string"
};
typeNames.interfaces["HostProxySwitch"] = {
dvsUuid: "string",
        dvsName: "string",
        key: "string",
        numPorts: "number",
        configNumPorts: "number",
        numPortsAvailable: "number",
        uplinkPort: "KeyValue",
        mtu: "number",
        pnic: "PhysicalNic",
        spec: "HostProxySwitchSpec",
        hostLag: "HostProxySwitchHostLagConfig",
        networkReservationSupported: "boolean",
        nsxtEnabled: "boolean",
        ensEnabled: "boolean",
        ensInterruptEnabled: "boolean",
        transportZones: "DistributedVirtualSwitchHostMemberTransportZoneInfo",
        nsxUsedUplinkPort: "string",
        nsxtStatus: "string",
        nsxtStatusDetail: "string"
};
typeNames.interfaces["HostProxySwitchConfig"] = {
changeOperation: "string",
        uuid: "string",
        spec: "HostProxySwitchSpec"
};
typeNames.interfaces["HostProxySwitchHostLagConfig"] = {
lagKey: "string",
        lagName: "string",
        uplinkPort: "KeyValue"
};
typeNames.interfaces["HostProxySwitchSpec"] = {
backing: "DistributedVirtualSwitchHostMemberBacking"
};
typeNames.interfaces["HostImageProfileSummary"] = {
name: "string",
        vendor: "string"
};
typeNames.interfaces["HostIpConfig"] = {
dhcp: "boolean",
        ipAddress: "string",
        subnetMask: "string",
        ipV6Config: "HostIpConfigIpV6AddressConfiguration"
};
typeNames.interfaces["HostIpConfigIpV6Address"] = {
ipAddress: "string",
        prefixLength: "number",
        origin: "string",
        dadState: "string",
        lifetime: "Date",
        operation: "string"
};
typeNames.interfaces["HostIpConfigIpV6AddressConfiguration"] = {
ipV6Address: "HostIpConfigIpV6Address",
        autoConfigurationEnabled: "boolean",
        dhcpV6Enabled: "boolean"
};
typeNames.interfaces["HostIpRouteConfig"] = {
defaultGateway: "string",
        gatewayDevice: "string",
        ipV6DefaultGateway: "string",
        ipV6GatewayDevice: "string"
};
typeNames.interfaces["HostIpRouteConfigSpec"] = {
gatewayDeviceConnection: "HostVirtualNicConnection",
        ipV6GatewayDeviceConnection: "HostVirtualNicConnection"
};
typeNames.interfaces["HostIpRouteEntry"] = {
network: "string",
        prefixLength: "number",
        gateway: "string",
        deviceName: "string"
};
typeNames.interfaces["HostIpRouteOp"] = {
changeOperation: "string",
        route: "HostIpRouteEntry"
};
typeNames.interfaces["HostIpRouteTableConfig"] = {
ipRoute: "HostIpRouteOp",
        ipv6Route: "HostIpRouteOp"
};
typeNames.interfaces["HostIpRouteTableInfo"] = {
ipRoute: "HostIpRouteEntry",
        ipv6Route: "HostIpRouteEntry"
};
typeNames.interfaces["HostIpmiInfo"] = {
bmcIpAddress: "string",
        bmcMacAddress: "string",
        login: "string",
        password: "string"
};
typeNames.interfaces["IscsiDependencyEntity"] = {
pnicDevice: "string",
        vnicDevice: "string",
        vmhbaName: "string"
};
typeNames.interfaces["IscsiMigrationDependency"] = {
migrationAllowed: "boolean",
        disallowReason: "IscsiStatus",
        dependency: "IscsiDependencyEntity"
};
typeNames.interfaces["IscsiPortInfo"] = {
vnicDevice: "string",
        vnic: "HostVirtualNic",
        pnicDevice: "string",
        pnic: "PhysicalNic",
        switchName: "string",
        switchUuid: "string",
        portgroupName: "string",
        portgroupKey: "string",
        portKey: "string",
        opaqueNetworkId: "string",
        opaqueNetworkType: "string",
        opaqueNetworkName: "string",
        externalId: "string",
        complianceStatus: "IscsiStatus",
        pathStatus: "string"
};
typeNames.interfaces["IscsiStatus"] = {
reason: "MethodFault"
};
typeNames.interfaces["KernelModuleInfo"] = {
id: "number",
        name: "string",
        version: "string",
        filename: "string",
        optionString: "string",
        loaded: "boolean",
        enabled: "boolean",
        useCount: "number",
        readOnlySection: "KernelModuleSectionInfo",
        writableSection: "KernelModuleSectionInfo",
        textSection: "KernelModuleSectionInfo",
        dataSection: "KernelModuleSectionInfo",
        bssSection: "KernelModuleSectionInfo"
};
typeNames.interfaces["KernelModuleSectionInfo"] = {
address: "number",
        length: "number"
};
typeNames.interfaces["HostLicenseSpec"] = {
source: "LicenseSource",
        editionKey: "string",
        disabledFeatureKey: "string",
        enabledFeatureKey: "string"
};
typeNames.interfaces["LinkDiscoveryProtocolConfig"] = {
protocol: "string",
        operation: "string"
};
typeNames.interfaces["HostAccountSpec"] = {
id: "string",
        password: "string",
        description: "string"
};
typeNames.interfaces["HostPosixAccountSpec"] = {
posixId: "number",
        shellAccess: "boolean"
};
typeNames.interfaces["HostLocalAuthenticationInfo"] = {

};
typeNames.interfaces["HostLocalFileSystemVolume"] = {
device: "string"
};
typeNames.interfaces["HostLocalFileSystemVolumeSpec"] = {
device: "string",
        localPath: "string"
};
typeNames.interfaces["HostLowLevelProvisioningManagerDiskLayoutSpec"] = {
controllerType: "string",
        busNumber: "number",
        unitNumber: "number",
        srcFilename: "string",
        dstFilename: "string"
};
typeNames.interfaces["HostLowLevelProvisioningManagerFileDeleteResult"] = {
fileName: "string",
        fault: "MethodFault"
};
typeNames.interfaces["HostLowLevelProvisioningManagerFileDeleteSpec"] = {
fileName: "string",
        fileType: "string"
};
typeNames.interfaces["HostLowLevelProvisioningManagerFileReserveResult"] = {
baseName: "string",
        parentDir: "string",
        reservedName: "string"
};
typeNames.interfaces["HostLowLevelProvisioningManagerFileReserveSpec"] = {
baseName: "string",
        parentDir: "string",
        fileType: "string",
        storageProfile: "string"
};
typeNames.interfaces["HostLowLevelProvisioningManagerSnapshotLayoutSpec"] = {
id: "number",
        srcFilename: "string",
        dstFilename: "string",
        disk: "HostLowLevelProvisioningManagerDiskLayoutSpec"
};
typeNames.interfaces["HostLowLevelProvisioningManagerVmMigrationStatus"] = {
migrationId: "number",
        type: "string",
        source: "boolean",
        consideredSuccessful: "boolean"
};
typeNames.interfaces["HostLowLevelProvisioningManagerVmRecoveryInfo"] = {
version: "string",
        biosUUID: "string",
        instanceUUID: "string",
        ftInfo: "FaultToleranceConfigInfo"
};
typeNames.interfaces["HostMaintenanceSpec"] = {
vsanMode: "VsanHostDecommissionMode",
        purpose: "string"
};
typeNames.interfaces["ServiceConsoleReservationInfo"] = {
serviceConsoleReservedCfg: "number",
        serviceConsoleReserved: "number",
        unreserved: "number"
};
typeNames.interfaces["VirtualMachineMemoryReservationInfo"] = {
virtualMachineMin: "number",
        virtualMachineMax: "number",
        virtualMachineReserved: "number",
        allocationPolicy: "string"
};
typeNames.interfaces["VirtualMachineMemoryReservationSpec"] = {
virtualMachineReserved: "number",
        allocationPolicy: "string"
};
typeNames.interfaces["HostMemorySpec"] = {
serviceConsoleReservation: "number"
};
typeNames.interfaces["HostMountInfo"] = {
path: "string",
        accessMode: "string",
        mounted: "boolean",
        accessible: "boolean",
        inaccessibleReason: "string"
};
typeNames.interfaces["HostMultipathInfo"] = {
lun: "HostMultipathInfoLogicalUnit"
};
typeNames.interfaces["HostMultipathInfoFixedLogicalUnitPolicy"] = {
prefer: "string"
};
typeNames.interfaces["HostMultipathInfoHppLogicalUnitPolicy"] = {
bytes: "number",
        iops: "number",
        path: "string",
        latencyEvalTime: "number",
        samplingIosPerPath: "number"
};
typeNames.interfaces["HostMultipathInfoLogicalUnit"] = {
key: "string",
        id: "string",
        lun: "ScsiLun",
        path: "HostMultipathInfoPath",
        policy: "HostMultipathInfoLogicalUnitPolicy",
        storageArrayTypePolicy: "HostMultipathInfoLogicalUnitStorageArrayTypePolicy"
};
typeNames.interfaces["HostMultipathInfoLogicalUnitPolicy"] = {
policy: "string"
};
typeNames.interfaces["HostMultipathInfoLogicalUnitStorageArrayTypePolicy"] = {
policy: "string"
};
typeNames.interfaces["HostMultipathInfoPath"] = {
key: "string",
        name: "string",
        pathState: "string",
        state: "string",
        isWorkingPath: "boolean",
        adapter: "HostHostBusAdapter",
        lun: "HostMultipathInfoLogicalUnit",
        transport: "HostTargetTransport"
};
typeNames.interfaces["HostMultipathStateInfo"] = {
path: "HostMultipathStateInfoPath"
};
typeNames.interfaces["HostMultipathStateInfoPath"] = {
name: "string",
        pathState: "string"
};
typeNames.interfaces["HostNasVolume"] = {
remoteHost: "string",
        remotePath: "string",
        userName: "string",
        remoteHostNames: "string",
        securityType: "string",
        protocolEndpoint: "boolean"
};
typeNames.interfaces["HostNasVolumeConfig"] = {
changeOperation: "string",
        spec: "HostNasVolumeSpec"
};
typeNames.interfaces["HostNasVolumeSpec"] = {
remoteHost: "string",
        remotePath: "string",
        localPath: "string",
        accessMode: "string",
        type: "string",
        userName: "string",
        password: "string",
        remoteHostNames: "string",
        securityType: "string"
};
typeNames.interfaces["HostNasVolumeUserInfo"] = {
user: "string"
};
typeNames.interfaces["HostNatService"] = {
key: "string",
        spec: "HostNatServiceSpec"
};
typeNames.interfaces["HostNatServiceConfig"] = {
changeOperation: "string",
        key: "string",
        spec: "HostNatServiceSpec"
};
typeNames.interfaces["HostNatServiceNameServiceSpec"] = {
dnsAutoDetect: "boolean",
        dnsPolicy: "string",
        dnsRetries: "number",
        dnsTimeout: "number",
        dnsNameServer: "string",
        nbdsTimeout: "number",
        nbnsRetries: "number",
        nbnsTimeout: "number"
};
typeNames.interfaces["HostNatServicePortForwardSpec"] = {
type: "string",
        name: "string",
        hostPort: "number",
        guestPort: "number",
        guestIpAddress: "string"
};
typeNames.interfaces["HostNatServiceSpec"] = {
virtualSwitch: "string",
        activeFtp: "boolean",
        allowAnyOui: "boolean",
        configPort: "boolean",
        ipGatewayAddress: "string",
        udpTimeout: "number",
        portForward: "HostNatServicePortForwardSpec",
        nameService: "HostNatServiceNameServiceSpec"
};
typeNames.interfaces["HostNetCapabilities"] = {
canSetPhysicalNicLinkSpeed: "boolean",
        supportsNicTeaming: "boolean",
        nicTeamingPolicy: "string",
        supportsVlan: "boolean",
        usesServiceConsoleNic: "boolean",
        supportsNetworkHints: "boolean",
        maxPortGroupsPerVswitch: "number",
        vswitchConfigSupported: "boolean",
        vnicConfigSupported: "boolean",
        ipRouteConfigSupported: "boolean",
        dnsConfigSupported: "boolean",
        dhcpOnVnicSupported: "boolean",
        ipV6Supported: "boolean",
        backupNfcNiocSupported: "boolean"
};
typeNames.interfaces["HostNetOffloadCapabilities"] = {
csumOffload: "boolean",
        tcpSegmentation: "boolean",
        zeroCopyXmit: "boolean"
};
typeNames.interfaces["HostNetStackInstance"] = {
key: "string",
        name: "string",
        dnsConfig: "HostDnsConfig",
        ipRouteConfig: "HostIpRouteConfig",
        requestedMaxNumberOfConnections: "number",
        congestionControlAlgorithm: "string",
        ipV6Enabled: "boolean",
        routeTableConfig: "HostIpRouteTableConfig"
};
typeNames.interfaces["HostNetworkInfo"] = {
vswitch: "HostVirtualSwitch",
        proxySwitch: "HostProxySwitch",
        portgroup: "HostPortGroup",
        pnic: "PhysicalNic",
        rdmaDevice: "HostRdmaDevice",
        vnic: "HostVirtualNic",
        consoleVnic: "HostVirtualNic",
        dnsConfig: "HostDnsConfig",
        ipRouteConfig: "HostIpRouteConfig",
        consoleIpRouteConfig: "HostIpRouteConfig",
        routeTableInfo: "HostIpRouteTableInfo",
        dhcp: "HostDhcpService",
        nat: "HostNatService",
        ipV6Enabled: "boolean",
        atBootIpV6Enabled: "boolean",
        netStackInstance: "HostNetStackInstance",
        opaqueSwitch: "HostOpaqueSwitch",
        opaqueNetwork: "HostOpaqueNetworkInfo",
        nsxTransportNodeId: "string"
};
typeNames.interfaces["HostNetworkPolicy"] = {
security: "HostNetworkSecurityPolicy",
        nicTeaming: "HostNicTeamingPolicy",
        offloadPolicy: "HostNetOffloadCapabilities",
        shapingPolicy: "HostNetworkTrafficShapingPolicy"
};
typeNames.interfaces["HostNicFailureCriteria"] = {
checkSpeed: "string",
        speed: "number",
        checkDuplex: "boolean",
        fullDuplex: "boolean",
        checkErrorPercent: "boolean",
        percentage: "number",
        checkBeacon: "boolean"
};
typeNames.interfaces["HostNicOrderPolicy"] = {
activeNic: "string",
        standbyNic: "string"
};
typeNames.interfaces["HostNicTeamingPolicy"] = {
policy: "string",
        reversePolicy: "boolean",
        notifySwitches: "boolean",
        rollingOrder: "boolean",
        failureCriteria: "HostNicFailureCriteria",
        nicOrder: "HostNicOrderPolicy"
};
typeNames.interfaces["HostNetworkSecurityPolicy"] = {
allowPromiscuous: "boolean",
        macChanges: "boolean",
        forgedTransmits: "boolean"
};
typeNames.interfaces["HostNetworkTrafficShapingPolicy"] = {
enabled: "boolean",
        averageBandwidth: "number",
        peakBandwidth: "number",
        burstSize: "number"
};
typeNames.interfaces["HostNtpConfig"] = {
server: "string",
        configFile: "string"
};
typeNames.interfaces["HostNumaInfo"] = {
type: "string",
        numNodes: "number",
        numaNode: "HostNumaNode"
};
typeNames.interfaces["HostNumaNode"] = {
typeId: "number",
        cpuID: "number",
        memoryRangeBegin: "number",
        memoryRangeLength: "number",
        pciId: "string"
};
typeNames.interfaces["HostNumericSensorInfo"] = {
name: "string",
        healthState: "ElementDescription",
        currentReading: "number",
        unitModifier: "number",
        baseUnits: "string",
        rateUnits: "string",
        sensorType: "string",
        id: "string",
        timeStamp: "string"
};
typeNames.interfaces["NvdimmDimmInfo"] = {
dimmHandle: "number",
        healthInfo: "NvdimmHealthInfo",
        totalCapacity: "number",
        persistentCapacity: "number",
        availablePersistentCapacity: "number",
        volatileCapacity: "number",
        availableVolatileCapacity: "number",
        blockCapacity: "number",
        regionInfo: "NvdimmRegionInfo",
        representationString: "string"
};
typeNames.interfaces["NvdimmGuid"] = {
uuid: "string"
};
typeNames.interfaces["NvdimmHealthInfo"] = {
healthStatus: "string",
        healthInformation: "string",
        stateFlagInfo: "string",
        dimmTemperature: "number",
        dimmTemperatureThreshold: "number",
        spareBlocksPercentage: "number",
        spareBlockThreshold: "number",
        dimmLifespanPercentage: "number",
        esTemperature: "number",
        esTemperatureThreshold: "number",
        esLifespanPercentage: "number"
};
typeNames.interfaces["NvdimmInterleaveSetInfo"] = {
setId: "number",
        rangeType: "string",
        baseAddress: "number",
        size: "number",
        availableSize: "number",
        deviceList: "number",
        state: "string"
};
typeNames.interfaces["NvdimmNamespaceCreateSpec"] = {
friendlyName: "string",
        blockSize: "number",
        blockCount: "number",
        type: "string",
        locationID: "number"
};
typeNames.interfaces["NvdimmNamespaceDeleteSpec"] = {
uuid: "string"
};
typeNames.interfaces["NvdimmNamespaceDetails"] = {
uuid: "string",
        friendlyName: "string",
        size: "number",
        type: "string",
        namespaceHealthStatus: "string",
        interleavesetID: "number",
        state: "string"
};
typeNames.interfaces["NvdimmNamespaceInfo"] = {
uuid: "string",
        friendlyName: "string",
        blockSize: "number",
        blockCount: "number",
        type: "string",
        namespaceHealthStatus: "string",
        locationID: "number",
        state: "string"
};
typeNames.interfaces["NvdimmSystemInfo"] = {
summary: "NvdimmSummary",
        dimms: "number",
        dimmInfo: "NvdimmDimmInfo",
        interleaveSet: "number",
        iSetInfo: "NvdimmInterleaveSetInfo",
        namespace: "NvdimmGuid",
        nsInfo: "NvdimmNamespaceInfo",
        nsDetails: "NvdimmNamespaceDetails"
};
typeNames.interfaces["NvdimmPMemNamespaceCreateSpec"] = {
friendlyName: "string",
        size: "number",
        interleavesetID: "number"
};
typeNames.interfaces["NvdimmRegionInfo"] = {
regionId: "number",
        setId: "number",
        rangeType: "string",
        startAddr: "number",
        size: "number",
        offset: "number"
};
typeNames.interfaces["NvdimmSummary"] = {
numDimms: "number",
        healthStatus: "string",
        totalCapacity: "number",
        persistentCapacity: "number",
        blockCapacity: "number",
        availableCapacity: "number",
        numInterleavesets: "number",
        numNamespaces: "number"
};
typeNames.interfaces["HostNvmeController"] = {
key: "string",
        controllerNumber: "number",
        subnqn: "string",
        name: "string",
        associatedAdapter: "HostHostBusAdapter",
        transportType: "string",
        fusedOperationSupported: "boolean",
        numberOfQueues: "number",
        queueSize: "number",
        attachedNamespace: "HostNvmeNamespace",
        vendorId: "string",
        model: "string",
        serialNumber: "string",
        firmwareVersion: "string"
};
typeNames.interfaces["HostNvmeDisconnectSpec"] = {
hbaName: "string",
        subnqn: "string",
        controllerNumber: "number"
};
typeNames.interfaces["HostNvmeDiscoveryLog"] = {
entry: "HostNvmeDiscoveryLogEntry",
        complete: "boolean"
};
typeNames.interfaces["HostNvmeDiscoveryLogEntry"] = {
subnqn: "string",
        subsystemType: "string",
        subsystemPortId: "number",
        controllerId: "number",
        adminQueueMaxSize: "number",
        transportParameters: "HostNvmeTransportParameters",
        transportRequirements: "string",
        connected: "boolean"
};
typeNames.interfaces["HostNvmeNamespace"] = {
key: "string",
        name: "string",
        id: "number",
        blockSize: "number",
        capacityInBlocks: "number"
};
typeNames.interfaces["HostNvmeSpec"] = {
hbaName: "string",
        transportParameters: "HostNvmeTransportParameters"
};
typeNames.interfaces["HostNvmeTopology"] = {
adapter: "HostNvmeTopologyInterface"
};
typeNames.interfaces["HostNvmeTopologyInterface"] = {
key: "string",
        adapter: "HostHostBusAdapter",
        connectedController: "HostNvmeController"
};
typeNames.interfaces["HostNvmeTransportParameters"] = {

};
typeNames.interfaces["HostOpaqueSwitch"] = {
key: "string",
        name: "string",
        pnic: "PhysicalNic",
        pnicZone: "HostOpaqueSwitchPhysicalNicZone",
        status: "string",
        vtep: "HostVirtualNic",
        extraConfig: "OptionValue",
        featureCapability: "HostFeatureCapability"
};
typeNames.interfaces["HostOpaqueSwitchPhysicalNicZone"] = {
key: "string",
        pnicDevice: "string"
};
typeNames.interfaces["HostPMemVolume"] = {
uuid: "string",
        version: "string"
};
typeNames.interfaces["HostParallelScsiHba"] = {

};
typeNames.interfaces["HostPatchManagerLocator"] = {
url: "string",
        proxy: "string"
};
typeNames.interfaces["HostPatchManagerPatchManagerOperationSpec"] = {
proxy: "string",
        port: "number",
        userName: "string",
        password: "string",
        cmdOption: "string"
};
typeNames.interfaces["HostPatchManagerResult"] = {
version: "string",
        status: "HostPatchManagerStatus",
        xmlResult: "string"
};
typeNames.interfaces["HostPatchManagerStatus"] = {
id: "string",
        applicable: "boolean",
        reason: "string",
        integrity: "string",
        installed: "boolean",
        installState: "string",
        prerequisitePatch: "HostPatchManagerStatusPrerequisitePatch",
        restartRequired: "boolean",
        reconnectRequired: "boolean",
        vmOffRequired: "boolean",
        supersededPatchIds: "string"
};
typeNames.interfaces["HostPatchManagerStatusPrerequisitePatch"] = {
id: "string",
        installState: "string"
};
typeNames.interfaces["HostPathSelectionPolicyOption"] = {
policy: "ElementDescription"
};
typeNames.interfaces["HostPciDevice"] = {
id: "string",
        classId: "number",
        bus: "number",
        slot: "number",
        function: "number",
        vendorId: "number",
        subVendorId: "number",
        vendorName: "string",
        deviceId: "number",
        subDeviceId: "number",
        parentBridge: "string",
        deviceName: "string"
};
typeNames.interfaces["HostPciPassthruConfig"] = {
id: "string",
        passthruEnabled: "boolean",
        applyNow: "boolean"
};
typeNames.interfaces["HostPciPassthruInfo"] = {
id: "string",
        dependentDevice: "string",
        passthruEnabled: "boolean",
        passthruCapable: "boolean",
        passthruActive: "boolean"
};
typeNames.interfaces["HostPcieHba"] = {

};
typeNames.interfaces["HostPersistentMemoryInfo"] = {
capacityInMB: "number",
        volumeUUID: "string"
};
typeNames.interfaces["PhysicalNic"] = {
key: "string",
        device: "string",
        pci: "string",
        driver: "string",
        linkSpeed: "PhysicalNicLinkInfo",
        validLinkSpecification: "PhysicalNicLinkInfo",
        spec: "PhysicalNicSpec",
        wakeOnLanSupported: "boolean",
        mac: "string",
        fcoeConfiguration: "FcoeConfig",
        vmDirectPathGen2Supported: "boolean",
        vmDirectPathGen2SupportedMode: "string",
        resourcePoolSchedulerAllowed: "boolean",
        resourcePoolSchedulerDisallowedReason: "string",
        autoNegotiateSupported: "boolean",
        enhancedNetworkingStackSupported: "boolean",
        ensInterruptSupported: "boolean",
        rdmaDevice: "HostRdmaDevice"
};
typeNames.interfaces["PhysicalNicCdpDeviceCapability"] = {
router: "boolean",
        transparentBridge: "boolean",
        sourceRouteBridge: "boolean",
        networkSwitch: "boolean",
        host: "boolean",
        igmpEnabled: "boolean",
        repeater: "boolean"
};
typeNames.interfaces["PhysicalNicCdpInfo"] = {
cdpVersion: "number",
        timeout: "number",
        ttl: "number",
        samples: "number",
        devId: "string",
        address: "string",
        portId: "string",
        deviceCapability: "PhysicalNicCdpDeviceCapability",
        softwareVersion: "string",
        hardwarePlatform: "string",
        ipPrefix: "string",
        ipPrefixLen: "number",
        vlan: "number",
        fullDuplex: "boolean",
        mtu: "number",
        systemName: "string",
        systemOID: "string",
        mgmtAddr: "string",
        location: "string"
};
typeNames.interfaces["PhysicalNicConfig"] = {
device: "string",
        spec: "PhysicalNicSpec"
};
typeNames.interfaces["PhysicalNicLinkInfo"] = {
speedMb: "number",
        duplex: "boolean"
};
typeNames.interfaces["LinkLayerDiscoveryProtocolInfo"] = {
chassisId: "string",
        portId: "string",
        timeToLive: "number",
        parameter: "KeyAnyValue"
};
typeNames.interfaces["PhysicalNicHintInfo"] = {
device: "string",
        subnet: "PhysicalNicIpHint",
        network: "PhysicalNicNameHint",
        connectedSwitchPort: "PhysicalNicCdpInfo",
        lldpInfo: "LinkLayerDiscoveryProtocolInfo"
};
typeNames.interfaces["PhysicalNicHint"] = {
vlanId: "number"
};
typeNames.interfaces["PhysicalNicIpHint"] = {
ipSubnet: "string"
};
typeNames.interfaces["PhysicalNicNameHint"] = {
network: "string"
};
typeNames.interfaces["PhysicalNicSpec"] = {
ip: "HostIpConfig",
        linkSpeed: "PhysicalNicLinkInfo",
        enableEnhancedNetworkingStack: "boolean",
        ensInterruptEnabled: "boolean"
};
typeNames.interfaces["HostPlugStoreTopology"] = {
adapter: "HostPlugStoreTopologyAdapter",
        path: "HostPlugStoreTopologyPath",
        target: "HostPlugStoreTopologyTarget",
        device: "HostPlugStoreTopologyDevice",
        plugin: "HostPlugStoreTopologyPlugin"
};
typeNames.interfaces["HostPlugStoreTopologyAdapter"] = {
key: "string",
        adapter: "HostHostBusAdapter",
        path: "HostPlugStoreTopologyPath"
};
typeNames.interfaces["HostPlugStoreTopologyDevice"] = {
key: "string",
        lun: "ScsiLun",
        path: "HostPlugStoreTopologyPath"
};
typeNames.interfaces["HostPlugStoreTopologyPath"] = {
key: "string",
        name: "string",
        channelNumber: "number",
        targetNumber: "number",
        lunNumber: "number",
        adapter: "HostPlugStoreTopologyAdapter",
        target: "HostPlugStoreTopologyTarget",
        device: "HostPlugStoreTopologyDevice"
};
typeNames.interfaces["HostPlugStoreTopologyPlugin"] = {
key: "string",
        name: "string",
        device: "HostPlugStoreTopologyDevice",
        claimedPath: "HostPlugStoreTopologyPath"
};
typeNames.interfaces["HostPlugStoreTopologyTarget"] = {
key: "string",
        transport: "HostTargetTransport"
};
typeNames.interfaces["HostPortGroup"] = {
key: "string",
        port: "HostPortGroupPort",
        vswitch: "HostVirtualSwitch",
        computedPolicy: "HostNetworkPolicy",
        spec: "HostPortGroupSpec"
};
typeNames.interfaces["HostPortGroupConfig"] = {
changeOperation: "string",
        spec: "HostPortGroupSpec"
};
typeNames.interfaces["HostPortGroupPort"] = {
key: "string",
        mac: "string",
        type: "string"
};
typeNames.interfaces["HostPortGroupSpec"] = {
name: "string",
        vlanId: "number",
        vswitchName: "string",
        policy: "HostNetworkPolicy"
};
typeNames.interfaces["PowerSystemCapability"] = {
availablePolicy: "HostPowerPolicy"
};
typeNames.interfaces["PowerSystemInfo"] = {
currentPolicy: "HostPowerPolicy"
};
typeNames.interfaces["HostPowerPolicy"] = {
key: "number",
        name: "string",
        shortName: "string",
        description: "string"
};
typeNames.interfaces["HostProtocolEndpoint"] = {
peType: "string",
        type: "string",
        uuid: "string",
        hostKey: HostSystem,
        storageArray: "string",
        nfsServer: "string",
        nfsDir: "string",
        nfsServerScope: "string",
        nfsServerMajor: "string",
        nfsServerAuthType: "string",
        nfsServerUser: "string",
        deviceId: "string"
};
typeNames.interfaces["HostRdmaDevice"] = {
key: "string",
        device: "string",
        driver: "string",
        description: "string",
        backing: "HostRdmaDeviceBacking",
        connectionInfo: "HostRdmaDeviceConnectionInfo",
        capability: "HostRdmaDeviceCapability"
};
typeNames.interfaces["HostRdmaDeviceBacking"] = {

};
typeNames.interfaces["HostRdmaDeviceCapability"] = {
roceV1Capable: "boolean",
        roceV2Capable: "boolean",
        iWarpCapable: "boolean"
};
typeNames.interfaces["HostRdmaDeviceConnectionInfo"] = {
state: "string",
        mtu: "number",
        speedInMbps: "number"
};
typeNames.interfaces["HostRdmaDevicePnicBacking"] = {
pairedUplink: "PhysicalNic"
};
typeNames.interfaces["HostRdmaHba"] = {
associatedRdmaDevice: "string"
};
typeNames.interfaces["HostReliableMemoryInfo"] = {
memorySize: "number"
};
typeNames.interfaces["HostResignatureRescanResult"] = {
rescan: "HostVmfsRescanResult",
        result: Datastore
};
typeNames.interfaces["HostFirewallRuleset"] = {
key: "string",
        label: "string",
        required: "boolean",
        rule: "HostFirewallRule",
        service: "string",
        enabled: "boolean",
        allowedHosts: "HostFirewallRulesetIpList"
};
typeNames.interfaces["HostFirewallRulesetIpList"] = {
ipAddress: "string",
        ipNetwork: "HostFirewallRulesetIpNetwork",
        allIp: "boolean"
};
typeNames.interfaces["HostFirewallRulesetIpNetwork"] = {
network: "string",
        prefixLength: "number"
};
typeNames.interfaces["HostFirewallRule"] = {
port: "number",
        endPort: "number",
        direction: "HostFirewallRuleDirection",
        portType: "HostFirewallRulePortType",
        protocol: "string"
};
typeNames.interfaces["HostFirewallRulesetRulesetSpec"] = {
allowedHosts: "HostFirewallRulesetIpList"
};
typeNames.interfaces["ScsiLun"] = {
key: "string",
        uuid: "string",
        descriptor: "ScsiLunDescriptor",
        canonicalName: "string",
        displayName: "string",
        lunType: "string",
        vendor: "string",
        model: "string",
        revision: "string",
        scsiLevel: "number",
        serialNumber: "string",
        durableName: "ScsiLunDurableName",
        alternateName: "ScsiLunDurableName",
        standardInquiry: "number",
        queueDepth: "number",
        operationalState: "string",
        capabilities: "ScsiLunCapabilities",
        vStorageSupport: "string",
        protocolEndpoint: "boolean",
        perenniallyReserved: "boolean",
        clusteredVmdkSupported: "boolean"
};
typeNames.interfaces["ScsiLunCapabilities"] = {
updateDisplayNameSupported: "boolean"
};
typeNames.interfaces["ScsiLunDescriptor"] = {
quality: "string",
        id: "string"
};
typeNames.interfaces["ScsiLunDurableName"] = {
namespace: "string",
        namespaceId: "number",
        data: "number"
};
typeNames.interfaces["HostScsiTopology"] = {
adapter: "HostScsiTopologyInterface"
};
typeNames.interfaces["HostScsiTopologyInterface"] = {
key: "string",
        adapter: "HostHostBusAdapter",
        target: "HostScsiTopologyTarget"
};
typeNames.interfaces["HostScsiTopologyLun"] = {
key: "string",
        lun: "number",
        scsiLun: "ScsiLun"
};
typeNames.interfaces["HostScsiTopologyTarget"] = {
key: "string",
        target: "number",
        lun: "HostScsiTopologyLun",
        transport: "HostTargetTransport"
};
typeNames.interfaces["HostSerialAttachedHba"] = {
nodeWorldWideName: "string"
};
typeNames.interfaces["HostService"] = {
key: "string",
        label: "string",
        required: "boolean",
        uninstallable: "boolean",
        running: "boolean",
        ruleset: "string",
        policy: "string",
        sourcePackage: "HostServiceSourcePackage"
};
typeNames.interfaces["HostServiceSourcePackage"] = {
sourcePackageName: "string",
        description: "string"
};
typeNames.interfaces["HostServiceConfig"] = {
serviceId: "string",
        startupPolicy: "string"
};
typeNames.interfaces["HostServiceInfo"] = {
service: "HostService"
};
typeNames.interfaces["HostSevInfo"] = {
sevState: "string",
        maxSevEsGuests: "number"
};
typeNames.interfaces["HostSgxInfo"] = {
sgxState: "string",
        totalEpcMemory: "number",
        flcMode: "string",
        lePubKeyHash: "string"
};
typeNames.interfaces["HostSharedGpuCapabilities"] = {
vgpu: "string",
        diskSnapshotSupported: "boolean",
        memorySnapshotSupported: "boolean",
        suspendSupported: "boolean",
        migrateSupported: "boolean"
};
typeNames.interfaces["HostSnmpSystemAgentLimits"] = {
maxReadOnlyCommunities: "number",
        maxTrapDestinations: "number",
        maxCommunityLength: "number",
        maxBufferSize: "number",
        capability: "HostSnmpAgentCapability"
};
typeNames.interfaces["HostSnmpConfigSpec"] = {
enabled: "boolean",
        port: "number",
        readOnlyCommunities: "string",
        trapTargets: "HostSnmpDestination",
        option: "KeyValue"
};
typeNames.interfaces["HostSnmpDestination"] = {
hostName: "string",
        port: "number",
        community: "string"
};
typeNames.interfaces["SoftwarePackage"] = {
name: "string",
        version: "string",
        type: "string",
        vendor: "string",
        acceptanceLevel: "string",
        summary: "string",
        description: "string",
        referenceURL: "string",
        creationDate: "Date",
        depends: "Relation",
        conflicts: "Relation",
        replaces: "Relation",
        provides: "string",
        maintenanceModeRequired: "boolean",
        hardwarePlatformsRequired: "string",
        capability: "SoftwarePackageCapability",
        tag: "string",
        payload: "string"
};
typeNames.interfaces["SoftwarePackageCapability"] = {
liveInstallAllowed: "boolean",
        liveRemoveAllowed: "boolean",
        statelessReady: "boolean",
        overlay: "boolean"
};
typeNames.interfaces["Relation"] = {
constraint: "string",
        name: "string",
        version: "string"
};
typeNames.interfaces["HostSriovConfig"] = {
sriovEnabled: "boolean",
        numVirtualFunction: "number"
};
typeNames.interfaces["HostSriovDevicePoolInfo"] = {
key: "string"
};
typeNames.interfaces["HostSriovInfo"] = {
sriovEnabled: "boolean",
        sriovCapable: "boolean",
        sriovActive: "boolean",
        numVirtualFunctionRequested: "number",
        numVirtualFunction: "number",
        maxVirtualFunctionSupported: "number"
};
typeNames.interfaces["HostSriovNetworkDevicePoolInfo"] = {
switchKey: "string",
        switchUuid: "string",
        pnic: "PhysicalNic"
};
typeNames.interfaces["HostSslThumbprintInfo"] = {
principal: "string",
        ownerTag: "string",
        sslThumbprints: "string"
};
typeNames.interfaces["HostStorageArrayTypePolicyOption"] = {
policy: "ElementDescription"
};
typeNames.interfaces["HostStorageDeviceInfo"] = {
hostBusAdapter: "HostHostBusAdapter",
        scsiLun: "ScsiLun",
        scsiTopology: "HostScsiTopology",
        nvmeTopology: "HostNvmeTopology",
        multipathInfo: "HostMultipathInfo",
        plugStoreTopology: "HostPlugStoreTopology",
        softwareInternetScsiEnabled: "boolean"
};
typeNames.interfaces["SystemEventInfo"] = {
recordId: "number",
        when: "string",
        selType: "number",
        message: "string",
        sensorNumber: "number"
};
typeNames.interfaces["HostSystemHealthInfo"] = {
numericSensorInfo: "HostNumericSensorInfo"
};
typeNames.interfaces["HostSystemIdentificationInfo"] = {
identifierValue: "string",
        identifierType: "ElementDescription"
};
typeNames.interfaces["HostSystemInfo"] = {
vendor: "string",
        model: "string",
        uuid: "string",
        otherIdentifyingInfo: "HostSystemIdentificationInfo",
        serialNumber: "string"
};
typeNames.interfaces["HostSystemResourceInfo"] = {
key: "string",
        config: "ResourceConfigSpec",
        child: "HostSystemResourceInfo"
};
typeNames.interfaces["HostSystemSwapConfiguration"] = {
option: "HostSystemSwapConfigurationSystemSwapOption"
};
typeNames.interfaces["HostSystemSwapConfigurationDatastoreOption"] = {
datastore: "string"
};
typeNames.interfaces["HostSystemSwapConfigurationDisabledOption"] = {

};
typeNames.interfaces["HostSystemSwapConfigurationHostCacheOption"] = {

};
typeNames.interfaces["HostSystemSwapConfigurationHostLocalSwapOption"] = {

};
typeNames.interfaces["HostSystemSwapConfigurationSystemSwapOption"] = {
key: "number"
};
typeNames.interfaces["HostTargetTransport"] = {

};
typeNames.interfaces["HostTpmAttestationInfo"] = {
time: "Date",
        status: "HostTpmAttestationInfoAcceptanceStatus",
        message: "LocalizableMessage"
};
typeNames.interfaces["HostTpmAttestationReport"] = {
tpmPcrValues: "HostTpmDigestInfo",
        tpmEvents: "HostTpmEventLogEntry",
        tpmLogReliable: "boolean"
};
typeNames.interfaces["HostTpmDigestInfo"] = {
pcrNumber: "number"
};
typeNames.interfaces["HostTpmEventDetails"] = {
dataHash: "number",
        dataHashMethod: "string"
};
typeNames.interfaces["HostTpmEventLogEntry"] = {
pcrIndex: "number",
        eventDetails: "HostTpmEventDetails"
};
typeNames.interfaces["HostTpmOptionEventDetails"] = {
optionsFileName: "string",
        bootOptions: "number"
};
typeNames.interfaces["HostTpmSoftwareComponentEventDetails"] = {
componentName: "string",
        vibName: "string",
        vibVersion: "string",
        vibVendor: "string"
};
typeNames.interfaces["HostTrustAuthorityAttestationInfo"] = {
attestationStatus: "string",
        serviceId: "string",
        attestedAt: "Date",
        attestedUntil: "Date",
        messages: "LocalizableMessage"
};
typeNames.interfaces["HostUnresolvedVmfsResignatureSpec"] = {
extentDevicePath: "string"
};
typeNames.interfaces["HostUnresolvedVmfsResolutionResult"] = {
spec: "HostUnresolvedVmfsResolutionSpec",
        vmfs: "HostVmfsVolume",
        fault: "MethodFault"
};
typeNames.interfaces["HostUnresolvedVmfsResolutionSpec"] = {
extentDevicePath: "string",
        uuidResolution: "string"
};
typeNames.interfaces["HostUnresolvedVmfsVolume"] = {
extent: "HostUnresolvedVmfsExtent",
        vmfsLabel: "string",
        vmfsUuid: "string",
        totalBlocks: "number",
        resolveStatus: "HostUnresolvedVmfsVolumeResolveStatus"
};
typeNames.interfaces["HostUnresolvedVmfsVolumeResolveStatus"] = {
resolvable: "boolean",
        incompleteExtents: "boolean",
        multipleCopies: "boolean"
};
typeNames.interfaces["HostVFlashResourceConfigurationResult"] = {
devicePath: "string",
        vffs: "HostVffsVolume",
        diskConfigurationResult: "HostDiskConfigurationResult"
};
typeNames.interfaces["HostVMotionConfig"] = {
vmotionNicKey: "string",
        enabled: "boolean"
};
typeNames.interfaces["HostVMotionNetConfig"] = {
candidateVnic: "HostVirtualNic",
        selectedVnic: "HostVirtualNic"
};
typeNames.interfaces["HostVfatVolume"] = {

};
typeNames.interfaces["HostVirtualNic"] = {
device: "string",
        key: "string",
        portgroup: "string",
        spec: "HostVirtualNicSpec",
        port: "HostPortGroupPort"
};
typeNames.interfaces["HostVirtualNicConfig"] = {
changeOperation: "string",
        device: "string",
        portgroup: "string",
        spec: "HostVirtualNicSpec"
};
typeNames.interfaces["HostVirtualNicIpRouteSpec"] = {
ipRouteConfig: "HostIpRouteConfig"
};
typeNames.interfaces["HostVirtualNicOpaqueNetworkSpec"] = {
opaqueNetworkId: "string",
        opaqueNetworkType: "string"
};
typeNames.interfaces["HostVirtualNicSpec"] = {
ip: "HostIpConfig",
        mac: "string",
        distributedVirtualPort: "DistributedVirtualSwitchPortConnection",
        portgroup: "string",
        mtu: "number",
        tsoEnabled: "boolean",
        netStackInstanceKey: "string",
        opaqueNetwork: "HostVirtualNicOpaqueNetworkSpec",
        externalId: "string",
        pinnedPnic: "string",
        ipRouteSpec: "HostVirtualNicIpRouteSpec",
        systemOwned: "boolean"
};
typeNames.interfaces["HostVirtualNicConnection"] = {
portgroup: "string",
        dvPort: "DistributedVirtualSwitchPortConnection",
        opNetwork: "HostVirtualNicOpaqueNetworkSpec"
};
typeNames.interfaces["VirtualNicManagerNetConfig"] = {
nicType: "string",
        multiSelectAllowed: "boolean",
        candidateVnic: "HostVirtualNic",
        selectedVnic: "HostVirtualNic"
};
typeNames.interfaces["HostVirtualNicManagerNicTypeSelection"] = {
vnic: "HostVirtualNicConnection",
        nicType: "string"
};
typeNames.interfaces["HostVirtualNicManagerInfo"] = {
netConfig: "VirtualNicManagerNetConfig"
};
typeNames.interfaces["HostVirtualSwitch"] = {
name: "string",
        key: "string",
        numPorts: "number",
        numPortsAvailable: "number",
        mtu: "number",
        portgroup: "HostPortGroup",
        pnic: "PhysicalNic",
        spec: "HostVirtualSwitchSpec"
};
typeNames.interfaces["HostVirtualSwitchAutoBridge"] = {
excludedNicDevice: "string"
};
typeNames.interfaces["HostVirtualSwitchBeaconConfig"] = {
interval: "number"
};
typeNames.interfaces["HostVirtualSwitchBondBridge"] = {
nicDevice: "string",
        beacon: "HostVirtualSwitchBeaconConfig",
        linkDiscoveryProtocolConfig: "LinkDiscoveryProtocolConfig"
};
typeNames.interfaces["HostVirtualSwitchBridge"] = {

};
typeNames.interfaces["HostVirtualSwitchConfig"] = {
changeOperation: "string",
        name: "string",
        spec: "HostVirtualSwitchSpec"
};
typeNames.interfaces["HostVirtualSwitchSimpleBridge"] = {
nicDevice: "string"
};
typeNames.interfaces["HostVirtualSwitchSpec"] = {
numPorts: "number",
        bridge: "HostVirtualSwitchBridge",
        policy: "HostNetworkPolicy",
        mtu: "number"
};
typeNames.interfaces["HostVmciAccessManagerAccessSpec"] = {
vm: VirtualMachine,
        services: "string",
        mode: "string"
};
typeNames.interfaces["VmfsDatastoreOption"] = {
info: "VmfsDatastoreBaseOption",
        spec: "VmfsDatastoreSpec"
};
typeNames.interfaces["VmfsDatastoreAllExtentOption"] = {

};
typeNames.interfaces["VmfsDatastoreBaseOption"] = {
layout: "HostDiskPartitionLayout",
        partitionFormatChange: "boolean"
};
typeNames.interfaces["VmfsDatastoreMultipleExtentOption"] = {
vmfsExtent: "HostDiskPartitionBlockRange"
};
typeNames.interfaces["VmfsDatastoreSingleExtentOption"] = {
vmfsExtent: "HostDiskPartitionBlockRange"
};
typeNames.interfaces["VmfsDatastoreSpec"] = {
diskUuid: "string"
};
typeNames.interfaces["HostVmfsRescanResult"] = {
host: HostSystem,
        fault: "MethodFault"
};
typeNames.interfaces["HostVsanInternalSystemCmmdsQuery"] = {
type: "string",
        uuid: "string",
        owner: "string"
};
typeNames.interfaces["HostVsanInternalSystemDeleteVsanObjectsResult"] = {
uuid: "string",
        success: "boolean",
        failureReason: "LocalizableMessage"
};
typeNames.interfaces["VsanNewPolicyBatch"] = {
size: "number",
        policy: "string"
};
typeNames.interfaces["VsanPolicyChangeBatch"] = {
uuid: "string",
        policy: "string"
};
typeNames.interfaces["VsanPolicyCost"] = {
changeDataSize: "number",
        currentDataSize: "number",
        tempDataSize: "number",
        copyDataSize: "number",
        changeFlashReadCacheSize: "number",
        currentFlashReadCacheSize: "number",
        currentDiskSpaceToAddressSpaceRatio: "number",
        diskSpaceToAddressSpaceRatio: "number"
};
typeNames.interfaces["VsanPolicySatisfiability"] = {
uuid: "string",
        isSatisfiable: "boolean",
        reason: "LocalizableMessage",
        cost: "VsanPolicyCost"
};
typeNames.interfaces["HostVsanInternalSystemVsanObjectOperationResult"] = {
uuid: "string",
        failureReason: "LocalizableMessage"
};
typeNames.interfaces["HostVsanInternalSystemVsanPhysicalDiskDiagnosticsResult"] = {
diskUuid: "string",
        success: "boolean",
        failureReason: "string"
};
typeNames.interfaces["HostVvolVolume"] = {
scId: "string",
        hostPE: "VVolHostPE",
        vasaProviderInfo: "VimVasaProviderInfo",
        storageArray: "VASAStorageArray"
};
typeNames.interfaces["VVolHostPE"] = {
key: HostSystem,
        protocolEndpoint: "HostProtocolEndpoint"
};
typeNames.interfaces["HostVvolVolumeSpecification"] = {
maxSizeInMB: "number",
        volumeName: "string",
        vasaProviderInfo: "VimVasaProviderInfo",
        storageArray: "VASAStorageArray",
        uuid: "string"
};
typeNames.interfaces["NetDhcpConfigInfo"] = {
ipv6: "NetDhcpConfigInfoDhcpOptions",
        ipv4: "NetDhcpConfigInfoDhcpOptions"
};
typeNames.interfaces["NetDhcpConfigInfoDhcpOptions"] = {
enable: "boolean",
        config: "KeyValue"
};
typeNames.interfaces["NetDhcpConfigSpec"] = {
ipv6: "NetDhcpConfigSpecDhcpOptionsSpec",
        ipv4: "NetDhcpConfigSpecDhcpOptionsSpec"
};
typeNames.interfaces["NetDhcpConfigSpecDhcpOptionsSpec"] = {
enable: "boolean",
        config: "KeyValue",
        operation: "string"
};
typeNames.interfaces["NetDnsConfigInfo"] = {
dhcp: "boolean",
        hostName: "string",
        domainName: "string",
        ipAddress: "string",
        searchDomain: "string"
};
typeNames.interfaces["NetDnsConfigSpec"] = {
dhcp: "boolean",
        hostName: "string",
        domainName: "string",
        ipAddress: "string",
        searchDomain: "string"
};
typeNames.interfaces["NetIpConfigInfo"] = {
ipAddress: "NetIpConfigInfoIpAddress",
        dhcp: "NetDhcpConfigInfo",
        autoConfigurationEnabled: "boolean"
};
typeNames.interfaces["NetIpConfigInfoIpAddress"] = {
ipAddress: "string",
        prefixLength: "number",
        origin: "string",
        state: "string",
        lifetime: "Date"
};
typeNames.interfaces["NetIpConfigSpec"] = {
ipAddress: "NetIpConfigSpecIpAddressSpec",
        dhcp: "NetDhcpConfigSpec",
        autoConfigurationEnabled: "boolean"
};
typeNames.interfaces["NetIpConfigSpecIpAddressSpec"] = {
ipAddress: "string",
        prefixLength: "number",
        operation: "string"
};
typeNames.interfaces["NetIpRouteConfigInfo"] = {
ipRoute: "NetIpRouteConfigInfoIpRoute"
};
typeNames.interfaces["NetIpRouteConfigInfoGateway"] = {
ipAddress: "string",
        device: "string"
};
typeNames.interfaces["NetIpRouteConfigInfoIpRoute"] = {
network: "string",
        prefixLength: "number",
        gateway: "NetIpRouteConfigInfoGateway"
};
typeNames.interfaces["NetIpRouteConfigSpec"] = {
ipRoute: "NetIpRouteConfigSpecIpRouteSpec"
};
typeNames.interfaces["NetIpRouteConfigSpecGatewaySpec"] = {
ipAddress: "string",
        device: "string"
};
typeNames.interfaces["NetIpRouteConfigSpecIpRouteSpec"] = {
network: "string",
        prefixLength: "number",
        gateway: "NetIpRouteConfigSpecGatewaySpec",
        operation: "string"
};
typeNames.interfaces["NetIpStackInfo"] = {
neighbor: "NetIpStackInfoNetToMedia",
        defaultRouter: "NetIpStackInfoDefaultRouter"
};
typeNames.interfaces["NetIpStackInfoDefaultRouter"] = {
ipAddress: "string",
        device: "string",
        lifetime: "Date",
        preference: "string"
};
typeNames.interfaces["NetIpStackInfoNetToMedia"] = {
ipAddress: "string",
        physicalAddress: "string",
        device: "string",
        type: "string"
};
typeNames.interfaces["NetBIOSConfigInfo"] = {
mode: "string"
};
typeNames.interfaces["WinNetBIOSConfigInfo"] = {
primaryWINS: "string",
        secondaryWINS: "string"
};
typeNames.interfaces["ArrayUpdateSpec"] = {
operation: "ArrayUpdateOperation",
        removeKey: "any"
};
typeNames.interfaces["OptionDef"] = {
optionType: "OptionType"
};
typeNames.interfaces["OptionType"] = {
valueIsReadonly: "boolean"
};
typeNames.interfaces["OptionValue"] = {
key: "string",
        value: "any"
};
typeNames.interfaces["StringOption"] = {
defaultValue: "string",
        validCharacters: "string"
};
typeNames.interfaces["ApplyProfile"] = {
enabled: "boolean",
        policy: "ProfilePolicy",
        profileTypeName: "string",
        profileVersion: "string",
        property: "ProfileApplyProfileProperty",
        favorite: "boolean",
        toBeMerged: "boolean",
        toReplaceWith: "boolean",
        toBeDeleted: "boolean",
        copyEnableStatus: "boolean",
        hidden: "boolean"
};
typeNames.interfaces["ProfileApplyProfileElement"] = {
key: "string"
};
typeNames.interfaces["ProfileApplyProfileProperty"] = {
propertyName: "string",
        array: "boolean",
        profile: "ApplyProfile"
};
typeNames.interfaces["ComplianceLocator"] = {
expressionName: "string",
        applyPath: "ProfilePropertyPath"
};
typeNames.interfaces["ComplianceProfile"] = {
expression: "ProfileExpression",
        rootExpression: "string"
};
typeNames.interfaces["ComplianceResult"] = {
profile: Profile,
        complianceStatus: "string",
        entity: ManagedEntity,
        checkTime: "Date",
        failure: "ComplianceFailure"
};
typeNames.interfaces["ComplianceFailure"] = {
failureType: "string",
        message: "LocalizableMessage",
        expressionName: "string",
        failureValues: "ComplianceFailureComplianceFailureValues"
};
typeNames.interfaces["ComplianceFailureComplianceFailureValues"] = {
comparisonIdentifier: "string",
        profileInstance: "string",
        hostValue: "any",
        profileValue: "any"
};
typeNames.interfaces["ProfileDeferredPolicyOptionParameter"] = {
inputPath: "ProfilePropertyPath",
        parameter: "KeyAnyValue"
};
typeNames.interfaces["ProfileExpression"] = {
id: "string",
        displayName: "string",
        negated: "boolean"
};
typeNames.interfaces["ProfileExpressionMetadata"] = {
expressionId: "ExtendedElementDescription",
        parameter: "ProfileParameterMetadata"
};
typeNames.interfaces["ProfileParameterMetadata"] = {
id: "ExtendedElementDescription",
        type: "string",
        optional: "boolean",
        defaultValue: "any",
        hidden: "boolean",
        securitySensitive: "boolean",
        readOnly: "boolean",
        parameterRelations: "ProfileParameterMetadataParameterRelationMetadata"
};
typeNames.interfaces["ProfileParameterMetadataParameterRelationMetadata"] = {
relationTypes: "string",
        values: "any",
        path: "ProfilePropertyPath",
        minCount: "number",
        maxCount: "number"
};
typeNames.interfaces["ProfilePolicy"] = {
id: "string",
        policyOption: "PolicyOption"
};
typeNames.interfaces["ProfilePolicyMetadata"] = {
id: "ExtendedElementDescription",
        possibleOption: "ProfilePolicyOptionMetadata"
};
typeNames.interfaces["PolicyOption"] = {
id: "string",
        parameter: "KeyAnyValue"
};
typeNames.interfaces["ProfilePolicyOptionMetadata"] = {
id: "ExtendedElementDescription",
        parameter: "ProfileParameterMetadata"
};
typeNames.interfaces["ProfileConfigInfo"] = {
name: "string",
        annotation: "string",
        enabled: "boolean"
};
typeNames.interfaces["ProfileCreateSpec"] = {
name: "string",
        annotation: "string",
        enabled: "boolean"
};
typeNames.interfaces["ProfileDescription"] = {
section: "ProfileDescriptionSection"
};
typeNames.interfaces["ProfileDescriptionSection"] = {
description: "ExtendedElementDescription",
        message: "LocalizableMessage"
};
typeNames.interfaces["ProfileSerializedCreateSpec"] = {
profileConfigString: "string"
};
typeNames.interfaces["ProfileMetadata"] = {
key: "string",
        profileTypeName: "string",
        description: "ExtendedDescription",
        sortSpec: "ProfileMetadataProfileSortSpec",
        profileCategory: "string",
        profileComponent: "string",
        operationMessages: "ProfileMetadataProfileOperationMessage"
};
typeNames.interfaces["ProfileMetadataProfileOperationMessage"] = {
operationName: "string",
        message: "LocalizableMessage"
};
typeNames.interfaces["ProfileMetadataProfileSortSpec"] = {
policyId: "string",
        parameter: "string"
};
typeNames.interfaces["ProfilePropertyPath"] = {
profilePath: "string",
        policyId: "string",
        parameterId: "string",
        policyOptionId: "string"
};
typeNames.interfaces["ProfileProfileStructure"] = {
profileTypeName: "string",
        child: "ProfileProfileStructureProperty"
};
typeNames.interfaces["ProfileProfileStructureProperty"] = {
propertyName: "string",
        array: "boolean",
        element: "ProfileProfileStructure"
};
typeNames.interfaces["ProfileSimpleExpression"] = {
expressionType: "string",
        parameter: "KeyAnyValue"
};
typeNames.interfaces["UserInputRequiredParameterMetadata"] = {
userInputParameter: "ProfileParameterMetadata"
};
typeNames.interfaces["ClusterProfileCompleteConfigSpec"] = {
complyProfile: "ComplianceProfile"
};
typeNames.interfaces["ClusterProfileConfigInfo"] = {
complyProfile: "ComplianceProfile"
};
typeNames.interfaces["ClusterProfileConfigServiceCreateSpec"] = {
serviceType: "string"
};
typeNames.interfaces["ClusterProfileConfigSpec"] = {

};
typeNames.interfaces["ClusterProfileCreateSpec"] = {

};
typeNames.interfaces["ActiveDirectoryProfile"] = {

};
typeNames.interfaces["AnswerFile"] = {
userInput: "ProfileDeferredPolicyOptionParameter",
        createdTime: "Date",
        modifiedTime: "Date"
};
typeNames.interfaces["AnswerFileStatusResult"] = {
checkedTime: "Date",
        host: HostSystem,
        status: "string",
        error: "AnswerFileStatusError"
};
typeNames.interfaces["AnswerFileStatusError"] = {
userInputPath: "ProfilePropertyPath",
        errMsg: "LocalizableMessage"
};
typeNames.interfaces["AuthenticationProfile"] = {
activeDirectory: "ActiveDirectoryProfile"
};
typeNames.interfaces["DateTimeProfile"] = {

};
typeNames.interfaces["DvsProfile"] = {
key: "string",
        name: "string",
        uplink: "PnicUplinkProfile"
};
typeNames.interfaces["DvsVNicProfile"] = {
key: "string",
        ipConfig: "IpAddressProfile"
};
typeNames.interfaces["ProfileExecuteResult"] = {
status: "string",
        configSpec: "HostConfigSpec",
        inapplicablePath: "string",
        requireInput: "ProfileDeferredPolicyOptionParameter",
        error: "ProfileExecuteError"
};
typeNames.interfaces["ProfileExecuteError"] = {
path: "ProfilePropertyPath",
        message: "LocalizableMessage"
};
typeNames.interfaces["FirewallProfile"] = {
ruleset: "FirewallProfileRulesetProfile"
};
typeNames.interfaces["FirewallProfileRulesetProfile"] = {
key: "string"
};
typeNames.interfaces["HostApplyProfile"] = {
memory: "HostMemoryProfile",
        storage: "StorageProfile",
        network: "NetworkProfile",
        datetime: "DateTimeProfile",
        firewall: "FirewallProfile",
        security: "SecurityProfile",
        service: "ServiceProfile",
        option: "OptionProfile",
        userAccount: "UserProfile",
        usergroupAccount: "UserGroupProfile",
        authentication: "AuthenticationProfile"
};
typeNames.interfaces["HostMemoryProfile"] = {

};
typeNames.interfaces["HostSpecification"] = {
createdTime: "Date",
        lastModified: "Date",
        host: HostSystem,
        subSpecs: "HostSubSpecification",
        changeID: "string"
};
typeNames.interfaces["HostSubSpecification"] = {
name: "string",
        createdTime: "Date",
        data: "number",
        binaryData: "Buffer"
};
typeNames.interfaces["IpAddressProfile"] = {

};
typeNames.interfaces["IpRouteProfile"] = {
staticRoute: "StaticRouteProfile"
};
typeNames.interfaces["NasStorageProfile"] = {
key: "string"
};
typeNames.interfaces["NetworkPolicyProfile"] = {

};
typeNames.interfaces["NetworkProfile"] = {
vswitch: "VirtualSwitchProfile",
        vmPortGroup: "VmPortGroupProfile",
        hostPortGroup: "HostPortGroupProfile",
        serviceConsolePortGroup: "ServiceConsolePortGroupProfile",
        dnsConfig: "NetworkProfileDnsConfigProfile",
        ipRouteConfig: "IpRouteProfile",
        consoleIpRouteConfig: "IpRouteProfile",
        pnic: "PhysicalNicProfile",
        dvswitch: "DvsProfile",
        dvsServiceConsoleNic: "DvsServiceConsoleVNicProfile",
        dvsHostNic: "DvsHostVNicProfile",
        nsxHostNic: "NsxHostVNicProfile",
        netStackInstance: "NetStackInstanceProfile",
        opaqueSwitch: "OpaqueSwitchProfile"
};
typeNames.interfaces["NetworkProfileDnsConfigProfile"] = {

};
typeNames.interfaces["NsxHostVNicProfile"] = {
key: "string",
        ipConfig: "IpAddressProfile"
};
typeNames.interfaces["OpaqueSwitchProfile"] = {

};
typeNames.interfaces["OptionProfile"] = {
key: "string"
};
typeNames.interfaces["PermissionProfile"] = {
key: "string"
};
typeNames.interfaces["PhysicalNicProfile"] = {
key: "string"
};
typeNames.interfaces["PnicUplinkProfile"] = {
key: "string"
};
typeNames.interfaces["PortGroupProfile"] = {
key: "string",
        name: "string",
        vlan: "VlanProfile",
        vswitch: "VirtualSwitchSelectionProfile",
        networkPolicy: "NetworkPolicyProfile"
};
typeNames.interfaces["VirtualSwitchSelectionProfile"] = {

};
typeNames.interfaces["VlanProfile"] = {

};
typeNames.interfaces["SecurityProfile"] = {
permission: "PermissionProfile"
};
typeNames.interfaces["ServiceConsolePortGroupProfile"] = {
ipConfig: "IpAddressProfile"
};
typeNames.interfaces["ServiceProfile"] = {
key: "string"
};
typeNames.interfaces["StaticRouteProfile"] = {
key: "string"
};
typeNames.interfaces["StorageProfile"] = {
nasStorage: "NasStorageProfile"
};
typeNames.interfaces["UserGroupProfile"] = {
key: "string"
};
typeNames.interfaces["UserProfile"] = {
key: "string"
};
typeNames.interfaces["VirtualSwitchProfile"] = {
key: "string",
        name: "string",
        link: "LinkProfile",
        numPorts: "NumPortsProfile",
        networkPolicy: "NetworkPolicyProfile"
};
typeNames.interfaces["LinkProfile"] = {

};
typeNames.interfaces["NumPortsProfile"] = {

};
typeNames.interfaces["VmPortGroupProfile"] = {

};
typeNames.interfaces["ScheduledTaskDescription"] = {
action: "TypeDescription",
        schedulerInfo: "ScheduledTaskDetail",
        state: "ElementDescription",
        dayOfWeek: "ElementDescription",
        weekOfMonth: "ElementDescription"
};
typeNames.interfaces["ScheduledTaskDetail"] = {
frequency: "string"
};
typeNames.interfaces["ScheduledTaskSpec"] = {
name: "string",
        description: "string",
        enabled: "boolean",
        scheduler: "TaskScheduler",
        action: "Action",
        notification: "string"
};
typeNames.interfaces["TaskScheduler"] = {
activeTime: "Date",
        expireTime: "Date"
};
typeNames.interfaces["ApplyStorageRecommendationResult"] = {
vm: VirtualMachine
};
typeNames.interfaces["StorageDrsAutomationConfig"] = {
spaceLoadBalanceAutomationMode: "string",
        ioLoadBalanceAutomationMode: "string",
        ruleEnforcementAutomationMode: "string",
        policyEnforcementAutomationMode: "string",
        vmEvacuationAutomationMode: "string"
};
typeNames.interfaces["StorageDrsConfigInfo"] = {
podConfig: "StorageDrsPodConfigInfo",
        vmConfig: "StorageDrsVmConfigInfo"
};
typeNames.interfaces["StorageDrsConfigSpec"] = {
podConfigSpec: "StorageDrsPodConfigSpec",
        vmConfigSpec: "StorageDrsVmConfigSpec"
};
typeNames.interfaces["HbrDiskMigrationAction"] = {
collectionId: "string",
        collectionName: "string",
        diskIds: "string",
        source: Datastore,
        destination: Datastore,
        sizeTransferred: "number",
        spaceUtilSrcBefore: "number",
        spaceUtilDstBefore: "number",
        spaceUtilSrcAfter: "number",
        spaceUtilDstAfter: "number",
        ioLatencySrcBefore: "number",
        ioLatencyDstBefore: "number"
};
typeNames.interfaces["StorageDrsIoLoadBalanceConfig"] = {
reservablePercentThreshold: "number",
        reservableIopsThreshold: "number",
        reservableThresholdMode: "string",
        ioLatencyThreshold: "number",
        ioLoadImbalanceThreshold: "number"
};
typeNames.interfaces["StorageDrsOptionSpec"] = {
option: "OptionValue"
};
typeNames.interfaces["PlacementAffinityRule"] = {
ruleType: "string",
        ruleScope: "string",
        vms: VirtualMachine,
        keys: "string"
};
typeNames.interfaces["PlacementRankResult"] = {
key: "string",
        candidate: ClusterComputeResource,
        reservedSpaceMB: "number",
        usedSpaceMB: "number",
        totalSpaceMB: "number",
        utilization: "number",
        faults: "MethodFault"
};
typeNames.interfaces["PlacementRankSpec"] = {
specs: "PlacementSpec",
        clusters: ClusterComputeResource,
        rules: "PlacementAffinityRule",
        placementRankByVm: "StorageDrsPlacementRankVmSpec"
};
typeNames.interfaces["StorageDrsPlacementRankVmSpec"] = {
vmPlacementSpec: "PlacementSpec",
        vmClusters: ClusterComputeResource
};
typeNames.interfaces["StorageDrsPodConfigInfo"] = {
enabled: "boolean",
        ioLoadBalanceEnabled: "boolean",
        defaultVmBehavior: "string",
        loadBalanceInterval: "number",
        defaultIntraVmAffinity: "boolean",
        spaceLoadBalanceConfig: "StorageDrsSpaceLoadBalanceConfig",
        ioLoadBalanceConfig: "StorageDrsIoLoadBalanceConfig",
        automationOverrides: "StorageDrsAutomationConfig",
        rule: "ClusterRuleInfo",
        option: "OptionValue"
};
typeNames.interfaces["StorageDrsPodConfigSpec"] = {
enabled: "boolean",
        ioLoadBalanceEnabled: "boolean",
        defaultVmBehavior: "string",
        loadBalanceInterval: "number",
        defaultIntraVmAffinity: "boolean",
        spaceLoadBalanceConfig: "StorageDrsSpaceLoadBalanceConfig",
        ioLoadBalanceConfig: "StorageDrsIoLoadBalanceConfig",
        automationOverrides: "StorageDrsAutomationConfig",
        rule: "ClusterRuleSpec",
        option: "StorageDrsOptionSpec"
};
typeNames.interfaces["StorageDrsSpaceLoadBalanceConfig"] = {
spaceThresholdMode: "string",
        spaceUtilizationThreshold: "number",
        freeSpaceThresholdGB: "number",
        minSpaceUtilizationDifference: "number"
};
typeNames.interfaces["StorageMigrationAction"] = {
vm: VirtualMachine,
        relocateSpec: "VirtualMachineRelocateSpec",
        source: Datastore,
        destination: Datastore,
        sizeTransferred: "number",
        spaceUtilSrcBefore: "number",
        spaceUtilDstBefore: "number",
        spaceUtilSrcAfter: "number",
        spaceUtilDstAfter: "number",
        ioLatencySrcBefore: "number",
        ioLatencyDstBefore: "number"
};
typeNames.interfaces["StoragePlacementAction"] = {
vm: VirtualMachine,
        relocateSpec: "VirtualMachineRelocateSpec",
        destination: Datastore,
        spaceUtilBefore: "number",
        spaceDemandBefore: "number",
        spaceUtilAfter: "number",
        spaceDemandAfter: "number",
        ioLatencyBefore: "number"
};
typeNames.interfaces["StoragePlacementResult"] = {
recommendations: "ClusterRecommendation",
        drsFault: "ClusterDrsFaults",
        task: Task
};
typeNames.interfaces["StorageDrsVmConfigInfo"] = {
vm: VirtualMachine,
        enabled: "boolean",
        behavior: "string",
        intraVmAffinity: "boolean",
        intraVmAntiAffinity: "VirtualDiskAntiAffinityRuleSpec",
        virtualDiskRules: "VirtualDiskRuleSpec"
};
typeNames.interfaces["StorageDrsVmConfigSpec"] = {
info: "StorageDrsVmConfigInfo"
};
typeNames.interfaces["VAppCloneSpec"] = {
location: Datastore,
        host: HostSystem,
        resourceSpec: "ResourceConfigSpec",
        vmFolder: Folder,
        networkMapping: "VAppCloneSpecNetworkMappingPair",
        property: "KeyValue",
        resourceMapping: "VAppCloneSpecResourceMap",
        provisioning: "string"
};
typeNames.interfaces["VAppCloneSpecNetworkMappingPair"] = {
source: Network,
        destination: Network
};
typeNames.interfaces["VAppCloneSpecResourceMap"] = {
source: ManagedEntity,
        parent: ResourcePool,
        resourceSpec: "ResourceConfigSpec",
        location: Datastore
};
typeNames.interfaces["VAppEntityConfigInfo"] = {
key: ManagedEntity,
        tag: "string",
        startOrder: "number",
        startDelay: "number",
        waitingForGuest: "boolean",
        startAction: "string",
        stopDelay: "number",
        stopAction: "string",
        destroyWithParent: "boolean"
};
typeNames.interfaces["VAppIPAssignmentInfo"] = {
supportedAllocationScheme: "string",
        ipAllocationPolicy: "string",
        supportedIpProtocol: "string",
        ipProtocol: "string"
};
typeNames.interfaces["IpPool"] = {
id: "number",
        name: "string",
        ipv4Config: "IpPoolIpPoolConfigInfo",
        ipv6Config: "IpPoolIpPoolConfigInfo",
        dnsDomain: "string",
        dnsSearchPath: "string",
        hostPrefix: "string",
        httpProxy: "string",
        networkAssociation: "IpPoolAssociation",
        availableIpv4Addresses: "number",
        availableIpv6Addresses: "number",
        allocatedIpv4Addresses: "number",
        allocatedIpv6Addresses: "number"
};
typeNames.interfaces["IpPoolAssociation"] = {
network: Network,
        networkName: "string"
};
typeNames.interfaces["IpPoolIpPoolConfigInfo"] = {
subnetAddress: "string",
        netmask: "string",
        gateway: "string",
        range: "string",
        dns: "string",
        dhcpServerAvailable: "boolean",
        ipPoolEnabled: "boolean"
};
typeNames.interfaces["VAppOvfSectionInfo"] = {
key: "number",
        namespace: "string",
        type: "string",
        atEnvelopeLevel: "boolean",
        contents: "string"
};
typeNames.interfaces["VAppOvfSectionSpec"] = {
info: "VAppOvfSectionInfo"
};
typeNames.interfaces["VAppProductInfo"] = {
key: "number",
        classId: "string",
        instanceId: "string",
        name: "string",
        vendor: "string",
        version: "string",
        fullVersion: "string",
        vendorUrl: "string",
        productUrl: "string",
        appUrl: "string"
};
typeNames.interfaces["VAppProductSpec"] = {
info: "VAppProductInfo"
};
typeNames.interfaces["VAppPropertyInfo"] = {
key: "number",
        classId: "string",
        instanceId: "string",
        id: "string",
        category: "string",
        label: "string",
        type: "string",
        typeReference: "string",
        userConfigurable: "boolean",
        defaultValue: "string",
        value: "string",
        description: "string"
};
typeNames.interfaces["VAppPropertySpec"] = {
info: "VAppPropertyInfo"
};
typeNames.interfaces["VmConfigInfo"] = {
product: "VAppProductInfo",
        property: "VAppPropertyInfo",
        ipAssignment: "VAppIPAssignmentInfo",
        eula: "string",
        ovfSection: "VAppOvfSectionInfo",
        ovfEnvironmentTransport: "string",
        installBootRequired: "boolean",
        installBootStopDelay: "number"
};
typeNames.interfaces["VmConfigSpec"] = {
product: "VAppProductSpec",
        property: "VAppPropertySpec",
        ipAssignment: "VAppIPAssignmentInfo",
        eula: "string",
        ovfSection: "VAppOvfSectionSpec",
        ovfEnvironmentTransport: "string",
        installBootRequired: "boolean",
        installBootStopDelay: "number"
};
typeNames.interfaces["ClusterNetworkConfigSpec"] = {
networkPortGroup: Network,
        ipSettings: "CustomizationIPSettings"
};
typeNames.interfaces["FailoverNodeInfo"] = {
clusterIpSettings: "CustomizationIPSettings",
        failoverIp: "CustomizationIPSettings",
        biosUuid: "string"
};
typeNames.interfaces["NodeDeploymentSpec"] = {
esxHost: HostSystem,
        datastore: Datastore,
        publicNetworkPortGroup: Network,
        clusterNetworkPortGroup: Network,
        folder: Folder,
        resourcePool: ResourcePool,
        managementVc: "ServiceLocator",
        nodeName: "string",
        ipSettings: "CustomizationIPSettings"
};
typeNames.interfaces["NodeNetworkSpec"] = {
ipSettings: "CustomizationIPSettings"
};
typeNames.interfaces["PassiveNodeDeploymentSpec"] = {
failoverIpSettings: "CustomizationIPSettings"
};
typeNames.interfaces["PassiveNodeNetworkSpec"] = {
failoverIpSettings: "CustomizationIPSettings"
};
typeNames.interfaces["SourceNodeSpec"] = {
managementVc: "ServiceLocator",
        activeVc: VirtualMachine
};
typeNames.interfaces["VchaClusterConfigInfo"] = {
failoverNodeInfo1: "FailoverNodeInfo",
        failoverNodeInfo2: "FailoverNodeInfo",
        witnessNodeInfo: "WitnessNodeInfo",
        state: "string"
};
typeNames.interfaces["VchaClusterConfigSpec"] = {
passiveIp: "string",
        witnessIp: "string"
};
typeNames.interfaces["VchaClusterDeploymentSpec"] = {
passiveDeploymentSpec: "PassiveNodeDeploymentSpec",
        witnessDeploymentSpec: "NodeDeploymentSpec",
        activeVcSpec: "SourceNodeSpec",
        activeVcNetworkConfig: "ClusterNetworkConfigSpec"
};
typeNames.interfaces["VchaClusterNetworkSpec"] = {
witnessNetworkSpec: "NodeNetworkSpec",
        passiveNetworkSpec: "PassiveNodeNetworkSpec"
};
typeNames.interfaces["WitnessNodeInfo"] = {
ipSettings: "CustomizationIPSettings",
        biosUuid: "string"
};
typeNames.interfaces["VchaClusterHealth"] = {
runtimeInfo: "VchaClusterRuntimeInfo",
        healthMessages: "LocalizableMessage",
        additionalInformation: "LocalizableMessage"
};
typeNames.interfaces["VchaClusterRuntimeInfo"] = {
clusterState: "string",
        nodeInfo: "VchaNodeRuntimeInfo",
        clusterMode: "string"
};
typeNames.interfaces["VchaNodeRuntimeInfo"] = {
nodeState: "string",
        nodeRole: "string",
        nodeIp: "string"
};
typeNames.interfaces["VirtualMachineAffinityInfo"] = {
affinitySet: "number"
};
typeNames.interfaces["VirtualMachineBootOptions"] = {
bootDelay: "number",
        enterBIOSSetup: "boolean",
        efiSecureBootEnabled: "boolean",
        bootRetryEnabled: "boolean",
        bootRetryDelay: "number",
        bootOrder: "VirtualMachineBootOptionsBootableDevice",
        networkBootProtocol: "string"
};
typeNames.interfaces["VirtualMachineBootOptionsBootableCdromDevice"] = {

};
typeNames.interfaces["VirtualMachineBootOptionsBootableDevice"] = {

};
typeNames.interfaces["VirtualMachineBootOptionsBootableDiskDevice"] = {
deviceKey: "number"
};
typeNames.interfaces["VirtualMachineBootOptionsBootableEthernetDevice"] = {
deviceKey: "number"
};
typeNames.interfaces["VirtualMachineBootOptionsBootableFloppyDevice"] = {

};
typeNames.interfaces["VirtualMachineCapability"] = {
snapshotOperationsSupported: "boolean",
        multipleSnapshotsSupported: "boolean",
        snapshotConfigSupported: "boolean",
        poweredOffSnapshotsSupported: "boolean",
        memorySnapshotsSupported: "boolean",
        revertToSnapshotSupported: "boolean",
        quiescedSnapshotsSupported: "boolean",
        disableSnapshotsSupported: "boolean",
        lockSnapshotsSupported: "boolean",
        consolePreferencesSupported: "boolean",
        cpuFeatureMaskSupported: "boolean",
        s1AcpiManagementSupported: "boolean",
        settingScreenResolutionSupported: "boolean",
        toolsAutoUpdateSupported: "boolean",
        vmNpivWwnSupported: "boolean",
        npivWwnOnNonRdmVmSupported: "boolean",
        vmNpivWwnDisableSupported: "boolean",
        vmNpivWwnUpdateSupported: "boolean",
        swapPlacementSupported: "boolean",
        toolsSyncTimeSupported: "boolean",
        virtualMmuUsageSupported: "boolean",
        diskSharesSupported: "boolean",
        bootOptionsSupported: "boolean",
        bootRetryOptionsSupported: "boolean",
        settingVideoRamSizeSupported: "boolean",
        settingDisplayTopologySupported: "boolean",
        recordReplaySupported: "boolean",
        changeTrackingSupported: "boolean",
        multipleCoresPerSocketSupported: "boolean",
        hostBasedReplicationSupported: "boolean",
        guestAutoLockSupported: "boolean",
        memoryReservationLockSupported: "boolean",
        featureRequirementSupported: "boolean",
        poweredOnMonitorTypeChangeSupported: "boolean",
        seSparseDiskSupported: "boolean",
        nestedHVSupported: "boolean",
        vPMCSupported: "boolean",
        secureBootSupported: "boolean",
        perVmEvcSupported: "boolean",
        virtualMmuUsageIgnored: "boolean",
        virtualExecUsageIgnored: "boolean",
        diskOnlySnapshotOnSuspendedVMSupported: "boolean",
        toolsSyncTimeAllowSupported: "boolean",
        sevSupported: "boolean"
};
typeNames.interfaces["VirtualMachineCloneSpec"] = {
location: "VirtualMachineRelocateSpec",
        template: "boolean",
        config: "VirtualMachineConfigSpec",
        customization: "CustomizationSpec",
        powerOn: "boolean",
        snapshot: VirtualMachineSnapshot,
        memory: "boolean"
};
typeNames.interfaces["VirtualMachineConfigInfo"] = {
changeVersion: "string",
        modified: "Date",
        name: "string",
        guestFullName: "string",
        version: "string",
        uuid: "string",
        createDate: "Date",
        instanceUuid: "string",
        npivNodeWorldWideName: "number",
        npivPortWorldWideName: "number",
        npivWorldWideNameType: "string",
        npivDesiredNodeWwns: "number",
        npivDesiredPortWwns: "number",
        npivTemporaryDisabled: "boolean",
        npivOnNonRdmDisks: "boolean",
        locationId: "string",
        template: "boolean",
        guestId: "string",
        alternateGuestName: "string",
        annotation: "string",
        files: "VirtualMachineFileInfo",
        tools: "ToolsConfigInfo",
        flags: "VirtualMachineFlagInfo",
        consolePreferences: "VirtualMachineConsolePreferences",
        defaultPowerOps: "VirtualMachineDefaultPowerOpInfo",
        hardware: "VirtualHardware",
        vcpuConfig: "VirtualMachineVcpuConfig",
        cpuAllocation: "ResourceAllocationInfo",
        memoryAllocation: "ResourceAllocationInfo",
        latencySensitivity: "LatencySensitivity",
        memoryHotAddEnabled: "boolean",
        cpuHotAddEnabled: "boolean",
        cpuHotRemoveEnabled: "boolean",
        hotPlugMemoryLimit: "number",
        hotPlugMemoryIncrementSize: "number",
        cpuAffinity: "VirtualMachineAffinityInfo",
        memoryAffinity: "VirtualMachineAffinityInfo",
        networkShaper: "VirtualMachineNetworkShaperInfo",
        extraConfig: "OptionValue",
        cpuFeatureMask: "HostCpuIdInfo",
        datastoreUrl: "VirtualMachineConfigInfoDatastoreUrlPair",
        swapPlacement: "string",
        bootOptions: "VirtualMachineBootOptions",
        ftInfo: "FaultToleranceConfigInfo",
        repConfig: "ReplicationConfigSpec",
        vAppConfig: "VmConfigInfo",
        vAssertsEnabled: "boolean",
        changeTrackingEnabled: "boolean",
        firmware: "string",
        maxMksConnections: "number",
        guestAutoLockEnabled: "boolean",
        managedBy: "ManagedByInfo",
        memoryReservationLockedToMax: "boolean",
        initialOverhead: "VirtualMachineConfigInfoOverheadInfo",
        nestedHVEnabled: "boolean",
        vPMCEnabled: "boolean",
        scheduledHardwareUpgradeInfo: "ScheduledHardwareUpgradeInfo",
        forkConfigInfo: "VirtualMachineForkConfigInfo",
        vFlashCacheReservation: "number",
        vmxConfigChecksum: "Buffer",
        messageBusTunnelEnabled: "boolean",
        vmStorageObjectId: "string",
        swapStorageObjectId: "string",
        keyId: "CryptoKeyId",
        guestIntegrityInfo: "VirtualMachineGuestIntegrityInfo",
        migrateEncryption: "string",
        sgxInfo: "VirtualMachineSgxInfo",
        contentLibItemInfo: "VirtualMachineContentLibraryItemInfo",
        guestMonitoringModeInfo: "VirtualMachineGuestMonitoringModeInfo",
        sevEnabled: "boolean"
};
typeNames.interfaces["VirtualMachineConfigInfoDatastoreUrlPair"] = {
name: "string",
        url: "string"
};
typeNames.interfaces["VirtualMachineConfigInfoOverheadInfo"] = {
initialMemoryReservation: "number",
        initialSwapReservation: "number"
};
typeNames.interfaces["VirtualMachineConfigOption"] = {
version: "string",
        description: "string",
        guestOSDescriptor: "GuestOsDescriptor",
        guestOSDefaultIndex: "number",
        hardwareOptions: "VirtualHardwareOption",
        capabilities: "VirtualMachineCapability",
        datastore: "DatastoreOption",
        defaultDevice: "VirtualDevice",
        supportedMonitorType: "string",
        supportedOvfEnvironmentTransport: "string",
        supportedOvfInstallTransport: "string",
        propertyRelations: "VirtualMachinePropertyRelation"
};
typeNames.interfaces["VirtualMachineConfigOptionDescriptor"] = {
key: "string",
        description: "string",
        host: HostSystem,
        createSupported: "boolean",
        defaultConfigOption: "boolean",
        runSupported: "boolean",
        upgradeSupported: "boolean"
};
typeNames.interfaces["VirtualMachineConfigSpec"] = {
changeVersion: "string",
        name: "string",
        version: "string",
        createDate: "Date",
        uuid: "string",
        instanceUuid: "string",
        npivNodeWorldWideName: "number",
        npivPortWorldWideName: "number",
        npivWorldWideNameType: "string",
        npivDesiredNodeWwns: "number",
        npivDesiredPortWwns: "number",
        npivTemporaryDisabled: "boolean",
        npivOnNonRdmDisks: "boolean",
        npivWorldWideNameOp: "string",
        locationId: "string",
        guestId: "string",
        alternateGuestName: "string",
        annotation: "string",
        files: "VirtualMachineFileInfo",
        tools: "ToolsConfigInfo",
        flags: "VirtualMachineFlagInfo",
        consolePreferences: "VirtualMachineConsolePreferences",
        powerOpInfo: "VirtualMachineDefaultPowerOpInfo",
        numCPUs: "number",
        vcpuConfig: "VirtualMachineVcpuConfig",
        numCoresPerSocket: "number",
        memoryMB: "number",
        memoryHotAddEnabled: "boolean",
        cpuHotAddEnabled: "boolean",
        cpuHotRemoveEnabled: "boolean",
        virtualICH7MPresent: "boolean",
        virtualSMCPresent: "boolean",
        deviceChange: "VirtualDeviceConfigSpec",
        cpuAllocation: "ResourceAllocationInfo",
        memoryAllocation: "ResourceAllocationInfo",
        latencySensitivity: "LatencySensitivity",
        cpuAffinity: "VirtualMachineAffinityInfo",
        memoryAffinity: "VirtualMachineAffinityInfo",
        networkShaper: "VirtualMachineNetworkShaperInfo",
        cpuFeatureMask: "VirtualMachineCpuIdInfoSpec",
        extraConfig: "OptionValue",
        swapPlacement: "string",
        bootOptions: "VirtualMachineBootOptions",
        vAppConfig: "VmConfigSpec",
        ftInfo: "FaultToleranceConfigInfo",
        repConfig: "ReplicationConfigSpec",
        vAppConfigRemoved: "boolean",
        vAssertsEnabled: "boolean",
        changeTrackingEnabled: "boolean",
        firmware: "string",
        maxMksConnections: "number",
        guestAutoLockEnabled: "boolean",
        managedBy: "ManagedByInfo",
        memoryReservationLockedToMax: "boolean",
        nestedHVEnabled: "boolean",
        vPMCEnabled: "boolean",
        scheduledHardwareUpgradeInfo: "ScheduledHardwareUpgradeInfo",
        vmProfile: "VirtualMachineProfileSpec",
        messageBusTunnelEnabled: "boolean",
        crypto: "CryptoSpec",
        migrateEncryption: "string",
        sgxInfo: "VirtualMachineSgxInfo",
        guestMonitoringModeInfo: "VirtualMachineGuestMonitoringModeInfo",
        sevEnabled: "boolean"
};
typeNames.interfaces["VirtualMachineCpuIdInfoSpec"] = {
info: "HostCpuIdInfo"
};
typeNames.interfaces["VirtualMachineConsolePreferences"] = {
powerOnWhenOpened: "boolean",
        enterFullScreenOnPowerOn: "boolean",
        closeOnPowerOffOrSuspend: "boolean"
};
typeNames.interfaces["VirtualMachineContentLibraryItemInfo"] = {
contentLibraryItemUuid: "string",
        contentLibraryItemVersion: "string"
};
typeNames.interfaces["DatastoreOption"] = {
unsupportedVolumes: "VirtualMachineDatastoreVolumeOption"
};
typeNames.interfaces["VirtualMachineDatastoreVolumeOption"] = {
fileSystemType: "string",
        majorVersion: "number"
};
typeNames.interfaces["VirtualMachineDefaultPowerOpInfo"] = {
powerOffType: "string",
        suspendType: "string",
        resetType: "string",
        defaultPowerOffType: "string",
        defaultSuspendType: "string",
        defaultResetType: "string",
        standbyAction: "string"
};
typeNames.interfaces["VirtualMachineDeviceRuntimeInfo"] = {
runtimeState: "VirtualMachineDeviceRuntimeInfoDeviceRuntimeState",
        key: "number"
};
typeNames.interfaces["VirtualMachineDeviceRuntimeInfoDeviceRuntimeState"] = {

};
typeNames.interfaces["VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeState"] = {
vmDirectPathGen2Active: "boolean",
        vmDirectPathGen2InactiveReasonVm: "string",
        vmDirectPathGen2InactiveReasonOther: "string",
        vmDirectPathGen2InactiveReasonExtended: "string",
        reservationStatus: "string",
        attachmentStatus: "string",
        featureRequirement: "VirtualMachineFeatureRequirement"
};
typeNames.interfaces["FaultToleranceConfigInfo"] = {
role: "number",
        instanceUuids: "string",
        configPaths: "string",
        orphaned: "boolean"
};
typeNames.interfaces["FaultToleranceConfigSpec"] = {
metaDataPath: "FaultToleranceMetaSpec",
        secondaryVmSpec: "FaultToleranceVMConfigSpec"
};
typeNames.interfaces["FaultToleranceMetaSpec"] = {
metaDataDatastore: Datastore
};
typeNames.interfaces["FaultTolerancePrimaryConfigInfo"] = {
secondaries: VirtualMachine
};
typeNames.interfaces["FaultToleranceSecondaryConfigInfo"] = {
primaryVM: VirtualMachine
};
typeNames.interfaces["FaultToleranceSecondaryOpResult"] = {
vm: VirtualMachine,
        powerOnAttempted: "boolean",
        powerOnResult: "ClusterPowerOnVmResult"
};
typeNames.interfaces["FaultToleranceVMConfigSpec"] = {
vmConfig: Datastore,
        disks: "FaultToleranceDiskSpec"
};
typeNames.interfaces["FaultToleranceDiskSpec"] = {
disk: "VirtualDevice",
        datastore: Datastore
};
typeNames.interfaces["VirtualMachineFeatureRequirement"] = {
key: "string",
        featureName: "string",
        value: "string"
};
typeNames.interfaces["VirtualMachineFileInfo"] = {
vmPathName: "string",
        snapshotDirectory: "string",
        suspendDirectory: "string",
        logDirectory: "string",
        ftMetadataDirectory: "string"
};
typeNames.interfaces["VirtualMachineFileLayout"] = {
configFile: "string",
        logFile: "string",
        disk: "VirtualMachineFileLayoutDiskLayout",
        snapshot: "VirtualMachineFileLayoutSnapshotLayout",
        swapFile: "string"
};
typeNames.interfaces["VirtualMachineFileLayoutDiskLayout"] = {
key: "number",
        diskFile: "string"
};
typeNames.interfaces["VirtualMachineFileLayoutSnapshotLayout"] = {
key: VirtualMachineSnapshot,
        snapshotFile: "string"
};
typeNames.interfaces["VirtualMachineFileLayoutEx"] = {
file: "VirtualMachineFileLayoutExFileInfo",
        disk: "VirtualMachineFileLayoutExDiskLayout",
        snapshot: "VirtualMachineFileLayoutExSnapshotLayout",
        timestamp: "Date"
};
typeNames.interfaces["VirtualMachineFileLayoutExDiskLayout"] = {
key: "number",
        chain: "VirtualMachineFileLayoutExDiskUnit"
};
typeNames.interfaces["VirtualMachineFileLayoutExDiskUnit"] = {
fileKey: "number"
};
typeNames.interfaces["VirtualMachineFileLayoutExFileInfo"] = {
key: "number",
        name: "string",
        type: "string",
        size: "number",
        uniqueSize: "number",
        backingObjectId: "string",
        accessible: "boolean"
};
typeNames.interfaces["VirtualMachineFileLayoutExSnapshotLayout"] = {
key: VirtualMachineSnapshot,
        dataKey: "number",
        memoryKey: "number",
        disk: "VirtualMachineFileLayoutExDiskLayout"
};
typeNames.interfaces["VirtualMachineFlagInfo"] = {
disableAcceleration: "boolean",
        enableLogging: "boolean",
        useToe: "boolean",
        runWithDebugInfo: "boolean",
        monitorType: "string",
        htSharing: "string",
        snapshotDisabled: "boolean",
        snapshotLocked: "boolean",
        diskUuidEnabled: "boolean",
        virtualMmuUsage: "string",
        virtualExecUsage: "string",
        snapshotPowerOffBehavior: "string",
        recordReplayEnabled: "boolean",
        faultToleranceType: "string",
        cbrcCacheEnabled: "boolean",
        vvtdEnabled: "boolean",
        vbsEnabled: "boolean"
};
typeNames.interfaces["VirtualMachineForkConfigInfo"] = {
parentEnabled: "boolean",
        childForkGroupId: "string",
        parentForkGroupId: "string",
        childType: "string"
};
typeNames.interfaces["GuestInfo"] = {
toolsStatus: "VirtualMachineToolsStatus",
        toolsVersionStatus: "string",
        toolsVersionStatus2: "string",
        toolsRunningStatus: "string",
        toolsVersion: "string",
        toolsInstallType: "string",
        guestId: "string",
        guestFamily: "string",
        guestFullName: "string",
        hostName: "string",
        ipAddress: "string",
        net: "GuestNicInfo",
        ipStack: "GuestStackInfo",
        disk: "GuestDiskInfo",
        screen: "GuestScreenInfo",
        guestState: "string",
        appHeartbeatStatus: "string",
        guestKernelCrashed: "boolean",
        appState: "string",
        guestOperationsReady: "boolean",
        interactiveGuestOperationsReady: "boolean",
        guestStateChangeSupported: "boolean",
        generationInfo: "GuestInfoNamespaceGenerationInfo",
        hwVersion: "string"
};
typeNames.interfaces["GuestDiskInfo"] = {
diskPath: "string",
        capacity: "number",
        freeSpace: "number",
        filesystemType: "string",
        mappings: "GuestInfoVirtualDiskMapping"
};
typeNames.interfaces["GuestInfoNamespaceGenerationInfo"] = {
key: "string",
        generationNo: "number"
};
typeNames.interfaces["GuestNicInfo"] = {
network: "string",
        ipAddress: "string",
        macAddress: "string",
        connected: "boolean",
        deviceConfigId: "number",
        dnsConfig: "NetDnsConfigInfo",
        ipConfig: "NetIpConfigInfo",
        netBIOSConfig: "NetBIOSConfigInfo"
};
typeNames.interfaces["GuestScreenInfo"] = {
width: "number",
        height: "number"
};
typeNames.interfaces["GuestStackInfo"] = {
dnsConfig: "NetDnsConfigInfo",
        ipRouteConfig: "NetIpRouteConfigInfo",
        ipStackConfig: "KeyValue",
        dhcpConfig: "NetDhcpConfigInfo"
};
typeNames.interfaces["GuestInfoVirtualDiskMapping"] = {
key: "number"
};
typeNames.interfaces["VirtualMachineGuestIntegrityInfo"] = {
enabled: "boolean"
};
typeNames.interfaces["VirtualMachineGuestMonitoringModeInfo"] = {
gmmFile: "string",
        gmmAppliance: "string"
};
typeNames.interfaces["GuestOsDescriptor"] = {
id: "string",
        family: "string",
        fullName: "string",
        supportedMaxCPUs: "number",
        numSupportedPhysicalSockets: "number",
        numSupportedCoresPerSocket: "number",
        supportedMinMemMB: "number",
        supportedMaxMemMB: "number",
        recommendedMemMB: "number",
        recommendedColorDepth: "number",
        supportedDiskControllerList: "string",
        recommendedSCSIController: "string",
        recommendedDiskController: "string",
        supportedNumDisks: "number",
        recommendedDiskSizeMB: "number",
        recommendedCdromController: "string",
        supportedEthernetCard: "string",
        recommendedEthernetCard: "string",
        supportsSlaveDisk: "boolean",
        cpuFeatureMask: "HostCpuIdInfo",
        smcRequired: "boolean",
        supportsWakeOnLan: "boolean",
        supportsVMI: "boolean",
        supportsMemoryHotAdd: "boolean",
        supportsCpuHotAdd: "boolean",
        supportsCpuHotRemove: "boolean",
        supportedFirmware: "string",
        recommendedFirmware: "string",
        supportedUSBControllerList: "string",
        recommendedUSBController: "string",
        supports3D: "boolean",
        recommended3D: "boolean",
        smcRecommended: "boolean",
        ich7mRecommended: "boolean",
        usbRecommended: "boolean",
        supportLevel: "string",
        supportedForCreate: "boolean",
        vRAMSizeInKB: "IntOption",
        numSupportedFloppyDevices: "number",
        wakeOnLanEthernetCard: "string",
        supportsPvscsiControllerForBoot: "boolean",
        diskUuidEnabled: "boolean",
        supportsHotPlugPCI: "boolean",
        supportsSecureBoot: "boolean",
        defaultSecureBoot: "boolean",
        persistentMemorySupported: "boolean",
        supportedMinPersistentMemoryMB: "number",
        supportedMaxPersistentMemoryMB: "number",
        recommendedPersistentMemoryMB: "number",
        persistentMemoryHotAddSupported: "boolean",
        persistentMemoryHotRemoveSupported: "boolean",
        persistentMemoryColdGrowthSupported: "boolean",
        persistentMemoryColdGrowthGranularityMB: "number",
        persistentMemoryHotGrowthSupported: "boolean",
        persistentMemoryHotGrowthGranularityMB: "number",
        numRecommendedPhysicalSockets: "number",
        numRecommendedCoresPerSocket: "number",
        vvtdSupported: "BoolOption",
        vbsSupported: "BoolOption",
        vsgxSupported: "BoolOption",
        supportsTPM20: "boolean",
        vwdtSupported: "boolean"
};
typeNames.interfaces["VirtualMachineGuestQuiesceSpec"] = {
timeout: "number"
};
typeNames.interfaces["VirtualMachineInstantCloneSpec"] = {
name: "string",
        location: "VirtualMachineRelocateSpec",
        config: "OptionValue",
        biosUuid: "string"
};
typeNames.interfaces["VirtualMachineLegacyNetworkSwitchInfo"] = {
name: "string"
};
typeNames.interfaces["VirtualMachineMessage"] = {
id: "string",
        argument: "any",
        text: "string"
};
typeNames.interfaces["VirtualMachineMetadataManagerVmMetadata"] = {
vmId: "string",
        metadata: "string"
};
typeNames.interfaces["VirtualMachineMetadataManagerVmMetadataInput"] = {
operation: "string",
        vmMetadata: "VirtualMachineMetadataManagerVmMetadata"
};
typeNames.interfaces["VirtualMachineMetadataManagerVmMetadataOwner"] = {
name: "string"
};
typeNames.interfaces["VirtualMachineMetadataManagerVmMetadataResult"] = {
vmMetadata: "VirtualMachineMetadataManagerVmMetadata",
        error: "MethodFault"
};
typeNames.interfaces["VirtualMachineNetworkShaperInfo"] = {
enabled: "boolean",
        peakBps: "number",
        averageBps: "number",
        burstSize: "number"
};
typeNames.interfaces["VirtualMachineProfileDetails"] = {
profile: "VirtualMachineProfileSpec",
        diskProfileDetails: "VirtualMachineProfileDetailsDiskProfileDetails"
};
typeNames.interfaces["VirtualMachineProfileDetailsDiskProfileDetails"] = {
diskId: "number",
        profile: "VirtualMachineProfileSpec"
};
typeNames.interfaces["VirtualMachineProfileRawData"] = {
extensionKey: "string",
        objectData: "string"
};
typeNames.interfaces["VirtualMachineProfileSpec"] = {

};
typeNames.interfaces["VirtualMachinePropertyRelation"] = {
key: "DynamicProperty",
        relations: "DynamicProperty"
};
typeNames.interfaces["VirtualMachineQuestionInfo"] = {
id: "string",
        text: "string",
        choice: "ChoiceOption",
        message: "VirtualMachineMessage"
};
typeNames.interfaces["ReplicationConfigSpec"] = {
generation: "number",
        vmReplicationId: "string",
        destination: "string",
        port: "number",
        rpo: "number",
        quiesceGuestEnabled: "boolean",
        paused: "boolean",
        oppUpdatesEnabled: "boolean",
        netCompressionEnabled: "boolean",
        netEncryptionEnabled: "boolean",
        encryptionDestination: "string",
        encryptionPort: "number",
        remoteCertificateThumbprint: "string",
        disk: "ReplicationInfoDiskSettings"
};
typeNames.interfaces["ReplicationInfoDiskSettings"] = {
key: "number",
        diskReplicationId: "string"
};
typeNames.interfaces["ScheduledHardwareUpgradeInfo"] = {
upgradePolicy: "string",
        versionKey: "string",
        scheduledHardwareUpgradeStatus: "string",
        fault: "MethodFault"
};
typeNames.interfaces["VirtualMachineSgxInfo"] = {
epcSize: "number",
        flcMode: "string",
        lePubKeyHash: "string"
};
typeNames.interfaces["VirtualMachineSnapshotInfo"] = {
currentSnapshot: VirtualMachineSnapshot,
        rootSnapshotList: "VirtualMachineSnapshotTree"
};
typeNames.interfaces["VirtualMachineSriovDevicePoolInfo"] = {
key: "string"
};
typeNames.interfaces["VirtualMachineSriovNetworkDevicePoolInfo"] = {
switchKey: "string",
        switchUuid: "string"
};
typeNames.interfaces["VirtualMachineStorageInfo"] = {
perDatastoreUsage: "VirtualMachineUsageOnDatastore",
        timestamp: "Date"
};
typeNames.interfaces["VirtualMachineUsageOnDatastore"] = {
datastore: Datastore,
        committed: "number",
        uncommitted: "number",
        unshared: "number"
};
typeNames.interfaces["VirtualMachineTargetInfo"] = {
name: "string",
        configurationTag: "string"
};
typeNames.interfaces["ToolsConfigInfo"] = {
toolsVersion: "number",
        toolsInstallType: "string",
        afterPowerOn: "boolean",
        afterResume: "boolean",
        beforeGuestStandby: "boolean",
        beforeGuestShutdown: "boolean",
        beforeGuestReboot: "boolean",
        toolsUpgradePolicy: "string",
        pendingCustomization: "string",
        customizationKeyId: "CryptoKeyId",
        syncTimeWithHostAllowed: "boolean",
        syncTimeWithHost: "boolean",
        lastInstallInfo: "ToolsConfigInfoToolsLastInstallInfo"
};
typeNames.interfaces["ToolsConfigInfoToolsLastInstallInfo"] = {
counter: "number",
        fault: "MethodFault"
};
typeNames.interfaces["VirtualMachineUsbInfo"] = {
description: "string",
        vendor: "number",
        product: "number",
        physicalPath: "string",
        family: "string",
        speed: "string",
        summary: "VirtualMachineSummary"
};
typeNames.interfaces["UsbScanCodeSpec"] = {
keyEvents: "UsbScanCodeSpecKeyEvent"
};
typeNames.interfaces["UsbScanCodeSpecKeyEvent"] = {
usbHidCode: "number",
        modifiers: "UsbScanCodeSpecModifierType"
};
typeNames.interfaces["UsbScanCodeSpecModifierType"] = {
leftControl: "boolean",
        leftShift: "boolean",
        leftAlt: "boolean",
        leftGui: "boolean",
        rightControl: "boolean",
        rightShift: "boolean",
        rightAlt: "boolean",
        rightGui: "boolean"
};
typeNames.interfaces["VirtualMachineVcpuConfig"] = {
latencySensitivity: "LatencySensitivity"
};
typeNames.interfaces["VirtualHardware"] = {
numCPU: "number",
        numCoresPerSocket: "number",
        memoryMB: "number",
        virtualICH7MPresent: "boolean",
        virtualSMCPresent: "boolean",
        device: "VirtualDevice"
};
typeNames.interfaces["VirtualHardwareOption"] = {
hwVersion: "number",
        virtualDeviceOption: "VirtualDeviceOption",
        deviceListReadonly: "boolean",
        numCPU: "number",
        numCoresPerSocket: "IntOption",
        numCpuReadonly: "boolean",
        memoryMB: "LongOption",
        numPCIControllers: "IntOption",
        numIDEControllers: "IntOption",
        numUSBControllers: "IntOption",
        numUSBXHCIControllers: "IntOption",
        numSIOControllers: "IntOption",
        numPS2Controllers: "IntOption",
        licensingLimit: "string",
        numSupportedWwnPorts: "IntOption",
        numSupportedWwnNodes: "IntOption",
        resourceConfigOption: "ResourceConfigOption",
        numNVDIMMControllers: "IntOption",
        numTPMDevices: "IntOption",
        numWDTDevices: "IntOption",
        numPrecisionClockDevices: "IntOption",
        epcMemoryMB: "LongOption"
};
typeNames.interfaces["VirtualMachineWindowsQuiesceSpec"] = {
vssBackupType: "number",
        vssBootableSystemState: "boolean",
        vssPartialFileSupport: "boolean",
        vssBackupContext: "string"
};
typeNames.interfaces["CheckResult"] = {
vm: VirtualMachine,
        host: HostSystem,
        warning: "MethodFault",
        error: "MethodFault"
};
typeNames.interfaces["CustomizationAdapterMapping"] = {
macAddress: "string",
        adapter: "CustomizationIPSettings"
};
typeNames.interfaces["CustomizationGlobalIPSettings"] = {
dnsSuffixList: "string",
        dnsServerList: "string"
};
typeNames.interfaces["CustomizationGuiRunOnce"] = {
commandList: "string"
};
typeNames.interfaces["CustomizationGuiUnattended"] = {
password: "CustomizationPassword",
        timeZone: "number",
        autoLogon: "boolean",
        autoLogonCount: "number"
};
typeNames.interfaces["CustomizationIPSettings"] = {
ip: "CustomizationIpGenerator",
        subnetMask: "string",
        gateway: "string",
        ipV6Spec: "CustomizationIPSettingsIpV6AddressSpec",
        dnsServerList: "string",
        dnsDomain: "string",
        primaryWINS: "string",
        secondaryWINS: "string",
        netBIOS: "CustomizationNetBIOSMode"
};
typeNames.interfaces["CustomizationIPSettingsIpV6AddressSpec"] = {
ip: "CustomizationIpV6Generator",
        gateway: "string"
};
typeNames.interfaces["CustomizationIdentification"] = {
joinWorkgroup: "string",
        joinDomain: "string",
        domainAdmin: "string",
        domainAdminPassword: "CustomizationPassword"
};
typeNames.interfaces["CustomizationIdentitySettings"] = {

};
typeNames.interfaces["CustomizationIpGenerator"] = {

};
typeNames.interfaces["CustomizationIpV6Generator"] = {

};
typeNames.interfaces["CustomizationLicenseFilePrintData"] = {
autoMode: "CustomizationLicenseDataMode",
        autoUsers: "number"
};
typeNames.interfaces["CustomizationLinuxPrep"] = {
hostName: "CustomizationName",
        domain: "string",
        timeZone: "string",
        hwClockUTC: "boolean",
        scriptText: "string"
};
typeNames.interfaces["CustomizationName"] = {

};
typeNames.interfaces["CustomizationOptions"] = {

};
typeNames.interfaces["CustomizationPassword"] = {
value: "string",
        plainText: "boolean"
};
typeNames.interfaces["CustomizationPrefixName"] = {
base: "string"
};
typeNames.interfaces["CustomizationSpec"] = {
options: "CustomizationOptions",
        identity: "CustomizationIdentitySettings",
        globalIPSettings: "CustomizationGlobalIPSettings",
        nicSettingMap: "CustomizationAdapterMapping",
        encryptionKey: "number"
};
typeNames.interfaces["CustomizationStatelessIpV6Generator"] = {

};
typeNames.interfaces["CustomizationSysprep"] = {
guiUnattended: "CustomizationGuiUnattended",
        userData: "CustomizationUserData",
        guiRunOnce: "CustomizationGuiRunOnce",
        identification: "CustomizationIdentification",
        licenseFilePrintData: "CustomizationLicenseFilePrintData"
};
typeNames.interfaces["CustomizationSysprepText"] = {
value: "string"
};
typeNames.interfaces["CustomizationUnknownIpGenerator"] = {

};
typeNames.interfaces["CustomizationUnknownIpV6Generator"] = {

};
typeNames.interfaces["CustomizationUnknownName"] = {

};
typeNames.interfaces["CustomizationUserData"] = {
fullName: "string",
        orgName: "string",
        computerName: "CustomizationName",
        productId: "string"
};
typeNames.interfaces["CustomizationVirtualMachineName"] = {

};
typeNames.interfaces["CustomizationWinOptions"] = {
changeSID: "boolean",
        deleteAccounts: "boolean",
        reboot: "CustomizationSysprepRebootOption"
};
typeNames.interfaces["HostDiskMappingInfo"] = {
physicalPartition: "HostDiskMappingPartitionInfo",
        name: "string",
        exclusive: "boolean"
};
typeNames.interfaces["HostDiskMappingPartitionInfo"] = {
name: "string",
        fileSystem: "string",
        capacityInKb: "number"
};
typeNames.interfaces["HostDiskMappingOption"] = {
physicalPartition: "HostDiskMappingPartitionOption",
        name: "string"
};
typeNames.interfaces["HostDiskMappingPartitionOption"] = {
name: "string",
        fileSystem: "string",
        capacityInKb: "number"
};
typeNames.interfaces["VirtualDevice"] = {
key: "number",
        deviceInfo: "Description",
        backing: "VirtualDeviceBackingInfo",
        connectable: "VirtualDeviceConnectInfo",
        slotInfo: "VirtualDeviceBusSlotInfo",
        controllerKey: "number",
        unitNumber: "number"
};
typeNames.interfaces["VirtualDeviceBackingInfo"] = {

};
typeNames.interfaces["VirtualDeviceBusSlotInfo"] = {

};
typeNames.interfaces["VirtualDeviceConnectInfo"] = {
migrateConnect: "string",
        startConnected: "boolean",
        allowGuestControl: "boolean",
        connected: "boolean",
        status: "string"
};
typeNames.interfaces["VirtualDeviceDeviceBackingInfo"] = {
deviceName: "string",
        useAutoDetect: "boolean"
};
typeNames.interfaces["VirtualDeviceFileBackingInfo"] = {
fileName: "string",
        datastore: Datastore,
        backingObjectId: "string"
};
typeNames.interfaces["VirtualDevicePciBusSlotInfo"] = {
pciSlotNumber: "number"
};
typeNames.interfaces["VirtualDevicePipeBackingInfo"] = {
pipeName: "string"
};
typeNames.interfaces["VirtualDeviceRemoteDeviceBackingInfo"] = {
deviceName: "string",
        useAutoDetect: "boolean"
};
typeNames.interfaces["VirtualDeviceURIBackingInfo"] = {
serviceURI: "string",
        direction: "string",
        proxyURI: "string"
};
typeNames.interfaces["VirtualDeviceOption"] = {
type: "string",
        connectOption: "VirtualDeviceConnectOption",
        busSlotOption: "VirtualDeviceBusSlotOption",
        controllerType: "string",
        autoAssignController: "BoolOption",
        backingOption: "VirtualDeviceBackingOption",
        defaultBackingOptionIndex: "number",
        licensingLimit: "string",
        deprecated: "boolean",
        plugAndPlay: "boolean",
        hotRemoveSupported: "boolean"
};
typeNames.interfaces["VirtualDeviceBackingOption"] = {
type: "string"
};
typeNames.interfaces["VirtualDeviceBusSlotOption"] = {
type: "string"
};
typeNames.interfaces["VirtualDeviceConnectOption"] = {
startConnected: "BoolOption",
        allowGuestControl: "BoolOption"
};
typeNames.interfaces["VirtualDeviceDeviceBackingOption"] = {
autoDetectAvailable: "BoolOption"
};
typeNames.interfaces["VirtualDeviceFileBackingOption"] = {
fileNameExtensions: "ChoiceOption"
};
typeNames.interfaces["VirtualDevicePipeBackingOption"] = {

};
typeNames.interfaces["VirtualDeviceRemoteDeviceBackingOption"] = {
autoDetectAvailable: "BoolOption"
};
typeNames.interfaces["VirtualDeviceURIBackingOption"] = {
directions: "ChoiceOption"
};
typeNames.interfaces["VirtualDeviceConfigSpec"] = {
operation: "VirtualDeviceConfigSpecOperation",
        fileOperation: "VirtualDeviceConfigSpecFileOperation",
        device: "VirtualDevice",
        profile: "VirtualMachineProfileSpec",
        backing: "VirtualDeviceConfigSpecBackingSpec"
};
typeNames.interfaces["VirtualDeviceConfigSpecBackingSpec"] = {
parent: "VirtualDeviceConfigSpecBackingSpec",
        crypto: "CryptoSpec"
};
typeNames.interfaces["VirtualDisk"] = {
capacityInKB: "number",
        capacityInBytes: "number",
        shares: "SharesInfo",
        storageIOAllocation: "StorageIOAllocationInfo",
        diskObjectId: "string",
        vFlashCacheConfigInfo: "VirtualDiskVFlashCacheConfigInfo",
        iofilter: "string",
        vDiskId: "ID",
        nativeUnmanagedLinkedClone: "boolean"
};
typeNames.interfaces["VirtualDiskFlatVer1BackingInfo"] = {
diskMode: "string",
        split: "boolean",
        writeThrough: "boolean",
        contentId: "string",
        parent: "VirtualDiskFlatVer1BackingInfo"
};
typeNames.interfaces["VirtualDiskFlatVer2BackingInfo"] = {
diskMode: "string",
        split: "boolean",
        writeThrough: "boolean",
        thinProvisioned: "boolean",
        eagerlyScrub: "boolean",
        uuid: "string",
        contentId: "string",
        changeId: "string",
        parent: "VirtualDiskFlatVer2BackingInfo",
        deltaDiskFormat: "string",
        digestEnabled: "boolean",
        deltaGrainSize: "number",
        deltaDiskFormatVariant: "string",
        sharing: "string",
        keyId: "CryptoKeyId"
};
typeNames.interfaces["VirtualDiskLocalPMemBackingInfo"] = {
diskMode: "string",
        uuid: "string",
        volumeUUID: "string",
        contentId: "string"
};
typeNames.interfaces["VirtualDiskPartitionedRawDiskVer2BackingInfo"] = {
partition: "number"
};
typeNames.interfaces["VirtualDiskRawDiskMappingVer1BackingInfo"] = {
lunUuid: "string",
        deviceName: "string",
        compatibilityMode: "string",
        diskMode: "string",
        uuid: "string",
        contentId: "string",
        changeId: "string",
        parent: "VirtualDiskRawDiskMappingVer1BackingInfo",
        deltaDiskFormat: "string",
        deltaGrainSize: "number",
        sharing: "string"
};
typeNames.interfaces["VirtualDiskRawDiskVer2BackingInfo"] = {
descriptorFileName: "string",
        uuid: "string",
        changeId: "string",
        sharing: "string"
};
typeNames.interfaces["VirtualDiskSeSparseBackingInfo"] = {
diskMode: "string",
        writeThrough: "boolean",
        uuid: "string",
        contentId: "string",
        changeId: "string",
        parent: "VirtualDiskSeSparseBackingInfo",
        deltaDiskFormat: "string",
        digestEnabled: "boolean",
        grainSize: "number",
        keyId: "CryptoKeyId"
};
typeNames.interfaces["VirtualDiskSparseVer1BackingInfo"] = {
diskMode: "string",
        split: "boolean",
        writeThrough: "boolean",
        spaceUsedInKB: "number",
        contentId: "string",
        parent: "VirtualDiskSparseVer1BackingInfo"
};
typeNames.interfaces["VirtualDiskSparseVer2BackingInfo"] = {
diskMode: "string",
        split: "boolean",
        writeThrough: "boolean",
        spaceUsedInKB: "number",
        uuid: "string",
        contentId: "string",
        changeId: "string",
        parent: "VirtualDiskSparseVer2BackingInfo",
        keyId: "CryptoKeyId"
};
typeNames.interfaces["VirtualDiskVFlashCacheConfigInfo"] = {
vFlashModule: "string",
        reservationInMB: "number",
        cacheConsistencyType: "string",
        cacheMode: "string",
        blockSizeInKB: "number"
};
typeNames.interfaces["VirtualDiskId"] = {
vm: VirtualMachine,
        diskId: "number"
};
typeNames.interfaces["VirtualDiskOption"] = {
capacityInKB: "LongOption",
        ioAllocationOption: "StorageIOAllocationOption",
        vFlashCacheConfigOption: "VirtualDiskOptionVFlashCacheConfigOption"
};
typeNames.interfaces["VirtualDiskDeltaDiskFormatsSupported"] = {
datastoreType: "string",
        deltaDiskFormat: "ChoiceOption"
};
typeNames.interfaces["VirtualDiskFlatVer1BackingOption"] = {
diskMode: "ChoiceOption",
        split: "BoolOption",
        writeThrough: "BoolOption",
        growable: "boolean"
};
typeNames.interfaces["VirtualDiskFlatVer2BackingOption"] = {
diskMode: "ChoiceOption",
        split: "BoolOption",
        writeThrough: "BoolOption",
        growable: "boolean",
        hotGrowable: "boolean",
        uuid: "boolean",
        thinProvisioned: "BoolOption",
        eagerlyScrub: "BoolOption",
        deltaDiskFormat: "ChoiceOption",
        deltaDiskFormatsSupported: "VirtualDiskDeltaDiskFormatsSupported"
};
typeNames.interfaces["VirtualDiskLocalPMemBackingOption"] = {
diskMode: "ChoiceOption",
        growable: "boolean",
        hotGrowable: "boolean",
        uuid: "boolean"
};
typeNames.interfaces["VirtualDiskPartitionedRawDiskVer2BackingOption"] = {

};
typeNames.interfaces["VirtualDiskRawDiskMappingVer1BackingOption"] = {
descriptorFileNameExtensions: "ChoiceOption",
        compatibilityMode: "ChoiceOption",
        diskMode: "ChoiceOption",
        uuid: "boolean"
};
typeNames.interfaces["VirtualDiskRawDiskVer2BackingOption"] = {
descriptorFileNameExtensions: "ChoiceOption",
        uuid: "boolean"
};
typeNames.interfaces["VirtualDiskSeSparseBackingOption"] = {
diskMode: "ChoiceOption",
        writeThrough: "BoolOption",
        growable: "boolean",
        hotGrowable: "boolean",
        uuid: "boolean",
        deltaDiskFormatsSupported: "VirtualDiskDeltaDiskFormatsSupported"
};
typeNames.interfaces["VirtualDiskSparseVer1BackingOption"] = {
diskModes: "ChoiceOption",
        split: "BoolOption",
        writeThrough: "BoolOption",
        growable: "boolean"
};
typeNames.interfaces["VirtualDiskSparseVer2BackingOption"] = {
diskMode: "ChoiceOption",
        split: "BoolOption",
        writeThrough: "BoolOption",
        growable: "boolean",
        hotGrowable: "boolean",
        uuid: "boolean"
};
typeNames.interfaces["VirtualDiskOptionVFlashCacheConfigOption"] = {
cacheConsistencyType: "ChoiceOption",
        cacheMode: "ChoiceOption",
        reservationInMB: "LongOption",
        blockSizeInKB: "LongOption"
};
typeNames.interfaces["VirtualDiskConfigSpec"] = {
diskMoveType: "string",
        migrateCache: "boolean"
};
typeNames.interfaces["VirtualEthernetCard"] = {
addressType: "string",
        macAddress: "string",
        wakeOnLanEnabled: "boolean",
        resourceAllocation: "VirtualEthernetCardResourceAllocation",
        externalId: "string",
        uptCompatibilityEnabled: "boolean"
};
typeNames.interfaces["VirtualEthernetCardDistributedVirtualPortBackingInfo"] = {
port: "DistributedVirtualSwitchPortConnection"
};
typeNames.interfaces["VirtualEthernetCardLegacyNetworkBackingInfo"] = {

};
typeNames.interfaces["VirtualEthernetCardNetworkBackingInfo"] = {
network: Network,
        inPassthroughMode: "boolean"
};
typeNames.interfaces["VirtualEthernetCardOpaqueNetworkBackingInfo"] = {
opaqueNetworkId: "string",
        opaqueNetworkType: "string"
};
typeNames.interfaces["VirtualEthernetCardResourceAllocation"] = {
reservation: "number",
        share: "SharesInfo",
        limit: "number"
};
typeNames.interfaces["VirtualEthernetCardOption"] = {
supportedOUI: "ChoiceOption",
        macType: "ChoiceOption",
        wakeOnLanEnabled: "BoolOption",
        vmDirectPathGen2Supported: "boolean",
        uptCompatibilityEnabled: "BoolOption"
};
typeNames.interfaces["VirtualEthernetCardDVPortBackingOption"] = {

};
typeNames.interfaces["VirtualEthernetCardLegacyNetworkBackingOption"] = {

};
typeNames.interfaces["VirtualEthernetCardNetworkBackingOption"] = {

};
typeNames.interfaces["VirtualEthernetCardOpaqueNetworkBackingOption"] = {

};
typeNames.interfaces["VirtualFloppy"] = {

};
typeNames.interfaces["VirtualFloppyDeviceBackingInfo"] = {

};
typeNames.interfaces["VirtualFloppyImageBackingInfo"] = {

};
typeNames.interfaces["VirtualFloppyRemoteDeviceBackingInfo"] = {

};
typeNames.interfaces["VirtualFloppyOption"] = {

};
typeNames.interfaces["VirtualFloppyDeviceBackingOption"] = {

};
typeNames.interfaces["VirtualFloppyImageBackingOption"] = {

};
typeNames.interfaces["VirtualFloppyRemoteDeviceBackingOption"] = {

};
typeNames.interfaces["VirtualKeyboard"] = {

};
typeNames.interfaces["VirtualKeyboardOption"] = {

};
typeNames.interfaces["VirtualNVDIMM"] = {
capacityInMB: "number"
};
typeNames.interfaces["VirtualNVDIMMBackingInfo"] = {
parent: "VirtualNVDIMMBackingInfo",
        changeId: "string"
};
typeNames.interfaces["VirtualNVDIMMOption"] = {
capacityInMB: "LongOption",
        growable: "boolean",
        hotGrowable: "boolean",
        granularityInMB: "number"
};
typeNames.interfaces["VirtualPCIPassthrough"] = {

};
typeNames.interfaces["VirtualPCIPassthroughAllowedDevice"] = {
vendorId: "number",
        deviceId: "number",
        subVendorId: "number",
        subDeviceId: "number",
        revisionId: "number"
};
typeNames.interfaces["VirtualPCIPassthroughDeviceBackingInfo"] = {
id: "string",
        deviceId: "string",
        systemId: "string",
        vendorId: "number"
};
typeNames.interfaces["VirtualPCIPassthroughDynamicBackingInfo"] = {
allowedDevice: "VirtualPCIPassthroughAllowedDevice",
        customLabel: "string",
        assignedId: "string"
};
typeNames.interfaces["VirtualPCIPassthroughPluginBackingInfo"] = {

};
typeNames.interfaces["VirtualPCIPassthroughVmiopBackingInfo"] = {
vgpu: "string"
};
typeNames.interfaces["VirtualPCIPassthroughOption"] = {

};
typeNames.interfaces["VirtualPCIPassthroughDeviceBackingOption"] = {

};
typeNames.interfaces["VirtualPCIPassthroughDynamicBackingOption"] = {

};
typeNames.interfaces["VirtualPCIPassthroughPluginBackingOption"] = {

};
typeNames.interfaces["VirtualPCIPassthroughVmiopBackingOption"] = {
vgpu: "StringOption",
        maxInstances: "number"
};
typeNames.interfaces["VirtualPCNet32"] = {

};
typeNames.interfaces["VirtualPCNet32Option"] = {
supportsMorphing: "boolean"
};
typeNames.interfaces["VirtualParallelPort"] = {

};
typeNames.interfaces["VirtualParallelPortDeviceBackingInfo"] = {

};
typeNames.interfaces["VirtualParallelPortFileBackingInfo"] = {

};
typeNames.interfaces["VirtualParallelPortOption"] = {

};
typeNames.interfaces["VirtualParallelPortDeviceBackingOption"] = {

};
typeNames.interfaces["VirtualParallelPortFileBackingOption"] = {

};
typeNames.interfaces["VirtualPointingDevice"] = {

};
typeNames.interfaces["VirtualPointingDeviceDeviceBackingInfo"] = {
hostPointingDevice: "string"
};
typeNames.interfaces["VirtualPointingDeviceOption"] = {

};
typeNames.interfaces["VirtualPointingDeviceBackingOption"] = {
hostPointingDevice: "ChoiceOption"
};
typeNames.interfaces["VirtualPrecisionClock"] = {

};
typeNames.interfaces["VirtualPrecisionClockSystemClockBackingInfo"] = {
protocol: "string"
};
typeNames.interfaces["VirtualPrecisionClockOption"] = {

};
typeNames.interfaces["VirtualPrecisionClockSystemClockBackingOption"] = {
protocol: "ChoiceOption"
};
typeNames.interfaces["VirtualSCSIPassthrough"] = {

};
typeNames.interfaces["VirtualSCSIPassthroughDeviceBackingInfo"] = {

};
typeNames.interfaces["VirtualSCSIPassthroughOption"] = {

};
typeNames.interfaces["VirtualSCSIPassthroughDeviceBackingOption"] = {

};
typeNames.interfaces["VirtualSerialPort"] = {
yieldOnPoll: "boolean"
};
typeNames.interfaces["VirtualSerialPortDeviceBackingInfo"] = {

};
typeNames.interfaces["VirtualSerialPortFileBackingInfo"] = {

};
typeNames.interfaces["VirtualSerialPortPipeBackingInfo"] = {
endpoint: "string",
        noRxLoss: "boolean"
};
typeNames.interfaces["VirtualSerialPortThinPrintBackingInfo"] = {

};
typeNames.interfaces["VirtualSerialPortURIBackingInfo"] = {

};
typeNames.interfaces["VirtualSerialPortOption"] = {
yieldOnPoll: "BoolOption"
};
typeNames.interfaces["VirtualSerialPortDeviceBackingOption"] = {

};
typeNames.interfaces["VirtualSerialPortFileBackingOption"] = {

};
typeNames.interfaces["VirtualSerialPortPipeBackingOption"] = {
endpoint: "ChoiceOption",
        noRxLoss: "BoolOption"
};
typeNames.interfaces["VirtualSerialPortThinPrintBackingOption"] = {

};
typeNames.interfaces["VirtualSerialPortURIBackingOption"] = {

};
typeNames.interfaces["VirtualSoundCard"] = {

};
typeNames.interfaces["VirtualSoundCardDeviceBackingInfo"] = {

};
typeNames.interfaces["VirtualSoundCardOption"] = {

};
typeNames.interfaces["VirtualSoundCardDeviceBackingOption"] = {

};
typeNames.interfaces["VirtualSriovEthernetCard"] = {
allowGuestOSMtuChange: "boolean",
        sriovBacking: "VirtualSriovEthernetCardSriovBackingInfo"
};
typeNames.interfaces["VirtualSriovEthernetCardSriovBackingInfo"] = {
physicalFunctionBacking: "VirtualPCIPassthroughDeviceBackingInfo",
        virtualFunctionBacking: "VirtualPCIPassthroughDeviceBackingInfo",
        virtualFunctionIndex: "number"
};
typeNames.interfaces["VirtualSriovEthernetCardOption"] = {

};
typeNames.interfaces["VirtualSriovEthernetCardSriovBackingOption"] = {

};
typeNames.interfaces["VirtualTPM"] = {
endorsementKeyCertificateSigningRequest: "Buffer",
        endorsementKeyCertificate: "Buffer"
};
typeNames.interfaces["VirtualTPMOption"] = {
supportedFirmware: "string"
};
typeNames.interfaces["VirtualUSB"] = {
connected: "boolean",
        vendor: "number",
        product: "number",
        family: "string",
        speed: "string"
};
typeNames.interfaces["VirtualUSBRemoteClientBackingInfo"] = {
hostname: "string"
};
typeNames.interfaces["VirtualUSBRemoteHostBackingInfo"] = {
hostname: "string"
};
typeNames.interfaces["VirtualUSBUSBBackingInfo"] = {

};
typeNames.interfaces["VirtualUSBOption"] = {

};
typeNames.interfaces["VirtualUSBRemoteClientBackingOption"] = {

};
typeNames.interfaces["VirtualUSBRemoteHostBackingOption"] = {

};
typeNames.interfaces["VirtualUSBUSBBackingOption"] = {

};
typeNames.interfaces["VirtualMachineVMCIDevice"] = {
id: "number",
        allowUnrestrictedCommunication: "boolean",
        filterEnable: "boolean",
        filterInfo: "VirtualMachineVMCIDeviceFilterInfo"
};
typeNames.interfaces["VirtualMachineVMCIDeviceFilterInfo"] = {
filters: "VirtualMachineVMCIDeviceFilterSpec"
};
typeNames.interfaces["VirtualMachineVMCIDeviceFilterSpec"] = {
rank: "number",
        action: "string",
        protocol: "string",
        direction: "string",
        lowerDstPortBoundary: "number",
        upperDstPortBoundary: "number"
};
typeNames.interfaces["VirtualMachineVMCIDeviceOption"] = {
allowUnrestrictedCommunication: "BoolOption",
        filterSpecOption: "VirtualMachineVMCIDeviceOptionFilterSpecOption",
        filterSupported: "BoolOption"
};
typeNames.interfaces["VirtualMachineVMCIDeviceOptionFilterSpecOption"] = {
action: "ChoiceOption",
        protocol: "ChoiceOption",
        direction: "ChoiceOption",
        lowerDstPortBoundary: "LongOption",
        upperDstPortBoundary: "LongOption"
};
typeNames.interfaces["VirtualMachineVMIROM"] = {

};
typeNames.interfaces["VirtualVMIROMOption"] = {

};
typeNames.interfaces["VirtualMachineVideoCard"] = {
videoRamSizeInKB: "number",
        numDisplays: "number",
        useAutoDetect: "boolean",
        enable3DSupport: "boolean",
        use3dRenderer: "string",
        graphicsMemorySizeInKB: "number"
};
typeNames.interfaces["VirtualVideoCardOption"] = {
videoRamSizeInKB: "LongOption",
        numDisplays: "IntOption",
        useAutoDetect: "BoolOption",
        support3D: "BoolOption",
        use3dRendererSupported: "BoolOption",
        graphicsMemorySizeInKB: "LongOption",
        graphicsMemorySizeSupported: "BoolOption"
};
typeNames.interfaces["VirtualVmxnet"] = {

};
typeNames.interfaces["VirtualVmxnet2"] = {

};
typeNames.interfaces["VirtualVmxnet3"] = {

};
typeNames.interfaces["VirtualVmxnet3Vrdma"] = {
deviceProtocol: "string"
};
typeNames.interfaces["VirtualVmxnetOption"] = {

};
typeNames.interfaces["VirtualWDT"] = {
runOnBoot: "boolean",
        running: "boolean"
};
typeNames.interfaces["VirtualWDTOption"] = {
runOnBoot: "BoolOption"
};
typeNames.interfaces["GuestAliases"] = {
base64Cert: "string",
        aliases: "GuestAuthAliasInfo"
};
typeNames.interfaces["GuestAuthAliasInfo"] = {
subject: "GuestAuthSubject",
        comment: "string"
};
typeNames.interfaces["GuestAuthAnySubject"] = {

};
typeNames.interfaces["GuestAuthNamedSubject"] = {
name: "string"
};
typeNames.interfaces["GuestAuthSubject"] = {

};
typeNames.interfaces["GuestMappedAliases"] = {
base64Cert: "string",
        username: "string",
        subjects: "GuestAuthSubject"
};
typeNames.interfaces["GuestFileAttributes"] = {
modificationTime: "Date",
        accessTime: "Date",
        symlinkTarget: "string"
};
typeNames.interfaces["GuestFileInfo"] = {
path: "string",
        type: "string",
        size: "number",
        attributes: "GuestFileAttributes"
};
typeNames.interfaces["FileTransferInformation"] = {
attributes: "GuestFileAttributes",
        size: "number",
        url: "string"
};
typeNames.interfaces["GuestListFileInfo"] = {
files: "GuestFileInfo",
        remaining: "number"
};
typeNames.interfaces["GuestPosixFileAttributes"] = {
ownerId: "number",
        groupId: "number",
        permissions: "number"
};
typeNames.interfaces["GuestWindowsFileAttributes"] = {
hidden: "boolean",
        readOnly: "boolean",
        createTime: "Date"
};
typeNames.interfaces["GuestAuthentication"] = {
interactiveSession: "boolean"
};
typeNames.interfaces["NamePasswordAuthentication"] = {
username: "string",
        password: "string"
};
typeNames.interfaces["GuestProcessInfo"] = {
name: "string",
        pid: "number",
        owner: "string",
        cmdLine: "string",
        startTime: "Date",
        endTime: "Date",
        exitCode: "number"
};
typeNames.interfaces["GuestProgramSpec"] = {
programPath: "string",
        arguments: "string",
        workingDirectory: "string",
        envVariables: "string"
};
typeNames.interfaces["GuestWindowsProgramSpec"] = {
startMinimized: "boolean"
};
typeNames.interfaces["SAMLTokenAuthentication"] = {
token: "string",
        username: "string"
};
typeNames.interfaces["SSPIAuthentication"] = {
sspiToken: "string"
};
typeNames.interfaces["TicketedSessionAuthentication"] = {
ticket: "string"
};
typeNames.interfaces["GuestRegKeySpec"] = {
keyName: "GuestRegKeyNameSpec",
        classType: "string",
        lastWritten: "Date"
};
typeNames.interfaces["GuestRegKeyNameSpec"] = {
registryPath: "string",
        wowBitness: "string"
};
typeNames.interfaces["GuestRegKeyRecordSpec"] = {
key: "GuestRegKeySpec",
        fault: "MethodFault"
};
typeNames.interfaces["GuestRegValueSpec"] = {
name: "GuestRegValueNameSpec",
        data: "GuestRegValueDataSpec"
};
typeNames.interfaces["GuestRegValueBinarySpec"] = {
value: "Buffer"
};
typeNames.interfaces["GuestRegValueDataSpec"] = {

};
typeNames.interfaces["GuestRegValueDwordSpec"] = {
value: "number"
};
typeNames.interfaces["GuestRegValueExpandStringSpec"] = {
value: "string"
};
typeNames.interfaces["GuestRegValueMultiStringSpec"] = {
value: "string"
};
typeNames.interfaces["GuestRegValueNameSpec"] = {
keyName: "GuestRegKeyNameSpec",
        name: "string"
};
typeNames.interfaces["GuestRegValueQwordSpec"] = {
value: "number"
};
typeNames.interfaces["GuestRegValueStringSpec"] = {
value: "string"
};
typeNames.interfaces["DeviceGroupId"] = {
id: "string"
};
typeNames.interfaces["FaultDomainId"] = {
id: "string"
};
typeNames.interfaces["ReplicationGroupId"] = {
faultDomainId: "FaultDomainId",
        deviceGroupId: "DeviceGroupId"
};
typeNames.interfaces["ReplicationSpec"] = {
replicationGroupId: "ReplicationGroupId"
};
typeNames.interfaces["VsanClusterConfigInfo"] = {
enabled: "boolean",
        defaultConfig: "VsanClusterConfigInfoHostDefaultInfo"
};
typeNames.interfaces["VsanClusterConfigInfoHostDefaultInfo"] = {
uuid: "string",
        autoClaimStorage: "boolean",
        checksumEnabled: "boolean"
};
typeNames.interfaces["VsanHostClusterStatus"] = {
uuid: "string",
        nodeUuid: "string",
        health: "string",
        nodeState: "VsanHostClusterStatusState",
        memberUuid: "string"
};
typeNames.interfaces["VsanHostClusterStatusState"] = {
state: "string",
        completion: "VsanHostClusterStatusStateCompletionEstimate"
};
typeNames.interfaces["VsanHostClusterStatusStateCompletionEstimate"] = {
completeTime: "Date",
        percentComplete: "number"
};
typeNames.interfaces["VsanHostConfigInfo"] = {
enabled: "boolean",
        hostSystem: HostSystem,
        clusterInfo: "VsanHostConfigInfoClusterInfo",
        storageInfo: "VsanHostConfigInfoStorageInfo",
        networkInfo: "VsanHostConfigInfoNetworkInfo",
        faultDomainInfo: "VsanHostFaultDomainInfo"
};
typeNames.interfaces["VsanHostConfigInfoClusterInfo"] = {
uuid: "string",
        nodeUuid: "string"
};
typeNames.interfaces["VsanHostFaultDomainInfo"] = {
name: "string"
};
typeNames.interfaces["VsanHostConfigInfoNetworkInfo"] = {
port: "VsanHostConfigInfoNetworkInfoPortConfig"
};
typeNames.interfaces["VsanHostConfigInfoNetworkInfoPortConfig"] = {
ipConfig: "VsanHostIpConfig",
        device: "string"
};
typeNames.interfaces["VsanHostConfigInfoStorageInfo"] = {
autoClaimStorage: "boolean",
        diskMapping: "VsanHostDiskMapping",
        diskMapInfo: "VsanHostDiskMapInfo",
        checksumEnabled: "boolean"
};
typeNames.interfaces["VsanHostDecommissionMode"] = {
objectAction: "string"
};
typeNames.interfaces["VsanHostDiskMapInfo"] = {
mapping: "VsanHostDiskMapping",
        mounted: "boolean"
};
typeNames.interfaces["VsanHostDiskMapResult"] = {
mapping: "VsanHostDiskMapping",
        diskResult: "VsanHostDiskResult",
        error: "MethodFault"
};
typeNames.interfaces["VsanHostDiskMapping"] = {
ssd: "HostScsiDisk",
        nonSsd: "HostScsiDisk"
};
typeNames.interfaces["VsanHostDiskResult"] = {
disk: "HostScsiDisk",
        state: "string",
        vsanUuid: "string",
        error: "MethodFault",
        degraded: "boolean"
};
typeNames.interfaces["VsanHostIpConfig"] = {
upstreamIpAddress: "string",
        downstreamIpAddress: "string"
};
typeNames.interfaces["VsanHostMembershipInfo"] = {
nodeUuid: "string",
        hostname: "string"
};
typeNames.interfaces["VsanHostVsanDiskInfo"] = {
vsanUuid: "string",
        formatVersion: "number"
};
typeNames.interfaces["VsanHostRuntimeInfo"] = {
membershipList: "VsanHostMembershipInfo",
        diskIssues: "VsanHostRuntimeInfoDiskIssue",
        accessGenNo: "number"
};
typeNames.interfaces["VsanHostRuntimeInfoDiskIssue"] = {
diskId: "string",
        issue: "string"
};
typeNames.interfaces["BaseConfigInfo"] = {
id: "ID",
        name: "string",
        createTime: "Date",
        keepAfterDeleteVm: "boolean",
        relocationDisabled: "boolean",
        nativeSnapshotSupported: "boolean",
        changedBlockTrackingEnabled: "boolean",
        backing: "BaseConfigInfoBackingInfo",
        iofilter: "string"
};
typeNames.interfaces["BaseConfigInfoBackingInfo"] = {
datastore: Datastore
};
typeNames.interfaces["BaseConfigInfoDiskFileBackingInfo"] = {
provisioningType: "string"
};
typeNames.interfaces["BaseConfigInfoFileBackingInfo"] = {
filePath: "string",
        backingObjectId: "string",
        parent: "BaseConfigInfoFileBackingInfo",
        deltaSizeInMB: "number",
        keyId: "CryptoKeyId"
};
typeNames.interfaces["BaseConfigInfoRawDiskMappingBackingInfo"] = {
lunUuid: "string",
        compatibilityMode: "string"
};
typeNames.interfaces["VslmCreateSpec"] = {
name: "string",
        keepAfterDeleteVm: "boolean",
        backingSpec: "VslmCreateSpecBackingSpec",
        capacityInMB: "number",
        profile: "VirtualMachineProfileSpec",
        crypto: "CryptoSpec",
        metadata: "KeyValue"
};
typeNames.interfaces["VslmCreateSpecBackingSpec"] = {
datastore: Datastore,
        path: "string"
};
typeNames.interfaces["VslmCreateSpecDiskFileBackingSpec"] = {
provisioningType: "string"
};
typeNames.interfaces["VslmCreateSpecRawDiskMappingBackingSpec"] = {
lunUuid: "string",
        compatibilityMode: "string"
};
typeNames.interfaces["DiskCryptoSpec"] = {
parent: "DiskCryptoSpec",
        crypto: "CryptoSpec"
};
typeNames.interfaces["ID"] = {
id: "string"
};
typeNames.interfaces["vslmInfrastructureObjectPolicy"] = {
name: "string",
        backingObjectId: "string",
        profileId: "string",
        error: "MethodFault"
};
typeNames.interfaces["vslmInfrastructureObjectPolicySpec"] = {
datastore: Datastore,
        profile: "VirtualMachineProfileSpec"
};
typeNames.interfaces["VslmMigrateSpec"] = {
backingSpec: "VslmCreateSpecBackingSpec",
        profile: "VirtualMachineProfileSpec",
        consolidate: "boolean",
        disksCrypto: "DiskCryptoSpec"
};
typeNames.interfaces["VslmRelocateSpec"] = {

};
typeNames.interfaces["VStorageObjectStateInfo"] = {
tentative: "boolean"
};
typeNames.interfaces["VslmTagEntry"] = {
tagName: "string",
        parentCategoryName: "string"
};
typeNames.interfaces["VStorageObject"] = {
config: "VStorageObjectConfigInfo"
};
typeNames.interfaces["VStorageObjectConfigInfo"] = {
capacityInMB: "number",
        consumptionType: "string",
        consumerId: "ID"
};
typeNames.interfaces["VStorageObjectSnapshotDetails"] = {
path: "string",
        changedBlockTrackingId: "string"
};
typeNames.interfaces["VStorageObjectSnapshotInfo"] = {
snapshots: "VStorageObjectSnapshotInfoVStorageObjectSnapshot"
};
typeNames.interfaces["VStorageObjectSnapshotInfoVStorageObjectSnapshot"] = {
id: "ID",
        backingObjectId: "string",
        createTime: "Date",
        description: "string"
};
typeNames.interfaces["RetrieveVStorageObjSpec"] = {
id: "ID",
        datastore: Datastore
};
typeNames.interfaces["VStorageObjectAssociations"] = {
id: "ID",
        vmDiskAssociations: "VStorageObjectAssociationsVmDiskAssociations",
        fault: "MethodFault"
};
typeNames.interfaces["VStorageObjectAssociationsVmDiskAssociations"] = {
vmId: "string",
        diskKey: "number"
};
typeNames.interfaces["EntityPrivilege"] = {
entity: ManagedEntity,
        privAvailability: "PrivilegeAvailability"
};
typeNames.interfaces["Permission"] = {
entity: ManagedEntity,
        principal: "string",
        group: "boolean",
        roleId: "number",
        propagate: "boolean"
};
typeNames.interfaces["AuthorizationPrivilege"] = {
privId: "string",
        onParent: "boolean",
        name: "string",
        privGroupName: "string"
};
typeNames.interfaces["PrivilegeAvailability"] = {
privId: "string",
        isGranted: "boolean"
};
typeNames.interfaces["AuthorizationRole"] = {
roleId: "number",
        system: "boolean",
        name: "string",
        info: "Description",
        privilege: "string"
};
typeNames.interfaces["UserPrivilegeResult"] = {
entity: ManagedEntity,
        privileges: "string"
};
typeNames.interfaces["BoolPolicy"] = {
value: "boolean"
};
typeNames.interfaces["EVCMode"] = {
guaranteedCPUFeatures: "HostCpuIdInfo",
        featureCapability: "HostFeatureCapability",
        featureMask: "HostFeatureMask",
        featureRequirement: "VirtualMachineFeatureRequirement",
        vendor: "string",
        track: "string",
        vendorTier: "number"
};
typeNames.interfaces["ImportSpec"] = {
entityConfig: "VAppEntityConfigInfo",
        instantiationOst: "OvfConsumerOstNode"
};
typeNames.interfaces["IntExpression"] = {
value: "number"
};
typeNames.interfaces["IpAddress"] = {

};
typeNames.interfaces["IpRange"] = {
addressPrefix: "string",
        prefixLength: "number"
};
typeNames.interfaces["LicenseAssignmentManagerLicenseAssignment"] = {
entityId: "string",
        scope: "string",
        entityDisplayName: "string",
        assignedLicense: "LicenseManagerLicenseInfo",
        properties: "KeyAnyValue"
};
typeNames.interfaces["MacAddress"] = {

};
typeNames.interfaces["MacRange"] = {
address: "string",
        mask: "string"
};
typeNames.interfaces["NetworkSummary"] = {
network: Network,
        name: "string",
        accessible: "boolean",
        ipPoolName: "string",
        ipPoolId: "number"
};
typeNames.interfaces["OpaqueNetworkCapability"] = {
networkReservationSupported: "boolean"
};
typeNames.interfaces["OpaqueNetworkSummary"] = {
opaqueNetworkId: "string",
        opaqueNetworkType: "string"
};
typeNames.interfaces["PosixUserSearchResult"] = {
id: "number",
        shellAccess: "boolean"
};
typeNames.interfaces["ResourcePoolResourceUsage"] = {
reservationUsed: "number",
        reservationUsedForVm: "number",
        unreservedForPool: "number",
        unreservedForVm: "number",
        overallUsage: "number",
        maxUsage: "number"
};
typeNames.interfaces["ResourcePoolRuntimeInfo"] = {
memory: "ResourcePoolResourceUsage",
        cpu: "ResourcePoolResourceUsage",
        overallStatus: "ManagedEntityStatus",
        sharesScalable: "string"
};
typeNames.interfaces["ResourcePoolSummary"] = {
name: "string",
        config: "ResourceConfigSpec",
        runtime: "ResourcePoolRuntimeInfo",
        quickStats: "ResourcePoolQuickStats",
        configuredMemoryMB: "number"
};
typeNames.interfaces["ResourcePoolQuickStats"] = {
overallCpuUsage: "number",
        overallCpuDemand: "number",
        guestMemoryUsage: "number",
        hostMemoryUsage: "number",
        distributedCpuEntitlement: "number",
        distributedMemoryEntitlement: "number",
        staticCpuEntitlement: "number",
        staticMemoryEntitlement: "number",
        privateMemory: "number",
        sharedMemory: "number",
        swappedMemory: "number",
        balloonedMemory: "number",
        overheadMemory: "number",
        consumedOverheadMemory: "number",
        compressedMemory: "number"
};
typeNames.interfaces["SingleIp"] = {
address: "string"
};
typeNames.interfaces["SingleMac"] = {
address: "string"
};
typeNames.interfaces["TaskFilterSpec"] = {
entity: "TaskFilterSpecByEntity",
        time: "TaskFilterSpecByTime",
        userName: "TaskFilterSpecByUsername",
        activationId: "string",
        state: "TaskInfoState",
        alarm: Alarm,
        scheduledTask: ScheduledTask,
        eventChainId: "number",
        tag: "string",
        parentTaskKey: "string",
        rootTaskKey: "string"
};
typeNames.interfaces["TaskFilterSpecByEntity"] = {
entity: ManagedEntity,
        recursion: "TaskFilterSpecRecursionOption"
};
typeNames.interfaces["TaskFilterSpecByTime"] = {
timeType: "TaskFilterSpecTimeOption",
        beginTime: "Date",
        endTime: "Date"
};
typeNames.interfaces["TaskFilterSpecByUsername"] = {
systemUser: "boolean",
        userList: "string"
};
typeNames.interfaces["VirtualAppLinkInfo"] = {
key: ManagedEntity,
        destroyWithParent: "boolean"
};
typeNames.interfaces["VirtualAppSummary"] = {
product: "VAppProductInfo",
        vAppState: "VirtualAppVAppState",
        suspended: "boolean",
        installBootRequired: "boolean",
        instanceUuid: "string"
};
typeNames.interfaces["DeviceBackedVirtualDiskSpec"] = {
device: "string"
};
typeNames.interfaces["FileBackedVirtualDiskSpec"] = {
capacityKb: "number",
        profile: "VirtualMachineProfileSpec",
        crypto: "CryptoSpec"
};
typeNames.interfaces["SeSparseVirtualDiskSpec"] = {
grainSizeKb: "number"
};
typeNames.interfaces["VirtualDiskSpec"] = {
diskType: "string",
        adapterType: "string"
};
typeNames.interfaces["VirtualMachineConnection"] = {
label: "string",
        client: "string",
        userName: "string"
};
typeNames.interfaces["DiskChangeInfo"] = {
startOffset: "number",
        length: "number",
        changedArea: "DiskChangeExtent"
};
typeNames.interfaces["DiskChangeExtent"] = {
start: "number",
        length: "number"
};
typeNames.interfaces["VirtualMachineDisplayTopology"] = {
x: "number",
        y: "number",
        width: "number",
        height: "number"
};
typeNames.interfaces["VirtualMachineMksConnection"] = {

};
typeNames.interfaces["VirtualMachineMksTicket"] = {
ticket: "string",
        cfgFile: "string",
        host: "string",
        port: "number",
        sslThumbprint: "string"
};
typeNames.interfaces["StorageRequirement"] = {
datastore: Datastore,
        freeSpaceRequiredInKb: "number"
};
typeNames.interfaces["VirtualMachineTicket"] = {
ticket: "string",
        cfgFile: "string",
        host: "string",
        port: "number",
        sslThumbprint: "string",
        url: "string"
};
typeNames.interfaces["VirtualMachineWipeResult"] = {
diskId: "number",
        shrinkableDiskSpace: "number"
};
typeNames.interfaces["AlarmFilterSpec"] = {
status: "ManagedEntityStatus",
        typeEntity: "string",
        typeTrigger: "string"
};
typeNames.interfaces["AlarmInfo"] = {
key: "string",
        alarm: Alarm,
        entity: ManagedEntity,
        lastModifiedTime: "Date",
        lastModifiedUser: "string",
        creationEventId: "number"
};
typeNames.interfaces["AlarmState"] = {
key: "string",
        entity: ManagedEntity,
        alarm: Alarm,
        overallStatus: "ManagedEntityStatus",
        time: "Date",
        acknowledged: "boolean",
        acknowledgedByUser: "string",
        acknowledgedTime: "Date",
        eventKey: "number",
        disabled: "boolean"
};
typeNames.interfaces["AlarmTriggeringAction"] = {
action: "Action",
        transitionSpecs: "AlarmTriggeringActionTransitionSpec",
        green2yellow: "boolean",
        yellow2red: "boolean",
        red2yellow: "boolean",
        yellow2green: "boolean"
};
typeNames.interfaces["AlarmTriggeringActionTransitionSpec"] = {
startState: "ManagedEntityStatus",
        finalState: "ManagedEntityStatus",
        repeats: "boolean"
};
typeNames.interfaces["EventAlarmExpression"] = {
comparisons: "EventAlarmExpressionComparison",
        eventType: "string",
        eventTypeId: "string",
        objectType: "string",
        status: "ManagedEntityStatus"
};
typeNames.interfaces["EventAlarmExpressionComparison"] = {
attributeName: "string",
        operator: "string",
        value: "string"
};
typeNames.interfaces["ClusterDasAamHostInfo"] = {
hostDasState: "ClusterDasAamNodeState",
        primaryHosts: "string"
};
typeNames.interfaces["ClusterDasVmConfigSpec"] = {
info: "ClusterDasVmConfigInfo"
};
typeNames.interfaces["ClusterDpmHostConfigSpec"] = {
info: "ClusterDpmHostConfigInfo"
};
typeNames.interfaces["ClusterDrsVmConfigSpec"] = {
info: "ClusterDrsVmConfigInfo"
};
typeNames.interfaces["ClusterFailoverHostAdmissionControlInfo"] = {
hostStatus: "ClusterFailoverHostAdmissionControlInfoHostStatus"
};
typeNames.interfaces["ClusterFailoverHostAdmissionControlInfoHostStatus"] = {
host: HostSystem,
        status: "ManagedEntityStatus"
};
typeNames.interfaces["ClusterFixedSizeSlotPolicy"] = {
cpu: "number",
        memory: "number"
};
typeNames.interfaces["ClusterGroupSpec"] = {
info: "ClusterGroupInfo"
};
typeNames.interfaces["PlacementSpec"] = {
priority: "VirtualMachineMovePriority",
        vm: VirtualMachine,
        configSpec: "VirtualMachineConfigSpec",
        relocateSpec: "VirtualMachineRelocateSpec",
        hosts: HostSystem,
        datastores: Datastore,
        storagePods: StoragePod,
        disallowPrerequisiteMoves: "boolean",
        rules: "ClusterRuleInfo",
        key: "string",
        placementType: "string",
        cloneSpec: "VirtualMachineCloneSpec",
        cloneName: "string"
};
typeNames.interfaces["ClusterRuleInfo"] = {
key: "number",
        status: "ManagedEntityStatus",
        enabled: "boolean",
        name: "string",
        mandatory: "boolean",
        userCreated: "boolean",
        inCompliance: "boolean",
        ruleUuid: "string"
};
typeNames.interfaces["ClusterRuleSpec"] = {
info: "ClusterRuleInfo"
};
typeNames.interfaces["ClusterVmHostRuleInfo"] = {
vmGroupName: "string",
        affineHostGroupName: "string",
        antiAffineHostGroupName: "string"
};
typeNames.interfaces["ClusterVmOrchestrationSpec"] = {
info: "ClusterVmOrchestrationInfo"
};
typeNames.interfaces["DVPortgroupConfigInfo"] = {
key: "string",
        name: "string",
        numPorts: "number",
        distributedVirtualSwitch: DistributedVirtualSwitch,
        defaultPortConfig: "DVPortSetting",
        description: "string",
        type: "string",
        backingType: "string",
        policy: "DVPortgroupPolicy",
        portNameFormat: "string",
        scope: ManagedEntity,
        vendorSpecificConfig: "DistributedVirtualSwitchKeyedOpaqueBlob",
        configVersion: "string",
        autoExpand: "boolean",
        vmVnicNetworkResourcePoolKey: "string",
        uplink: "boolean",
        transportZoneUuid: "string",
        transportZoneName: "string",
        logicalSwitchUuid: "string",
        segmentId: "string"
};
typeNames.interfaces["DVPortgroupConfigSpec"] = {
configVersion: "string",
        name: "string",
        numPorts: "number",
        portNameFormat: "string",
        defaultPortConfig: "DVPortSetting",
        description: "string",
        type: "string",
        backingType: "string",
        scope: ManagedEntity,
        policy: "DVPortgroupPolicy",
        vendorSpecificConfig: "DistributedVirtualSwitchKeyedOpaqueBlob",
        autoExpand: "boolean",
        vmVnicNetworkResourcePoolKey: "string",
        transportZoneUuid: "string",
        transportZoneName: "string",
        logicalSwitchUuid: "string",
        segmentId: "string"
};
typeNames.interfaces["DistributedVirtualPortgroupNsxPortgroupOperationResult"] = {
portgroups: DistributedVirtualPortgroup,
        problems: "DistributedVirtualPortgroupProblem"
};
typeNames.interfaces["DVPortgroupPolicy"] = {
blockOverrideAllowed: "boolean",
        shapingOverrideAllowed: "boolean",
        vendorConfigOverrideAllowed: "boolean",
        livePortMovingAllowed: "boolean",
        portConfigResetAtDisconnect: "boolean",
        networkResourcePoolOverrideAllowed: "boolean",
        trafficFilterOverrideAllowed: "boolean"
};
typeNames.interfaces["DistributedVirtualPortgroupProblem"] = {
logicalSwitchUuid: "string",
        fault: "MethodFault"
};
typeNames.interfaces["CryptoManagerKmipCertificateInfo"] = {
subject: "string",
        issuer: "string",
        serialNumber: "string",
        notBefore: "Date",
        notAfter: "Date",
        fingerprint: "string",
        checkTime: "Date",
        secondsSinceValid: "number",
        secondsBeforeExpire: "number"
};
typeNames.interfaces["CryptoManagerKmipClusterStatus"] = {
clusterId: "KeyProviderId",
        overallStatus: "ManagedEntityStatus",
        managementType: "string",
        servers: "CryptoManagerKmipServerStatus",
        clientCertInfo: "CryptoManagerKmipCertificateInfo"
};
typeNames.interfaces["CryptoManagerKmipCryptoKeyStatus"] = {
keyId: "CryptoKeyId",
        keyAvailable: "boolean",
        reason: "string",
        encryptedVMs: VirtualMachine,
        affectedHosts: HostSystem,
        referencedByTags: "string"
};
typeNames.interfaces["CryptoManagerKmipServerCertInfo"] = {
certificate: "string",
        certInfo: "CryptoManagerKmipCertificateInfo",
        clientTrustServer: "boolean"
};
typeNames.interfaces["CryptoManagerKmipServerStatus"] = {
name: "string",
        status: "ManagedEntityStatus",
        connectionStatus: "string",
        certInfo: "CryptoManagerKmipCertificateInfo",
        clientTrustServer: "boolean",
        serverTrustClient: "boolean"
};
typeNames.interfaces["KmipServerStatus"] = {
clusterId: "KeyProviderId",
        name: "string",
        status: "ManagedEntityStatus",
        description: "string"
};
typeNames.interfaces["AccountCreatedEvent"] = {
spec: "HostAccountSpec",
        group: "boolean"
};
typeNames.interfaces["AccountRemovedEvent"] = {
account: "string",
        group: "boolean"
};
typeNames.interfaces["AccountUpdatedEvent"] = {
spec: "HostAccountSpec",
        group: "boolean",
        prevDescription: "string"
};
typeNames.interfaces["AdminPasswordNotChangedEvent"] = {

};
typeNames.interfaces["AlarmEvent"] = {
alarm: "AlarmEventArgument"
};
typeNames.interfaces["AlarmReconfiguredEvent"] = {
entity: "ManagedEntityEventArgument",
        configChanges: "ChangesInfoEventArgument"
};
typeNames.interfaces["AlarmRemovedEvent"] = {
entity: "ManagedEntityEventArgument"
};
typeNames.interfaces["AlarmScriptCompleteEvent"] = {
entity: "ManagedEntityEventArgument",
        script: "string"
};
typeNames.interfaces["AlarmScriptFailedEvent"] = {
entity: "ManagedEntityEventArgument",
        script: "string",
        reason: "MethodFault"
};
typeNames.interfaces["AlarmSnmpCompletedEvent"] = {
entity: "ManagedEntityEventArgument"
};
typeNames.interfaces["AlarmSnmpFailedEvent"] = {
entity: "ManagedEntityEventArgument",
        reason: "MethodFault"
};
typeNames.interfaces["AlarmStatusChangedEvent"] = {
source: "ManagedEntityEventArgument",
        entity: "ManagedEntityEventArgument",
        from: "string",
        to: "string"
};
typeNames.interfaces["AllVirtualMachinesLicensedEvent"] = {

};
typeNames.interfaces["AlreadyAuthenticatedSessionEvent"] = {

};
typeNames.interfaces["AuthorizationEvent"] = {

};
typeNames.interfaces["BadUsernameSessionEvent"] = {
ipAddress: "string"
};
typeNames.interfaces["CanceledHostOperationEvent"] = {

};
typeNames.interfaces["ClusterEvent"] = {

};
typeNames.interfaces["ClusterOvercommittedEvent"] = {

};
typeNames.interfaces["ClusterReconfiguredEvent"] = {
configChanges: "ChangesInfoEventArgument"
};
typeNames.interfaces["ClusterStatusChangedEvent"] = {
oldStatus: "string",
        newStatus: "string"
};
typeNames.interfaces["CustomFieldEvent"] = {

};
typeNames.interfaces["CustomFieldValueChangedEvent"] = {
entity: "ManagedEntityEventArgument",
        fieldKey: "number",
        name: "string",
        value: "string",
        prevState: "string"
};
typeNames.interfaces["CustomizationEvent"] = {
logLocation: "string"
};
typeNames.interfaces["CustomizationFailed"] = {
reason: "string"
};
typeNames.interfaces["CustomizationLinuxIdentityFailed"] = {

};
typeNames.interfaces["CustomizationNetworkSetupFailed"] = {

};
typeNames.interfaces["CustomizationStartedEvent"] = {

};
typeNames.interfaces["CustomizationSucceeded"] = {

};
typeNames.interfaces["CustomizationSysprepFailed"] = {
sysprepVersion: "string",
        systemVersion: "string"
};
typeNames.interfaces["CustomizationUnknownFailure"] = {

};
typeNames.interfaces["DVPortgroupEvent"] = {

};
typeNames.interfaces["DVPortgroupReconfiguredEvent"] = {
configSpec: "DVPortgroupConfigSpec",
        configChanges: "ChangesInfoEventArgument"
};
typeNames.interfaces["DVPortgroupRenamedEvent"] = {
oldName: "string",
        newName: "string"
};
typeNames.interfaces["DasAdmissionControlDisabledEvent"] = {

};
typeNames.interfaces["DasAdmissionControlEnabledEvent"] = {

};
typeNames.interfaces["DasAgentFoundEvent"] = {

};
typeNames.interfaces["DasAgentUnavailableEvent"] = {

};
typeNames.interfaces["DasClusterIsolatedEvent"] = {

};
typeNames.interfaces["DasDisabledEvent"] = {

};
typeNames.interfaces["DasEnabledEvent"] = {

};
typeNames.interfaces["DasHostFailedEvent"] = {
failedHost: "HostEventArgument"
};
typeNames.interfaces["DasHostIsolatedEvent"] = {
isolatedHost: "HostEventArgument"
};
typeNames.interfaces["DatacenterEvent"] = {

};
typeNames.interfaces["DatacenterRenamedEvent"] = {
oldName: "string",
        newName: "string"
};
typeNames.interfaces["DatastoreDiscoveredEvent"] = {
datastore: "DatastoreEventArgument"
};
typeNames.interfaces["DatastoreEvent"] = {
datastore: "DatastoreEventArgument"
};
typeNames.interfaces["DatastoreFileEvent"] = {
targetFile: "string",
        sourceOfOperation: "string",
        succeeded: "boolean"
};
typeNames.interfaces["DatastoreFileMovedEvent"] = {
sourceDatastore: "DatastoreEventArgument",
        sourceFile: "string"
};
typeNames.interfaces["DatastoreIORMReconfiguredEvent"] = {

};
typeNames.interfaces["DatastorePrincipalConfigured"] = {
datastorePrincipal: "string"
};
typeNames.interfaces["DatastoreRemovedOnHostEvent"] = {
datastore: "DatastoreEventArgument"
};
typeNames.interfaces["DatastoreRenamedEvent"] = {
oldName: "string",
        newName: "string"
};
typeNames.interfaces["DatastoreRenamedOnHostEvent"] = {
oldName: "string",
        newName: "string"
};
typeNames.interfaces["DrsDisabledEvent"] = {

};
typeNames.interfaces["DrsEnabledEvent"] = {
behavior: "string"
};
typeNames.interfaces["DrsInvocationFailedEvent"] = {

};
typeNames.interfaces["DrsRecoveredFromFailureEvent"] = {

};
typeNames.interfaces["DrsResourceConfigureFailedEvent"] = {
reason: "MethodFault"
};
typeNames.interfaces["DrsResourceConfigureSyncedEvent"] = {

};
typeNames.interfaces["DrsRuleComplianceEvent"] = {

};
typeNames.interfaces["DrsRuleViolationEvent"] = {

};
typeNames.interfaces["DrsSoftRuleViolationEvent"] = {

};
typeNames.interfaces["DrsVmMigratedEvent"] = {

};
typeNames.interfaces["DrsVmPoweredOnEvent"] = {

};
typeNames.interfaces["DuplicateIpDetectedEvent"] = {
duplicateIP: "string",
        macAddress: "string"
};
typeNames.interfaces["DvpgImportEvent"] = {
importType: "string"
};
typeNames.interfaces["DvpgRestoreEvent"] = {

};
typeNames.interfaces["DvsEvent"] = {

};
typeNames.interfaces["DvsHealthStatusChangeEvent"] = {
switchUuid: "string",
        healthResult: "HostMemberHealthCheckResult"
};
typeNames.interfaces["DvsHostBackInSyncEvent"] = {
hostBackInSync: "HostEventArgument"
};
typeNames.interfaces["DvsHostJoinedEvent"] = {
hostJoined: "HostEventArgument"
};
typeNames.interfaces["DvsHostLeftEvent"] = {
hostLeft: "HostEventArgument"
};
typeNames.interfaces["DvsHostStatusUpdated"] = {
hostMember: "HostEventArgument",
        oldStatus: "string",
        newStatus: "string",
        oldStatusDetail: "string",
        newStatusDetail: "string"
};
typeNames.interfaces["DvsHostWentOutOfSyncEvent"] = {
hostOutOfSync: "DvsOutOfSyncHostArgument"
};
typeNames.interfaces["DvsImportEvent"] = {
importType: "string"
};
typeNames.interfaces["DvsMergedEvent"] = {
sourceDvs: "DvsEventArgument",
        destinationDvs: "DvsEventArgument"
};
typeNames.interfaces["DvsPortBlockedEvent"] = {
portKey: "string",
        statusDetail: "string",
        runtimeInfo: "DVPortStatus",
        prevBlockState: "string"
};
typeNames.interfaces["DvsPortConnectedEvent"] = {
portKey: "string",
        connectee: "DistributedVirtualSwitchPortConnectee"
};
typeNames.interfaces["DvsPortCreatedEvent"] = {
portKey: "string"
};
typeNames.interfaces["DvsPortDeletedEvent"] = {
portKey: "string"
};
typeNames.interfaces["DvsPortDisconnectedEvent"] = {
portKey: "string",
        connectee: "DistributedVirtualSwitchPortConnectee"
};
typeNames.interfaces["DvsPortEnteredPassthruEvent"] = {
portKey: "string",
        runtimeInfo: "DVPortStatus"
};
typeNames.interfaces["DvsPortExitedPassthruEvent"] = {
portKey: "string",
        runtimeInfo: "DVPortStatus"
};
typeNames.interfaces["DvsPortJoinPortgroupEvent"] = {
portKey: "string",
        portgroupKey: "string",
        portgroupName: "string"
};
typeNames.interfaces["DvsPortLeavePortgroupEvent"] = {
portKey: "string",
        portgroupKey: "string",
        portgroupName: "string"
};
typeNames.interfaces["DvsPortLinkDownEvent"] = {
portKey: "string",
        runtimeInfo: "DVPortStatus"
};
typeNames.interfaces["DvsPortLinkUpEvent"] = {
portKey: "string",
        runtimeInfo: "DVPortStatus"
};
typeNames.interfaces["DvsPortReconfiguredEvent"] = {
portKey: "string",
        configChanges: "ChangesInfoEventArgument"
};
typeNames.interfaces["DvsPortRuntimeChangeEvent"] = {
portKey: "string",
        runtimeInfo: "DVPortStatus"
};
typeNames.interfaces["DvsPortUnblockedEvent"] = {
portKey: "string",
        runtimeInfo: "DVPortStatus",
        prevBlockState: "string"
};
typeNames.interfaces["DvsPortVendorSpecificStateChangeEvent"] = {
portKey: "string"
};
typeNames.interfaces["DvsRenamedEvent"] = {
oldName: "string",
        newName: "string"
};
typeNames.interfaces["DvsRestoreEvent"] = {

};
typeNames.interfaces["DvsUpgradeAvailableEvent"] = {
productInfo: "DistributedVirtualSwitchProductSpec"
};
typeNames.interfaces["DvsUpgradeInProgressEvent"] = {
productInfo: "DistributedVirtualSwitchProductSpec"
};
typeNames.interfaces["DvsUpgradeRejectedEvent"] = {
productInfo: "DistributedVirtualSwitchProductSpec"
};
typeNames.interfaces["DvsUpgradedEvent"] = {
productInfo: "DistributedVirtualSwitchProductSpec"
};
typeNames.interfaces["EnteredMaintenanceModeEvent"] = {

};
typeNames.interfaces["EnteredStandbyModeEvent"] = {

};
typeNames.interfaces["EnteringMaintenanceModeEvent"] = {

};
typeNames.interfaces["EnteringStandbyModeEvent"] = {

};
typeNames.interfaces["EntityEventArgument"] = {
name: "string"
};
typeNames.interfaces["ErrorUpgradeEvent"] = {

};
typeNames.interfaces["ExitMaintenanceModeEvent"] = {

};
typeNames.interfaces["ExitStandbyModeFailedEvent"] = {

};
typeNames.interfaces["ExitedStandbyModeEvent"] = {

};
typeNames.interfaces["ExitingStandbyModeEvent"] = {

};
typeNames.interfaces["ExtendedEvent"] = {
eventTypeId: "string",
        managedObject: "ManagedObject",
        data: "ExtendedEventPair"
};
typeNames.interfaces["ExtendedEventPair"] = {
key: "string",
        value: "string"
};
typeNames.interfaces["FailoverLevelRestored"] = {

};
typeNames.interfaces["FolderEventArgument"] = {
folder: Folder
};
typeNames.interfaces["GhostDvsProxySwitchDetectedEvent"] = {
switchUuid: "string"
};
typeNames.interfaces["GhostDvsProxySwitchRemovedEvent"] = {
switchUuid: "string"
};
typeNames.interfaces["GlobalMessageChangedEvent"] = {
message: "string",
        prevMessage: "string"
};
typeNames.interfaces["HostAddFailedEvent"] = {
hostname: "string"
};
typeNames.interfaces["HostAddedEvent"] = {

};
typeNames.interfaces["HostAdminDisableEvent"] = {

};
typeNames.interfaces["HostAdminEnableEvent"] = {

};
typeNames.interfaces["HostCnxFailedAccountFailedEvent"] = {

};
typeNames.interfaces["HostCnxFailedAlreadyManagedEvent"] = {
serverName: "string"
};
typeNames.interfaces["HostCnxFailedBadCcagentEvent"] = {

};
typeNames.interfaces["HostCnxFailedBadUsernameEvent"] = {

};
typeNames.interfaces["HostCnxFailedBadVersionEvent"] = {

};
typeNames.interfaces["HostCnxFailedCcagentUpgradeEvent"] = {

};
typeNames.interfaces["HostCnxFailedEvent"] = {

};
typeNames.interfaces["HostCnxFailedNetworkErrorEvent"] = {

};
typeNames.interfaces["HostCnxFailedNoAccessEvent"] = {

};
typeNames.interfaces["HostCnxFailedNoConnectionEvent"] = {

};
typeNames.interfaces["HostCnxFailedNoLicenseEvent"] = {

};
typeNames.interfaces["HostCnxFailedNotFoundEvent"] = {

};
typeNames.interfaces["HostCnxFailedTimeoutEvent"] = {

};
typeNames.interfaces["HostComplianceCheckedEvent"] = {
profile: "ProfileEventArgument"
};
typeNames.interfaces["HostCompliantEvent"] = {

};
typeNames.interfaces["HostConfigAppliedEvent"] = {

};
typeNames.interfaces["HostConnectedEvent"] = {

};
typeNames.interfaces["HostConnectionLostEvent"] = {

};
typeNames.interfaces["HostDasDisabledEvent"] = {

};
typeNames.interfaces["HostDasDisablingEvent"] = {

};
typeNames.interfaces["HostDasEnabledEvent"] = {

};
typeNames.interfaces["HostDasEnablingEvent"] = {

};
typeNames.interfaces["HostDasErrorEvent"] = {
message: "string",
        reason: "string"
};
typeNames.interfaces["HostDasEvent"] = {

};
typeNames.interfaces["HostDasOkEvent"] = {

};
typeNames.interfaces["HostDisconnectedEvent"] = {
reason: "string"
};
typeNames.interfaces["HostEnableAdminFailedEvent"] = {
permissions: "Permission"
};
typeNames.interfaces["HostEventArgument"] = {
host: HostSystem
};
typeNames.interfaces["HostExtraNetworksEvent"] = {
ips: "string"
};
typeNames.interfaces["HostInventoryFullEvent"] = {
capacity: "number"
};
typeNames.interfaces["HostIsolationIpPingFailedEvent"] = {
isolationIp: "string"
};
typeNames.interfaces["HostLicenseExpiredEvent"] = {

};
typeNames.interfaces["HostLocalPortCreatedEvent"] = {
hostLocalPort: "DVSHostLocalPortInfo"
};
typeNames.interfaces["HostMissingNetworksEvent"] = {
ips: "string"
};
typeNames.interfaces["HostMonitoringStateChangedEvent"] = {
state: "string",
        prevState: "string"
};
typeNames.interfaces["HostNoAvailableNetworksEvent"] = {
ips: "string"
};
typeNames.interfaces["HostNoHAEnabledPortGroupsEvent"] = {

};
typeNames.interfaces["HostNoRedundantManagementNetworkEvent"] = {

};
typeNames.interfaces["HostNotInClusterEvent"] = {

};
typeNames.interfaces["HostOvercommittedEvent"] = {

};
typeNames.interfaces["HostPrimaryAgentNotShortNameEvent"] = {
primaryAgent: "string"
};
typeNames.interfaces["HostShortNameInconsistentEvent"] = {
shortName: "string",
        shortName2: "string"
};
typeNames.interfaces["HostStatusChangedEvent"] = {

};
typeNames.interfaces["IncorrectHostInformationEvent"] = {

};
typeNames.interfaces["InfoUpgradeEvent"] = {

};
typeNames.interfaces["InsufficientFailoverResourcesEvent"] = {

};
typeNames.interfaces["InvalidEditionEvent"] = {
feature: "string"
};
typeNames.interfaces["ManagedEntityEventArgument"] = {
entity: ManagedEntity
};
typeNames.interfaces["MigrationEvent"] = {
fault: "MethodFault"
};
typeNames.interfaces["MigrationHostErrorEvent"] = {
dstHost: "HostEventArgument"
};
typeNames.interfaces["MigrationHostWarningEvent"] = {
dstHost: "HostEventArgument"
};
typeNames.interfaces["MigrationResourceErrorEvent"] = {
dstPool: "ResourcePoolEventArgument",
        dstHost: "HostEventArgument"
};
typeNames.interfaces["MigrationResourceWarningEvent"] = {
dstPool: "ResourcePoolEventArgument",
        dstHost: "HostEventArgument"
};
typeNames.interfaces["MigrationWarningEvent"] = {

};
typeNames.interfaces["MtuMatchEvent"] = {

};
typeNames.interfaces["MtuMismatchEvent"] = {

};
typeNames.interfaces["NetworkEventArgument"] = {
network: Network
};
typeNames.interfaces["NoAccessUserEvent"] = {
ipAddress: "string"
};
typeNames.interfaces["NoMaintenanceModeDrsRecommendationForVM"] = {

};
typeNames.interfaces["NonVIWorkloadDetectedOnDatastoreEvent"] = {

};
typeNames.interfaces["NotEnoughResourcesToStartVmEvent"] = {
reason: "string"
};
typeNames.interfaces["OutOfSyncDvsHost"] = {
hostOutOfSync: "DvsOutOfSyncHostArgument"
};
typeNames.interfaces["PermissionEvent"] = {
entity: "ManagedEntityEventArgument",
        principal: "string",
        group: "boolean"
};
typeNames.interfaces["PermissionRemovedEvent"] = {

};
typeNames.interfaces["PermissionUpdatedEvent"] = {
role: "RoleEventArgument",
        propagate: "boolean",
        prevRole: "RoleEventArgument",
        prevPropagate: "boolean"
};
typeNames.interfaces["ProfileAssociatedEvent"] = {

};
typeNames.interfaces["ProfileChangedEvent"] = {

};
typeNames.interfaces["ProfileCreatedEvent"] = {

};
typeNames.interfaces["ProfileDissociatedEvent"] = {

};
typeNames.interfaces["RecoveryEvent"] = {
hostName: "string",
        portKey: "string",
        dvsUuid: "string",
        vnic: "string"
};
typeNames.interfaces["ResourcePoolCreatedEvent"] = {
parent: "ResourcePoolEventArgument"
};
typeNames.interfaces["ResourcePoolDestroyedEvent"] = {

};
typeNames.interfaces["ResourcePoolEventArgument"] = {
resourcePool: ResourcePool
};
typeNames.interfaces["RoleEvent"] = {
role: "RoleEventArgument"
};
typeNames.interfaces["RoleRemovedEvent"] = {

};
typeNames.interfaces["RoleUpdatedEvent"] = {
privilegeList: "string",
        prevRoleName: "string",
        privilegesAdded: "string",
        privilegesRemoved: "string"
};
typeNames.interfaces["RollbackEvent"] = {
hostName: "string",
        methodName: "string"
};
typeNames.interfaces["ScheduledTaskCompletedEvent"] = {

};
typeNames.interfaces["ScheduledTaskCreatedEvent"] = {

};
typeNames.interfaces["ScheduledTaskEmailCompletedEvent"] = {
to: "string"
};
typeNames.interfaces["ScheduledTaskEmailFailedEvent"] = {
to: "string",
        reason: "MethodFault"
};
typeNames.interfaces["ScheduledTaskEventArgument"] = {
scheduledTask: ScheduledTask
};
typeNames.interfaces["ServerStartedSessionEvent"] = {

};
typeNames.interfaces["TeamingMatchEvent"] = {

};
typeNames.interfaces["TeamingMisMatchEvent"] = {

};
typeNames.interfaces["TemplateBeingUpgradedEvent"] = {

};
typeNames.interfaces["UplinkPortMtuNotSupportEvent"] = {

};
typeNames.interfaces["UplinkPortMtuSupportEvent"] = {

};
typeNames.interfaces["UplinkPortVlanTrunkedEvent"] = {

};
typeNames.interfaces["UplinkPortVlanUntrunkedEvent"] = {

};
typeNames.interfaces["VmAcquiredMksTicketEvent"] = {

};
typeNames.interfaces["VmAcquiredTicketEvent"] = {
ticketType: "string"
};
typeNames.interfaces["VmAutoRenameEvent"] = {
oldName: "string",
        newName: "string"
};
typeNames.interfaces["VmBeingCreatedEvent"] = {
configSpec: "VirtualMachineConfigSpec"
};
typeNames.interfaces["VmBeingDeployedEvent"] = {
srcTemplate: "VmEventArgument"
};
typeNames.interfaces["VmBeingHotMigratedEvent"] = {
destHost: "HostEventArgument",
        destDatacenter: "DatacenterEventArgument",
        destDatastore: "DatastoreEventArgument"
};
typeNames.interfaces["VmBeingMigratedEvent"] = {
destHost: "HostEventArgument",
        destDatacenter: "DatacenterEventArgument",
        destDatastore: "DatastoreEventArgument"
};
typeNames.interfaces["VmBeingRelocatedEvent"] = {
destHost: "HostEventArgument",
        destDatacenter: "DatacenterEventArgument",
        destDatastore: "DatastoreEventArgument"
};
typeNames.interfaces["VmCloneEvent"] = {

};
typeNames.interfaces["VmCloneFailedEvent"] = {
destFolder: "FolderEventArgument",
        destName: "string",
        destHost: "HostEventArgument",
        reason: "MethodFault"
};
typeNames.interfaces["VmClonedEvent"] = {
sourceVm: "VmEventArgument"
};
typeNames.interfaces["VmConfigMissingEvent"] = {

};
typeNames.interfaces["VmConnectedEvent"] = {

};
typeNames.interfaces["VmCreatedEvent"] = {

};
typeNames.interfaces["VmDasBeingResetEvent"] = {
reason: "string"
};
typeNames.interfaces["VmDasBeingResetWithScreenshotEvent"] = {
screenshotFilePath: "string"
};
typeNames.interfaces["VmDasResetFailedEvent"] = {

};
typeNames.interfaces["VmDasUpdateErrorEvent"] = {

};
typeNames.interfaces["VmDasUpdateOkEvent"] = {

};
typeNames.interfaces["VmDateRolledBackEvent"] = {

};
typeNames.interfaces["VmDeployFailedEvent"] = {
destDatastore: "EntityEventArgument",
        reason: "MethodFault"
};
typeNames.interfaces["VmDeployedEvent"] = {
srcTemplate: "VmEventArgument"
};
typeNames.interfaces["VmDisconnectedEvent"] = {

};
typeNames.interfaces["VmDiscoveredEvent"] = {

};
typeNames.interfaces["VmDiskFailedEvent"] = {
disk: "string",
        reason: "MethodFault"
};
typeNames.interfaces["VmEmigratingEvent"] = {

};
typeNames.interfaces["VmEndRecordingEvent"] = {

};
typeNames.interfaces["VmEndReplayingEvent"] = {

};
typeNames.interfaces["VmEventArgument"] = {
vm: VirtualMachine
};
typeNames.interfaces["VmFaultToleranceStateChangedEvent"] = {
oldState: "VirtualMachineFaultToleranceState",
        newState: "VirtualMachineFaultToleranceState"
};
typeNames.interfaces["VmHealthMonitoringStateChangedEvent"] = {
state: "string",
        prevState: "string"
};
typeNames.interfaces["VmPowerOffOnIsolationEvent"] = {
isolatedHost: "HostEventArgument"
};
typeNames.interfaces["VmRelocateFailedEvent"] = {
destHost: "HostEventArgument",
        reason: "MethodFault",
        destDatacenter: "DatacenterEventArgument",
        destDatastore: "DatastoreEventArgument"
};
typeNames.interfaces["VmVnicPoolReservationViolationClearEvent"] = {
vmVnicResourcePoolKey: "string",
        vmVnicResourcePoolName: "string"
};
typeNames.interfaces["VmVnicPoolReservationViolationRaiseEvent"] = {
vmVnicResourcePoolKey: "string",
        vmVnicResourcePoolName: "string"
};
typeNames.interfaces["ActiveDirectoryFault"] = {
errorCode: "number"
};
typeNames.interfaces["AlreadyExists"] = {
name: "string"
};
typeNames.interfaces["AlreadyUpgraded"] = {

};
typeNames.interfaces["AnswerFileUpdateFailed"] = {
failure: "AnswerFileUpdateFailure"
};
typeNames.interfaces["AnswerFileUpdateFailure"] = {
userInputPath: "ProfilePropertyPath",
        errMsg: "LocalizableMessage"
};
typeNames.interfaces["AuthMinimumAdminPermission"] = {

};
typeNames.interfaces["CannotAccessLocalSource"] = {

};
typeNames.interfaces["CannotAccessVmComponent"] = {

};
typeNames.interfaces["CannotAccessVmConfig"] = {
reason: "MethodFault"
};
typeNames.interfaces["CannotAccessVmDevice"] = {
device: "string",
        backing: "string",
        connected: "boolean"
};
typeNames.interfaces["CannotAccessVmDisk"] = {
fault: "MethodFault"
};
typeNames.interfaces["CannotChangeDrsBehaviorForFtSecondary"] = {
vm: VirtualMachine,
        vmName: "string"
};
typeNames.interfaces["CannotChangeHaSettingsForFtSecondary"] = {
vm: VirtualMachine,
        vmName: "string"
};
typeNames.interfaces["CannotChangeVsanClusterUuid"] = {

};
typeNames.interfaces["CannotChangeVsanNodeUuid"] = {

};
typeNames.interfaces["CannotComputeFTCompatibleHosts"] = {
vm: VirtualMachine,
        vmName: "string"
};
typeNames.interfaces["CannotDisableSnapshot"] = {

};
typeNames.interfaces["CannotDisconnectHostWithFaultToleranceVm"] = {
hostName: "string"
};
typeNames.interfaces["CannotEnableVmcpForCluster"] = {
host: HostSystem,
        hostName: "string",
        reason: "string"
};
typeNames.interfaces["CannotMoveFaultToleranceVm"] = {
moveType: "string",
        vmName: "string"
};
typeNames.interfaces["CannotMoveHostWithFaultToleranceVm"] = {

};
typeNames.interfaces["CannotMoveVsanEnabledHost"] = {

};
typeNames.interfaces["CannotPlaceWithoutPrerequisiteMoves"] = {

};
typeNames.interfaces["CannotReconfigureVsanWhenHaEnabled"] = {

};
typeNames.interfaces["CannotUseNetwork"] = {
device: "string",
        backing: "string",
        connected: "boolean",
        reason: "string",
        network: Network
};
typeNames.interfaces["ConcurrentAccess"] = {

};
typeNames.interfaces["CpuHotPlugNotSupported"] = {

};
typeNames.interfaces["CustomizationFault"] = {

};
typeNames.interfaces["CustomizationPending"] = {

};
typeNames.interfaces["DasConfigFault"] = {
reason: "string",
        output: "string",
        event: "Event"
};
typeNames.interfaces["DeltaDiskFormatNotSupported"] = {
datastore: Datastore,
        deltaDiskFormat: "string"
};
typeNames.interfaces["DestinationVsanDisabled"] = {
destinationCluster: "string"
};
typeNames.interfaces["DomainNotFound"] = {
domainName: "string"
};
typeNames.interfaces["DrsDisabledOnVm"] = {

};
typeNames.interfaces["DuplicateName"] = {
name: "string",
        object: "ManagedObject"
};
typeNames.interfaces["DuplicateVsanNetworkInterface"] = {
device: "string"
};
typeNames.interfaces["DvsFault"] = {

};
typeNames.interfaces["DvsNotAuthorized"] = {
sessionExtensionKey: "string",
        dvsExtensionKey: "string"
};
typeNames.interfaces["DvsOperationBulkFault"] = {
hostFault: "DvsOperationBulkFaultFaultOnHost"
};
typeNames.interfaces["DvsOperationBulkFaultFaultOnHost"] = {
host: HostSystem,
        fault: "MethodFault"
};
typeNames.interfaces["DvsScopeViolated"] = {
scope: ManagedEntity,
        entity: ManagedEntity
};
typeNames.interfaces["EVCConfigFault"] = {
faults: "MethodFault"
};
typeNames.interfaces["EVCModeIllegalByVendor"] = {
clusterCPUVendor: "string",
        modeCPUVendor: "string"
};
typeNames.interfaces["EVCModeUnsupportedByHosts"] = {
evcMode: "string",
        host: HostSystem,
        hostName: "string"
};
typeNames.interfaces["EVCUnsupportedByHostHardware"] = {
host: HostSystem,
        hostName: "string"
};
typeNames.interfaces["EVCUnsupportedByHostSoftware"] = {
host: HostSystem,
        hostName: "string"
};
typeNames.interfaces["EightHostLimitViolated"] = {

};
typeNames.interfaces["ExpiredAddonLicense"] = {

};
typeNames.interfaces["ExpiredEditionLicense"] = {

};
typeNames.interfaces["ExtendedFault"] = {
faultTypeId: "string",
        data: "KeyValue"
};
typeNames.interfaces["FaultToleranceCannotEditMem"] = {
vmName: "string",
        vm: VirtualMachine
};
typeNames.interfaces["FaultToleranceNotLicensed"] = {
hostName: "string"
};
typeNames.interfaces["FaultTolerancePrimaryPowerOnNotAttempted"] = {
secondaryVm: VirtualMachine,
        primaryVm: VirtualMachine
};
typeNames.interfaces["FaultToleranceVmNotDasProtected"] = {
vm: VirtualMachine,
        vmName: "string"
};
typeNames.interfaces["FcoeFault"] = {

};
typeNames.interfaces["FcoeFaultPnicHasNoPortSet"] = {
nicDevice: "string"
};
typeNames.interfaces["FileFault"] = {
file: "string"
};
typeNames.interfaces["FileLocked"] = {

};
typeNames.interfaces["FileNameTooLong"] = {

};
typeNames.interfaces["FileNotFound"] = {

};
typeNames.interfaces["FileNotWritable"] = {

};
typeNames.interfaces["FileTooLarge"] = {
datastore: "string",
        fileSize: "number",
        maxFileSize: "number"
};
typeNames.interfaces["FtIssuesOnHost"] = {
host: HostSystem,
        hostName: "string",
        errors: "MethodFault"
};
typeNames.interfaces["GenericDrsFault"] = {
hostFaults: "MethodFault"
};
typeNames.interfaces["GenericVmConfigFault"] = {
reason: "string"
};
typeNames.interfaces["GuestOperationsFault"] = {

};
typeNames.interfaces["GuestOperationsUnavailable"] = {

};
typeNames.interfaces["GuestPermissionDenied"] = {

};
typeNames.interfaces["GuestProcessNotFound"] = {
pid: "number"
};
typeNames.interfaces["GuestRegistryFault"] = {
windowsSystemErrorCode: "number"
};
typeNames.interfaces["GuestRegistryKeyFault"] = {
keyName: "string"
};
typeNames.interfaces["GuestRegistryKeyHasSubkeys"] = {

};
typeNames.interfaces["GuestRegistryKeyInvalid"] = {

};
typeNames.interfaces["GuestRegistryKeyParentVolatile"] = {

};
typeNames.interfaces["GuestRegistryValueFault"] = {
keyName: "string",
        valueName: "string"
};
typeNames.interfaces["GuestRegistryValueNotFound"] = {

};
typeNames.interfaces["HeterogenousHostsBlockingEVC"] = {

};
typeNames.interfaces["HostConfigFault"] = {

};
typeNames.interfaces["HostConnectFault"] = {

};
typeNames.interfaces["HostHasComponentFailure"] = {
hostName: "string",
        componentType: "string",
        componentName: "string"
};
typeNames.interfaces["HostInDomain"] = {

};
typeNames.interfaces["HostIncompatibleForFaultTolerance"] = {
hostName: "string",
        reason: "string"
};
typeNames.interfaces["HostIncompatibleForRecordReplay"] = {
hostName: "string",
        reason: "string"
};
typeNames.interfaces["HostPowerOpFailed"] = {

};
typeNames.interfaces["HostSpecificationOperationFailed"] = {
host: HostSystem
};
typeNames.interfaces["HttpFault"] = {
statusCode: "number",
        statusMessage: "string"
};
typeNames.interfaces["IORMNotSupportedHostOnDatastore"] = {
datastore: Datastore,
        datastoreName: "string",
        host: HostSystem
};
typeNames.interfaces["ImportHostAddFailure"] = {
hostIp: "string"
};
typeNames.interfaces["ImportOperationBulkFault"] = {
importFaults: "ImportOperationBulkFaultFaultOnImport"
};
typeNames.interfaces["ImportOperationBulkFaultFaultOnImport"] = {
entityType: "string",
        key: "string",
        fault: "MethodFault"
};
typeNames.interfaces["InaccessibleVFlashSource"] = {
hostName: "string"
};
typeNames.interfaces["IncompatibleHostForFtSecondary"] = {
host: HostSystem,
        error: "MethodFault"
};
typeNames.interfaces["IncorrectFileType"] = {

};
typeNames.interfaces["InsufficientResourcesFault"] = {

};
typeNames.interfaces["InsufficientStandbyResource"] = {

};
typeNames.interfaces["InsufficientStorageIops"] = {
unreservedIops: "number",
        requestedIops: "number",
        datastoreName: "string"
};
typeNames.interfaces["InsufficientStorageSpace"] = {

};
typeNames.interfaces["InsufficientVFlashResourcesFault"] = {
freeSpaceInMB: "number",
        freeSpace: "number",
        requestedSpaceInMB: "number",
        requestedSpace: "number"
};
typeNames.interfaces["InvalidAffinitySettingFault"] = {

};
typeNames.interfaces["InvalidBmcRole"] = {

};
typeNames.interfaces["InvalidCAMServer"] = {
camServer: "string"
};
typeNames.interfaces["InvalidDatastore"] = {
datastore: Datastore,
        name: "string"
};
typeNames.interfaces["InvalidDatastorePath"] = {
datastorePath: "string"
};
typeNames.interfaces["InvalidEvent"] = {

};
typeNames.interfaces["InvalidFolder"] = {
target: ManagedEntity
};
typeNames.interfaces["InvalidFormat"] = {

};
typeNames.interfaces["InvalidGuestLogin"] = {

};
typeNames.interfaces["InvalidHostName"] = {

};
typeNames.interfaces["InvalidIpfixConfig"] = {
property: "string"
};
typeNames.interfaces["InvalidIpmiLoginInfo"] = {

};
typeNames.interfaces["InvalidIpmiMacAddress"] = {
userProvidedMacAddress: "string",
        observedMacAddress: "string"
};
typeNames.interfaces["InvalidLicense"] = {
licenseContent: "string"
};
typeNames.interfaces["InvalidLocale"] = {

};
typeNames.interfaces["InvalidLogin"] = {

};
typeNames.interfaces["InvalidName"] = {
name: "string",
        entity: ManagedEntity
};
typeNames.interfaces["InvalidOperationOnSecondaryVm"] = {
instanceUuid: "string"
};
typeNames.interfaces["InvalidPrivilege"] = {
privilege: "string"
};
typeNames.interfaces["InvalidResourcePoolStructureFault"] = {

};
typeNames.interfaces["InvalidSnapshotFormat"] = {

};
typeNames.interfaces["InvalidState"] = {

};
typeNames.interfaces["InvalidVmConfig"] = {
property: "string"
};
typeNames.interfaces["InvalidVmState"] = {
vm: VirtualMachine
};
typeNames.interfaces["IpHostnameGeneratorError"] = {

};
typeNames.interfaces["IscsiFault"] = {

};
typeNames.interfaces["IscsiFaultInvalidVnic"] = {
vnicDevice: "string"
};
typeNames.interfaces["IscsiFaultPnicInUse"] = {
pnicDevice: "string"
};
typeNames.interfaces["IscsiFaultVnicAlreadyBound"] = {
vnicDevice: "string"
};
typeNames.interfaces["IscsiFaultVnicHasActivePaths"] = {
vnicDevice: "string"
};
typeNames.interfaces["IscsiFaultVnicHasMultipleUplinks"] = {
vnicDevice: "string"
};
typeNames.interfaces["IscsiFaultVnicHasNoUplinks"] = {
vnicDevice: "string"
};
typeNames.interfaces["IscsiFaultVnicHasWrongUplink"] = {
vnicDevice: "string"
};
typeNames.interfaces["IscsiFaultVnicInUse"] = {
vnicDevice: "string"
};
typeNames.interfaces["IscsiFaultVnicIsLastPath"] = {
vnicDevice: "string"
};
typeNames.interfaces["IscsiFaultVnicNotBound"] = {
vnicDevice: "string"
};
typeNames.interfaces["IscsiFaultVnicNotFound"] = {
vnicDevice: "string"
};
typeNames.interfaces["KeyNotFound"] = {
key: "string"
};
typeNames.interfaces["LargeRDMNotSupportedOnDatastore"] = {
device: "string",
        datastore: Datastore,
        datastoreName: "string"
};
typeNames.interfaces["LicenseEntityNotFound"] = {
entityId: "string"
};
typeNames.interfaces["LicenseServerUnavailable"] = {
licenseServer: "string"
};
typeNames.interfaces["LimitExceeded"] = {
property: "string",
        limit: "number"
};
typeNames.interfaces["LinuxVolumeNotClean"] = {

};
typeNames.interfaces["LogBundlingFailed"] = {

};
typeNames.interfaces["MemoryHotPlugNotSupported"] = {

};
typeNames.interfaces["MigrationFault"] = {

};
typeNames.interfaces["MigrationFeatureNotSupported"] = {
atSourceHost: "boolean",
        failedHostName: "string",
        failedHost: HostSystem
};
typeNames.interfaces["MigrationNotReady"] = {
reason: "string"
};
typeNames.interfaces["MismatchedBundle"] = {
bundleUuid: "string",
        hostUuid: "string",
        bundleBuildNumber: "number",
        hostBuildNumber: "number"
};
typeNames.interfaces["MismatchedNetworkPolicies"] = {
device: "string",
        backing: "string",
        connected: "boolean"
};
typeNames.interfaces["MismatchedVMotionNetworkNames"] = {
sourceNetwork: "string",
        destNetwork: "string"
};
typeNames.interfaces["MissingBmcSupport"] = {

};
typeNames.interfaces["MissingLinuxCustResources"] = {

};
typeNames.interfaces["MissingWindowsCustResources"] = {

};
typeNames.interfaces["MksConnectionLimitReached"] = {
connectionLimit: "number"
};
typeNames.interfaces["MountError"] = {
vm: VirtualMachine,
        diskIndex: "number"
};
typeNames.interfaces["MultipleCertificatesVerifyFault"] = {
thumbprintData: "MultipleCertificatesVerifyFaultThumbprintData"
};
typeNames.interfaces["MultipleCertificatesVerifyFaultThumbprintData"] = {
port: "number",
        thumbprint: "string"
};
typeNames.interfaces["NamespaceFull"] = {
name: "string",
        currentMaxSize: "number",
        requiredSize: "number"
};
typeNames.interfaces["NamespaceLimitReached"] = {
limit: "number"
};
typeNames.interfaces["NamespaceWriteProtected"] = {
name: "string"
};
typeNames.interfaces["NasConfigFault"] = {
name: "string"
};
typeNames.interfaces["NasConnectionLimitReached"] = {
remoteHost: "string",
        remotePath: "string"
};
typeNames.interfaces["NasSessionCredentialConflict"] = {
remoteHost: "string",
        remotePath: "string",
        userName: "string"
};
typeNames.interfaces["NasVolumeNotMounted"] = {
remoteHost: "string",
        remotePath: "string"
};
typeNames.interfaces["NetworkCopyFault"] = {

};
typeNames.interfaces["NetworkDisruptedAndConfigRolledBack"] = {
host: "string"
};
typeNames.interfaces["NetworkInaccessible"] = {

};
typeNames.interfaces["NetworksMayNotBeTheSame"] = {
name: "string"
};
typeNames.interfaces["NicSettingMismatch"] = {
numberOfNicsInSpec: "number",
        numberOfNicsInVM: "number"
};
typeNames.interfaces["NoActiveHostInCluster"] = {
computeResource: ComputeResource
};
typeNames.interfaces["NoClientCertificate"] = {

};
typeNames.interfaces["NoCompatibleDatastore"] = {

};
typeNames.interfaces["NoCompatibleHardAffinityHost"] = {
vmName: "string"
};
typeNames.interfaces["NoCompatibleHost"] = {
host: HostSystem,
        error: "MethodFault"
};
typeNames.interfaces["NoCompatibleHostWithAccessToDevice"] = {

};
typeNames.interfaces["NoCompatibleSoftAffinityHost"] = {
vmName: "string"
};
typeNames.interfaces["NoConnectedDatastore"] = {

};
typeNames.interfaces["NoDiskFound"] = {

};
typeNames.interfaces["NoDiskSpace"] = {
datastore: "string"
};
typeNames.interfaces["NoDisksToCustomize"] = {

};
typeNames.interfaces["NoGateway"] = {

};
typeNames.interfaces["NoGuestHeartbeat"] = {

};
typeNames.interfaces["NoHost"] = {
name: "string"
};
typeNames.interfaces["NoHostSuitableForFtSecondary"] = {
vm: VirtualMachine,
        vmName: "string"
};
typeNames.interfaces["NoPeerHostFound"] = {

};
typeNames.interfaces["NoPermissionOnAD"] = {

};
typeNames.interfaces["NoPermissionOnHost"] = {

};
typeNames.interfaces["NoPermissionOnNasVolume"] = {
userName: "string"
};
typeNames.interfaces["NoSubjectName"] = {

};
typeNames.interfaces["NoVirtualNic"] = {

};
typeNames.interfaces["NonADUserRequired"] = {

};
typeNames.interfaces["NonHomeRDMVMotionNotSupported"] = {
device: "string"
};
typeNames.interfaces["NotADirectory"] = {

};
typeNames.interfaces["NotAFile"] = {

};
typeNames.interfaces["NotFound"] = {

};
typeNames.interfaces["NotSupportedDeviceForFT"] = {
host: HostSystem,
        hostName: "string",
        vm: VirtualMachine,
        vmName: "string",
        deviceType: "string",
        deviceLabel: "string"
};
typeNames.interfaces["NotSupportedHost"] = {
productName: "string",
        productVersion: "string"
};
typeNames.interfaces["NotSupportedHostForChecksum"] = {

};
typeNames.interfaces["NotSupportedHostForVFlash"] = {
hostName: "string"
};
typeNames.interfaces["NotSupportedHostForVmcp"] = {
hostName: "string"
};
typeNames.interfaces["NotSupportedHostForVmemFile"] = {
hostName: "string"
};
typeNames.interfaces["NotSupportedHostForVsan"] = {
hostName: "string"
};
typeNames.interfaces["NotSupportedHostInCluster"] = {

};
typeNames.interfaces["NotSupportedHostInDvs"] = {
switchProductSpec: "DistributedVirtualSwitchProductSpec"
};
typeNames.interfaces["NotSupportedHostInHACluster"] = {
hostName: "string",
        build: "string"
};
typeNames.interfaces["NumVirtualCpusExceedsLimit"] = {
maxSupportedVcpus: "number"
};
typeNames.interfaces["NumVirtualCpusIncompatible"] = {
reason: "string",
        numCpu: "number"
};
typeNames.interfaces["OperationDisabledByGuest"] = {

};
typeNames.interfaces["OperationNotSupportedByGuest"] = {

};
typeNames.interfaces["OutOfBounds"] = {
argumentName: "string"
};
typeNames.interfaces["OvfConsumerPowerOnFault"] = {
extensionKey: "string",
        extensionName: "string",
        description: "string"
};
typeNames.interfaces["OvfConsumerValidationFault"] = {
extensionKey: "string",
        extensionName: "string",
        message: "string"
};
typeNames.interfaces["OvfFault"] = {

};
typeNames.interfaces["OvfImport"] = {

};
typeNames.interfaces["OvfImportFailed"] = {

};
typeNames.interfaces["OvfInvalidPackage"] = {
lineNumber: "number"
};
typeNames.interfaces["OvfMappedOsId"] = {
ovfId: "number",
        ovfDescription: "string",
        targetDescription: "string"
};
typeNames.interfaces["OvfMissingHardware"] = {
name: "string",
        resourceType: "number"
};
typeNames.interfaces["OvfNetworkMappingNotSupported"] = {

};
typeNames.interfaces["OvfProperty"] = {
type: "string",
        value: "string"
};
typeNames.interfaces["OvfPropertyNetwork"] = {

};
typeNames.interfaces["OvfPropertyQualifier"] = {
qualifier: "string"
};
typeNames.interfaces["OvfPropertyQualifierDuplicate"] = {
qualifier: "string"
};
typeNames.interfaces["OvfPropertyQualifierIgnored"] = {
qualifier: "string"
};
typeNames.interfaces["OvfPropertyType"] = {

};
typeNames.interfaces["OvfPropertyValue"] = {

};
typeNames.interfaces["OvfSystemFault"] = {

};
typeNames.interfaces["OvfToXmlUnsupportedElement"] = {
name: "string"
};
typeNames.interfaces["OvfUnknownDevice"] = {
device: "VirtualDevice",
        vmName: "string"
};
typeNames.interfaces["OvfUnknownEntity"] = {
lineNumber: "number"
};
typeNames.interfaces["OvfUnsupportedDeviceBackingInfo"] = {
elementName: "string",
        instanceId: "string",
        deviceName: "string",
        backingName: "string"
};
typeNames.interfaces["OvfUnsupportedDeviceBackingOption"] = {
elementName: "string",
        instanceId: "string",
        deviceName: "string",
        backingName: "string"
};
typeNames.interfaces["OvfUnsupportedDiskProvisioning"] = {
diskProvisioning: "string",
        supportedDiskProvisioning: "string"
};
typeNames.interfaces["OvfUnsupportedPackage"] = {
lineNumber: "number"
};
typeNames.interfaces["OvfUnsupportedSubType"] = {
elementName: "string",
        instanceId: "string",
        deviceType: "number",
        deviceSubType: "string"
};
typeNames.interfaces["OvfUnsupportedType"] = {
name: "string",
        instanceId: "string",
        deviceType: "number"
};
typeNames.interfaces["OvfWrongNamespace"] = {
namespaceName: "string"
};
typeNames.interfaces["OvfXmlFormat"] = {
description: "string"
};
typeNames.interfaces["PasswordExpired"] = {

};
typeNames.interfaces["PatchBinariesNotFound"] = {
patchID: "string",
        binary: "string"
};
typeNames.interfaces["PatchMetadataInvalid"] = {
patchID: "string",
        metaData: "string"
};
typeNames.interfaces["PatchMetadataNotFound"] = {

};
typeNames.interfaces["PatchNotApplicable"] = {
patchID: "string"
};
typeNames.interfaces["PatchSuperseded"] = {
supersede: "string"
};
typeNames.interfaces["PlatformConfigFault"] = {
text: "string"
};
typeNames.interfaces["PowerOnFtSecondaryFailed"] = {
vm: VirtualMachine,
        vmName: "string",
        hostSelectionBy: "FtIssuesOnHostHostSelectionType",
        hostErrors: "MethodFault",
        rootCause: "MethodFault"
};
typeNames.interfaces["ProfileUpdateFailed"] = {
failure: "ProfileUpdateFailedUpdateFailure",
        warnings: "ProfileUpdateFailedUpdateFailure"
};
typeNames.interfaces["ProfileUpdateFailedUpdateFailure"] = {
profilePath: "ProfilePropertyPath",
        errMsg: "LocalizableMessage"
};
typeNames.interfaces["QuarantineModeFault"] = {
vmName: "string",
        faultType: "string"
};
typeNames.interfaces["QuestionPending"] = {
text: "string"
};
typeNames.interfaces["RDMConversionNotSupported"] = {
device: "string"
};
typeNames.interfaces["RDMNotPreserved"] = {
device: "string"
};
typeNames.interfaces["RDMNotSupportedOnDatastore"] = {
device: "string",
        datastore: Datastore,
        datastoreName: "string"
};
typeNames.interfaces["RDMPointsToInaccessibleDisk"] = {

};
typeNames.interfaces["ReadHostResourcePoolTreeFailed"] = {

};
typeNames.interfaces["ReadOnlyDisksWithLegacyDestination"] = {
roDiskCount: "number",
        timeoutDanger: "boolean"
};
typeNames.interfaces["RebootRequired"] = {
patch: "string"
};
typeNames.interfaces["RecordReplayDisabled"] = {

};
typeNames.interfaces["RemoveFailed"] = {

};
typeNames.interfaces["ReplicationFault"] = {

};
typeNames.interfaces["ReplicationIncompatibleWithFT"] = {

};
typeNames.interfaces["ReplicationInvalidOptions"] = {
options: "string",
        entity: ManagedEntity
};
typeNames.interfaces["ReplicationNotSupportedOnHost"] = {

};
typeNames.interfaces["ReplicationVmFault"] = {
reason: "string",
        state: "string",
        instanceId: "string",
        vm: VirtualMachine
};
typeNames.interfaces["ReplicationVmInProgressFault"] = {
requestedActivity: "string",
        inProgressActivity: "string"
};
typeNames.interfaces["ResourceInUse"] = {
type: "string",
        name: "string"
};
typeNames.interfaces["ResourceNotAvailable"] = {
containerType: "string",
        containerName: "string",
        type: "string"
};
typeNames.interfaces["RollbackFailure"] = {
entityName: "string",
        entityType: "string"
};
typeNames.interfaces["RuleViolation"] = {
host: HostSystem,
        rule: "ClusterRuleInfo"
};
typeNames.interfaces["SSLDisabledFault"] = {

};
typeNames.interfaces["SSLVerifyFault"] = {
selfSigned: "boolean",
        thumbprint: "string"
};
typeNames.interfaces["SSPIChallenge"] = {
base64Token: "string"
};
typeNames.interfaces["SecondaryVmAlreadyDisabled"] = {
instanceUuid: "string"
};
typeNames.interfaces["SecondaryVmAlreadyEnabled"] = {
instanceUuid: "string"
};
typeNames.interfaces["SecondaryVmAlreadyRegistered"] = {
instanceUuid: "string"
};
typeNames.interfaces["SecondaryVmNotRegistered"] = {
instanceUuid: "string"
};
typeNames.interfaces["ShrinkDiskFault"] = {
diskId: "number"
};
typeNames.interfaces["SnapshotCopyNotSupported"] = {

};
typeNames.interfaces["SnapshotFault"] = {

};
typeNames.interfaces["SnapshotIncompatibleDeviceInVm"] = {
fault: "MethodFault"
};
typeNames.interfaces["SnapshotLocked"] = {

};
typeNames.interfaces["SnapshotMoveFromNonHomeNotSupported"] = {

};
typeNames.interfaces["SnapshotMoveNotSupported"] = {

};
typeNames.interfaces["SnapshotMoveToNonHomeNotSupported"] = {

};
typeNames.interfaces["SnapshotNoChange"] = {

};
typeNames.interfaces["SnapshotRevertIssue"] = {
snapshotName: "string",
        event: "Event",
        errors: "boolean"
};
typeNames.interfaces["SoftRuleVioCorrectionDisallowed"] = {
vmName: "string"
};
typeNames.interfaces["SoftRuleVioCorrectionImpact"] = {
vmName: "string"
};
typeNames.interfaces["SsdDiskNotAvailable"] = {
devicePath: "string"
};
typeNames.interfaces["StorageDrsCannotMoveDiskInMultiWriterMode"] = {

};
typeNames.interfaces["StorageDrsCannotMoveFTVm"] = {

};
typeNames.interfaces["StorageDrsCannotMoveIndependentDisk"] = {

};
typeNames.interfaces["StorageDrsCannotMoveManuallyPlacedSwapFile"] = {

};
typeNames.interfaces["StorageDrsCannotMoveManuallyPlacedVm"] = {

};
typeNames.interfaces["StorageDrsCannotMoveSharedDisk"] = {

};
typeNames.interfaces["StorageDrsCannotMoveTemplate"] = {

};
typeNames.interfaces["StorageDrsCannotMoveVmInUserFolder"] = {

};
typeNames.interfaces["StorageDrsCannotMoveVmWithMountedCDROM"] = {

};
typeNames.interfaces["StorageDrsCannotMoveVmWithNoFilesInLayout"] = {

};
typeNames.interfaces["StorageDrsDatacentersCannotShareDatastore"] = {

};
typeNames.interfaces["StorageDrsDisabledOnVm"] = {

};
typeNames.interfaces["StorageDrsHbrDiskNotMovable"] = {
nonMovableDiskIds: "string"
};
typeNames.interfaces["StorageDrsHmsMoveInProgress"] = {

};
typeNames.interfaces["StorageDrsHmsUnreachable"] = {

};
typeNames.interfaces["StorageDrsIolbDisabledInternally"] = {

};
typeNames.interfaces["StorageDrsRelocateDisabled"] = {

};
typeNames.interfaces["StorageDrsStaleHmsCollection"] = {

};
typeNames.interfaces["StorageDrsUnableToMoveFiles"] = {

};
typeNames.interfaces["StorageVMotionNotSupported"] = {

};
typeNames.interfaces["SuspendedRelocateNotSupported"] = {

};
typeNames.interfaces["SwapDatastoreUnset"] = {

};
typeNames.interfaces["SwapPlacementOverrideNotSupported"] = {

};
typeNames.interfaces["SwitchIpUnset"] = {

};
typeNames.interfaces["SwitchNotInUpgradeMode"] = {

};
typeNames.interfaces["TaskInProgress"] = {
task: Task
};
typeNames.interfaces["Timedout"] = {

};
typeNames.interfaces["TooManyConcurrentNativeClones"] = {

};
typeNames.interfaces["TooManyConsecutiveOverrides"] = {

};
typeNames.interfaces["TooManyDevices"] = {

};
typeNames.interfaces["TooManyDisksOnLegacyHost"] = {
diskCount: "number",
        timeoutDanger: "boolean"
};
typeNames.interfaces["TooManyGuestLogons"] = {

};
typeNames.interfaces["TooManyHosts"] = {

};
typeNames.interfaces["TooManyNativeCloneLevels"] = {

};
typeNames.interfaces["TooManyNativeClonesOnFile"] = {

};
typeNames.interfaces["TooManySnapshotLevels"] = {

};
typeNames.interfaces["ToolsAlreadyUpgraded"] = {

};
typeNames.interfaces["ToolsAutoUpgradeNotSupported"] = {

};
typeNames.interfaces["ToolsImageCopyFailed"] = {

};
typeNames.interfaces["ToolsImageNotAvailable"] = {

};
typeNames.interfaces["ToolsImageSignatureCheckFailed"] = {

};
typeNames.interfaces["ToolsInstallationInProgress"] = {

};
typeNames.interfaces["ToolsUnavailable"] = {

};
typeNames.interfaces["ToolsUpgradeCancelled"] = {

};
typeNames.interfaces["UncommittedUndoableDisk"] = {

};
typeNames.interfaces["UncustomizableGuest"] = {
uncustomizableGuestOS: "string"
};
typeNames.interfaces["UnexpectedCustomizationFault"] = {

};
typeNames.interfaces["UnrecognizedHost"] = {
hostName: "string"
};
typeNames.interfaces["UnsharedSwapVMotionNotSupported"] = {

};
typeNames.interfaces["UnsupportedDatastore"] = {
datastore: Datastore
};
typeNames.interfaces["UnsupportedGuest"] = {
unsupportedGuestOS: "string"
};
typeNames.interfaces["UnsupportedVimApiVersion"] = {
version: "string"
};
typeNames.interfaces["UnsupportedVmxLocation"] = {

};
typeNames.interfaces["UserNotFound"] = {
principal: "string",
        unresolved: "boolean"
};
typeNames.interfaces["VAppConfigFault"] = {

};
typeNames.interfaces["VAppNotRunning"] = {

};
typeNames.interfaces["VAppPropertyFault"] = {
id: "string",
        category: "string",
        label: "string",
        type: "string",
        value: "string"
};
typeNames.interfaces["VAppTaskInProgress"] = {

};
typeNames.interfaces["VFlashCacheHotConfigNotSupported"] = {

};
typeNames.interfaces["VFlashModuleNotSupported"] = {
vmName: "string",
        moduleName: "string",
        reason: "string",
        hostName: "string"
};
typeNames.interfaces["VFlashModuleVersionIncompatible"] = {
moduleName: "string",
        vmRequestModuleVersion: "string",
        hostMinSupportedVerson: "string",
        hostModuleVersion: "string"
};
typeNames.interfaces["VMotionAcrossNetworkNotSupported"] = {

};
typeNames.interfaces["VMotionInterfaceIssue"] = {
atSourceHost: "boolean",
        failedHost: "string",
        failedHostEntity: HostSystem
};
typeNames.interfaces["VMotionLinkCapacityLow"] = {
network: "string"
};
typeNames.interfaces["VMotionLinkDown"] = {
network: "string"
};
typeNames.interfaces["VMotionNotConfigured"] = {

};
typeNames.interfaces["VMotionNotLicensed"] = {

};
typeNames.interfaces["VMotionNotSupported"] = {

};
typeNames.interfaces["VMotionProtocolIncompatible"] = {

};
typeNames.interfaces["VirtualHardwareCompatibilityIssue"] = {

};
typeNames.interfaces["VirtualHardwareVersionNotSupported"] = {
hostName: "string",
        host: HostSystem
};
typeNames.interfaces["VmAlreadyExistsInDatacenter"] = {
host: HostSystem,
        hostname: "string",
        vm: VirtualMachine
};
typeNames.interfaces["VmFaultToleranceConfigIssue"] = {
reason: "string",
        entityName: "string",
        entity: ManagedEntity
};
typeNames.interfaces["VmFaultToleranceConfigIssueWrapper"] = {
entityName: "string",
        entity: ManagedEntity,
        error: "MethodFault"
};
typeNames.interfaces["VmFaultToleranceInvalidFileBacking"] = {
backingType: "string",
        backingFilename: "string"
};
typeNames.interfaces["VmFaultToleranceTooManyFtVcpusOnHost"] = {
hostName: "string",
        maxNumFtVcpus: "number"
};
typeNames.interfaces["VmFaultToleranceTooManyVMsOnHost"] = {
hostName: "string",
        maxNumFtVms: "number"
};
typeNames.interfaces["VmPowerOnDisabled"] = {

};
typeNames.interfaces["VmSmpFaultToleranceTooManyVMsOnHost"] = {
hostName: "string",
        maxNumSmpFtVms: "number"
};
typeNames.interfaces["VmWwnConflict"] = {
vm: VirtualMachine,
        host: HostSystem,
        name: "string",
        wwn: "number"
};
typeNames.interfaces["VmfsMountFault"] = {
uuid: "string"
};
typeNames.interfaces["VmotionInterfaceNotEnabled"] = {

};
typeNames.interfaces["VolumeEditorError"] = {

};
typeNames.interfaces["VsanClusterUuidMismatch"] = {
hostClusterUuid: "string",
        destinationClusterUuid: "string"
};
typeNames.interfaces["VsanDiskFault"] = {
device: "string"
};
typeNames.interfaces["VsanIncompatibleDiskMapping"] = {

};
typeNames.interfaces["VspanDestPortConflict"] = {
vspanSessionKey1: "string",
        vspanSessionKey2: "string",
        portKey: "string"
};
typeNames.interfaces["VspanPortConflict"] = {
vspanSessionKey1: "string",
        vspanSessionKey2: "string",
        portKey: "string"
};
typeNames.interfaces["VspanPortMoveFault"] = {
srcPortgroupName: "string",
        destPortgroupName: "string",
        portKey: "string"
};
typeNames.interfaces["VspanPortPromiscChangeFault"] = {
portKey: "string"
};
typeNames.interfaces["VspanPortgroupPromiscChangeFault"] = {
portgroupName: "string"
};
typeNames.interfaces["VspanPortgroupTypeChangeFault"] = {
portgroupName: "string"
};
typeNames.interfaces["VspanPromiscuousPortNotSupported"] = {
vspanSessionKey: "string",
        portKey: "string"
};
typeNames.interfaces["VspanSameSessionPortConflict"] = {
vspanSessionKey: "string",
        portKey: "string"
};
typeNames.interfaces["WakeOnLanNotSupported"] = {

};
typeNames.interfaces["WakeOnLanNotSupportedByVmotionNIC"] = {

};
typeNames.interfaces["WillLoseHAProtection"] = {
resolution: "string"
};
typeNames.interfaces["WillModifyConfigCpuRequirements"] = {

};
typeNames.interfaces["WillResetSnapshotDirectory"] = {

};
typeNames.interfaces["HostActiveDirectoryInfo"] = {
joinedDomain: "string",
        trustedDomain: "string",
        domainMembershipStatus: "string",
        smartCardAuthenticationEnabled: "boolean"
};
typeNames.interfaces["HostBlockAdapterTargetTransport"] = {

};
typeNames.interfaces["HostBlockHba"] = {

};
typeNames.interfaces["HostBootDeviceInfo"] = {
bootDevices: "HostBootDevice",
        currentBootDeviceKey: "string"
};
typeNames.interfaces["HostConfigSpec"] = {
nasDatastore: "HostNasVolumeConfig",
        network: "HostNetworkConfig",
        nicTypeSelection: "HostVirtualNicManagerNicTypeSelection",
        service: "HostServiceConfig",
        firewall: "HostFirewallConfig",
        option: "OptionValue",
        datastorePrincipal: "string",
        datastorePrincipalPasswd: "string",
        datetime: "HostDateTimeConfig",
        storageDevice: "HostStorageDeviceInfo",
        license: "HostLicenseSpec",
        security: "HostSecuritySpec",
        userAccount: "HostAccountSpec",
        usergroupAccount: "HostAccountSpec",
        memory: "HostMemorySpec",
        activeDirectory: "HostActiveDirectory",
        genericConfig: "KeyAnyValue",
        graphicsConfig: "HostGraphicsConfig",
        assignableHardwareConfig: "HostAssignableHardwareConfig"
};
typeNames.interfaces["HostConnectSpec"] = {
hostName: "string",
        port: "number",
        sslThumbprint: "string",
        userName: "string",
        password: "string",
        vmFolder: Folder,
        force: "boolean",
        vimAccountName: "string",
        vimAccountPassword: "string",
        managementIp: "string",
        lockdownMode: "HostLockdownMode",
        hostGateway: "HostGatewaySpec"
};
typeNames.interfaces["HostDatastoreSystemCapabilities"] = {
nfsMountCreationRequired: "boolean",
        nfsMountCreationSupported: "boolean",
        localDatastoreSupported: "boolean",
        vmfsExtentExpansionSupported: "boolean"
};
typeNames.interfaces["HostDatastoreSystemDatastoreResult"] = {
key: Datastore,
        fault: "MethodFault"
};
typeNames.interfaces["HostDatastoreSystemVvolDatastoreSpec"] = {
name: "string",
        scId: "string"
};
typeNames.interfaces["HostDateTimeInfo"] = {
timeZone: "HostDateTimeSystemTimeZone",
        systemClockProtocol: "string",
        ntpConfig: "HostNtpConfig"
};
typeNames.interfaces["HostFibreChannelHba"] = {
portWorldWideName: "number",
        nodeWorldWideName: "number",
        portType: "FibreChannelPortType",
        speed: "number"
};
typeNames.interfaces["HostFibreChannelOverEthernetHba"] = {
underlyingNic: "string",
        linkInfo: "HostFibreChannelOverEthernetHbaLinkInfo",
        isSoftwareFcoe: "boolean",
        markedForRemoval: "boolean"
};
typeNames.interfaces["HostFibreChannelOverEthernetHbaLinkInfo"] = {
vnportMac: "string",
        fcfMac: "string",
        vlanId: "number"
};
typeNames.interfaces["HostFibreChannelTargetTransport"] = {
portWorldWideName: "number",
        nodeWorldWideName: "number"
};
typeNames.interfaces["HostFirewallConfig"] = {
rule: "HostFirewallConfigRuleSetConfig",
        defaultBlockingPolicy: "HostFirewallDefaultPolicy"
};
typeNames.interfaces["HostFirewallConfigRuleSetConfig"] = {
rulesetId: "string",
        enabled: "boolean",
        allowedHosts: "HostFirewallRulesetIpList"
};
typeNames.interfaces["HostInternetScsiHba"] = {
isSoftwareBased: "boolean",
        canBeDisabled: "boolean",
        networkBindingSupport: "HostInternetScsiHbaNetworkBindingSupportType",
        discoveryCapabilities: "HostInternetScsiHbaDiscoveryCapabilities",
        discoveryProperties: "HostInternetScsiHbaDiscoveryProperties",
        authenticationCapabilities: "HostInternetScsiHbaAuthenticationCapabilities",
        authenticationProperties: "HostInternetScsiHbaAuthenticationProperties",
        digestCapabilities: "HostInternetScsiHbaDigestCapabilities",
        digestProperties: "HostInternetScsiHbaDigestProperties",
        ipCapabilities: "HostInternetScsiHbaIPCapabilities",
        ipProperties: "HostInternetScsiHbaIPProperties",
        supportedAdvancedOptions: "OptionDef",
        advancedOptions: "HostInternetScsiHbaParamValue",
        iScsiName: "string",
        iScsiAlias: "string",
        configuredSendTarget: "HostInternetScsiHbaSendTarget",
        configuredStaticTarget: "HostInternetScsiHbaStaticTarget",
        maxSpeedMb: "number",
        currentSpeedMb: "number"
};
typeNames.interfaces["HostInternetScsiHbaAuthenticationCapabilities"] = {
chapAuthSettable: "boolean",
        krb5AuthSettable: "boolean",
        srpAuthSettable: "boolean",
        spkmAuthSettable: "boolean",
        mutualChapSettable: "boolean",
        targetChapSettable: "boolean",
        targetMutualChapSettable: "boolean"
};
typeNames.interfaces["HostInternetScsiHbaAuthenticationProperties"] = {
chapAuthEnabled: "boolean",
        chapName: "string",
        chapSecret: "string",
        chapAuthenticationType: "string",
        chapInherited: "boolean",
        mutualChapName: "string",
        mutualChapSecret: "string",
        mutualChapAuthenticationType: "string",
        mutualChapInherited: "boolean"
};
typeNames.interfaces["HostInternetScsiHbaDigestCapabilities"] = {
headerDigestSettable: "boolean",
        dataDigestSettable: "boolean",
        targetHeaderDigestSettable: "boolean",
        targetDataDigestSettable: "boolean"
};
typeNames.interfaces["HostInternetScsiHbaDigestProperties"] = {
headerDigestType: "string",
        headerDigestInherited: "boolean",
        dataDigestType: "string",
        dataDigestInherited: "boolean"
};
typeNames.interfaces["HostInternetScsiHbaDiscoveryCapabilities"] = {
iSnsDiscoverySettable: "boolean",
        slpDiscoverySettable: "boolean",
        staticTargetDiscoverySettable: "boolean",
        sendTargetsDiscoverySettable: "boolean"
};
typeNames.interfaces["HostInternetScsiHbaDiscoveryProperties"] = {
iSnsDiscoveryEnabled: "boolean",
        iSnsDiscoveryMethod: "string",
        iSnsHost: "string",
        slpDiscoveryEnabled: "boolean",
        slpDiscoveryMethod: "string",
        slpHost: "string",
        staticTargetDiscoveryEnabled: "boolean",
        sendTargetsDiscoveryEnabled: "boolean"
};
typeNames.interfaces["HostInternetScsiHbaIPCapabilities"] = {
addressSettable: "boolean",
        ipConfigurationMethodSettable: "boolean",
        subnetMaskSettable: "boolean",
        defaultGatewaySettable: "boolean",
        primaryDnsServerAddressSettable: "boolean",
        alternateDnsServerAddressSettable: "boolean",
        ipv6Supported: "boolean",
        arpRedirectSettable: "boolean",
        mtuSettable: "boolean",
        hostNameAsTargetAddress: "boolean",
        nameAliasSettable: "boolean",
        ipv4EnableSettable: "boolean",
        ipv6EnableSettable: "boolean",
        ipv6PrefixLengthSettable: "boolean",
        ipv6PrefixLength: "number",
        ipv6DhcpConfigurationSettable: "boolean",
        ipv6LinkLocalAutoConfigurationSettable: "boolean",
        ipv6RouterAdvertisementConfigurationSettable: "boolean",
        ipv6DefaultGatewaySettable: "boolean",
        ipv6MaxStaticAddressesSupported: "number"
};
typeNames.interfaces["HostInternetScsiHbaIPProperties"] = {
mac: "string",
        address: "string",
        dhcpConfigurationEnabled: "boolean",
        subnetMask: "string",
        defaultGateway: "string",
        primaryDnsServerAddress: "string",
        alternateDnsServerAddress: "string",
        ipv6Address: "string",
        ipv6SubnetMask: "string",
        ipv6DefaultGateway: "string",
        arpRedirectEnabled: "boolean",
        mtu: "number",
        jumboFramesEnabled: "boolean",
        ipv4Enabled: "boolean",
        ipv6Enabled: "boolean",
        ipv6properties: "HostInternetScsiHbaIPv6Properties"
};
typeNames.interfaces["HostInternetScsiHbaIPv6Properties"] = {
iscsiIpv6Address: "HostInternetScsiHbaIscsiIpv6Address",
        ipv6DhcpConfigurationEnabled: "boolean",
        ipv6LinkLocalAutoConfigurationEnabled: "boolean",
        ipv6RouterAdvertisementConfigurationEnabled: "boolean",
        ipv6DefaultGateway: "string"
};
typeNames.interfaces["HostInternetScsiHbaIscsiIpv6Address"] = {
address: "string",
        prefixLength: "number",
        origin: "string",
        operation: "string"
};
typeNames.interfaces["HostInternetScsiHbaParamValue"] = {
isInherited: "boolean"
};
typeNames.interfaces["HostInternetScsiHbaSendTarget"] = {
address: "string",
        port: "number",
        authenticationProperties: "HostInternetScsiHbaAuthenticationProperties",
        digestProperties: "HostInternetScsiHbaDigestProperties",
        supportedAdvancedOptions: "OptionDef",
        advancedOptions: "HostInternetScsiHbaParamValue",
        parent: "string"
};
typeNames.interfaces["HostInternetScsiHbaStaticTarget"] = {
address: "string",
        port: "number",
        iScsiName: "string",
        discoveryMethod: "string",
        authenticationProperties: "HostInternetScsiHbaAuthenticationProperties",
        digestProperties: "HostInternetScsiHbaDigestProperties",
        supportedAdvancedOptions: "OptionDef",
        advancedOptions: "HostInternetScsiHbaParamValue",
        parent: "string"
};
typeNames.interfaces["HostInternetScsiHbaTargetSet"] = {
staticTargets: "HostInternetScsiHbaStaticTarget",
        sendTargets: "HostInternetScsiHbaSendTarget"
};
typeNames.interfaces["HostInternetScsiTargetTransport"] = {
iScsiName: "string",
        iScsiAlias: "string",
        address: "string"
};
typeNames.interfaces["HostNetworkConfig"] = {
vswitch: "HostVirtualSwitchConfig",
        proxySwitch: "HostProxySwitchConfig",
        portgroup: "HostPortGroupConfig",
        pnic: "PhysicalNicConfig",
        vnic: "HostVirtualNicConfig",
        consoleVnic: "HostVirtualNicConfig",
        dnsConfig: "HostDnsConfig",
        ipRouteConfig: "HostIpRouteConfig",
        consoleIpRouteConfig: "HostIpRouteConfig",
        routeTableConfig: "HostIpRouteTableConfig",
        dhcp: "HostDhcpServiceConfig",
        nat: "HostNatServiceConfig",
        ipV6Enabled: "boolean",
        netStackSpec: "HostNetworkConfigNetStackSpec"
};
typeNames.interfaces["HostNetworkConfigNetStackSpec"] = {
netStackInstance: "HostNetStackInstance",
        operation: "string"
};
typeNames.interfaces["HostNetworkConfigResult"] = {
vnicDevice: "string",
        consoleVnicDevice: "string"
};
typeNames.interfaces["HostNvmeConnectSpec"] = {
subnqn: "string",
        controllerId: "number",
        adminQueueSize: "number",
        keepAliveTimeout: "number"
};
typeNames.interfaces["HostNvmeDiscoverSpec"] = {
autoConnect: "boolean"
};
typeNames.interfaces["HostNvmeOpaqueTransportParameters"] = {
trtype: "string",
        traddr: "string",
        adrfam: "string",
        trsvcid: "string",
        tsas: "Buffer"
};
typeNames.interfaces["HostNvmeOverFibreChannelParameters"] = {
nodeWorldWideName: "number",
        portWorldWideName: "number"
};
typeNames.interfaces["HostNvmeOverRdmaParameters"] = {
address: "string",
        addressFamily: "string",
        portNumber: "number"
};
typeNames.interfaces["HostOpaqueNetworkInfo"] = {
opaqueNetworkId: "string",
        opaqueNetworkName: "string",
        opaqueNetworkType: "string",
        pnicZone: "string",
        capability: "OpaqueNetworkCapability",
        extraConfig: "OptionValue"
};
typeNames.interfaces["HostParallelScsiTargetTransport"] = {

};
typeNames.interfaces["HostPcieTargetTransport"] = {

};
typeNames.interfaces["HostRdmaTargetTransport"] = {

};
typeNames.interfaces["HostScsiDisk"] = {
capacity: "HostDiskDimensionsLba",
        devicePath: "string",
        ssd: "boolean",
        localDisk: "boolean",
        physicalLocation: "string",
        emulatedDIXDIFEnabled: "boolean",
        vsanDiskInfo: "VsanHostVsanDiskInfo",
        scsiDiskType: "string"
};
typeNames.interfaces["HostScsiDiskPartition"] = {
diskName: "string",
        partition: "number"
};
typeNames.interfaces["HostSecuritySpec"] = {
adminPassword: "string",
        removePermission: "Permission",
        addPermission: "Permission"
};
typeNames.interfaces["HostSerialAttachedTargetTransport"] = {

};
typeNames.interfaces["HostListSummary"] = {
host: HostSystem,
        hardware: "HostHardwareSummary",
        runtime: "HostRuntimeInfo",
        config: "HostConfigSummary",
        quickStats: "HostListSummaryQuickStats",
        overallStatus: "ManagedEntityStatus",
        rebootRequired: "boolean",
        customValue: "CustomFieldValue",
        managementServerIp: "string",
        maxEVCModeKey: "string",
        currentEVCModeKey: "string",
        currentEVCGraphicsModeKey: "string",
        gateway: "HostListSummaryGatewaySummary",
        tpmAttestation: "HostTpmAttestationInfo",
        trustAuthorityAttestationInfos: "HostTrustAuthorityAttestationInfo"
};
typeNames.interfaces["HostConfigSummary"] = {
name: "string",
        port: "number",
        sslThumbprint: "string",
        product: "AboutInfo",
        vmotionEnabled: "boolean",
        faultToleranceEnabled: "boolean",
        featureVersion: "HostFeatureVersionInfo",
        agentVmDatastore: Datastore,
        agentVmNetwork: Network
};
typeNames.interfaces["HostListSummaryGatewaySummary"] = {
gatewayType: "string",
        gatewayId: "string"
};
typeNames.interfaces["HostHardwareSummary"] = {
vendor: "string",
        model: "string",
        uuid: "string",
        otherIdentifyingInfo: "HostSystemIdentificationInfo",
        memorySize: "number",
        cpuModel: "string",
        cpuMhz: "number",
        numCpuPkgs: "number",
        numCpuCores: "number",
        numCpuThreads: "number",
        numNics: "number",
        numHBAs: "number"
};
typeNames.interfaces["HostListSummaryQuickStats"] = {
overallCpuUsage: "number",
        overallMemoryUsage: "number",
        distributedCpuFairness: "number",
        distributedMemoryFairness: "number",
        availablePMemCapacity: "number",
        uptime: "number"
};
typeNames.interfaces["HostTpmBootSecurityOptionEventDetails"] = {
bootSecurityOption: "string"
};
typeNames.interfaces["HostTpmCommandEventDetails"] = {
commandLine: "string"
};
typeNames.interfaces["HostUnresolvedVmfsExtent"] = {
device: "HostScsiDiskPartition",
        devicePath: "string",
        vmfsUuid: "string",
        isHeadExtent: "boolean",
        ordinal: "number",
        startBlock: "number",
        endBlock: "number",
        reason: "string"
};
typeNames.interfaces["HostVFlashManagerVFlashCacheConfigInfo"] = {
vFlashModuleConfigOption: "HostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption",
        defaultVFlashModule: "string",
        swapCacheReservationInGB: "number"
};
typeNames.interfaces["HostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption"] = {
vFlashModule: "string",
        vFlashModuleVersion: "string",
        minSupportedModuleVersion: "string",
        cacheConsistencyType: "ChoiceOption",
        cacheMode: "ChoiceOption",
        blockSizeInKBOption: "LongOption",
        reservationInMBOption: "LongOption",
        maxDiskSizeInKB: "number"
};
typeNames.interfaces["HostVFlashManagerVFlashCacheConfigSpec"] = {
defaultVFlashModule: "string",
        swapCacheReservationInGB: "number"
};
typeNames.interfaces["HostVFlashManagerVFlashConfigInfo"] = {
vFlashResourceConfigInfo: "HostVFlashManagerVFlashResourceConfigInfo",
        vFlashCacheConfigInfo: "HostVFlashManagerVFlashCacheConfigInfo"
};
typeNames.interfaces["HostVFlashManagerVFlashResourceConfigInfo"] = {
vffs: "HostVffsVolume",
        capacity: "number"
};
typeNames.interfaces["HostVFlashManagerVFlashResourceConfigSpec"] = {
vffsUuid: "string"
};
typeNames.interfaces["HostVFlashManagerVFlashResourceRunTimeInfo"] = {
usage: "number",
        capacity: "number",
        accessible: "boolean",
        capacityForVmCache: "number",
        freeForVmCache: "number"
};
typeNames.interfaces["HostVMotionInfo"] = {
netConfig: "HostVMotionNetConfig",
        ipConfig: "HostIpConfig"
};
typeNames.interfaces["HostVffsVolume"] = {
majorVersion: "number",
        version: "string",
        uuid: "string",
        extent: "HostScsiDiskPartition"
};
typeNames.interfaces["HostVffsSpec"] = {
devicePath: "string",
        partition: "HostDiskPartitionSpec",
        majorVersion: "number",
        volumeName: "string"
};
typeNames.interfaces["VmfsDatastoreExpandSpec"] = {
partition: "HostDiskPartitionSpec",
        extent: "HostScsiDiskPartition"
};
typeNames.interfaces["VmfsDatastoreExtendSpec"] = {
partition: "HostDiskPartitionSpec",
        extent: "HostScsiDiskPartition"
};
typeNames.interfaces["HostVmfsVolume"] = {
blockSizeMb: "number",
        blockSize: "number",
        unmapGranularity: "number",
        unmapPriority: "string",
        unmapBandwidthSpec: "VmfsUnmapBandwidthSpec",
        maxBlocks: "number",
        majorVersion: "number",
        version: "string",
        uuid: "string",
        extent: "HostScsiDiskPartition",
        vmfsUpgradable: "boolean",
        forceMountedInfo: "HostForceMountedInfo",
        ssd: "boolean",
        local: "boolean",
        scsiDiskType: "string"
};
typeNames.interfaces["VmfsConfigOption"] = {
blockSizeOption: "number",
        unmapGranularityOption: "number",
        unmapBandwidthFixedValue: "LongOption",
        unmapBandwidthDynamicMin: "LongOption",
        unmapBandwidthDynamicMax: "LongOption",
        unmapBandwidthIncrement: "number"
};
typeNames.interfaces["HostVmfsSpec"] = {
extent: "HostScsiDiskPartition",
        blockSizeMb: "number",
        majorVersion: "number",
        volumeName: "string",
        blockSize: "number",
        unmapGranularity: "number",
        unmapPriority: "string",
        unmapBandwidthSpec: "VmfsUnmapBandwidthSpec"
};
typeNames.interfaces["VmfsUnmapBandwidthSpec"] = {
policy: "string",
        fixedValue: "number",
        dynamicMin: "number",
        dynamicMax: "number"
};
typeNames.interfaces["BoolOption"] = {
supported: "boolean",
        defaultValue: "boolean"
};
typeNames.interfaces["ChoiceOption"] = {
choiceInfo: "ElementDescription",
        defaultIndex: "number"
};
typeNames.interfaces["FloatOption"] = {
min: "number",
        max: "number",
        defaultValue: "number"
};
typeNames.interfaces["IntOption"] = {
min: "number",
        max: "number",
        defaultValue: "number"
};
typeNames.interfaces["LongOption"] = {
min: "number",
        max: "number",
        defaultValue: "number"
};
typeNames.interfaces["ProfileCompositeExpression"] = {
operator: "string",
        expressionName: "string"
};
typeNames.interfaces["CompositePolicyOption"] = {
option: "PolicyOption"
};
typeNames.interfaces["ProfileCompositePolicyOptionMetadata"] = {
option: "string"
};
typeNames.interfaces["DvsHostVNicProfile"] = {

};
typeNames.interfaces["DvsServiceConsoleVNicProfile"] = {

};
typeNames.interfaces["HostPortGroupProfile"] = {
ipConfig: "IpAddressProfile"
};
typeNames.interfaces["HostProfileCompleteConfigSpec"] = {
applyProfile: "HostApplyProfile",
        customComplyProfile: "ComplianceProfile",
        disabledExpressionListChanged: "boolean",
        disabledExpressionList: "string",
        validatorHost: HostSystem,
        validating: "boolean",
        hostConfig: "HostProfileConfigInfo"
};
typeNames.interfaces["HostProfileConfigInfo"] = {
applyProfile: "HostApplyProfile",
        defaultComplyProfile: "ComplianceProfile",
        defaultComplyLocator: "ComplianceLocator",
        customComplyProfile: "ComplianceProfile",
        disabledExpressionList: "string",
        description: "ProfileDescription"
};
typeNames.interfaces["HostProfileConfigSpec"] = {

};
typeNames.interfaces["HostProfileHostBasedConfigSpec"] = {
host: HostSystem,
        useHostProfileEngine: "boolean"
};
typeNames.interfaces["HostProfileSerializedHostProfileSpec"] = {
validatorHost: HostSystem,
        validating: "boolean"
};
typeNames.interfaces["HostProfileValidationFailureInfo"] = {
name: "string",
        annotation: "string",
        updateType: "string",
        host: HostSystem,
        applyProfile: "HostApplyProfile",
        failures: "ProfileUpdateFailedUpdateFailure",
        faults: "MethodFault"
};
typeNames.interfaces["NetStackInstanceProfile"] = {
key: "string",
        dnsConfig: "NetworkProfileDnsConfigProfile",
        ipRouteConfig: "IpRouteProfile"
};
typeNames.interfaces["AnswerFileCreateSpec"] = {
validating: "boolean"
};
typeNames.interfaces["AnswerFileOptionsCreateSpec"] = {
userInput: "ProfileDeferredPolicyOptionParameter"
};
typeNames.interfaces["AnswerFileSerializedCreateSpec"] = {
answerFileConfigString: "string"
};
typeNames.interfaces["ApplyHostProfileConfigurationResult"] = {
startTime: "Date",
        completeTime: "Date",
        host: HostSystem,
        status: "string",
        errors: "MethodFault"
};
typeNames.interfaces["ApplyHostProfileConfigurationSpec"] = {
host: HostSystem,
        taskListRequirement: "string",
        taskDescription: "LocalizableMessage",
        rebootStateless: "boolean",
        rebootHost: "boolean",
        faultData: "MethodFault"
};
typeNames.interfaces["HostProfileManagerCompositionResult"] = {
errors: "LocalizableMessage",
        results: "HostProfileManagerCompositionResultResultElement"
};
typeNames.interfaces["HostProfileManagerCompositionResultResultElement"] = {
target: Profile,
        status: "string",
        errors: "LocalizableMessage"
};
typeNames.interfaces["HostProfileManagerCompositionValidationResult"] = {
results: "HostProfileManagerCompositionValidationResultResultElement",
        errors: "LocalizableMessage"
};
typeNames.interfaces["HostProfileManagerCompositionValidationResultResultElement"] = {
target: Profile,
        status: "string",
        errors: "LocalizableMessage",
        sourceDiffForToBeMerged: "HostApplyProfile",
        targetDiffForToBeMerged: "HostApplyProfile",
        toBeAdded: "HostApplyProfile",
        toBeDeleted: "HostApplyProfile",
        toBeDisabled: "HostApplyProfile",
        toBeEnabled: "HostApplyProfile",
        toBeReenableCC: "HostApplyProfile"
};
typeNames.interfaces["HostProfileManagerConfigTaskList"] = {
configSpec: "HostConfigSpec",
        taskDescription: "LocalizableMessage",
        taskListRequirement: "string"
};
typeNames.interfaces["HostProfilesEntityCustomizations"] = {

};
typeNames.interfaces["HostProfileManagerHostToConfigSpecMap"] = {
host: HostSystem,
        configSpec: "AnswerFileCreateSpec"
};
typeNames.interfaces["StructuredCustomizations"] = {
entity: ManagedEntity,
        customizations: "AnswerFile"
};
typeNames.interfaces["AfterStartupTaskScheduler"] = {
minute: "number"
};
typeNames.interfaces["OnceTaskScheduler"] = {
runAt: "Date"
};
typeNames.interfaces["RecurrentTaskScheduler"] = {
interval: "number"
};
typeNames.interfaces["ScheduledTaskInfo"] = {
scheduledTask: ScheduledTask,
        entity: ManagedEntity,
        lastModifiedTime: "Date",
        lastModifiedUser: "string",
        nextRunTime: "Date",
        prevRunTime: "Date",
        state: "TaskInfoState",
        error: "MethodFault",
        result: "any",
        progress: "number",
        activeTask: Task,
        taskObject: "ManagedObject"
};
typeNames.interfaces["StorageDrsPodSelectionSpec"] = {
initialVmConfig: "VmPodConfigForPlacement",
        storagePod: StoragePod
};
typeNames.interfaces["PodDiskLocator"] = {
diskId: "number",
        diskMoveType: "string",
        diskBackingInfo: "VirtualDeviceBackingInfo",
        profile: "VirtualMachineProfileSpec"
};
typeNames.interfaces["VmPodConfigForPlacement"] = {
storagePod: StoragePod,
        disk: "PodDiskLocator",
        vmConfig: "StorageDrsVmConfigInfo",
        interVmRule: "ClusterRuleInfo"
};
typeNames.interfaces["StoragePlacementSpec"] = {
type: "string",
        priority: "VirtualMachineMovePriority",
        vm: VirtualMachine,
        podSelectionSpec: "StorageDrsPodSelectionSpec",
        cloneSpec: "VirtualMachineCloneSpec",
        cloneName: "string",
        configSpec: "VirtualMachineConfigSpec",
        relocateSpec: "VirtualMachineRelocateSpec",
        resourcePool: ResourcePool,
        host: HostSystem,
        folder: Folder,
        disallowPrerequisiteMoves: "boolean",
        resourceLeaseDurationSec: "number"
};
typeNames.interfaces["VirtualDiskAntiAffinityRuleSpec"] = {
diskId: "number"
};
typeNames.interfaces["VirtualDiskRuleSpec"] = {
diskRuleType: "string",
        diskId: "number"
};
typeNames.interfaces["VAppConfigInfo"] = {
entityConfig: "VAppEntityConfigInfo",
        annotation: "string",
        instanceUuid: "string",
        managedBy: "ManagedByInfo"
};
typeNames.interfaces["VAppConfigSpec"] = {
entityConfig: "VAppEntityConfigInfo",
        annotation: "string",
        instanceUuid: "string",
        managedBy: "ManagedByInfo"
};
typeNames.interfaces["VirtualAppImportSpec"] = {
name: "string",
        vAppConfigSpec: "VAppConfigSpec",
        resourcePoolSpec: "ResourceConfigSpec",
        child: "ImportSpec"
};
typeNames.interfaces["VirtualMachineCdromInfo"] = {
description: "string"
};
typeNames.interfaces["ConfigTarget"] = {
numCpus: "number",
        numCpuCores: "number",
        numNumaNodes: "number",
        maxCpusPerHost: "number",
        smcPresent: "boolean",
        datastore: "VirtualMachineDatastoreInfo",
        network: "VirtualMachineNetworkInfo",
        opaqueNetwork: "OpaqueNetworkTargetInfo",
        distributedVirtualPortgroup: "DistributedVirtualPortgroupInfo",
        distributedVirtualSwitch: "DistributedVirtualSwitchInfo",
        cdRom: "VirtualMachineCdromInfo",
        serial: "VirtualMachineSerialInfo",
        parallel: "VirtualMachineParallelInfo",
        sound: "VirtualMachineSoundInfo",
        usb: "VirtualMachineUsbInfo",
        floppy: "VirtualMachineFloppyInfo",
        legacyNetworkInfo: "VirtualMachineLegacyNetworkSwitchInfo",
        scsiPassthrough: "VirtualMachineScsiPassthroughInfo",
        scsiDisk: "VirtualMachineScsiDiskDeviceInfo",
        ideDisk: "VirtualMachineIdeDiskDeviceInfo",
        maxMemMBOptimalPerf: "number",
        supportedMaxMemMB: "number",
        resourcePool: "ResourcePoolRuntimeInfo",
        autoVmotion: "boolean",
        pciPassthrough: "VirtualMachinePciPassthroughInfo",
        sriov: "VirtualMachineSriovInfo",
        vFlashModule: "VirtualMachineVFlashModuleInfo",
        sharedGpuPassthroughTypes: "VirtualMachinePciSharedGpuPassthroughInfo",
        availablePersistentMemoryReservationMB: "number",
        dynamicPassthrough: "VirtualMachineDynamicPassthroughInfo",
        sgxTargetInfo: "VirtualMachineSgxTargetInfo",
        precisionClockInfo: "VirtualMachinePrecisionClockInfo",
        sevSupported: "boolean"
};
typeNames.interfaces["VirtualMachineDefaultProfileSpec"] = {

};
typeNames.interfaces["VirtualMachineDefinedProfileSpec"] = {
profileId: "string",
        replicationSpec: "ReplicationSpec",
        profileData: "VirtualMachineProfileRawData",
        profileParams: "KeyValue"
};
typeNames.interfaces["VirtualMachineDiskDeviceInfo"] = {
capacity: "number",
        vm: VirtualMachine
};
typeNames.interfaces["VirtualMachineDynamicPassthroughInfo"] = {
vendorName: "string",
        deviceName: "string",
        customLabel: "string",
        vendorId: "number",
        deviceId: "number"
};
typeNames.interfaces["VirtualMachineEmptyProfileSpec"] = {

};
typeNames.interfaces["VirtualMachineFloppyInfo"] = {

};
typeNames.interfaces["VirtualMachineIdeDiskDeviceInfo"] = {
partitionTable: "VirtualMachineIdeDiskDevicePartitionInfo"
};
typeNames.interfaces["VirtualMachineIdeDiskDevicePartitionInfo"] = {
id: "number",
        capacity: "number"
};
typeNames.interfaces["VirtualMachineNetworkInfo"] = {
network: "NetworkSummary",
        vswitch: "string"
};
typeNames.interfaces["OpaqueNetworkTargetInfo"] = {
network: "OpaqueNetworkSummary",
        networkReservationSupported: "boolean"
};
typeNames.interfaces["VirtualMachineParallelInfo"] = {

};
typeNames.interfaces["VirtualMachinePciPassthroughInfo"] = {
pciDevice: "HostPciDevice",
        systemId: "string"
};
typeNames.interfaces["VirtualMachinePciSharedGpuPassthroughInfo"] = {
vgpu: "string"
};
typeNames.interfaces["VirtualMachinePrecisionClockInfo"] = {
systemClockProtocol: "string"
};
typeNames.interfaces["VirtualMachineRelocateSpec"] = {
service: "ServiceLocator",
        folder: Folder,
        datastore: Datastore,
        diskMoveType: "string",
        pool: ResourcePool,
        host: HostSystem,
        disk: "VirtualMachineRelocateSpecDiskLocator",
        transform: "VirtualMachineRelocateTransformation",
        deviceChange: "VirtualDeviceConfigSpec",
        profile: "VirtualMachineProfileSpec",
        cryptoSpec: "CryptoSpec"
};
typeNames.interfaces["VirtualMachineRelocateSpecDiskLocator"] = {
diskId: "number",
        datastore: Datastore,
        diskMoveType: "string",
        diskBackingInfo: "VirtualDeviceBackingInfo",
        profile: "VirtualMachineProfileSpec",
        backing: "VirtualMachineRelocateSpecDiskLocatorBackingSpec"
};
typeNames.interfaces["VirtualMachineRelocateSpecDiskLocatorBackingSpec"] = {
parent: "VirtualMachineRelocateSpecDiskLocatorBackingSpec",
        crypto: "CryptoSpec"
};
typeNames.interfaces["VirtualMachineRuntimeInfo"] = {
device: "VirtualMachineDeviceRuntimeInfo",
        host: HostSystem,
        connectionState: "VirtualMachineConnectionState",
        powerState: "VirtualMachinePowerState",
        faultToleranceState: "VirtualMachineFaultToleranceState",
        dasVmProtection: "VirtualMachineRuntimeInfoDasProtectionState",
        toolsInstallerMounted: "boolean",
        suspendTime: "Date",
        bootTime: "Date",
        suspendInterval: "number",
        question: "VirtualMachineQuestionInfo",
        memoryOverhead: "number",
        maxCpuUsage: "number",
        maxMemoryUsage: "number",
        numMksConnections: "number",
        recordReplayState: "VirtualMachineRecordReplayState",
        cleanPowerOff: "boolean",
        needSecondaryReason: "string",
        onlineStandby: "boolean",
        minRequiredEVCModeKey: "string",
        consolidationNeeded: "boolean",
        offlineFeatureRequirement: "VirtualMachineFeatureRequirement",
        featureRequirement: "VirtualMachineFeatureRequirement",
        featureMask: "HostFeatureMask",
        vFlashCacheAllocation: "number",
        paused: "boolean",
        snapshotInBackground: "boolean",
        quiescedForkParent: "boolean",
        instantCloneFrozen: "boolean",
        cryptoState: "string"
};
typeNames.interfaces["VirtualMachineRuntimeInfoDasProtectionState"] = {
dasProtected: "boolean"
};
typeNames.interfaces["VirtualMachineScsiDiskDeviceInfo"] = {
disk: "HostScsiDisk",
        transportHint: "string",
        lunNumber: "number"
};
typeNames.interfaces["VirtualMachineScsiPassthroughInfo"] = {
scsiClass: "string",
        vendor: "string",
        physicalUnitNumber: "number"
};
typeNames.interfaces["VirtualMachineSerialInfo"] = {

};
typeNames.interfaces["VirtualMachineSgxTargetInfo"] = {
maxEpcSize: "number",
        flcModes: "string",
        lePubKeyHashes: "string"
};
typeNames.interfaces["VirtualMachineSnapshotTree"] = {
snapshot: VirtualMachineSnapshot,
        vm: VirtualMachine,
        name: "string",
        description: "string",
        id: "number",
        createTime: "Date",
        state: "VirtualMachinePowerState",
        quiesced: "boolean",
        backupManifest: "string",
        childSnapshotList: "VirtualMachineSnapshotTree",
        replaySupported: "boolean"
};
typeNames.interfaces["VirtualMachineSoundInfo"] = {

};
typeNames.interfaces["VirtualMachineSriovInfo"] = {
virtualFunction: "boolean",
        pnic: "string",
        devicePool: "VirtualMachineSriovDevicePoolInfo"
};
typeNames.interfaces["VirtualMachineSummary"] = {
vm: VirtualMachine,
        runtime: "VirtualMachineRuntimeInfo",
        guest: "VirtualMachineGuestSummary",
        config: "VirtualMachineConfigSummary",
        storage: "VirtualMachineStorageSummary",
        quickStats: "VirtualMachineQuickStats",
        overallStatus: "ManagedEntityStatus",
        customValue: "CustomFieldValue"
};
typeNames.interfaces["VirtualMachineConfigSummary"] = {
name: "string",
        template: "boolean",
        vmPathName: "string",
        memorySizeMB: "number",
        cpuReservation: "number",
        memoryReservation: "number",
        numCpu: "number",
        numEthernetCards: "number",
        numVirtualDisks: "number",
        uuid: "string",
        instanceUuid: "string",
        guestId: "string",
        guestFullName: "string",
        annotation: "string",
        product: "VAppProductInfo",
        installBootRequired: "boolean",
        ftInfo: "FaultToleranceConfigInfo",
        managedBy: "ManagedByInfo",
        tpmPresent: "boolean",
        numVmiopBackings: "number",
        hwVersion: "string"
};
typeNames.interfaces["VirtualMachineGuestSummary"] = {
guestId: "string",
        guestFullName: "string",
        toolsStatus: "VirtualMachineToolsStatus",
        toolsVersionStatus: "string",
        toolsVersionStatus2: "string",
        toolsRunningStatus: "string",
        hostName: "string",
        ipAddress: "string",
        hwVersion: "string"
};
typeNames.interfaces["VirtualMachineQuickStats"] = {
overallCpuUsage: "number",
        overallCpuDemand: "number",
        overallCpuReadiness: "number",
        guestMemoryUsage: "number",
        hostMemoryUsage: "number",
        guestHeartbeatStatus: "ManagedEntityStatus",
        distributedCpuEntitlement: "number",
        distributedMemoryEntitlement: "number",
        staticCpuEntitlement: "number",
        staticMemoryEntitlement: "number",
        grantedMemory: "number",
        privateMemory: "number",
        sharedMemory: "number",
        swappedMemory: "number",
        balloonedMemory: "number",
        consumedOverheadMemory: "number",
        ftLogBandwidth: "number",
        ftSecondaryLatency: "number",
        ftLatencyStatus: "ManagedEntityStatus",
        compressedMemory: "number",
        uptimeSeconds: "number",
        ssdSwappedMemory: "number"
};
typeNames.interfaces["VirtualMachineStorageSummary"] = {
committed: "number",
        uncommitted: "number",
        unshared: "number",
        timestamp: "Date"
};
typeNames.interfaces["VirtualMachineVFlashModuleInfo"] = {
vFlashModule: "HostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption"
};
typeNames.interfaces["VirtualMachineImportSpec"] = {
configSpec: "VirtualMachineConfigSpec",
        resPoolEntity: ResourcePool
};
typeNames.interfaces["CustomizationAutoIpV6Generator"] = {

};
typeNames.interfaces["CustomizationCustomIpGenerator"] = {
argument: "string"
};
typeNames.interfaces["CustomizationCustomIpV6Generator"] = {
argument: "string"
};
typeNames.interfaces["CustomizationCustomName"] = {
argument: "string"
};
typeNames.interfaces["CustomizationDhcpIpGenerator"] = {

};
typeNames.interfaces["CustomizationDhcpIpV6Generator"] = {

};
typeNames.interfaces["CustomizationFixedIp"] = {
ipAddress: "string"
};
typeNames.interfaces["CustomizationFixedIpV6"] = {
ipAddress: "string",
        subnetMask: "number"
};
typeNames.interfaces["CustomizationFixedName"] = {
name: "string"
};
typeNames.interfaces["CustomizationLinuxOptions"] = {

};
typeNames.interfaces["VirtualCdrom"] = {

};
typeNames.interfaces["VirtualCdromAtapiBackingInfo"] = {

};
typeNames.interfaces["VirtualCdromIsoBackingInfo"] = {

};
typeNames.interfaces["VirtualCdromPassthroughBackingInfo"] = {
exclusive: "boolean"
};
typeNames.interfaces["VirtualCdromRemoteAtapiBackingInfo"] = {

};
typeNames.interfaces["VirtualCdromRemotePassthroughBackingInfo"] = {
exclusive: "boolean"
};
typeNames.interfaces["VirtualCdromOption"] = {

};
typeNames.interfaces["VirtualCdromAtapiBackingOption"] = {

};
typeNames.interfaces["VirtualCdromIsoBackingOption"] = {

};
typeNames.interfaces["VirtualCdromPassthroughBackingOption"] = {
exclusive: "BoolOption"
};
typeNames.interfaces["VirtualCdromRemoteAtapiBackingOption"] = {

};
typeNames.interfaces["VirtualCdromRemotePassthroughBackingOption"] = {
exclusive: "BoolOption"
};
typeNames.interfaces["VirtualController"] = {
busNumber: "number",
        device: "number"
};
typeNames.interfaces["VirtualControllerOption"] = {
devices: "IntOption",
        supportedDevice: "string"
};
typeNames.interfaces["VirtualE1000"] = {

};
typeNames.interfaces["VirtualE1000Option"] = {

};
typeNames.interfaces["VirtualE1000e"] = {

};
typeNames.interfaces["VirtualE1000eOption"] = {

};
typeNames.interfaces["VirtualEnsoniq1371"] = {

};
typeNames.interfaces["VirtualEnsoniq1371Option"] = {

};
typeNames.interfaces["VirtualHdAudioCard"] = {

};
typeNames.interfaces["VirtualHdAudioCardOption"] = {

};
typeNames.interfaces["VirtualIDEController"] = {

};
typeNames.interfaces["VirtualIDEControllerOption"] = {
numIDEDisks: "IntOption",
        numIDECdroms: "IntOption"
};
typeNames.interfaces["VirtualNVDIMMController"] = {

};
typeNames.interfaces["VirtualNVDIMMControllerOption"] = {
numNVDIMMControllers: "IntOption"
};
typeNames.interfaces["VirtualNVMEController"] = {

};
typeNames.interfaces["VirtualNVMEControllerOption"] = {
numNVMEDisks: "IntOption"
};
typeNames.interfaces["VirtualPCIController"] = {

};
typeNames.interfaces["VirtualPCIControllerOption"] = {
numSCSIControllers: "IntOption",
        numEthernetCards: "IntOption",
        numVideoCards: "IntOption",
        numSoundCards: "IntOption",
        numVmiRoms: "IntOption",
        numVmciDevices: "IntOption",
        numPCIPassthroughDevices: "IntOption",
        numSasSCSIControllers: "IntOption",
        numVmxnet3EthernetCards: "IntOption",
        numParaVirtualSCSIControllers: "IntOption",
        numSATAControllers: "IntOption",
        numNVMEControllers: "IntOption",
        numVmxnet3VrdmaEthernetCards: "IntOption"
};
typeNames.interfaces["VirtualPS2Controller"] = {

};
typeNames.interfaces["VirtualPS2ControllerOption"] = {
numKeyboards: "IntOption",
        numPointingDevices: "IntOption"
};
typeNames.interfaces["VirtualSATAController"] = {

};
typeNames.interfaces["VirtualSATAControllerOption"] = {
numSATADisks: "IntOption",
        numSATACdroms: "IntOption"
};
typeNames.interfaces["VirtualSCSIController"] = {
hotAddRemove: "boolean",
        sharedBus: "VirtualSCSISharing",
        scsiCtlrUnitNumber: "number"
};
typeNames.interfaces["VirtualSCSIControllerOption"] = {
numSCSIDisks: "IntOption",
        numSCSICdroms: "IntOption",
        numSCSIPassthrough: "IntOption",
        sharing: "VirtualSCSISharing",
        defaultSharedIndex: "number",
        hotAddRemove: "BoolOption",
        scsiCtlrUnitNumber: "number"
};
typeNames.interfaces["VirtualSIOController"] = {

};
typeNames.interfaces["VirtualSIOControllerOption"] = {
numFloppyDrives: "IntOption",
        numSerialPorts: "IntOption",
        numParallelPorts: "IntOption"
};
typeNames.interfaces["VirtualSoundBlaster16"] = {

};
typeNames.interfaces["VirtualSoundBlaster16Option"] = {

};
typeNames.interfaces["VirtualUSBController"] = {
autoConnectDevices: "boolean",
        ehciEnabled: "boolean"
};
typeNames.interfaces["VirtualUSBControllerPciBusSlotInfo"] = {
ehciPciSlotNumber: "number"
};
typeNames.interfaces["VirtualUSBControllerOption"] = {
autoConnectDevices: "BoolOption",
        ehciSupported: "BoolOption",
        supportedSpeeds: "string"
};
typeNames.interfaces["VirtualUSBXHCIController"] = {
autoConnectDevices: "boolean"
};
typeNames.interfaces["VirtualUSBXHCIControllerOption"] = {
autoConnectDevices: "BoolOption",
        supportedSpeeds: "string"
};
typeNames.interfaces["VirtualVmxnet2Option"] = {

};
typeNames.interfaces["VirtualVmxnet3Option"] = {

};
typeNames.interfaces["VirtualVmxnet3VrdmaOption"] = {
deviceProtocol: "ChoiceOption"
};
typeNames.interfaces["VslmCloneSpec"] = {
name: "string",
        keepAfterDeleteVm: "boolean",
        metadata: "KeyValue"
};
typeNames.interfaces["ComputeResourceConfigInfo"] = {
vmSwapPlacement: "string",
        spbmEnabled: "boolean",
        defaultHardwareVersionKey: "string"
};
typeNames.interfaces["ComputeResourceConfigSpec"] = {
vmSwapPlacement: "string",
        spbmEnabled: "boolean",
        defaultHardwareVersionKey: "string",
        desiredSoftwareSpec: "DesiredSoftwareSpec"
};
typeNames.interfaces["ComputeResourceHostSPBMLicenseInfo"] = {
host: HostSystem,
        licenseState: "ComputeResourceHostSPBMLicenseInfoHostSPBMLicenseState"
};
typeNames.interfaces["ComputeResourceSummary"] = {
totalCpu: "number",
        totalMemory: "number",
        numCpuCores: "number",
        numCpuThreads: "number",
        effectiveCpu: "number",
        effectiveMemory: "number",
        numHosts: "number",
        numEffectiveHosts: "number",
        overallStatus: "ManagedEntityStatus"
};
typeNames.interfaces["DatacenterBasicConnectInfo"] = {
hostname: "string",
        error: "MethodFault",
        serverIp: "string",
        numVm: "number",
        numPoweredOnVm: "number",
        hostProductInfo: "AboutInfo",
        hardwareVendor: "string",
        hardwareModel: "string"
};
typeNames.interfaces["DatacenterConfigInfo"] = {
defaultHardwareVersionKey: "string"
};
typeNames.interfaces["DatacenterConfigSpec"] = {
defaultHardwareVersionKey: "string"
};
typeNames.interfaces["DatastoreCapability"] = {
directoryHierarchySupported: "boolean",
        rawDiskMappingsSupported: "boolean",
        perFileThinProvisioningSupported: "boolean",
        storageIORMSupported: "boolean",
        nativeSnapshotSupported: "boolean",
        topLevelDirectoryCreateSupported: "boolean",
        seSparseSupported: "boolean",
        vmfsSparseSupported: "boolean",
        vsanSparseSupported: "boolean",
        upitSupported: "boolean",
        vmdkExpandSupported: "boolean",
        clusteredVmdkSupported: "boolean"
};
typeNames.interfaces["DatastoreHostMount"] = {
key: HostSystem,
        mountInfo: "HostMountInfo"
};
typeNames.interfaces["DatastoreInfo"] = {
name: "string",
        url: "string",
        freeSpace: "number",
        maxFileSize: "number",
        maxVirtualDiskCapacity: "number",
        maxMemoryFileSize: "number",
        timestamp: "Date",
        containerId: "string",
        aliasOf: "string"
};
typeNames.interfaces["DatastoreMountPathDatastorePair"] = {
oldMountPath: "string",
        datastore: Datastore
};
typeNames.interfaces["DatastoreSummary"] = {
datastore: Datastore,
        name: "string",
        url: "string",
        capacity: "number",
        freeSpace: "number",
        uncommitted: "number",
        accessible: "boolean",
        multipleHostAccess: "boolean",
        type: "string",
        maintenanceMode: "string"
};
typeNames.interfaces["DatastoreVVolContainerFailoverPair"] = {
srcContainer: "string",
        tgtContainer: "string",
        vvolMapping: "KeyValue"
};
typeNames.interfaces["DVSBackupRestoreCapability"] = {
backupRestoreSupported: "boolean"
};
typeNames.interfaces["DVSCapability"] = {
dvsOperationSupported: "boolean",
        dvPortGroupOperationSupported: "boolean",
        dvPortOperationSupported: "boolean",
        compatibleHostComponentProductInfo: "DistributedVirtualSwitchHostProductSpec",
        featuresSupported: "DVSFeatureCapability"
};
typeNames.interfaces["DVSConfigInfo"] = {
uuid: "string",
        name: "string",
        numStandalonePorts: "number",
        numPorts: "number",
        maxPorts: "number",
        uplinkPortPolicy: "DVSUplinkPortPolicy",
        uplinkPortgroup: DistributedVirtualPortgroup,
        defaultPortConfig: "DVPortSetting",
        host: "DistributedVirtualSwitchHostMember",
        productInfo: "DistributedVirtualSwitchProductSpec",
        targetInfo: "DistributedVirtualSwitchProductSpec",
        extensionKey: "string",
        vendorSpecificConfig: "DistributedVirtualSwitchKeyedOpaqueBlob",
        policy: "DVSPolicy",
        description: "string",
        configVersion: "string",
        contact: "DVSContactInfo",
        switchIpAddress: "string",
        createTime: "Date",
        networkResourceManagementEnabled: "boolean",
        defaultProxySwitchMaxNumPorts: "number",
        healthCheckConfig: "DVSHealthCheckConfig",
        infrastructureTrafficResourceConfig: "DvsHostInfrastructureTrafficResource",
        netResourcePoolTrafficResourceConfig: "DvsHostInfrastructureTrafficResource",
        networkResourceControlVersion: "string",
        vmVnicNetworkResourcePool: "DVSVmVnicNetworkResourcePool",
        pnicCapacityRatioForReservation: "number"
};
typeNames.interfaces["DVSConfigSpec"] = {
configVersion: "string",
        name: "string",
        numStandalonePorts: "number",
        maxPorts: "number",
        uplinkPortPolicy: "DVSUplinkPortPolicy",
        uplinkPortgroup: DistributedVirtualPortgroup,
        defaultPortConfig: "DVPortSetting",
        host: "DistributedVirtualSwitchHostMemberConfigSpec",
        extensionKey: "string",
        description: "string",
        policy: "DVSPolicy",
        vendorSpecificConfig: "DistributedVirtualSwitchKeyedOpaqueBlob",
        contact: "DVSContactInfo",
        switchIpAddress: "string",
        defaultProxySwitchMaxNumPorts: "number",
        infrastructureTrafficResourceConfig: "DvsHostInfrastructureTrafficResource",
        netResourcePoolTrafficResourceConfig: "DvsHostInfrastructureTrafficResource",
        networkResourceControlVersion: "string"
};
typeNames.interfaces["DVSContactInfo"] = {
name: "string",
        contact: "string"
};
typeNames.interfaces["DVSCreateSpec"] = {
configSpec: "DVSConfigSpec",
        productInfo: "DistributedVirtualSwitchProductSpec",
        capability: "DVSCapability"
};
typeNames.interfaces["DVSFeatureCapability"] = {
networkResourceManagementSupported: "boolean",
        vmDirectPathGen2Supported: "boolean",
        nicTeamingPolicy: "string",
        networkResourcePoolHighShareValue: "number",
        networkResourceManagementCapability: "DVSNetworkResourceManagementCapability",
        healthCheckCapability: "DVSHealthCheckCapability",
        rollbackCapability: "DVSRollbackCapability",
        backupRestoreCapability: "DVSBackupRestoreCapability",
        networkFilterSupported: "boolean",
        macLearningSupported: "boolean"
};
typeNames.interfaces["DVSHealthCheckConfig"] = {
enable: "boolean",
        interval: "number"
};
typeNames.interfaces["DVSHealthCheckCapability"] = {

};
typeNames.interfaces["DvsHostInfrastructureTrafficResource"] = {
key: "string",
        description: "string",
        allocationInfo: "DvsHostInfrastructureTrafficResourceAllocation"
};
typeNames.interfaces["DvsHostInfrastructureTrafficResourceAllocation"] = {
limit: "number",
        shares: "SharesInfo",
        reservation: "number"
};
typeNames.interfaces["DVSNameArrayUplinkPortPolicy"] = {
uplinkPortName: "string"
};
typeNames.interfaces["DVSNetworkResourceManagementCapability"] = {
networkResourceManagementSupported: "boolean",
        networkResourcePoolHighShareValue: "number",
        qosSupported: "boolean",
        userDefinedNetworkResourcePoolsSupported: "boolean",
        networkResourceControlVersion3Supported: "boolean",
        userDefinedInfraTrafficPoolSupported: "boolean"
};
typeNames.interfaces["DvsResourceRuntimeInfo"] = {
capacity: "number",
        usage: "number",
        available: "number",
        allocatedResource: "DvsVnicAllocatedResource",
        vmVnicNetworkResourcePoolRuntime: "DvsVmVnicNetworkResourcePoolRuntimeInfo"
};
typeNames.interfaces["DVSRollbackCapability"] = {
rollbackSupported: "boolean"
};
typeNames.interfaces["DVSRuntimeInfo"] = {
hostMemberRuntime: "HostMemberRuntimeInfo",
        resourceRuntimeInfo: "DvsResourceRuntimeInfo"
};
typeNames.interfaces["DVSSummary"] = {
name: "string",
        uuid: "string",
        numPorts: "number",
        productInfo: "DistributedVirtualSwitchProductSpec",
        hostMember: HostSystem,
        vm: VirtualMachine,
        host: HostSystem,
        portgroupName: "string",
        description: "string",
        contact: "DVSContactInfo",
        numHosts: "number"
};
typeNames.interfaces["DVSPolicy"] = {
autoPreInstallAllowed: "boolean",
        autoUpgradeAllowed: "boolean",
        partialUpgradeAllowed: "boolean"
};
typeNames.interfaces["DVSUplinkPortPolicy"] = {

};
typeNames.interfaces["FolderBatchAddHostsToClusterResult"] = {
hostsAddedToCluster: HostSystem,
        hostsFailedInventoryAdd: "FolderFailedHostResult",
        hostsFailedMoveToCluster: "FolderFailedHostResult"
};
typeNames.interfaces["FolderBatchAddStandaloneHostsResult"] = {
addedHosts: HostSystem,
        hostsFailedInventoryAdd: "FolderFailedHostResult"
};
typeNames.interfaces["FolderFailedHostResult"] = {
hostName: "string",
        host: HostSystem,
        context: "LocalizableMessage",
        fault: "MethodFault"
};
typeNames.interfaces["FolderNewHostSpec"] = {
hostCnxSpec: "HostConnectSpec",
        esxLicense: "string"
};
typeNames.interfaces["HealthUpdate"] = {
entity: ManagedEntity,
        healthUpdateInfoId: "string",
        id: "string",
        status: "ManagedEntityStatus",
        remediation: "string"
};
typeNames.interfaces["HostSystemComplianceCheckState"] = {
state: "string",
        checkTime: "Date"
};
typeNames.interfaces["HostSystemReconnectSpec"] = {
syncState: "boolean"
};
typeNames.interfaces["HostSystemRemediationState"] = {
state: "string",
        operationTime: "Date"
};
typeNames.interfaces["HostVMotionCompatibility"] = {
host: HostSystem,
        compatibility: "string"
};
typeNames.interfaces["ProductComponentInfo"] = {
id: "string",
        name: "string",
        version: "string",
        release: "number"
};
typeNames.interfaces["StoragePodSummary"] = {
name: "string",
        capacity: "number",
        freeSpace: "number"
};
typeNames.interfaces["VasaProviderContainerSpec"] = {
vasaProviderInfo: "VimVasaProviderInfo",
        scId: "string",
        deleted: "boolean"
};
typeNames.interfaces["ClusterAffinityRuleSpec"] = {
vm: VirtualMachine
};
typeNames.interfaces["ClusterAntiAffinityRuleSpec"] = {
vm: VirtualMachine
};
typeNames.interfaces["ClusterConfigInfoEx"] = {
dasConfig: "ClusterDasConfigInfo",
        dasVmConfig: "ClusterDasVmConfigInfo",
        drsConfig: "ClusterDrsConfigInfo",
        drsVmConfig: "ClusterDrsVmConfigInfo",
        rule: "ClusterRuleInfo",
        orchestration: "ClusterOrchestrationInfo",
        vmOrchestration: "ClusterVmOrchestrationInfo",
        dpmConfigInfo: "ClusterDpmConfigInfo",
        dpmHostConfig: "ClusterDpmHostConfigInfo",
        vsanConfigInfo: "VsanClusterConfigInfo",
        vsanHostConfig: "VsanHostConfigInfo",
        group: "ClusterGroupInfo",
        infraUpdateHaConfig: "ClusterInfraUpdateHaConfigInfo",
        proactiveDrsConfig: "ClusterProactiveDrsConfigInfo",
        cryptoConfig: "ClusterCryptoConfigInfo"
};
typeNames.interfaces["ClusterConfigSpecEx"] = {
dasConfig: "ClusterDasConfigInfo",
        dasVmConfigSpec: "ClusterDasVmConfigSpec",
        drsConfig: "ClusterDrsConfigInfo",
        drsVmConfigSpec: "ClusterDrsVmConfigSpec",
        rulesSpec: "ClusterRuleSpec",
        orchestration: "ClusterOrchestrationInfo",
        vmOrchestrationSpec: "ClusterVmOrchestrationSpec",
        dpmConfig: "ClusterDpmConfigInfo",
        dpmHostConfigSpec: "ClusterDpmHostConfigSpec",
        vsanConfig: "VsanClusterConfigInfo",
        vsanHostConfigSpec: "VsanHostConfigInfo",
        groupSpec: "ClusterGroupSpec",
        infraUpdateHaConfig: "ClusterInfraUpdateHaConfigInfo",
        proactiveDrsConfig: "ClusterProactiveDrsConfigInfo",
        inHciWorkflow: "boolean",
        cryptoConfig: "ClusterCryptoConfigInfo"
};
typeNames.interfaces["ClusterDependencyRuleInfo"] = {
vmGroup: "string",
        dependsOnVmGroup: "string"
};
typeNames.interfaces["DistributedVirtualSwitchManagerCompatibilityResult"] = {
host: HostSystem,
        error: "MethodFault"
};
typeNames.interfaces["DVSManagerDvsConfigTarget"] = {
distributedVirtualPortgroup: "DistributedVirtualPortgroupInfo",
        distributedVirtualSwitch: "DistributedVirtualSwitchInfo"
};
typeNames.interfaces["DistributedVirtualSwitchManagerDvsProductSpec"] = {
newSwitchProductSpec: "DistributedVirtualSwitchProductSpec",
        distributedVirtualSwitch: DistributedVirtualSwitch
};
typeNames.interfaces["DistributedVirtualSwitchManagerHostArrayFilter"] = {
host: HostSystem
};
typeNames.interfaces["DistributedVirtualSwitchManagerHostContainer"] = {
container: ManagedEntity,
        recursive: "boolean"
};
typeNames.interfaces["DistributedVirtualSwitchManagerHostContainerFilter"] = {
hostContainer: "DistributedVirtualSwitchManagerHostContainer"
};
typeNames.interfaces["DistributedVirtualSwitchManagerHostDvsFilterSpec"] = {
inclusive: "boolean"
};
typeNames.interfaces["DistributedVirtualSwitchManagerHostDvsMembershipFilter"] = {
distributedVirtualSwitch: DistributedVirtualSwitch
};
typeNames.interfaces["DistributedVirtualSwitchManagerImportResult"] = {
distributedVirtualSwitch: DistributedVirtualSwitch,
        distributedVirtualPortgroup: DistributedVirtualPortgroup,
        importFault: "ImportOperationBulkFaultFaultOnImport"
};
typeNames.interfaces["VMwareDVSConfigInfo"] = {
vspanSession: "VMwareVspanSession",
        pvlanConfig: "VMwareDVSPvlanMapEntry",
        maxMtu: "number",
        linkDiscoveryProtocolConfig: "LinkDiscoveryProtocolConfig",
        ipfixConfig: "VMwareIpfixConfig",
        lacpGroupConfig: "VMwareDvsLacpGroupConfig",
        lacpApiVersion: "string",
        multicastFilteringMode: "string"
};
typeNames.interfaces["VMwareDVSConfigSpec"] = {
pvlanConfigSpec: "VMwareDVSPvlanConfigSpec",
        vspanConfigSpec: "VMwareDVSVspanConfigSpec",
        maxMtu: "number",
        linkDiscoveryProtocolConfig: "LinkDiscoveryProtocolConfig",
        ipfixConfig: "VMwareIpfixConfig",
        lacpApiVersion: "string",
        multicastFilteringMode: "string"
};
typeNames.interfaces["DVSFailureCriteria"] = {
checkSpeed: "StringPolicy",
        speed: "IntPolicy",
        checkDuplex: "BoolPolicy",
        fullDuplex: "BoolPolicy",
        checkErrorPercent: "BoolPolicy",
        percentage: "IntPolicy",
        checkBeacon: "BoolPolicy"
};
typeNames.interfaces["VMwareDVSFeatureCapability"] = {
vspanSupported: "boolean",
        lldpSupported: "boolean",
        ipfixSupported: "boolean",
        ipfixCapability: "VMwareDvsIpfixCapability",
        multicastSnoopingSupported: "boolean",
        vspanCapability: "VMwareDVSVspanCapability",
        lacpCapability: "VMwareDvsLacpCapability",
        nsxSupported: "boolean"
};
typeNames.interfaces["VMwareIpfixConfig"] = {
collectorIpAddress: "string",
        collectorPort: "number",
        observationDomainId: "number",
        activeFlowTimeout: "number",
        idleFlowTimeout: "number",
        samplingRate: "number",
        internalFlowsOnly: "boolean"
};
typeNames.interfaces["VMwareDvsIpfixCapability"] = {
ipfixSupported: "boolean",
        ipv6ForIpfixSupported: "boolean",
        observationDomainIdSupported: "boolean"
};
typeNames.interfaces["VMwareDvsLacpCapability"] = {
lacpSupported: "boolean",
        multiLacpGroupSupported: "boolean"
};
typeNames.interfaces["VMwareDvsLacpGroupConfig"] = {
key: "string",
        name: "string",
        mode: "string",
        uplinkNum: "number",
        loadbalanceAlgorithm: "string",
        vlan: "VMwareDvsLagVlanConfig",
        ipfix: "VMwareDvsLagIpfixConfig",
        uplinkName: "string",
        uplinkPortKey: "string"
};
typeNames.interfaces["VMwareDvsLacpGroupSpec"] = {
lacpGroupConfig: "VMwareDvsLacpGroupConfig",
        operation: "string"
};
typeNames.interfaces["VMwareDvsLagIpfixConfig"] = {
ipfixEnabled: "boolean"
};
typeNames.interfaces["VMwareDvsLagVlanConfig"] = {
vlanId: "NumericRange"
};
typeNames.interfaces["DVSMacLearningPolicy"] = {
enabled: "boolean",
        allowUnicastFlooding: "boolean",
        limit: "number",
        limitPolicy: "string"
};
typeNames.interfaces["DVSMacManagementPolicy"] = {
allowPromiscuous: "boolean",
        macChanges: "boolean",
        forgedTransmits: "boolean",
        macLearningPolicy: "DVSMacLearningPolicy"
};
typeNames.interfaces["VMwareDVSMtuHealthCheckResult"] = {
mtuMismatch: "boolean",
        vlanSupportSwitchMtu: "NumericRange",
        vlanNotSupportSwitchMtu: "NumericRange"
};
typeNames.interfaces["VMwareDVSPvlanConfigSpec"] = {
pvlanEntry: "VMwareDVSPvlanMapEntry",
        operation: "string"
};
typeNames.interfaces["VMwareDVSPvlanMapEntry"] = {
primaryVlanId: "number",
        secondaryVlanId: "number",
        pvlanType: "string"
};
typeNames.interfaces["VmwareDistributedVirtualSwitchPvlanSpec"] = {
pvlanId: "number"
};
typeNames.interfaces["DVSSecurityPolicy"] = {
allowPromiscuous: "BoolPolicy",
        macChanges: "BoolPolicy",
        forgedTransmits: "BoolPolicy"
};
typeNames.interfaces["VMwareDVSTeamingHealthCheckConfig"] = {

};
typeNames.interfaces["VMwareDVSTeamingHealthCheckResult"] = {
teamingStatus: "string"
};
typeNames.interfaces["VmwareDistributedVirtualSwitchTrunkVlanSpec"] = {
vlanId: "NumericRange"
};
typeNames.interfaces["VMwareUplinkLacpPolicy"] = {
enable: "BoolPolicy",
        mode: "StringPolicy"
};
typeNames.interfaces["VMwareUplinkPortOrderPolicy"] = {
activeUplinkPort: "string",
        standbyUplinkPort: "string"
};
typeNames.interfaces["VmwareUplinkPortTeamingPolicy"] = {
policy: "StringPolicy",
        reversePolicy: "BoolPolicy",
        notifySwitches: "BoolPolicy",
        rollingOrder: "BoolPolicy",
        failureCriteria: "DVSFailureCriteria",
        uplinkPortOrder: "VMwareUplinkPortOrderPolicy"
};
typeNames.interfaces["VMwareDVSPortgroupPolicy"] = {
vlanOverrideAllowed: "boolean",
        uplinkTeamingOverrideAllowed: "boolean",
        securityPolicyOverrideAllowed: "boolean",
        ipfixOverrideAllowed: "boolean",
        macManagementOverrideAllowed: "boolean"
};
typeNames.interfaces["VMwareDVSVlanHealthCheckResult"] = {
trunkedVlan: "NumericRange",
        untrunkedVlan: "NumericRange"
};
typeNames.interfaces["VmwareDistributedVirtualSwitchVlanIdSpec"] = {
vlanId: "number"
};
typeNames.interfaces["VMwareDVSVlanMtuHealthCheckConfig"] = {

};
typeNames.interfaces["VmwareDistributedVirtualSwitchVlanSpec"] = {

};
typeNames.interfaces["VMwareDVSHealthCheckConfig"] = {

};
typeNames.interfaces["VMwareDVSHealthCheckCapability"] = {
vlanMtuSupported: "boolean",
        teamingSupported: "boolean"
};
typeNames.interfaces["VMwareDVSPortSetting"] = {
vlan: "VmwareDistributedVirtualSwitchVlanSpec",
        qosTag: "IntPolicy",
        uplinkTeamingPolicy: "VmwareUplinkPortTeamingPolicy",
        securityPolicy: "DVSSecurityPolicy",
        ipfixEnabled: "BoolPolicy",
        txUplink: "BoolPolicy",
        lacpPolicy: "VMwareUplinkLacpPolicy",
        macManagementPolicy: "DVSMacManagementPolicy",
        VNI: "IntPolicy"
};
typeNames.interfaces["VMwareDVSVspanConfigSpec"] = {
vspanSession: "VMwareVspanSession",
        operation: "string"
};
typeNames.interfaces["VMwareDVSVspanCapability"] = {
mixedDestSupported: "boolean",
        dvportSupported: "boolean",
        remoteSourceSupported: "boolean",
        remoteDestSupported: "boolean",
        encapRemoteSourceSupported: "boolean",
        erspanProtocolSupported: "boolean",
        mirrorNetstackSupported: "boolean"
};
typeNames.interfaces["VMwareVspanPort"] = {
portKey: "string",
        uplinkPortName: "string",
        wildcardPortConnecteeType: "string",
        vlans: "number",
        ipAddress: "string"
};
typeNames.interfaces["VMwareVspanSession"] = {
key: "string",
        name: "string",
        description: "string",
        enabled: "boolean",
        sourcePortTransmitted: "VMwareVspanPort",
        sourcePortReceived: "VMwareVspanPort",
        destinationPort: "VMwareVspanPort",
        encapsulationVlanId: "number",
        stripOriginalVlan: "boolean",
        mirroredPacketLength: "number",
        normalTrafficAllowed: "boolean",
        sessionType: "string",
        samplingRate: "number",
        encapType: "string",
        erspanId: "number",
        erspanCOS: "number",
        erspanGraNanosec: "boolean",
        netstack: "string"
};
typeNames.interfaces["AlarmAcknowledgedEvent"] = {
source: "ManagedEntityEventArgument",
        entity: "ManagedEntityEventArgument"
};
typeNames.interfaces["AlarmActionTriggeredEvent"] = {
source: "ManagedEntityEventArgument",
        entity: "ManagedEntityEventArgument"
};
typeNames.interfaces["AlarmClearedEvent"] = {
source: "ManagedEntityEventArgument",
        entity: "ManagedEntityEventArgument",
        from: "string"
};
typeNames.interfaces["AlarmCreatedEvent"] = {
entity: "ManagedEntityEventArgument"
};
typeNames.interfaces["AlarmEmailCompletedEvent"] = {
entity: "ManagedEntityEventArgument",
        to: "string"
};
typeNames.interfaces["AlarmEmailFailedEvent"] = {
entity: "ManagedEntityEventArgument",
        to: "string",
        reason: "MethodFault"
};
typeNames.interfaces["AlarmEventArgument"] = {
alarm: Alarm
};
typeNames.interfaces["ClusterComplianceCheckedEvent"] = {
profile: "ProfileEventArgument"
};
typeNames.interfaces["ClusterCreatedEvent"] = {
parent: "FolderEventArgument"
};
typeNames.interfaces["ClusterDestroyedEvent"] = {

};
typeNames.interfaces["ComputeResourceEventArgument"] = {
computeResource: ComputeResource
};
typeNames.interfaces["CustomFieldDefEvent"] = {
fieldKey: "number",
        name: "string"
};
typeNames.interfaces["CustomFieldDefRemovedEvent"] = {

};
typeNames.interfaces["CustomFieldDefRenamedEvent"] = {
newName: "string"
};
typeNames.interfaces["DVPortgroupCreatedEvent"] = {

};
typeNames.interfaces["DVPortgroupDestroyedEvent"] = {

};
typeNames.interfaces["DatacenterCreatedEvent"] = {
parent: "FolderEventArgument"
};
typeNames.interfaces["DatacenterEventArgument"] = {
datacenter: Datacenter
};
typeNames.interfaces["DatastoreCapacityIncreasedEvent"] = {
oldCapacity: "number",
        newCapacity: "number"
};
typeNames.interfaces["DatastoreDestroyedEvent"] = {

};
typeNames.interfaces["DatastoreDuplicatedEvent"] = {

};
typeNames.interfaces["DatastoreEventArgument"] = {
datastore: Datastore
};
typeNames.interfaces["DatastoreFileCopiedEvent"] = {
sourceDatastore: "DatastoreEventArgument",
        sourceFile: "string"
};
typeNames.interfaces["DatastoreFileDeletedEvent"] = {

};
typeNames.interfaces["DrsEnteredStandbyModeEvent"] = {

};
typeNames.interfaces["DrsEnteringStandbyModeEvent"] = {

};
typeNames.interfaces["DrsExitStandbyModeFailedEvent"] = {

};
typeNames.interfaces["DrsExitedStandbyModeEvent"] = {

};
typeNames.interfaces["DrsExitingStandbyModeEvent"] = {

};
typeNames.interfaces["DvsCreatedEvent"] = {
parent: "FolderEventArgument"
};
typeNames.interfaces["DvsDestroyedEvent"] = {

};
typeNames.interfaces["DvsEventArgument"] = {
dvs: DistributedVirtualSwitch
};
typeNames.interfaces["DvsReconfiguredEvent"] = {
configSpec: "DVSConfigSpec",
        configChanges: "ChangesInfoEventArgument"
};
typeNames.interfaces["MigrationErrorEvent"] = {

};
typeNames.interfaces["PermissionAddedEvent"] = {
role: "RoleEventArgument",
        propagate: "boolean"
};
typeNames.interfaces["RoleAddedEvent"] = {
privilegeList: "string"
};
typeNames.interfaces["VmBeingClonedEvent"] = {
destFolder: "FolderEventArgument",
        destName: "string",
        destHost: "HostEventArgument"
};
typeNames.interfaces["VmBeingClonedNoFolderEvent"] = {
destName: "string",
        destHost: "HostEventArgument"
};
typeNames.interfaces["ActiveVMsBlockingEVC"] = {
evcMode: "string",
        host: HostSystem,
        hostName: "string"
};
typeNames.interfaces["AdminDisabled"] = {

};
typeNames.interfaces["AdminNotDisabled"] = {

};
typeNames.interfaces["AffinityConfigured"] = {
configuredAffinity: "string"
};
typeNames.interfaces["AgentInstallFailed"] = {
reason: "string",
        statusCode: "number",
        installerOutput: "string"
};
typeNames.interfaces["AlreadyBeingManaged"] = {
ipAddress: "string"
};
typeNames.interfaces["AlreadyConnected"] = {
name: "string"
};
typeNames.interfaces["ApplicationQuiesceFault"] = {

};
typeNames.interfaces["BackupBlobReadFailure"] = {
entityName: "string",
        entityType: "string",
        fault: "MethodFault"
};
typeNames.interfaces["BackupBlobWriteFailure"] = {
entityName: "string",
        entityType: "string",
        fault: "MethodFault"
};
typeNames.interfaces["BlockedByFirewall"] = {

};
typeNames.interfaces["CAMServerRefusedConnection"] = {

};
typeNames.interfaces["CannotAccessFile"] = {

};
typeNames.interfaces["CannotAccessNetwork"] = {
network: Network
};
typeNames.interfaces["CannotAddHostWithFTVmAsStandalone"] = {

};
typeNames.interfaces["CannotAddHostWithFTVmToDifferentCluster"] = {

};
typeNames.interfaces["CannotAddHostWithFTVmToNonHACluster"] = {

};
typeNames.interfaces["CannotCreateFile"] = {

};
typeNames.interfaces["CannotDecryptPasswords"] = {

};
typeNames.interfaces["CannotDeleteFile"] = {

};
typeNames.interfaces["CannotModifyConfigCpuRequirements"] = {

};
typeNames.interfaces["CannotMoveVmWithDeltaDisk"] = {
device: "string"
};
typeNames.interfaces["CannotMoveVmWithNativeDeltaDisk"] = {

};
typeNames.interfaces["CannotPowerOffVmInCluster"] = {
operation: "string",
        vm: VirtualMachine,
        vmName: "string"
};
typeNames.interfaces["ClockSkew"] = {

};
typeNames.interfaces["CloneFromSnapshotNotSupported"] = {

};
typeNames.interfaces["CollectorAddressUnset"] = {

};
typeNames.interfaces["ConflictingConfiguration"] = {
configInConflict: "ConflictingConfigurationConfig"
};
typeNames.interfaces["ConflictingConfigurationConfig"] = {
entity: ManagedEntity,
        propertyPath: "string"
};
typeNames.interfaces["CpuIncompatible"] = {
level: "number",
        registerName: "string",
        registerBits: "string",
        desiredBits: "string",
        host: HostSystem
};
typeNames.interfaces["CpuIncompatible1ECX"] = {
sse3: "boolean",
        pclmulqdq: "boolean",
        ssse3: "boolean",
        sse41: "boolean",
        sse42: "boolean",
        aes: "boolean",
        other: "boolean",
        otherOnly: "boolean"
};
typeNames.interfaces["CpuIncompatible81EDX"] = {
nx: "boolean",
        ffxsr: "boolean",
        rdtscp: "boolean",
        lm: "boolean",
        other: "boolean",
        otherOnly: "boolean"
};
typeNames.interfaces["DatacenterMismatch"] = {
invalidArgument: "DatacenterMismatchArgument",
        expectedDatacenter: Datacenter
};
typeNames.interfaces["DatacenterMismatchArgument"] = {
entity: ManagedEntity,
        inputDatacenter: Datacenter
};
typeNames.interfaces["DatastoreNotWritableOnHost"] = {
host: HostSystem
};
typeNames.interfaces["DestinationSwitchFull"] = {

};
typeNames.interfaces["DeviceNotSupported"] = {
device: "string",
        reason: "string"
};
typeNames.interfaces["DigestNotSupported"] = {

};
typeNames.interfaces["DirectoryNotEmpty"] = {

};
typeNames.interfaces["DisableAdminNotSupported"] = {

};
typeNames.interfaces["DisallowedMigrationDeviceAttached"] = {
fault: "MethodFault"
};
typeNames.interfaces["DisconnectedHostsBlockingEVC"] = {

};
typeNames.interfaces["DiskHasPartitions"] = {

};
typeNames.interfaces["DiskIsLastRemainingNonSSD"] = {

};
typeNames.interfaces["DiskIsNonLocal"] = {

};
typeNames.interfaces["DiskIsUSB"] = {

};
typeNames.interfaces["DiskMoveTypeNotSupported"] = {

};
typeNames.interfaces["DiskNotSupported"] = {
disk: "number"
};
typeNames.interfaces["DiskTooSmall"] = {

};
typeNames.interfaces["DrsVmotionIncompatibleFault"] = {
host: HostSystem
};
typeNames.interfaces["DuplicateDisks"] = {

};
typeNames.interfaces["DvsApplyOperationFault"] = {
objectFault: "DvsApplyOperationFaultFaultOnObject"
};
typeNames.interfaces["DvsApplyOperationFaultFaultOnObject"] = {
objectId: "string",
        type: "string",
        fault: "MethodFault"
};
typeNames.interfaces["EVCAdmissionFailed"] = {
faults: "MethodFault"
};
typeNames.interfaces["EVCAdmissionFailedCPUFeaturesForMode"] = {
currentEVCModeKey: "string"
};
typeNames.interfaces["EVCAdmissionFailedCPUModel"] = {

};
typeNames.interfaces["EVCAdmissionFailedCPUModelForMode"] = {
currentEVCModeKey: "string"
};
typeNames.interfaces["EVCAdmissionFailedCPUVendor"] = {
clusterCPUVendor: "string",
        hostCPUVendor: "string"
};
typeNames.interfaces["EVCAdmissionFailedCPUVendorUnknown"] = {

};
typeNames.interfaces["EVCAdmissionFailedHostDisconnected"] = {

};
typeNames.interfaces["EVCAdmissionFailedHostSoftware"] = {

};
typeNames.interfaces["EVCAdmissionFailedHostSoftwareForMode"] = {

};
typeNames.interfaces["EVCAdmissionFailedVmActive"] = {

};
typeNames.interfaces["EncryptionKeyRequired"] = {
requiredKey: "CryptoKeyId"
};
typeNames.interfaces["FailToEnableSPBM"] = {
cs: ComputeResource,
        csName: "string",
        hostLicenseStates: "ComputeResourceHostSPBMLicenseInfo"
};
typeNames.interfaces["FaultToleranceAntiAffinityViolated"] = {
hostName: "string",
        host: HostSystem
};
typeNames.interfaces["FaultToleranceCpuIncompatible"] = {
model: "boolean",
        family: "boolean",
        stepping: "boolean"
};
typeNames.interfaces["FaultToleranceNeedsThickDisk"] = {
vmName: "string"
};
typeNames.interfaces["FaultToleranceNotSameBuild"] = {
build: "string"
};
typeNames.interfaces["FeatureRequirementsNotMet"] = {
featureRequirement: "VirtualMachineFeatureRequirement",
        vm: VirtualMachine,
        host: HostSystem
};
typeNames.interfaces["FileAlreadyExists"] = {

};
typeNames.interfaces["FileBackedPortNotSupported"] = {

};
typeNames.interfaces["FilesystemQuiesceFault"] = {

};
typeNames.interfaces["FilterInUse"] = {
disk: "VirtualDiskId"
};
typeNames.interfaces["FullStorageVMotionNotSupported"] = {

};
typeNames.interfaces["GatewayConnectFault"] = {
gatewayType: "string",
        gatewayId: "string",
        gatewayInfo: "string",
        details: "LocalizableMessage"
};
typeNames.interfaces["GatewayNotFound"] = {

};
typeNames.interfaces["GatewayNotReachable"] = {

};
typeNames.interfaces["GatewayOperationRefused"] = {

};
typeNames.interfaces["GatewayToHostConnectFault"] = {
hostname: "string",
        port: "number"
};
typeNames.interfaces["GatewayToHostTrustVerifyFault"] = {
verificationToken: "string",
        propertiesToVerify: "KeyValue"
};
typeNames.interfaces["GuestAuthenticationChallenge"] = {
serverChallenge: "GuestAuthentication",
        sessionID: "number"
};
typeNames.interfaces["GuestComponentsOutOfDate"] = {

};
typeNames.interfaces["GuestMultipleMappings"] = {

};
typeNames.interfaces["GuestRegistryKeyAlreadyExists"] = {

};
typeNames.interfaces["HAErrorsAtDest"] = {

};
typeNames.interfaces["HostConfigFailed"] = {
failure: "MethodFault"
};
typeNames.interfaces["HotSnapshotMoveNotSupported"] = {

};
typeNames.interfaces["IDEDiskNotSupported"] = {

};
typeNames.interfaces["InaccessibleDatastore"] = {
detail: "string"
};
typeNames.interfaces["InaccessibleFTMetadataDatastore"] = {

};
typeNames.interfaces["IncompatibleDefaultDevice"] = {
device: "string"
};
typeNames.interfaces["IncompatibleHostForVmReplication"] = {
vmName: "string",
        hostName: "string",
        reason: "string"
};
typeNames.interfaces["IndependentDiskVMotionNotSupported"] = {

};
typeNames.interfaces["InsufficientAgentVmsDeployed"] = {
hostName: "string",
        requiredNumAgentVms: "number",
        currentNumAgentVms: "number"
};
typeNames.interfaces["InsufficientCpuResourcesFault"] = {
unreserved: "number",
        requested: "number"
};
typeNames.interfaces["InsufficientDisks"] = {

};
typeNames.interfaces["InsufficientFailoverResourcesFault"] = {

};
typeNames.interfaces["InsufficientGraphicsResourcesFault"] = {

};
typeNames.interfaces["InsufficientHostCapacityFault"] = {
host: HostSystem
};
typeNames.interfaces["InsufficientHostCpuCapacityFault"] = {
unreserved: "number",
        requested: "number"
};
typeNames.interfaces["InsufficientHostMemoryCapacityFault"] = {
unreserved: "number",
        requested: "number"
};
typeNames.interfaces["InsufficientMemoryResourcesFault"] = {
unreserved: "number",
        requested: "number"
};
typeNames.interfaces["InsufficientNetworkCapacity"] = {

};
typeNames.interfaces["InsufficientNetworkResourcePoolCapacity"] = {
dvsName: "string",
        dvsUuid: "string",
        resourcePoolKey: "string",
        available: "number",
        requested: "number",
        device: "string"
};
typeNames.interfaces["InsufficientPerCpuCapacity"] = {

};
typeNames.interfaces["InsufficientStandbyCpuResource"] = {
available: "number",
        requested: "number"
};
typeNames.interfaces["InsufficientStandbyMemoryResource"] = {
available: "number",
        requested: "number"
};
typeNames.interfaces["InvalidBundle"] = {

};
typeNames.interfaces["InvalidCAMCertificate"] = {

};
typeNames.interfaces["InvalidClientCertificate"] = {

};
typeNames.interfaces["InvalidDatastoreState"] = {
datastoreName: "string"
};
typeNames.interfaces["InvalidDeviceSpec"] = {
deviceIndex: "number"
};
typeNames.interfaces["InvalidDiskFormat"] = {

};
typeNames.interfaces["InvalidHostState"] = {
host: HostSystem
};
typeNames.interfaces["InvalidNasCredentials"] = {
userName: "string"
};
typeNames.interfaces["InvalidNetworkInType"] = {

};
typeNames.interfaces["InvalidNetworkResource"] = {
remoteHost: "string",
        remotePath: "string"
};
typeNames.interfaces["InvalidPowerState"] = {
requestedState: "VirtualMachinePowerState",
        existingState: "VirtualMachinePowerState"
};
typeNames.interfaces["InvalidPropertyType"] = {

};
typeNames.interfaces["InvalidPropertyValue"] = {

};
typeNames.interfaces["LargeRDMConversionNotSupported"] = {
device: "string"
};
typeNames.interfaces["LegacyNetworkInterfaceInUse"] = {

};
typeNames.interfaces["MaintenanceModeFileMove"] = {

};
typeNames.interfaces["MemoryFileFormatNotSupportedByDatastore"] = {
datastoreName: "string",
        type: "string"
};
typeNames.interfaces["MemorySizeNotRecommended"] = {
memorySizeMB: "number",
        minMemorySizeMB: "number",
        maxMemorySizeMB: "number"
};
typeNames.interfaces["MemorySizeNotSupported"] = {
memorySizeMB: "number",
        minMemorySizeMB: "number",
        maxMemorySizeMB: "number"
};
typeNames.interfaces["MemorySizeNotSupportedByDatastore"] = {
datastore: Datastore,
        memorySizeMB: "number",
        maxMemorySizeMB: "number"
};
typeNames.interfaces["MemorySnapshotOnIndependentDisk"] = {

};
typeNames.interfaces["MigrationDisabled"] = {

};
typeNames.interfaces["MissingController"] = {

};
typeNames.interfaces["MissingIpPool"] = {

};
typeNames.interfaces["MissingNetworkIpConfig"] = {

};
typeNames.interfaces["MissingPowerOffConfiguration"] = {

};
typeNames.interfaces["MissingPowerOnConfiguration"] = {

};
typeNames.interfaces["MultiWriterNotSupported"] = {

};
typeNames.interfaces["MultipleSnapshotsNotSupported"] = {

};
typeNames.interfaces["NoAvailableIp"] = {
network: Network
};
typeNames.interfaces["NoVcManagedIpConfigured"] = {

};
typeNames.interfaces["NoVmInVApp"] = {

};
typeNames.interfaces["NonPersistentDisksNotSupported"] = {

};
typeNames.interfaces["NonVmwareOuiMacNotSupportedHost"] = {
hostName: "string"
};
typeNames.interfaces["NotEnoughCpus"] = {
numCpuDest: "number",
        numCpuVm: "number"
};
typeNames.interfaces["NotEnoughLogicalCpus"] = {
host: HostSystem
};
typeNames.interfaces["NotUserConfigurableProperty"] = {

};
typeNames.interfaces["NumVirtualCoresPerSocketNotSupported"] = {
maxSupportedCoresPerSocketDest: "number",
        numCoresPerSocketVm: "number"
};
typeNames.interfaces["NumVirtualCpusNotSupported"] = {
maxSupportedVcpusDest: "number",
        numCpuVm: "number"
};
typeNames.interfaces["OvfAttribute"] = {
elementName: "string",
        attributeName: "string"
};
typeNames.interfaces["OvfConstraint"] = {
name: "string"
};
typeNames.interfaces["OvfConsumerCallbackFault"] = {
extensionKey: "string",
        extensionName: "string"
};
typeNames.interfaces["OvfConsumerCommunicationError"] = {
description: "string"
};
typeNames.interfaces["OvfConsumerFault"] = {
errorKey: "string",
        message: "string",
        params: "KeyValue"
};
typeNames.interfaces["OvfConsumerInvalidSection"] = {
lineNumber: "number",
        description: "string"
};
typeNames.interfaces["OvfConsumerUndeclaredSection"] = {
qualifiedSectionType: "string"
};
typeNames.interfaces["OvfConsumerUndefinedPrefix"] = {
prefix: "string"
};
typeNames.interfaces["OvfCpuCompatibility"] = {
registerName: "string",
        level: "number",
        registerValue: "string",
        desiredRegisterValue: "string"
};
typeNames.interfaces["OvfCpuCompatibilityCheckNotSupported"] = {

};
typeNames.interfaces["OvfDiskMappingNotFound"] = {
diskName: "string",
        vmName: "string"
};
typeNames.interfaces["OvfDiskOrderConstraint"] = {

};
typeNames.interfaces["OvfElement"] = {
name: "string"
};
typeNames.interfaces["OvfElementInvalidValue"] = {
value: "string"
};
typeNames.interfaces["OvfExport"] = {

};
typeNames.interfaces["OvfExportFailed"] = {

};
typeNames.interfaces["OvfHardwareCheck"] = {

};
typeNames.interfaces["OvfHardwareExport"] = {
device: "VirtualDevice",
        vmPath: "string"
};
typeNames.interfaces["OvfHostResourceConstraint"] = {
value: "string"
};
typeNames.interfaces["OvfHostValueNotParsed"] = {
property: "string",
        value: "string"
};
typeNames.interfaces["OvfInternalError"] = {

};
typeNames.interfaces["OvfInvalidValue"] = {
value: "string"
};
typeNames.interfaces["OvfInvalidValueConfiguration"] = {

};
typeNames.interfaces["OvfInvalidValueEmpty"] = {

};
typeNames.interfaces["OvfInvalidValueFormatMalformed"] = {

};
typeNames.interfaces["OvfInvalidValueReference"] = {

};
typeNames.interfaces["OvfInvalidVmName"] = {
name: "string"
};
typeNames.interfaces["OvfMissingAttribute"] = {

};
typeNames.interfaces["OvfMissingElement"] = {

};
typeNames.interfaces["OvfMissingElementNormalBoundary"] = {
boundary: "string"
};
typeNames.interfaces["OvfNoHostNic"] = {

};
typeNames.interfaces["OvfNoSupportedHardwareFamily"] = {
version: "string"
};
typeNames.interfaces["OvfPropertyExport"] = {
type: "string",
        value: "string"
};
typeNames.interfaces["OvfPropertyNetworkExport"] = {
network: "string"
};
typeNames.interfaces["OvfUnableToExportDisk"] = {
diskName: "string"
};
typeNames.interfaces["OvfUnexpectedElement"] = {

};
typeNames.interfaces["OvfUnknownDeviceBacking"] = {
backing: "VirtualDeviceBackingInfo"
};
typeNames.interfaces["OvfUnsupportedAttribute"] = {
elementName: "string",
        attributeName: "string"
};
typeNames.interfaces["OvfUnsupportedAttributeValue"] = {
value: "string"
};
typeNames.interfaces["OvfUnsupportedDeviceExport"] = {

};
typeNames.interfaces["OvfUnsupportedElement"] = {
name: "string"
};
typeNames.interfaces["OvfUnsupportedElementValue"] = {
value: "string"
};
typeNames.interfaces["OvfUnsupportedSection"] = {
info: "string"
};
typeNames.interfaces["OvfWrongElement"] = {

};
typeNames.interfaces["PatchAlreadyInstalled"] = {

};
typeNames.interfaces["PatchInstallFailed"] = {
rolledBack: "boolean"
};
typeNames.interfaces["PatchIntegrityError"] = {

};
typeNames.interfaces["PatchMetadataCorrupted"] = {

};
typeNames.interfaces["PatchMissingDependencies"] = {
prerequisitePatch: "string",
        prerequisiteLib: "string"
};
typeNames.interfaces["PowerOnFtSecondaryTimedout"] = {
vm: VirtualMachine,
        vmName: "string",
        timeout: "number"
};
typeNames.interfaces["QuiesceDatastoreIOForHAFailed"] = {
host: HostSystem,
        hostName: "string",
        ds: Datastore,
        dsName: "string"
};
typeNames.interfaces["RDMNotSupported"] = {

};
typeNames.interfaces["RawDiskNotSupported"] = {

};
typeNames.interfaces["RemoteDeviceNotSupported"] = {

};
typeNames.interfaces["ReplicationConfigFault"] = {

};
typeNames.interfaces["ReplicationDiskConfigFault"] = {
reason: "string",
        vmRef: VirtualMachine,
        key: "number"
};
typeNames.interfaces["ReplicationVmConfigFault"] = {
reason: "string",
        vmRef: VirtualMachine
};
typeNames.interfaces["SharedBusControllerNotSupported"] = {

};
typeNames.interfaces["SnapshotCloneNotSupported"] = {

};
typeNames.interfaces["SnapshotDisabled"] = {

};
typeNames.interfaces["StorageVmotionIncompatible"] = {
datastore: Datastore
};
typeNames.interfaces["SwapDatastoreNotWritableOnHost"] = {

};
typeNames.interfaces["UnSupportedDatastoreForVFlash"] = {
datastoreName: "string",
        type: "string"
};
typeNames.interfaces["UnconfiguredPropertyValue"] = {

};
typeNames.interfaces["VMINotSupported"] = {

};
typeNames.interfaces["VMOnConflictDVPort"] = {

};
typeNames.interfaces["VMOnVirtualIntranet"] = {

};
typeNames.interfaces["VirtualDiskModeNotSupported"] = {
mode: "string"
};
typeNames.interfaces["VirtualEthernetCardNotSupported"] = {

};
typeNames.interfaces["VmfsAlreadyMounted"] = {

};
typeNames.interfaces["VmfsAmbiguousMount"] = {

};
typeNames.interfaces["HostConfigInfo"] = {
host: HostSystem,
        product: "AboutInfo",
        deploymentInfo: "HostDeploymentInfo",
        hyperThread: "HostHyperThreadScheduleInfo",
        consoleReservation: "ServiceConsoleReservationInfo",
        virtualMachineReservation: "VirtualMachineMemoryReservationInfo",
        storageDevice: "HostStorageDeviceInfo",
        multipathState: "HostMultipathStateInfo",
        fileSystemVolume: "HostFileSystemVolumeInfo",
        systemFile: "string",
        network: "HostNetworkInfo",
        vmotion: "HostVMotionInfo",
        virtualNicManagerInfo: "HostVirtualNicManagerInfo",
        capabilities: "HostNetCapabilities",
        datastoreCapabilities: "HostDatastoreSystemCapabilities",
        offloadCapabilities: "HostNetOffloadCapabilities",
        service: "HostServiceInfo",
        firewall: "HostFirewallInfo",
        autoStart: "HostAutoStartManagerConfig",
        activeDiagnosticPartition: "HostDiagnosticPartition",
        option: "OptionValue",
        optionDef: "OptionDef",
        datastorePrincipal: "string",
        localSwapDatastore: Datastore,
        systemSwapConfiguration: "HostSystemSwapConfiguration",
        systemResources: "HostSystemResourceInfo",
        dateTimeInfo: "HostDateTimeInfo",
        flags: "HostFlagInfo",
        adminDisabled: "boolean",
        lockdownMode: "HostLockdownMode",
        ipmi: "HostIpmiInfo",
        sslThumbprintInfo: "HostSslThumbprintInfo",
        sslThumbprintData: "HostSslThumbprintInfo",
        certificate: "number",
        pciPassthruInfo: "HostPciPassthruInfo",
        authenticationManagerInfo: "HostAuthenticationManagerInfo",
        featureVersion: "HostFeatureVersionInfo",
        powerSystemCapability: "PowerSystemCapability",
        powerSystemInfo: "PowerSystemInfo",
        cacheConfigurationInfo: "HostCacheConfigurationInfo",
        wakeOnLanCapable: "boolean",
        featureCapability: "HostFeatureCapability",
        maskedFeatureCapability: "HostFeatureCapability",
        vFlashConfigInfo: "HostVFlashManagerVFlashConfigInfo",
        vsanHostConfig: "VsanHostConfigInfo",
        domainList: "string",
        scriptCheckSum: "Buffer",
        hostConfigCheckSum: "Buffer",
        descriptionTreeCheckSum: "Buffer",
        graphicsInfo: "HostGraphicsInfo",
        sharedPassthruGpuTypes: "string",
        graphicsConfig: "HostGraphicsConfig",
        sharedGpuCapabilities: "HostSharedGpuCapabilities",
        ioFilterInfo: "HostIoFilterInfo",
        sriovDevicePool: "HostSriovDevicePoolInfo",
        assignableHardwareBinding: "HostAssignableHardwareBinding",
        assignableHardwareConfig: "HostAssignableHardwareConfig"
};
typeNames.interfaces["HostConnectInfo"] = {
serverIp: "string",
        inDasCluster: "boolean",
        host: "HostListSummary",
        vm: "VirtualMachineSummary",
        vimAccountNameRequired: "boolean",
        clusterSupported: "boolean",
        network: "HostConnectInfoNetworkInfo",
        datastore: "HostDatastoreConnectInfo",
        license: "HostLicenseConnectInfo",
        capability: "HostCapability"
};
typeNames.interfaces["HostDatastoreExistsConnectInfo"] = {
newDatastoreName: "string"
};
typeNames.interfaces["HostDatastoreConnectInfo"] = {
summary: "DatastoreSummary"
};
typeNames.interfaces["HostDatastoreNameConflictConnectInfo"] = {
newDatastoreName: "string"
};
typeNames.interfaces["HostLicenseConnectInfo"] = {
license: "LicenseManagerLicenseInfo",
        evaluation: "LicenseManagerEvaluationInfo",
        resource: "HostLicensableResourceInfo"
};
typeNames.interfaces["HostConnectInfoNetworkInfo"] = {
summary: "NetworkSummary"
};
typeNames.interfaces["HostNewNetworkConnectInfo"] = {

};
typeNames.interfaces["HostDiagnosticPartition"] = {
storageType: "string",
        diagnosticType: "string",
        slots: "number",
        id: "HostScsiDiskPartition"
};
typeNames.interfaces["HostDiagnosticPartitionCreateDescription"] = {
layout: "HostDiskPartitionLayout",
        diskUuid: "string",
        spec: "HostDiagnosticPartitionCreateSpec"
};
typeNames.interfaces["HostDiagnosticPartitionCreateOption"] = {
storageType: "string",
        diagnosticType: "string",
        disk: "HostScsiDisk"
};
typeNames.interfaces["HostDiagnosticPartitionCreateSpec"] = {
storageType: "string",
        diagnosticType: "string",
        id: "HostScsiDiskPartition",
        partition: "HostDiskPartitionSpec",
        active: "boolean"
};
typeNames.interfaces["HostFibreChannelOverEthernetTargetTransport"] = {
vnportMac: "string",
        fcfMac: "string",
        vlanId: "number"
};
typeNames.interfaces["LocalDatastoreInfo"] = {
path: "string"
};
typeNames.interfaces["NasDatastoreInfo"] = {
nas: "HostNasVolume"
};
typeNames.interfaces["PMemDatastoreInfo"] = {
pmem: "HostPMemVolume"
};
typeNames.interfaces["HostRuntimeInfo"] = {
connectionState: "HostSystemConnectionState",
        powerState: "HostSystemPowerState",
        standbyMode: "string",
        inMaintenanceMode: "boolean",
        inQuarantineMode: "boolean",
        bootTime: "Date",
        healthSystemRuntime: "HealthSystemRuntime",
        dasHostState: "ClusterDasFdmHostState",
        tpmPcrValues: "HostTpmDigestInfo",
        vsanRuntimeInfo: "VsanHostRuntimeInfo",
        networkRuntimeInfo: "HostRuntimeInfoNetworkRuntimeInfo",
        vFlashResourceRuntimeInfo: "HostVFlashManagerVFlashResourceRunTimeInfo",
        hostMaxVirtualDiskCapacity: "number",
        cryptoState: "string",
        cryptoKeyId: "CryptoKeyId"
};
typeNames.interfaces["HostRuntimeInfoNetStackInstanceRuntimeInfo"] = {
netStackInstanceKey: "string",
        state: "string",
        vmknicKeys: "string",
        maxNumberOfConnections: "number",
        currentIpV6Enabled: "boolean"
};
typeNames.interfaces["HostNetworkResourceRuntime"] = {
pnicResourceInfo: "HostPnicNetworkResourceInfo"
};
typeNames.interfaces["HostRuntimeInfoNetworkRuntimeInfo"] = {
netStackInstanceRuntimeInfo: "HostRuntimeInfoNetStackInstanceRuntimeInfo",
        networkResourceRuntime: "HostNetworkResourceRuntime"
};
typeNames.interfaces["HostPlacedVirtualNicIdentifier"] = {
vm: VirtualMachine,
        vnicKey: "string",
        reservation: "number"
};
typeNames.interfaces["HostPnicNetworkResourceInfo"] = {
pnicDevice: "string",
        availableBandwidthForVMTraffic: "number",
        unusedBandwidthForVMTraffic: "number",
        placedVirtualNics: "HostPlacedVirtualNicIdentifier"
};
typeNames.interfaces["HostStorageSystemDiskLocatorLedResult"] = {
key: "string",
        fault: "MethodFault"
};
typeNames.interfaces["HostStorageSystemScsiLunResult"] = {
key: "string",
        fault: "MethodFault"
};
typeNames.interfaces["HostStorageSystemVmfsVolumeResult"] = {
key: "string",
        fault: "MethodFault"
};
typeNames.interfaces["HostVMotionManagerDstInstantCloneResult"] = {
dstVmId: "number",
        startTime: "number",
        cptLoadTime: "number",
        cptLoadDoneTime: "number",
        replicateMemDoneTime: "number",
        endTime: "number",
        cptXferTime: "number",
        cptCacheUsed: "number",
        devCptStreamSize: "number",
        devCptStreamTime: "number"
};
typeNames.interfaces["HostVMotionManagerSrcInstantCloneResult"] = {
startTime: "number",
        quiesceTime: "number",
        quiesceDoneTime: "number",
        resumeDoneTime: "number",
        endTime: "number"
};
typeNames.interfaces["VmfsDatastoreCreateSpec"] = {
partition: "HostDiskPartitionSpec",
        vmfs: "HostVmfsSpec",
        extent: "HostScsiDiskPartition"
};
typeNames.interfaces["VmfsDatastoreInfo"] = {
maxPhysicalRDMFileSize: "number",
        maxVirtualRDMFileSize: "number",
        vmfs: "HostVmfsVolume"
};
typeNames.interfaces["VsanDatastoreInfo"] = {
membershipUuid: "string",
        accessGenNo: "number"
};
typeNames.interfaces["VvolDatastoreInfo"] = {
vvolDS: "HostVvolVolume"
};
typeNames.interfaces["HourlyTaskScheduler"] = {
minute: "number"
};
typeNames.interfaces["VirtualMachineDatastoreInfo"] = {
datastore: "DatastoreSummary",
        capability: "DatastoreCapability",
        maxFileSize: "number",
        maxVirtualDiskCapacity: "number",
        maxPhysicalRDMFileSize: "number",
        maxVirtualRDMFileSize: "number",
        mode: "string",
        vStorageSupport: "string"
};
typeNames.interfaces["ParaVirtualSCSIController"] = {

};
typeNames.interfaces["ParaVirtualSCSIControllerOption"] = {

};
typeNames.interfaces["VirtualAHCIController"] = {

};
typeNames.interfaces["VirtualAHCIControllerOption"] = {

};
typeNames.interfaces["VirtualBusLogicController"] = {

};
typeNames.interfaces["VirtualBusLogicControllerOption"] = {

};
typeNames.interfaces["VirtualLsiLogicController"] = {

};
typeNames.interfaces["VirtualLsiLogicControllerOption"] = {

};
typeNames.interfaces["VirtualLsiLogicSASController"] = {

};
typeNames.interfaces["VirtualLsiLogicSASControllerOption"] = {

};
typeNames.interfaces["ClusterComputeResourceClusterConfigResult"] = {
failedHosts: "FolderFailedHostResult",
        configuredHosts: HostSystem
};
typeNames.interfaces["ClusterComputeResourceDVSConfigurationValidation"] = {
isDvsValid: "boolean",
        isDvpgValid: "boolean"
};
typeNames.interfaces["ClusterComputeResourceDVSSetting"] = {
dvSwitch: DistributedVirtualSwitch,
        pnicDevices: "string",
        dvPortgroupSetting: "ClusterComputeResourceDVSSettingDVPortgroupToServiceMapping"
};
typeNames.interfaces["ClusterComputeResourceDVSSettingDVPortgroupToServiceMapping"] = {
dvPortgroup: DistributedVirtualPortgroup,
        service: "string"
};
typeNames.interfaces["ClusterComputeResourceDvsProfile"] = {
dvsName: "string",
        dvSwitch: DistributedVirtualSwitch,
        pnicDevices: "string",
        dvPortgroupMapping: "ClusterComputeResourceDvsProfileDVPortgroupSpecToServiceMapping"
};
typeNames.interfaces["ClusterComputeResourceDvsProfileDVPortgroupSpecToServiceMapping"] = {
dvPortgroupSpec: "DVPortgroupConfigSpec",
        dvPortgroup: DistributedVirtualPortgroup,
        service: "string"
};
typeNames.interfaces["ClusterComputeResourceHCIConfigInfo"] = {
workflowState: "string",
        dvsSetting: "ClusterComputeResourceDVSSetting",
        configuredHosts: HostSystem,
        hostConfigProfile: "ClusterComputeResourceHostConfigurationProfile"
};
typeNames.interfaces["ClusterComputeResourceHCIConfigSpec"] = {
dvsProf: "ClusterComputeResourceDvsProfile",
        hostConfigProfile: "ClusterComputeResourceHostConfigurationProfile",
        vSanConfigSpec: "SDDCBase",
        vcProf: "ClusterComputeResourceVCProfile"
};
typeNames.interfaces["ClusterComputeResourceHostConfigurationInput"] = {
host: HostSystem,
        hostVmkNics: "ClusterComputeResourceHostVmkNicInfo",
        allowedInNonMaintenanceMode: "boolean"
};
typeNames.interfaces["ClusterComputeResourceHostConfigurationProfile"] = {
dateTimeConfig: "HostDateTimeConfig",
        lockdownMode: "HostLockdownMode"
};
typeNames.interfaces["ClusterComputeResourceHostConfigurationValidation"] = {
host: HostSystem,
        isDvsSettingValid: "boolean",
        isVmknicSettingValid: "boolean",
        isNtpSettingValid: "boolean",
        isLockdownModeValid: "boolean"
};
typeNames.interfaces["ClusterComputeResourceHostVmkNicInfo"] = {
nicSpec: "HostVirtualNicSpec",
        service: "string"
};
typeNames.interfaces["ClusterComputeResourceSummary"] = {
currentFailoverLevel: "number",
        admissionControlInfo: "ClusterDasAdmissionControlInfo",
        numVmotions: "number",
        targetBalance: "number",
        currentBalance: "number",
        drsScore: "number",
        numVmsPerDrsScoreBucket: "number",
        usageSummary: "ClusterUsageSummary",
        currentEVCModeKey: "string",
        currentEVCGraphicsModeKey: "string",
        dasData: "ClusterDasData",
        clusterMaintenanceModeStatus: "string"
};
typeNames.interfaces["ClusterComputeResourceVCProfile"] = {
clusterSpec: "ClusterConfigSpecEx",
        evcModeKey: "string",
        evcGraphicsModeKey: "string"
};
typeNames.interfaces["ClusterComputeResourceValidationResultBase"] = {
info: "LocalizableMessage"
};
typeNames.interfaces["CustomFieldDefAddedEvent"] = {

};
typeNames.interfaces["ConnectedIso"] = {
cdrom: "VirtualCdrom",
        filename: "string"
};
typeNames.interfaces["CpuCompatibilityUnknown"] = {

};
typeNames.interfaces["DeviceBackingNotSupported"] = {
backing: "string"
};
typeNames.interfaces["DeviceControllerNotSupported"] = {
controller: "string"
};
typeNames.interfaces["DeviceHotPlugNotSupported"] = {

};
typeNames.interfaces["DeviceNotFound"] = {

};
typeNames.interfaces["DeviceUnsupportedForVmPlatform"] = {

};
typeNames.interfaces["DeviceUnsupportedForVmVersion"] = {
currentVersion: "string",
        expectedVersion: "string"
};
typeNames.interfaces["DisallowedDiskModeChange"] = {

};
typeNames.interfaces["GatewayHostNotReachable"] = {

};
typeNames.interfaces["GatewayToHostAuthFault"] = {
invalidProperties: "string",
        missingProperties: "string"
};
typeNames.interfaces["InvalidController"] = {
controllerKey: "number"
};
typeNames.interfaces["InvalidDeviceBacking"] = {

};
typeNames.interfaces["InvalidDeviceOperation"] = {
badOp: "VirtualDeviceConfigSpecOperation",
        badFileOp: "VirtualDeviceConfigSpecFileOperation"
};
typeNames.interfaces["InvalidHostConnectionState"] = {

};
typeNames.interfaces["OvfConnectedDevice"] = {

};
typeNames.interfaces["OvfConnectedDeviceFloppy"] = {
filename: "string"
};
typeNames.interfaces["OvfConnectedDeviceIso"] = {
filename: "string"
};
typeNames.interfaces["OvfDuplicateElement"] = {

};
typeNames.interfaces["OvfDuplicatedElementBoundary"] = {
boundary: "string"
};
typeNames.interfaces["OvfDuplicatedPropertyIdExport"] = {
fqid: "string"
};
typeNames.interfaces["OvfDuplicatedPropertyIdImport"] = {

};
typeNames.interfaces["OvfNoSpaceOnController"] = {
parent: "string"
};
typeNames.interfaces["PhysCompatRDMNotSupported"] = {

};
typeNames.interfaces["UnusedVirtualDiskBlocksNotScrubbed"] = {

};
typeNames.interfaces["VirtualDiskBlocksNotFullyProvisioned"] = {

};
typeNames.interfaces["DailyTaskScheduler"] = {
hour: "number"
};
typeNames.interfaces["MonthlyTaskScheduler"] = {

};
typeNames.interfaces["WeeklyTaskScheduler"] = {
sunday: "boolean",
        monday: "boolean",
        tuesday: "boolean",
        wednesday: "boolean",
        thursday: "boolean",
        friday: "boolean",
        saturday: "boolean"
};
typeNames.interfaces["DVPortNotSupported"] = {

};
typeNames.interfaces["MonthlyByDayTaskScheduler"] = {
day: "number"
};
typeNames.interfaces["MonthlyByWeekdayTaskScheduler"] = {
offset: "WeekOfMonth",
        weekday: "DayOfWeek"
};
typeNames.classes["PropertyCollector"] = {
filter: PropertyFilter,
        _this: PropertyCollector
};
typeNames.classes["PropertyFilter"] = {
spec: "PropertyFilterSpec",
        partialUpdates: "boolean",
        _this: PropertyFilter
};
typeNames.classes["CertificateManager"] = {

};
typeNames.classes["CustomFieldsManager"] = {
field: "CustomFieldDef",
        _this: CustomFieldsManager
};
typeNames.classes["CustomizationSpecManager"] = {
info: "CustomizationSpecInfo",
        encryptionKey: "number",
        _this: CustomizationSpecManager
};
typeNames.classes["DatastoreNamespaceManager"] = {

};
typeNames.classes["DiagnosticManager"] = {

};
typeNames.classes["EnvironmentBrowser"] = {
datastoreBrowser: HostDatastoreBrowser,
        _this: EnvironmentBrowser
};
typeNames.classes["ExtensibleManagedObject"] = {
value: "CustomFieldValue",
        availableField: "CustomFieldDef",
        _this: ExtensibleManagedObject
};
typeNames.classes["ExtensionManager"] = {
extensionList: "Extension",
        _this: ExtensionManager
};
typeNames.classes["FileManager"] = {

};
typeNames.classes["HealthUpdateManager"] = {

};
typeNames.classes["HistoryCollector"] = {
filter: "any",
        _this: HistoryCollector
};
typeNames.classes["HttpNfcLease"] = {
initializeProgress: "number",
        transferProgress: "number",
        mode: "string",
        capabilities: "HttpNfcLeaseCapabilities",
        info: "HttpNfcLeaseInfo",
        state: "HttpNfcLeaseState",
        error: "MethodFault",
        _this: HttpNfcLease
};
typeNames.classes["IoFilterManager"] = {

};
typeNames.classes["IpPoolManager"] = {

};
typeNames.classes["LicenseManager"] = {
source: "LicenseSource",
        sourceAvailable: "boolean",
        diagnostics: "LicenseDiagnostics",
        featureInfo: "LicenseFeatureInfo",
        licensedEdition: "string",
        licenses: "LicenseManagerLicenseInfo",
        licenseAssignmentManager: LicenseAssignmentManager,
        evaluation: "LicenseManagerEvaluationInfo",
        _this: LicenseManager
};
typeNames.classes["LocalizationManager"] = {
catalog: "LocalizationManagerMessageCatalog",
        _this: LocalizationManager
};
typeNames.classes["OverheadMemoryManager"] = {

};
typeNames.classes["OvfManager"] = {
ovfImportOption: "OvfOptionInfo",
        ovfExportOption: "OvfOptionInfo",
        _this: OvfManager
};
typeNames.classes["PerformanceManager"] = {
description: "PerformanceDescription",
        historicalInterval: "PerfInterval",
        perfCounter: "PerfCounterInfo",
        _this: PerformanceManager
};
typeNames.classes["ResourcePlanningManager"] = {

};
typeNames.classes["SearchIndex"] = {

};
typeNames.classes["ServiceManager"] = {
service: "ServiceManagerServiceInfo",
        _this: ServiceManager
};
typeNames.classes["SessionManager"] = {
sessionList: "UserSession",
        currentSession: "UserSession",
        message: "string",
        messageLocaleList: "string",
        supportedLocaleList: "string",
        defaultLocale: "string",
        _this: SessionManager
};
typeNames.classes["SimpleCommand"] = {
encodingType: "SimpleCommandEncoding",
        entity: "ServiceManagerServiceInfo",
        _this: SimpleCommand
};
typeNames.classes["SiteInfoManager"] = {

};
typeNames.classes["StorageQueryManager"] = {

};
typeNames.classes["StorageResourceManager"] = {

};
typeNames.classes["TaskHistoryCollector"] = {
latestPage: "TaskInfo",
        _this: TaskHistoryCollector
};
typeNames.classes["TaskManager"] = {
recentTask: Task,
        description: "TaskDescription",
        maxCollector: "number",
        _this: TaskManager
};
typeNames.classes["UserDirectory"] = {
domainList: "string",
        _this: UserDirectory
};
typeNames.classes["VirtualizationManager"] = {

};
typeNames.classes["VsanUpgradeSystem"] = {

};
typeNames.classes["Alarm"] = {
info: "AlarmInfo",
        _this: Alarm
};
typeNames.classes["ClusterEVCManager"] = {
managedCluster: ClusterComputeResource,
        evcState: "ClusterEVCManagerEVCState",
        _this: ClusterEVCManager
};
typeNames.classes["CryptoManager"] = {
enabled: "boolean",
        _this: CryptoManager
};
typeNames.classes["CryptoManagerHost"] = {

};
typeNames.classes["CryptoManagerHostKMS"] = {

};
typeNames.classes["EventHistoryCollector"] = {
latestPage: "Event",
        _this: EventHistoryCollector
};
typeNames.classes["EventManager"] = {
description: "EventDescription",
        latestEvent: "Event",
        maxCollector: "number",
        _this: EventManager
};
typeNames.classes["HostAssignableHardwareManager"] = {
binding: "HostAssignableHardwareBinding",
        config: "HostAssignableHardwareConfig",
        _this: HostAssignableHardwareManager
};
typeNames.classes["HostAuthenticationManager"] = {
info: "HostAuthenticationManagerInfo",
        supportedStore: HostAuthenticationStore,
        _this: HostAuthenticationManager
};
typeNames.classes["HostAuthenticationStore"] = {
info: "HostAuthenticationStoreInfo",
        _this: HostAuthenticationStore
};
typeNames.classes["HostAutoStartManager"] = {
config: "HostAutoStartManagerConfig",
        _this: HostAutoStartManager
};
typeNames.classes["HostBootDeviceSystem"] = {

};
typeNames.classes["HostCacheConfigurationManager"] = {
cacheConfigurationInfo: "HostCacheConfigurationInfo",
        _this: HostCacheConfigurationManager
};
typeNames.classes["HostCertificateManager"] = {
certificateInfo: "HostCertificateManagerCertificateInfo",
        _this: HostCertificateManager
};
typeNames.classes["HostCpuSchedulerSystem"] = {
hyperthreadInfo: "HostHyperThreadScheduleInfo",
        _this: HostCpuSchedulerSystem
};
typeNames.classes["HostDatastoreBrowser"] = {
datastore: Datastore,
        supportedType: "FileQuery",
        _this: HostDatastoreBrowser
};
typeNames.classes["HostDateTimeSystem"] = {
dateTimeInfo: "HostDateTimeInfo",
        _this: HostDateTimeSystem
};
typeNames.classes["HostDirectoryStore"] = {

};
typeNames.classes["HostEsxAgentHostManager"] = {
configInfo: "HostEsxAgentHostManagerConfigInfo",
        _this: HostEsxAgentHostManager
};
typeNames.classes["HostFirmwareSystem"] = {

};
typeNames.classes["HostGraphicsManager"] = {
graphicsInfo: "HostGraphicsInfo",
        graphicsConfig: "HostGraphicsConfig",
        sharedPassthruGpuTypes: "string",
        sharedGpuCapabilities: "HostSharedGpuCapabilities",
        _this: HostGraphicsManager
};
typeNames.classes["HostHealthStatusSystem"] = {
runtime: "HealthSystemRuntime",
        _this: HostHealthStatusSystem
};
typeNames.classes["HostAccessManager"] = {
lockdownMode: "HostLockdownMode",
        _this: HostAccessManager
};
typeNames.classes["HostImageConfigManager"] = {

};
typeNames.classes["IscsiManager"] = {

};
typeNames.classes["HostKernelModuleSystem"] = {

};
typeNames.classes["HostLocalAccountManager"] = {

};
typeNames.classes["HostLocalAuthentication"] = {

};
typeNames.classes["HostMemorySystem"] = {
consoleReservationInfo: "ServiceConsoleReservationInfo",
        virtualMachineReservationInfo: "VirtualMachineMemoryReservationInfo",
        _this: HostMemorySystem
};
typeNames.classes["MessageBusProxy"] = {

};
typeNames.classes["HostNvdimmSystem"] = {
nvdimmSystemInfo: "NvdimmSystemInfo",
        _this: HostNvdimmSystem
};
typeNames.classes["HostPatchManager"] = {

};
typeNames.classes["HostPciPassthruSystem"] = {
pciPassthruInfo: "HostPciPassthruInfo",
        sriovDevicePoolInfo: "HostSriovDevicePoolInfo",
        _this: HostPciPassthruSystem
};
typeNames.classes["HostPowerSystem"] = {
capability: "PowerSystemCapability",
        info: "PowerSystemInfo",
        _this: HostPowerSystem
};
typeNames.classes["HostServiceSystem"] = {
serviceInfo: "HostServiceInfo",
        _this: HostServiceSystem
};
typeNames.classes["HostSnmpSystem"] = {
configuration: "HostSnmpConfigSpec",
        limits: "HostSnmpSystemAgentLimits",
        _this: HostSnmpSystem
};
typeNames.classes["HostVMotionSystem"] = {
netConfig: "HostVMotionNetConfig",
        ipConfig: "HostIpConfig",
        _this: HostVMotionSystem
};
typeNames.classes["HostVirtualNicManager"] = {
info: "HostVirtualNicManagerInfo",
        _this: HostVirtualNicManager
};
typeNames.classes["HostVsanInternalSystem"] = {

};
typeNames.classes["HostVsanSystem"] = {
config: "VsanHostConfigInfo",
        _this: HostVsanSystem
};
typeNames.classes["OptionManager"] = {
supportedOption: "OptionDef",
        setting: "OptionValue",
        _this: OptionManager
};
typeNames.classes["ProfileComplianceManager"] = {

};
typeNames.classes["Profile"] = {
config: "ProfileConfigInfo",
        description: "ProfileDescription",
        name: "string",
        createdTime: "Date",
        modifiedTime: "Date",
        entity: ManagedEntity,
        complianceStatus: "string",
        _this: Profile
};
typeNames.classes["ProfileManager"] = {
profile: Profile,
        _this: ProfileManager
};
typeNames.classes["ClusterProfile"] = {

};
typeNames.classes["ClusterProfileManager"] = {

};
typeNames.classes["HostSpecificationManager"] = {

};
typeNames.classes["ScheduledTask"] = {
info: "ScheduledTaskInfo",
        _this: ScheduledTask
};
typeNames.classes["ScheduledTaskManager"] = {
scheduledTask: ScheduledTask,
        description: "ScheduledTaskDescription",
        _this: ScheduledTaskManager
};
typeNames.classes["TenantTenantManager"] = {

};
typeNames.classes["FailoverClusterConfigurator"] = {
disabledConfigureMethod: "string",
        _this: FailoverClusterConfigurator
};
typeNames.classes["FailoverClusterManager"] = {
disabledClusterMethod: "string",
        _this: FailoverClusterManager
};
typeNames.classes["View"] = {

};
typeNames.classes["ViewManager"] = {
viewList: View,
        _this: ViewManager
};
typeNames.classes["VirtualMachineGuestCustomizationManager"] = {

};
typeNames.classes["VirtualMachineSnapshot"] = {
config: "VirtualMachineConfigInfo",
        childSnapshot: VirtualMachineSnapshot,
        vm: VirtualMachine,
        _this: VirtualMachineSnapshot
};
typeNames.classes["VirtualMachineCompatibilityChecker"] = {

};
typeNames.classes["GuestAliasManager"] = {

};
typeNames.classes["GuestAuthManager"] = {

};
typeNames.classes["GuestFileManager"] = {

};
typeNames.classes["GuestOperationsManager"] = {
authManager: GuestAuthManager,
        fileManager: GuestFileManager,
        processManager: GuestProcessManager,
        guestWindowsRegistryManager: GuestWindowsRegistryManager,
        aliasManager: GuestAliasManager,
        _this: GuestOperationsManager
};
typeNames.classes["GuestProcessManager"] = {

};
typeNames.classes["GuestWindowsRegistryManager"] = {

};
typeNames.classes["VStorageObjectManagerBase"] = {

};
typeNames.classes["AuthorizationManager"] = {
privilegeList: "AuthorizationPrivilege",
        roleList: "AuthorizationRole",
        description: "AuthorizationDescription",
        _this: AuthorizationManager
};
typeNames.classes["LicenseAssignmentManager"] = {

};
typeNames.classes["ManagedEntity"] = {
parent: ManagedEntity,
        customValue: "CustomFieldValue",
        overallStatus: "ManagedEntityStatus",
        configStatus: "ManagedEntityStatus",
        configIssue: "Event",
        effectiveRole: "number",
        permission: "Permission",
        name: "string",
        disabledMethod: "string",
        recentTask: Task,
        declaredAlarmState: "AlarmState",
        triggeredAlarmState: "AlarmState",
        alarmActionsEnabled: "boolean",
        tag: "Tag",
        _this: ManagedEntity
};
typeNames.classes["Network"] = {
summary: "NetworkSummary",
        host: HostSystem,
        vm: VirtualMachine,
        _this: Network
};
typeNames.classes["OpaqueNetwork"] = {
capability: "OpaqueNetworkCapability",
        extraConfig: "OptionValue",
        _this: OpaqueNetwork
};
typeNames.classes["ResourcePool"] = {
summary: "ResourcePoolSummary",
        runtime: "ResourcePoolRuntimeInfo",
        owner: ComputeResource,
        resourcePool: ResourcePool,
        vm: VirtualMachine,
        config: "ResourceConfigSpec",
        namespace: "string",
        childConfiguration: "ResourceConfigSpec",
        _this: ResourcePool
};
typeNames.classes["Task"] = {
info: "TaskInfo",
        _this: Task
};
typeNames.classes["VirtualApp"] = {
parentFolder: Folder,
        datastore: Datastore,
        network: Network,
        vAppConfig: "VAppConfigInfo",
        parentVApp: ManagedEntity,
        childLink: "VirtualAppLinkInfo",
        _this: VirtualApp
};
typeNames.classes["VirtualDiskManager"] = {

};
typeNames.classes["VirtualMachine"] = {
capability: "VirtualMachineCapability",
        config: "VirtualMachineConfigInfo",
        layout: "VirtualMachineFileLayout",
        layoutEx: "VirtualMachineFileLayoutEx",
        storage: "VirtualMachineStorageInfo",
        environmentBrowser: EnvironmentBrowser,
        resourcePool: ResourcePool,
        parentVApp: ManagedEntity,
        resourceConfig: "ResourceConfigSpec",
        runtime: "VirtualMachineRuntimeInfo",
        guest: "GuestInfo",
        summary: "VirtualMachineSummary",
        datastore: Datastore,
        network: Network,
        snapshot: "VirtualMachineSnapshotInfo",
        rootSnapshot: VirtualMachineSnapshot,
        guestHeartbeatStatus: "ManagedEntityStatus",
        _this: VirtualMachine
};
typeNames.classes["AlarmManager"] = {
defaultExpression: "AlarmExpression",
        description: "AlarmDescription",
        _this: AlarmManager
};
typeNames.classes["DistributedVirtualPortgroup"] = {
key: "string",
        config: "DVPortgroupConfigInfo",
        portKeys: "string",
        _this: DistributedVirtualPortgroup
};
typeNames.classes["CryptoManagerKmip"] = {
kmipServers: "KmipClusterInfo",
        _this: CryptoManagerKmip
};
typeNames.classes["HostActiveDirectoryAuthentication"] = {

};
typeNames.classes["HostDatastoreSystem"] = {
datastore: Datastore,
        capabilities: "HostDatastoreSystemCapabilities",
        _this: HostDatastoreSystem
};
typeNames.classes["HostFirewallSystem"] = {
firewallInfo: "HostFirewallInfo",
        _this: HostFirewallSystem
};
typeNames.classes["HostNetworkSystem"] = {
capabilities: "HostNetCapabilities",
        networkInfo: "HostNetworkInfo",
        offloadCapabilities: "HostNetOffloadCapabilities",
        networkConfig: "HostNetworkConfig",
        dnsConfig: "HostDnsConfig",
        ipRouteConfig: "HostIpRouteConfig",
        consoleIpRouteConfig: "HostIpRouteConfig",
        _this: HostNetworkSystem
};
typeNames.classes["HostVFlashManager"] = {
vFlashConfigInfo: "HostVFlashManagerVFlashConfigInfo",
        _this: HostVFlashManager
};
typeNames.classes["HostProfile"] = {
validationState: "string",
        validationStateUpdateTime: "Date",
        validationFailureInfo: "HostProfileValidationFailureInfo",
        referenceHost: HostSystem,
        _this: HostProfile
};
typeNames.classes["HostProfileManager"] = {

};
typeNames.classes["ManagedObjectView"] = {
view: "ManagedObject",
        _this: ManagedObjectView
};
typeNames.classes["VirtualMachineProvisioningChecker"] = {

};
typeNames.classes["HostVStorageObjectManager"] = {

};
typeNames.classes["VcenterVStorageObjectManager"] = {

};
typeNames.classes["ComputeResource"] = {
resourcePool: ResourcePool,
        host: HostSystem,
        datastore: Datastore,
        network: Network,
        summary: "ComputeResourceSummary",
        environmentBrowser: EnvironmentBrowser,
        configurationEx: "ComputeResourceConfigInfo",
        lifecycleManaged: "boolean",
        _this: ComputeResource
};
typeNames.classes["Datacenter"] = {
vmFolder: Folder,
        hostFolder: Folder,
        datastoreFolder: Folder,
        networkFolder: Folder,
        datastore: Datastore,
        network: Network,
        configuration: "DatacenterConfigInfo",
        _this: Datacenter
};
typeNames.classes["Datastore"] = {
info: "DatastoreInfo",
        summary: "DatastoreSummary",
        host: "DatastoreHostMount",
        vm: VirtualMachine,
        browser: HostDatastoreBrowser,
        capability: "DatastoreCapability",
        iormConfiguration: "StorageIORMInfo",
        _this: Datastore
};
typeNames.classes["DistributedVirtualSwitch"] = {
uuid: "string",
        capability: "DVSCapability",
        summary: "DVSSummary",
        config: "DVSConfigInfo",
        networkResourcePool: "DVSNetworkResourcePool",
        portgroup: DistributedVirtualPortgroup,
        runtime: "DVSRuntimeInfo",
        _this: DistributedVirtualSwitch
};
typeNames.classes["Folder"] = {
childType: "string",
        childEntity: ManagedEntity,
        namespace: "string",
        _this: Folder
};
typeNames.classes["HostSystem"] = {
runtime: "HostRuntimeInfo",
        summary: "HostListSummary",
        hardware: "HostHardwareInfo",
        capability: "HostCapability",
        licensableResource: "HostLicensableResourceInfo",
        remediationState: "HostSystemRemediationState",
        precheckRemediationResult: "ApplyHostProfileConfigurationSpec",
        remediationResult: "ApplyHostProfileConfigurationResult",
        complianceCheckState: "HostSystemComplianceCheckState",
        complianceCheckResult: "ComplianceResult",
        configManager: "HostConfigManager",
        config: "HostConfigInfo",
        vm: VirtualMachine,
        datastore: Datastore,
        network: Network,
        datastoreBrowser: HostDatastoreBrowser,
        systemResources: "HostSystemResourceInfo",
        answerFileValidationState: "AnswerFileStatusResult",
        answerFileValidationResult: "AnswerFileStatusResult",
        _this: HostSystem
};
typeNames.classes["ServiceInstance"] = {
serverClock: "Date",
        capability: "Capability",
        content: "ServiceContent",
        _this: ServiceInstance
};
typeNames.classes["StoragePod"] = {
summary: "StoragePodSummary",
        podStorageDrsEntry: "PodStorageDrsEntry",
        _this: StoragePod
};
typeNames.classes["DistributedVirtualSwitchManager"] = {

};
typeNames.classes["VmwareDistributedVirtualSwitch"] = {

};
typeNames.classes["HostDiagnosticSystem"] = {
activePartition: "HostDiagnosticPartition",
        _this: HostDiagnosticSystem
};
typeNames.classes["HostStorageSystem"] = {
storageDeviceInfo: "HostStorageDeviceInfo",
        fileSystemVolumeInfo: "HostFileSystemVolumeInfo",
        systemFile: "string",
        multipathStateInfo: "HostMultipathStateInfo",
        _this: HostStorageSystem
};
typeNames.classes["ContainerView"] = {
container: ManagedEntity,
        type: "string",
        recursive: "boolean",
        _this: ContainerView
};
typeNames.classes["InventoryView"] = {

};
typeNames.classes["ListView"] = {

};
typeNames.classes["ClusterComputeResource"] = {
configuration: "ClusterConfigInfo",
        recommendation: "ClusterRecommendation",
        drsRecommendation: "ClusterDrsRecommendation",
        hciConfig: "ClusterComputeResourceHCIConfigInfo",
        migrationHistory: "ClusterDrsMigration",
        actionHistory: "ClusterActionHistory",
        drsFault: "ClusterDrsFaults",
        _this: ClusterComputeResource
}